"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShowArchive = exports.SlideTreeArchive = exports.ThemeArchive = exports.ThemeCustomTimingCurveArchive = exports.ActionGhostSelectionArchive = exports.CanvasSelectionArchive = exports.IOSSavedPlaybackStateArchive = exports.IOSRestorableViewStateRootArchive = exports.UIStateArchive = exports.DesktopUILayoutArchive = exports.SlideNodeArchive_SlideSpecificHyperlinkMapEntry = exports.SlideNodeArchive = exports.SlideArchive_InstructionalTextMap_InstructionalTextMapEntry = exports.SlideArchive_InstructionalTextMap = exports.SlideArchive_SageTagMapEntry = exports.SlideArchive = exports.ClassicThemeRecordArchive = exports.ClassicStylesheetRecordArchive = exports.NoteArchive = exports.PlaceholderArchive = exports.BuildArchive = exports.BuildAttributesArchive = exports.BuildAttributeTupleArchive = exports.BuildAttributeValueArchive = exports.BuildChunkIdentifierArchive = exports.BuildChunkArchive = exports.TransitionArchive = exports.TransitionAttributesArchive = exports.AnimationAttributesArchive = exports.LiveVideoCaptureDeviceDescription_Position = exports.MixedIdOperationArgs_ArgsListKind = exports.Soundtrack_SoundtrackMode = exports.RecordingMovieEventArchive_RecordingMovieEventType = exports.RecordingPauseEventArchive_RecordingPauseEventType = exports.RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase = exports.RecordingArchive_RecordingSyncStateEnum = exports.ShowArchive_KNShowMode = exports.IOSSavedPlaybackStateArchive_PresentationType = exports.DesktopUILayoutArchive_InspectorPaneViewMode = exports.DesktopUILayoutArchive_SidebarViewMode = exports.PlaceholderArchive_Kind = exports.BuildAttributesArchive_ActionBuildAttributesJiggleIntensity = exports.BuildAttributesArchive_BuildAttributesDeliveryOption = exports.BuildAttributesArchive_BuildAttributesTextDelivery = exports.BuildAttributesArchive_BuildAttributesCurveStyle = exports.BuildAttributesArchive_BuildAttributesRotationDirection = exports.BuildAttributesArchive_BuildAttributesAcceleration = exports.BuildAttributeValueArchive_BuildAttributeValueType = exports.TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType = exports.TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType = void 0;
exports.MotionBackgroundFillArchive = exports.MotionBackgroundStyleArchive = exports.MotionBackgroundStylePropertiesArchive = exports.LiveVideoSourceUsageEntry = exports.LiveVideoSourceCollection = exports.LiveVideoCaptureDeviceDescription = exports.LiveVideoSourceCollaborationCommandUsageState = exports.LiveVideoSource = exports.LiveVideoInfo = exports.MixedIdOperationArgs = exports.PresenterNotesSelectionArchive = exports.SlideCollectionSelectionArchive_OutlineSelection = exports.SlideCollectionSelectionArchive = exports.SlideNumberAttachmentArchive = exports.Soundtrack = exports.MovieSegmentArchive = exports.RecordingMovieTrackArchive = exports.RecordingMovieEventArchive = exports.RecordingPauseEventArchive = exports.RecordingLaserEventArchive = exports.RecordingNavigationEventArchive = exports.RecordingEventArchive = exports.RecordingEventTrackArchive = exports.RecordingCorrectionHistory = exports.RecordingSyncState = exports.RecordingArchive = exports.PrototypeForUndoTemplateChangeArchive = exports.PasteboardNativeStorageArchive_LiveVideoSourcePair = exports.PasteboardNativeStorageArchive = exports.SlideStyleArchive = exports.SlideStylePropertiesArchive = exports.DocumentArchive = void 0;
const runtime_1 = require("@protobuf-ts/runtime");
const runtime_2 = require("@protobuf-ts/runtime");
const runtime_3 = require("@protobuf-ts/runtime");
const runtime_4 = require("@protobuf-ts/runtime");
const runtime_5 = require("@protobuf-ts/runtime");
const TSKArchives_1 = require("./TSKArchives");
const TSKArchives_2 = require("./TSKArchives");
const TSKArchives_3 = require("./TSKArchives");
const TSWPArchives_1 = require("./TSWPArchives");
const TSPMessages_1 = require("./TSPMessages");
const TSPMessages_2 = require("./TSPMessages");
const TSSArchives_1 = require("./TSSArchives");
const TSDArchives_1 = require("./TSDArchives");
const TSAArchives_1 = require("./TSAArchives");
const TSSArchives_2 = require("./TSSArchives");
const TSPMessages_3 = require("./TSPMessages");
const TSKArchives_4 = require("./TSKArchives");
const TSCHArchives_1 = require("./TSCHArchives");
const TSPMessages_4 = require("./TSPMessages");
const TSPMessages_5 = require("./TSPMessages");
const TSPMessages_6 = require("./TSPMessages");
const TSDArchives_2 = require("./TSDArchives");
const TSWPArchives_2 = require("./TSWPArchives");
const TSDArchives_3 = require("./TSDArchives");
const TSSArchives_3 = require("./TSSArchives");
const TSWPArchives_3 = require("./TSWPArchives");
const TSPMessages_7 = require("./TSPMessages");
const TSPMessages_8 = require("./TSPMessages");
const TSDArchives_4 = require("./TSDArchives");
const TSPMessages_9 = require("./TSPMessages");
/**
 * @generated from protobuf enum KN.TransitionAttributesArchive.TransitionCustomAttributesTimingCurveType
 */
var TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType;
(function (TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType) {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType[TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType["UNSPECIFIED$"] = 0] = "UNSPECIFIED$";
    /**
     * @generated from protobuf enum value: TransitionCustomAttributesTimingCurveTypeLinear = 1;
     */
    TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType[TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType["TransitionCustomAttributesTimingCurveTypeLinear"] = 1] = "TransitionCustomAttributesTimingCurveTypeLinear";
    /**
     * @generated from protobuf enum value: TransitionCustomAttributesTimingCurveTypeEaseIn = 2;
     */
    TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType[TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType["TransitionCustomAttributesTimingCurveTypeEaseIn"] = 2] = "TransitionCustomAttributesTimingCurveTypeEaseIn";
    /**
     * @generated from protobuf enum value: TransitionCustomAttributesTimingCurveTypeEaseOut = 3;
     */
    TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType[TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType["TransitionCustomAttributesTimingCurveTypeEaseOut"] = 3] = "TransitionCustomAttributesTimingCurveTypeEaseOut";
    /**
     * @generated from protobuf enum value: TransitionCustomAttributesTimingCurveTypeEaseInEaseOut = 4;
     */
    TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType[TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType["TransitionCustomAttributesTimingCurveTypeEaseInEaseOut"] = 4] = "TransitionCustomAttributesTimingCurveTypeEaseInEaseOut";
    /**
     * @generated from protobuf enum value: TransitionCustomAttributesTimingCurveTypeCustom = 5;
     */
    TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType[TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType["TransitionCustomAttributesTimingCurveTypeCustom"] = 5] = "TransitionCustomAttributesTimingCurveTypeCustom";
})(TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType = exports.TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType || (exports.TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType = {}));
/**
 * @generated from protobuf enum KN.TransitionAttributesArchive.TransitionCustomAttributesTextDeliveryType
 */
var TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType;
(function (TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType) {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType[TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType["UNSPECIFIED$"] = 0] = "UNSPECIFIED$";
    /**
     * @generated from protobuf enum value: TransitionCustomAttributesTextDeliveryTypeByObject = 1;
     */
    TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType[TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType["TransitionCustomAttributesTextDeliveryTypeByObject"] = 1] = "TransitionCustomAttributesTextDeliveryTypeByObject";
    /**
     * @generated from protobuf enum value: TransitionCustomAttributesTextDeliveryTypeByWord = 2;
     */
    TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType[TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType["TransitionCustomAttributesTextDeliveryTypeByWord"] = 2] = "TransitionCustomAttributesTextDeliveryTypeByWord";
    /**
     * @generated from protobuf enum value: TransitionCustomAttributesTextDeliveryTypeByCharacter = 3;
     */
    TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType[TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType["TransitionCustomAttributesTextDeliveryTypeByCharacter"] = 3] = "TransitionCustomAttributesTextDeliveryTypeByCharacter";
    /**
     * @generated from protobuf enum value: TransitionCustomAttributesTextDeliveryTypeByLine = 4;
     */
    TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType[TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType["TransitionCustomAttributesTextDeliveryTypeByLine"] = 4] = "TransitionCustomAttributesTextDeliveryTypeByLine";
})(TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType = exports.TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType || (exports.TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType = {}));
/**
 * @generated from protobuf enum KN.BuildAttributeValueArchive.BuildAttributeValueType
 */
var BuildAttributeValueArchive_BuildAttributeValueType;
(function (BuildAttributeValueArchive_BuildAttributeValueType) {
    /**
     * @generated from protobuf enum value: k_integer = 0;
     */
    BuildAttributeValueArchive_BuildAttributeValueType[BuildAttributeValueArchive_BuildAttributeValueType["k_integer"] = 0] = "k_integer";
    /**
     * @generated from protobuf enum value: k_double = 2;
     */
    BuildAttributeValueArchive_BuildAttributeValueType[BuildAttributeValueArchive_BuildAttributeValueType["k_double"] = 2] = "k_double";
    /**
     * @generated from protobuf enum value: k_bool = 3;
     */
    BuildAttributeValueArchive_BuildAttributeValueType[BuildAttributeValueArchive_BuildAttributeValueType["k_bool"] = 3] = "k_bool";
    /**
     * @generated from protobuf enum value: k_string = 4;
     */
    BuildAttributeValueArchive_BuildAttributeValueType[BuildAttributeValueArchive_BuildAttributeValueType["k_string"] = 4] = "k_string";
    /**
     * @generated from protobuf enum value: k_path_source = 5;
     */
    BuildAttributeValueArchive_BuildAttributeValueType[BuildAttributeValueArchive_BuildAttributeValueType["k_path_source"] = 5] = "k_path_source";
    /**
     * @generated from protobuf enum value: k_color = 6;
     */
    BuildAttributeValueArchive_BuildAttributeValueType[BuildAttributeValueArchive_BuildAttributeValueType["k_color"] = 6] = "k_color";
})(BuildAttributeValueArchive_BuildAttributeValueType = exports.BuildAttributeValueArchive_BuildAttributeValueType || (exports.BuildAttributeValueArchive_BuildAttributeValueType = {}));
/**
 * @generated from protobuf enum KN.BuildAttributesArchive.BuildAttributesAcceleration
 */
var BuildAttributesArchive_BuildAttributesAcceleration;
(function (BuildAttributesArchive_BuildAttributesAcceleration) {
    /**
     * @generated from protobuf enum value: kNone = 0;
     */
    BuildAttributesArchive_BuildAttributesAcceleration[BuildAttributesArchive_BuildAttributesAcceleration["kNone"] = 0] = "kNone";
    /**
     * @generated from protobuf enum value: kEaseIn = 1;
     */
    BuildAttributesArchive_BuildAttributesAcceleration[BuildAttributesArchive_BuildAttributesAcceleration["kEaseIn"] = 1] = "kEaseIn";
    /**
     * @generated from protobuf enum value: kEaseOut = 2;
     */
    BuildAttributesArchive_BuildAttributesAcceleration[BuildAttributesArchive_BuildAttributesAcceleration["kEaseOut"] = 2] = "kEaseOut";
    /**
     * @generated from protobuf enum value: kEaseBoth = 3;
     */
    BuildAttributesArchive_BuildAttributesAcceleration[BuildAttributesArchive_BuildAttributesAcceleration["kEaseBoth"] = 3] = "kEaseBoth";
    /**
     * @generated from protobuf enum value: kCustom = 4;
     */
    BuildAttributesArchive_BuildAttributesAcceleration[BuildAttributesArchive_BuildAttributesAcceleration["kCustom"] = 4] = "kCustom";
})(BuildAttributesArchive_BuildAttributesAcceleration = exports.BuildAttributesArchive_BuildAttributesAcceleration || (exports.BuildAttributesArchive_BuildAttributesAcceleration = {}));
/**
 * @generated from protobuf enum KN.BuildAttributesArchive.BuildAttributesRotationDirection
 */
var BuildAttributesArchive_BuildAttributesRotationDirection;
(function (BuildAttributesArchive_BuildAttributesRotationDirection) {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    BuildAttributesArchive_BuildAttributesRotationDirection[BuildAttributesArchive_BuildAttributesRotationDirection["UNSPECIFIED$"] = 0] = "UNSPECIFIED$";
    /**
     * @generated from protobuf enum value: kClockwise = 31;
     */
    BuildAttributesArchive_BuildAttributesRotationDirection[BuildAttributesArchive_BuildAttributesRotationDirection["kClockwise"] = 31] = "kClockwise";
    /**
     * @generated from protobuf enum value: kCounterclockwise = 32;
     */
    BuildAttributesArchive_BuildAttributesRotationDirection[BuildAttributesArchive_BuildAttributesRotationDirection["kCounterclockwise"] = 32] = "kCounterclockwise";
})(BuildAttributesArchive_BuildAttributesRotationDirection = exports.BuildAttributesArchive_BuildAttributesRotationDirection || (exports.BuildAttributesArchive_BuildAttributesRotationDirection = {}));
/**
 * @generated from protobuf enum KN.BuildAttributesArchive.BuildAttributesCurveStyle
 */
var BuildAttributesArchive_BuildAttributesCurveStyle;
(function (BuildAttributesArchive_BuildAttributesCurveStyle) {
    /**
     * @generated from protobuf enum value: kStraight = 0;
     */
    BuildAttributesArchive_BuildAttributesCurveStyle[BuildAttributesArchive_BuildAttributesCurveStyle["kStraight"] = 0] = "kStraight";
    /**
     * @generated from protobuf enum value: kCurved = 1;
     */
    BuildAttributesArchive_BuildAttributesCurveStyle[BuildAttributesArchive_BuildAttributesCurveStyle["kCurved"] = 1] = "kCurved";
})(BuildAttributesArchive_BuildAttributesCurveStyle = exports.BuildAttributesArchive_BuildAttributesCurveStyle || (exports.BuildAttributesArchive_BuildAttributesCurveStyle = {}));
/**
 * @generated from protobuf enum KN.BuildAttributesArchive.BuildAttributesTextDelivery
 */
var BuildAttributesArchive_BuildAttributesTextDelivery;
(function (BuildAttributesArchive_BuildAttributesTextDelivery) {
    /**
     * @generated from protobuf enum value: kTextDeliveryUndefined = 0;
     */
    BuildAttributesArchive_BuildAttributesTextDelivery[BuildAttributesArchive_BuildAttributesTextDelivery["kTextDeliveryUndefined"] = 0] = "kTextDeliveryUndefined";
    /**
     * @generated from protobuf enum value: kTextDeliveryByObject = 1;
     */
    BuildAttributesArchive_BuildAttributesTextDelivery[BuildAttributesArchive_BuildAttributesTextDelivery["kTextDeliveryByObject"] = 1] = "kTextDeliveryByObject";
    /**
     * @generated from protobuf enum value: kTextDeliveryByWord = 2;
     */
    BuildAttributesArchive_BuildAttributesTextDelivery[BuildAttributesArchive_BuildAttributesTextDelivery["kTextDeliveryByWord"] = 2] = "kTextDeliveryByWord";
    /**
     * @generated from protobuf enum value: kTextDeliveryByCharacter = 3;
     */
    BuildAttributesArchive_BuildAttributesTextDelivery[BuildAttributesArchive_BuildAttributesTextDelivery["kTextDeliveryByCharacter"] = 3] = "kTextDeliveryByCharacter";
    /**
     * @generated from protobuf enum value: kTextDeliveryByLine = 4;
     */
    BuildAttributesArchive_BuildAttributesTextDelivery[BuildAttributesArchive_BuildAttributesTextDelivery["kTextDeliveryByLine"] = 4] = "kTextDeliveryByLine";
})(BuildAttributesArchive_BuildAttributesTextDelivery = exports.BuildAttributesArchive_BuildAttributesTextDelivery || (exports.BuildAttributesArchive_BuildAttributesTextDelivery = {}));
/**
 * @generated from protobuf enum KN.BuildAttributesArchive.BuildAttributesDeliveryOption
 */
var BuildAttributesArchive_BuildAttributesDeliveryOption;
(function (BuildAttributesArchive_BuildAttributesDeliveryOption) {
    /**
     * @generated from protobuf enum value: kDeliveryOptionUndefined = 0;
     */
    BuildAttributesArchive_BuildAttributesDeliveryOption[BuildAttributesArchive_BuildAttributesDeliveryOption["kDeliveryOptionUndefined"] = 0] = "kDeliveryOptionUndefined";
    /**
     * @generated from protobuf enum value: kDeliveryOptionForward = 1;
     */
    BuildAttributesArchive_BuildAttributesDeliveryOption[BuildAttributesArchive_BuildAttributesDeliveryOption["kDeliveryOptionForward"] = 1] = "kDeliveryOptionForward";
    /**
     * @generated from protobuf enum value: kDeliveryOptionBackward = 2;
     */
    BuildAttributesArchive_BuildAttributesDeliveryOption[BuildAttributesArchive_BuildAttributesDeliveryOption["kDeliveryOptionBackward"] = 2] = "kDeliveryOptionBackward";
    /**
     * @generated from protobuf enum value: kDeliveryOptionFromCenter = 3;
     */
    BuildAttributesArchive_BuildAttributesDeliveryOption[BuildAttributesArchive_BuildAttributesDeliveryOption["kDeliveryOptionFromCenter"] = 3] = "kDeliveryOptionFromCenter";
    /**
     * @generated from protobuf enum value: kDeliveryOptionFromEdges = 4;
     */
    BuildAttributesArchive_BuildAttributesDeliveryOption[BuildAttributesArchive_BuildAttributesDeliveryOption["kDeliveryOptionFromEdges"] = 4] = "kDeliveryOptionFromEdges";
    /**
     * @generated from protobuf enum value: kDeliveryOptionRandom = 5;
     */
    BuildAttributesArchive_BuildAttributesDeliveryOption[BuildAttributesArchive_BuildAttributesDeliveryOption["kDeliveryOptionRandom"] = 5] = "kDeliveryOptionRandom";
})(BuildAttributesArchive_BuildAttributesDeliveryOption = exports.BuildAttributesArchive_BuildAttributesDeliveryOption || (exports.BuildAttributesArchive_BuildAttributesDeliveryOption = {}));
/**
 * @generated from protobuf enum KN.BuildAttributesArchive.ActionBuildAttributesJiggleIntensity
 */
var BuildAttributesArchive_ActionBuildAttributesJiggleIntensity;
(function (BuildAttributesArchive_ActionBuildAttributesJiggleIntensity) {
    /**
     * @generated from protobuf enum value: kJiggleIntensitySmall = 0;
     */
    BuildAttributesArchive_ActionBuildAttributesJiggleIntensity[BuildAttributesArchive_ActionBuildAttributesJiggleIntensity["kJiggleIntensitySmall"] = 0] = "kJiggleIntensitySmall";
    /**
     * @generated from protobuf enum value: kJiggleIntensityMedium = 1;
     */
    BuildAttributesArchive_ActionBuildAttributesJiggleIntensity[BuildAttributesArchive_ActionBuildAttributesJiggleIntensity["kJiggleIntensityMedium"] = 1] = "kJiggleIntensityMedium";
    /**
     * @generated from protobuf enum value: kJiggleIntensityLarge = 2;
     */
    BuildAttributesArchive_ActionBuildAttributesJiggleIntensity[BuildAttributesArchive_ActionBuildAttributesJiggleIntensity["kJiggleIntensityLarge"] = 2] = "kJiggleIntensityLarge";
})(BuildAttributesArchive_ActionBuildAttributesJiggleIntensity = exports.BuildAttributesArchive_ActionBuildAttributesJiggleIntensity || (exports.BuildAttributesArchive_ActionBuildAttributesJiggleIntensity = {}));
/**
 * @generated from protobuf enum KN.PlaceholderArchive.Kind
 */
var PlaceholderArchive_Kind;
(function (PlaceholderArchive_Kind) {
    /**
     * @generated from protobuf enum value: kKindPlaceholder = 0;
     */
    PlaceholderArchive_Kind[PlaceholderArchive_Kind["kKindPlaceholder"] = 0] = "kKindPlaceholder";
    /**
     * @generated from protobuf enum value: kKindSlideNumberPlaceholder = 1;
     */
    PlaceholderArchive_Kind[PlaceholderArchive_Kind["kKindSlideNumberPlaceholder"] = 1] = "kKindSlideNumberPlaceholder";
    /**
     * @generated from protobuf enum value: kKindTitlePlaceholder = 2;
     */
    PlaceholderArchive_Kind[PlaceholderArchive_Kind["kKindTitlePlaceholder"] = 2] = "kKindTitlePlaceholder";
    /**
     * @generated from protobuf enum value: kKindBodyPlaceholder = 3;
     */
    PlaceholderArchive_Kind[PlaceholderArchive_Kind["kKindBodyPlaceholder"] = 3] = "kKindBodyPlaceholder";
    /**
     * @generated from protobuf enum value: kKindObjectPlaceholder = 4;
     */
    PlaceholderArchive_Kind[PlaceholderArchive_Kind["kKindObjectPlaceholder"] = 4] = "kKindObjectPlaceholder";
})(PlaceholderArchive_Kind = exports.PlaceholderArchive_Kind || (exports.PlaceholderArchive_Kind = {}));
/**
 * @generated from protobuf enum KN.DesktopUILayoutArchive.SidebarViewMode
 */
var DesktopUILayoutArchive_SidebarViewMode;
(function (DesktopUILayoutArchive_SidebarViewMode) {
    /**
     * @generated from protobuf enum value: kSidebarViewModeNavigator = 0;
     */
    DesktopUILayoutArchive_SidebarViewMode[DesktopUILayoutArchive_SidebarViewMode["kSidebarViewModeNavigator"] = 0] = "kSidebarViewModeNavigator";
    /**
     * @generated from protobuf enum value: kSidebarViewModeOutline = 1;
     */
    DesktopUILayoutArchive_SidebarViewMode[DesktopUILayoutArchive_SidebarViewMode["kSidebarViewModeOutline"] = 1] = "kSidebarViewModeOutline";
})(DesktopUILayoutArchive_SidebarViewMode = exports.DesktopUILayoutArchive_SidebarViewMode || (exports.DesktopUILayoutArchive_SidebarViewMode = {}));
/**
 * @generated from protobuf enum KN.DesktopUILayoutArchive.InspectorPaneViewMode
 */
var DesktopUILayoutArchive_InspectorPaneViewMode;
(function (DesktopUILayoutArchive_InspectorPaneViewMode) {
    /**
     * @generated from protobuf enum value: kInspectorPaneViewModeFormat = 0;
     */
    DesktopUILayoutArchive_InspectorPaneViewMode[DesktopUILayoutArchive_InspectorPaneViewMode["kInspectorPaneViewModeFormat"] = 0] = "kInspectorPaneViewModeFormat";
    /**
     * @generated from protobuf enum value: kInspectorPaneViewModeAnimate = 1;
     */
    DesktopUILayoutArchive_InspectorPaneViewMode[DesktopUILayoutArchive_InspectorPaneViewMode["kInspectorPaneViewModeAnimate"] = 1] = "kInspectorPaneViewModeAnimate";
    /**
     * @generated from protobuf enum value: kInspectorPaneViewModeSetup = 2;
     */
    DesktopUILayoutArchive_InspectorPaneViewMode[DesktopUILayoutArchive_InspectorPaneViewMode["kInspectorPaneViewModeSetup"] = 2] = "kInspectorPaneViewModeSetup";
})(DesktopUILayoutArchive_InspectorPaneViewMode = exports.DesktopUILayoutArchive_InspectorPaneViewMode || (exports.DesktopUILayoutArchive_InspectorPaneViewMode = {}));
/**
 * @generated from protobuf enum KN.IOSSavedPlaybackStateArchive.PresentationType
 */
var IOSSavedPlaybackStateArchive_PresentationType;
(function (IOSSavedPlaybackStateArchive_PresentationType) {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    IOSSavedPlaybackStateArchive_PresentationType[IOSSavedPlaybackStateArchive_PresentationType["UNSPECIFIED$"] = 0] = "UNSPECIFIED$";
    /**
     * @generated from protobuf enum value: Manual = 1;
     */
    IOSSavedPlaybackStateArchive_PresentationType[IOSSavedPlaybackStateArchive_PresentationType["Manual"] = 1] = "Manual";
    /**
     * @generated from protobuf enum value: Record = 2;
     */
    IOSSavedPlaybackStateArchive_PresentationType[IOSSavedPlaybackStateArchive_PresentationType["Record"] = 2] = "Record";
    /**
     * @generated from protobuf enum value: PlayRecording = 3;
     */
    IOSSavedPlaybackStateArchive_PresentationType[IOSSavedPlaybackStateArchive_PresentationType["PlayRecording"] = 3] = "PlayRecording";
    /**
     * @generated from protobuf enum value: Rehearse = 4;
     */
    IOSSavedPlaybackStateArchive_PresentationType[IOSSavedPlaybackStateArchive_PresentationType["Rehearse"] = 4] = "Rehearse";
    /**
     * @generated from protobuf enum value: Showcast = 5;
     */
    IOSSavedPlaybackStateArchive_PresentationType[IOSSavedPlaybackStateArchive_PresentationType["Showcast"] = 5] = "Showcast";
})(IOSSavedPlaybackStateArchive_PresentationType = exports.IOSSavedPlaybackStateArchive_PresentationType || (exports.IOSSavedPlaybackStateArchive_PresentationType = {}));
/**
 * @generated from protobuf enum KN.ShowArchive.KNShowMode
 */
var ShowArchive_KNShowMode;
(function (ShowArchive_KNShowMode) {
    /**
     * @generated from protobuf enum value: kKNShowModeNormal = 0;
     */
    ShowArchive_KNShowMode[ShowArchive_KNShowMode["kKNShowModeNormal"] = 0] = "kKNShowModeNormal";
    /**
     * @generated from protobuf enum value: kKNShowModeAutoPlay = 1;
     */
    ShowArchive_KNShowMode[ShowArchive_KNShowMode["kKNShowModeAutoPlay"] = 1] = "kKNShowModeAutoPlay";
    /**
     * @generated from protobuf enum value: kKNShowModeHyperlinksOnly = 2;
     */
    ShowArchive_KNShowMode[ShowArchive_KNShowMode["kKNShowModeHyperlinksOnly"] = 2] = "kKNShowModeHyperlinksOnly";
})(ShowArchive_KNShowMode = exports.ShowArchive_KNShowMode || (exports.ShowArchive_KNShowMode = {}));
/**
 * @generated from protobuf enum KN.RecordingArchive.RecordingSyncStateEnum
 */
var RecordingArchive_RecordingSyncStateEnum;
(function (RecordingArchive_RecordingSyncStateEnum) {
    /**
     * @generated from protobuf enum value: kRecordingSyncStateInSyncWithShow = 0;
     */
    RecordingArchive_RecordingSyncStateEnum[RecordingArchive_RecordingSyncStateEnum["kRecordingSyncStateInSyncWithShow"] = 0] = "kRecordingSyncStateInSyncWithShow";
    /**
     * @generated from protobuf enum value: kRecordingSyncStateOutOfSyncWithShow = 1;
     */
    RecordingArchive_RecordingSyncStateEnum[RecordingArchive_RecordingSyncStateEnum["kRecordingSyncStateOutOfSyncWithShow"] = 1] = "kRecordingSyncStateOutOfSyncWithShow";
})(RecordingArchive_RecordingSyncStateEnum = exports.RecordingArchive_RecordingSyncStateEnum || (exports.RecordingArchive_RecordingSyncStateEnum = {}));
/**
 * @generated from protobuf enum KN.RecordingNavigationEventArchive.RecordingNavigationEventAnimationPhase
 */
var RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase;
(function (RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase) {
    /**
     * @generated from protobuf enum value: kRecordingNavigationEventAnimationNone = 0;
     */
    RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase[RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase["kRecordingNavigationEventAnimationNone"] = 0] = "kRecordingNavigationEventAnimationNone";
    /**
     * @generated from protobuf enum value: kRecordingNavigationEventAnimationStart = 1;
     */
    RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase[RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase["kRecordingNavigationEventAnimationStart"] = 1] = "kRecordingNavigationEventAnimationStart";
    /**
     * @generated from protobuf enum value: kRecordingNavigationEventAnimationEnd = 2;
     */
    RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase[RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase["kRecordingNavigationEventAnimationEnd"] = 2] = "kRecordingNavigationEventAnimationEnd";
})(RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase = exports.RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase || (exports.RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase = {}));
/**
 * @generated from protobuf enum KN.RecordingPauseEventArchive.RecordingPauseEventType
 */
var RecordingPauseEventArchive_RecordingPauseEventType;
(function (RecordingPauseEventArchive_RecordingPauseEventType) {
    /**
     * @generated from protobuf enum value: kRecordingPauseEventTypeResume = 0;
     */
    RecordingPauseEventArchive_RecordingPauseEventType[RecordingPauseEventArchive_RecordingPauseEventType["kRecordingPauseEventTypeResume"] = 0] = "kRecordingPauseEventTypeResume";
    /**
     * @generated from protobuf enum value: kRecordingPauseEventTypePause = 1;
     */
    RecordingPauseEventArchive_RecordingPauseEventType[RecordingPauseEventArchive_RecordingPauseEventType["kRecordingPauseEventTypePause"] = 1] = "kRecordingPauseEventTypePause";
    /**
     * @generated from protobuf enum value: kRecordingPauseEventTypeConcealWithBlack = 2;
     */
    RecordingPauseEventArchive_RecordingPauseEventType[RecordingPauseEventArchive_RecordingPauseEventType["kRecordingPauseEventTypeConcealWithBlack"] = 2] = "kRecordingPauseEventTypeConcealWithBlack";
    /**
     * @generated from protobuf enum value: kRecordingPauseEventTypeConcealWithWhite = 3;
     */
    RecordingPauseEventArchive_RecordingPauseEventType[RecordingPauseEventArchive_RecordingPauseEventType["kRecordingPauseEventTypeConcealWithWhite"] = 3] = "kRecordingPauseEventTypeConcealWithWhite";
})(RecordingPauseEventArchive_RecordingPauseEventType = exports.RecordingPauseEventArchive_RecordingPauseEventType || (exports.RecordingPauseEventArchive_RecordingPauseEventType = {}));
/**
 * @generated from protobuf enum KN.RecordingMovieEventArchive.RecordingMovieEventType
 */
var RecordingMovieEventArchive_RecordingMovieEventType;
(function (RecordingMovieEventArchive_RecordingMovieEventType) {
    /**
     * @generated from protobuf enum value: kRecordingMovieEventNone = 0;
     */
    RecordingMovieEventArchive_RecordingMovieEventType[RecordingMovieEventArchive_RecordingMovieEventType["kRecordingMovieEventNone"] = 0] = "kRecordingMovieEventNone";
    /**
     * @generated from protobuf enum value: kRecordingMovieEventSeek = 1;
     */
    RecordingMovieEventArchive_RecordingMovieEventType[RecordingMovieEventArchive_RecordingMovieEventType["kRecordingMovieEventSeek"] = 1] = "kRecordingMovieEventSeek";
    /**
     * @generated from protobuf enum value: kRecordingMovieEventSetRate = 2;
     */
    RecordingMovieEventArchive_RecordingMovieEventType[RecordingMovieEventArchive_RecordingMovieEventType["kRecordingMovieEventSetRate"] = 2] = "kRecordingMovieEventSetRate";
    /**
     * @generated from protobuf enum value: kRecordingMovieEventStartPlayback = 3;
     */
    RecordingMovieEventArchive_RecordingMovieEventType[RecordingMovieEventArchive_RecordingMovieEventType["kRecordingMovieEventStartPlayback"] = 3] = "kRecordingMovieEventStartPlayback";
    /**
     * @generated from protobuf enum value: kRecordingMovieEventStopPlayback = 4;
     */
    RecordingMovieEventArchive_RecordingMovieEventType[RecordingMovieEventArchive_RecordingMovieEventType["kRecordingMovieEventStopPlayback"] = 4] = "kRecordingMovieEventStopPlayback";
    /**
     * @generated from protobuf enum value: kRecordingMovieEventBeginScrubbing = 5;
     */
    RecordingMovieEventArchive_RecordingMovieEventType[RecordingMovieEventArchive_RecordingMovieEventType["kRecordingMovieEventBeginScrubbing"] = 5] = "kRecordingMovieEventBeginScrubbing";
    /**
     * @generated from protobuf enum value: kRecordingMovieEventEndScrubbing = 6;
     */
    RecordingMovieEventArchive_RecordingMovieEventType[RecordingMovieEventArchive_RecordingMovieEventType["kRecordingMovieEventEndScrubbing"] = 6] = "kRecordingMovieEventEndScrubbing";
})(RecordingMovieEventArchive_RecordingMovieEventType = exports.RecordingMovieEventArchive_RecordingMovieEventType || (exports.RecordingMovieEventArchive_RecordingMovieEventType = {}));
/**
 * @generated from protobuf enum KN.Soundtrack.SoundtrackMode
 */
var Soundtrack_SoundtrackMode;
(function (Soundtrack_SoundtrackMode) {
    /**
     * @generated from protobuf enum value: kKNSoundtrackModePlayOnce = 0;
     */
    Soundtrack_SoundtrackMode[Soundtrack_SoundtrackMode["kKNSoundtrackModePlayOnce"] = 0] = "kKNSoundtrackModePlayOnce";
    /**
     * @generated from protobuf enum value: kKNSoundtrackModeLoop = 1;
     */
    Soundtrack_SoundtrackMode[Soundtrack_SoundtrackMode["kKNSoundtrackModeLoop"] = 1] = "kKNSoundtrackModeLoop";
    /**
     * @generated from protobuf enum value: kKNSoundtrackModeDoNotPlay = 2;
     */
    Soundtrack_SoundtrackMode[Soundtrack_SoundtrackMode["kKNSoundtrackModeDoNotPlay"] = 2] = "kKNSoundtrackModeDoNotPlay";
})(Soundtrack_SoundtrackMode = exports.Soundtrack_SoundtrackMode || (exports.Soundtrack_SoundtrackMode = {}));
/**
 * @generated from protobuf enum KN.MixedIdOperationArgs.ArgsListKind
 */
var MixedIdOperationArgs_ArgsListKind;
(function (MixedIdOperationArgs_ArgsListKind) {
    /**
     * @generated from protobuf enum value: Add = 0;
     */
    MixedIdOperationArgs_ArgsListKind[MixedIdOperationArgs_ArgsListKind["Add"] = 0] = "Add";
    /**
     * @generated from protobuf enum value: Remove = 1;
     */
    MixedIdOperationArgs_ArgsListKind[MixedIdOperationArgs_ArgsListKind["Remove"] = 1] = "Remove";
    /**
     * @generated from protobuf enum value: ShowPlaceholder = 2;
     */
    MixedIdOperationArgs_ArgsListKind[MixedIdOperationArgs_ArgsListKind["ShowPlaceholder"] = 2] = "ShowPlaceholder";
    /**
     * @generated from protobuf enum value: HidePlaceholder = 3;
     */
    MixedIdOperationArgs_ArgsListKind[MixedIdOperationArgs_ArgsListKind["HidePlaceholder"] = 3] = "HidePlaceholder";
})(MixedIdOperationArgs_ArgsListKind = exports.MixedIdOperationArgs_ArgsListKind || (exports.MixedIdOperationArgs_ArgsListKind = {}));
/**
 * @generated from protobuf enum KN.LiveVideoCaptureDeviceDescription.Position
 */
var LiveVideoCaptureDeviceDescription_Position;
(function (LiveVideoCaptureDeviceDescription_Position) {
    /**
     * @generated from protobuf enum value: Unspecified = 0;
     */
    LiveVideoCaptureDeviceDescription_Position[LiveVideoCaptureDeviceDescription_Position["Unspecified"] = 0] = "Unspecified";
    /**
     * @generated from protobuf enum value: Back = 1;
     */
    LiveVideoCaptureDeviceDescription_Position[LiveVideoCaptureDeviceDescription_Position["Back"] = 1] = "Back";
    /**
     * @generated from protobuf enum value: Front = 2;
     */
    LiveVideoCaptureDeviceDescription_Position[LiveVideoCaptureDeviceDescription_Position["Front"] = 2] = "Front";
})(LiveVideoCaptureDeviceDescription_Position = exports.LiveVideoCaptureDeviceDescription_Position || (exports.LiveVideoCaptureDeviceDescription_Position = {}));
// @generated message type with reflection information, may provide speed optimized methods
class AnimationAttributesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.AnimationAttributesArchive", [
            { no: 1, name: "animation_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "effect", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "duration", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "direction", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "delay", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "is_automatic", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "color", kind: "message", T: () => TSPMessages_9.Color },
            { no: 8, name: "custom_effect_timing_curve_1", kind: "message", T: () => TSDArchives_4.PathSourceArchive },
            { no: 9, name: "custom_effect_timing_curve_2", kind: "message", T: () => TSDArchives_4.PathSourceArchive },
            { no: 10, name: "custom_effect_timing_curve_3", kind: "message", T: () => TSDArchives_4.PathSourceArchive },
            { no: 11, name: "random_number_seed", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "custom_detail", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 13, name: "custom_effect_timing_curve_theme_name_1", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "custom_effect_timing_curve_theme_name_2", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "custom_effect_timing_curve_theme_name_3", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "writing_direction_is_rtl", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string animation_type */ 1:
                    message.animationType = reader.string();
                    break;
                case /* optional string effect */ 2:
                    message.effect = reader.string();
                    break;
                case /* optional double duration */ 3:
                    message.duration = reader.double();
                    break;
                case /* optional uint32 direction */ 4:
                    message.direction = reader.uint32();
                    break;
                case /* optional double delay */ 5:
                    message.delay = reader.double();
                    break;
                case /* optional bool is_automatic */ 6:
                    message.isAutomatic = reader.bool();
                    break;
                case /* optional TSP.Color color */ 7:
                    message.color = TSPMessages_9.Color.internalBinaryRead(reader, reader.uint32(), options, message.color);
                    break;
                case /* optional TSD.PathSourceArchive custom_effect_timing_curve_1 */ 8:
                    message.customEffectTimingCurve1 = TSDArchives_4.PathSourceArchive.internalBinaryRead(reader, reader.uint32(), options, message.customEffectTimingCurve1);
                    break;
                case /* optional TSD.PathSourceArchive custom_effect_timing_curve_2 */ 9:
                    message.customEffectTimingCurve2 = TSDArchives_4.PathSourceArchive.internalBinaryRead(reader, reader.uint32(), options, message.customEffectTimingCurve2);
                    break;
                case /* optional TSD.PathSourceArchive custom_effect_timing_curve_3 */ 10:
                    message.customEffectTimingCurve3 = TSDArchives_4.PathSourceArchive.internalBinaryRead(reader, reader.uint32(), options, message.customEffectTimingCurve3);
                    break;
                case /* optional uint32 random_number_seed */ 11:
                    message.randomNumberSeed = reader.uint32();
                    break;
                case /* optional double custom_detail */ 12:
                    message.customDetail = reader.double();
                    break;
                case /* optional string custom_effect_timing_curve_theme_name_1 */ 13:
                    message.customEffectTimingCurveThemeName1 = reader.string();
                    break;
                case /* optional string custom_effect_timing_curve_theme_name_2 */ 14:
                    message.customEffectTimingCurveThemeName2 = reader.string();
                    break;
                case /* optional string custom_effect_timing_curve_theme_name_3 */ 15:
                    message.customEffectTimingCurveThemeName3 = reader.string();
                    break;
                case /* optional bool writing_direction_is_rtl */ 16:
                    message.writingDirectionIsRtl = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string animation_type = 1; */
        if (message.animationType !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.animationType);
        /* optional string effect = 2; */
        if (message.effect !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.effect);
        /* optional double duration = 3; */
        if (message.duration !== undefined)
            writer.tag(3, runtime_1.WireType.Bit64).double(message.duration);
        /* optional uint32 direction = 4; */
        if (message.direction !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.direction);
        /* optional double delay = 5; */
        if (message.delay !== undefined)
            writer.tag(5, runtime_1.WireType.Bit64).double(message.delay);
        /* optional bool is_automatic = 6; */
        if (message.isAutomatic !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.isAutomatic);
        /* optional TSP.Color color = 7; */
        if (message.color)
            TSPMessages_9.Color.internalBinaryWrite(message.color, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.PathSourceArchive custom_effect_timing_curve_1 = 8; */
        if (message.customEffectTimingCurve1)
            TSDArchives_4.PathSourceArchive.internalBinaryWrite(message.customEffectTimingCurve1, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.PathSourceArchive custom_effect_timing_curve_2 = 9; */
        if (message.customEffectTimingCurve2)
            TSDArchives_4.PathSourceArchive.internalBinaryWrite(message.customEffectTimingCurve2, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.PathSourceArchive custom_effect_timing_curve_3 = 10; */
        if (message.customEffectTimingCurve3)
            TSDArchives_4.PathSourceArchive.internalBinaryWrite(message.customEffectTimingCurve3, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 random_number_seed = 11; */
        if (message.randomNumberSeed !== undefined)
            writer.tag(11, runtime_1.WireType.Varint).uint32(message.randomNumberSeed);
        /* optional double custom_detail = 12; */
        if (message.customDetail !== undefined)
            writer.tag(12, runtime_1.WireType.Bit64).double(message.customDetail);
        /* optional string custom_effect_timing_curve_theme_name_1 = 13; */
        if (message.customEffectTimingCurveThemeName1 !== undefined)
            writer.tag(13, runtime_1.WireType.LengthDelimited).string(message.customEffectTimingCurveThemeName1);
        /* optional string custom_effect_timing_curve_theme_name_2 = 14; */
        if (message.customEffectTimingCurveThemeName2 !== undefined)
            writer.tag(14, runtime_1.WireType.LengthDelimited).string(message.customEffectTimingCurveThemeName2);
        /* optional string custom_effect_timing_curve_theme_name_3 = 15; */
        if (message.customEffectTimingCurveThemeName3 !== undefined)
            writer.tag(15, runtime_1.WireType.LengthDelimited).string(message.customEffectTimingCurveThemeName3);
        /* optional bool writing_direction_is_rtl = 16; */
        if (message.writingDirectionIsRtl !== undefined)
            writer.tag(16, runtime_1.WireType.Varint).bool(message.writingDirectionIsRtl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.AnimationAttributesArchive
 */
exports.AnimationAttributesArchive = new AnimationAttributesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransitionAttributesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.TransitionAttributesArchive", [
            { no: 8, name: "animationAttributes", kind: "message", T: () => exports.AnimationAttributesArchive },
            { no: 9, name: "custom_twist", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "custom_mosaic_size", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "custom_mosaic_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "custom_bounce", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "custom_magic_move_fade_unmatched_objects", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "custom_timing_curve", kind: "enum", opt: true, T: () => ["KN.TransitionAttributesArchive.TransitionCustomAttributesTimingCurveType", TransitionAttributesArchive_TransitionCustomAttributesTimingCurveType] },
            { no: 16, name: "custom_text_delivery_type", kind: "enum", opt: true, T: () => ["KN.TransitionAttributesArchive.TransitionCustomAttributesTextDeliveryType", TransitionAttributesArchive_TransitionCustomAttributesTextDeliveryType] },
            { no: 17, name: "custom_motion_blur", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "custom_travel_distance", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 1, name: "database_animation_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "database_effect", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "database_duration", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "database_direction", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "database_delay", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "database_is_automatic", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "database_color", kind: "message", T: () => TSPMessages_9.Color }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional KN.AnimationAttributesArchive animationAttributes */ 8:
                    message.animationAttributes = exports.AnimationAttributesArchive.internalBinaryRead(reader, reader.uint32(), options, message.animationAttributes);
                    break;
                case /* optional float custom_twist */ 9:
                    message.customTwist = reader.float();
                    break;
                case /* optional uint32 custom_mosaic_size */ 10:
                    message.customMosaicSize = reader.uint32();
                    break;
                case /* optional uint32 custom_mosaic_type */ 11:
                    message.customMosaicType = reader.uint32();
                    break;
                case /* optional bool custom_bounce */ 12:
                    message.customBounce = reader.bool();
                    break;
                case /* optional bool custom_magic_move_fade_unmatched_objects */ 13:
                    message.customMagicMoveFadeUnmatchedObjects = reader.bool();
                    break;
                case /* optional KN.TransitionAttributesArchive.TransitionCustomAttributesTimingCurveType custom_timing_curve */ 15:
                    message.customTimingCurve = reader.int32();
                    break;
                case /* optional KN.TransitionAttributesArchive.TransitionCustomAttributesTextDeliveryType custom_text_delivery_type */ 16:
                    message.customTextDeliveryType = reader.int32();
                    break;
                case /* optional bool custom_motion_blur */ 17:
                    message.customMotionBlur = reader.bool();
                    break;
                case /* optional float custom_travel_distance */ 18:
                    message.customTravelDistance = reader.float();
                    break;
                case /* optional string database_animation_type = 1 [deprecated = true];*/ 1:
                    message.databaseAnimationType = reader.string();
                    break;
                case /* optional string database_effect = 2 [deprecated = true];*/ 2:
                    message.databaseEffect = reader.string();
                    break;
                case /* optional double database_duration = 3 [deprecated = true];*/ 3:
                    message.databaseDuration = reader.double();
                    break;
                case /* optional uint32 database_direction = 4 [deprecated = true];*/ 4:
                    message.databaseDirection = reader.uint32();
                    break;
                case /* optional float database_delay = 5 [deprecated = true];*/ 5:
                    message.databaseDelay = reader.float();
                    break;
                case /* optional bool database_is_automatic = 6 [deprecated = true];*/ 6:
                    message.databaseIsAutomatic = reader.bool();
                    break;
                case /* optional TSP.Color database_color = 7 [deprecated = true];*/ 7:
                    message.databaseColor = TSPMessages_9.Color.internalBinaryRead(reader, reader.uint32(), options, message.databaseColor);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional KN.AnimationAttributesArchive animationAttributes = 8; */
        if (message.animationAttributes)
            exports.AnimationAttributesArchive.internalBinaryWrite(message.animationAttributes, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional float custom_twist = 9; */
        if (message.customTwist !== undefined)
            writer.tag(9, runtime_1.WireType.Bit32).float(message.customTwist);
        /* optional uint32 custom_mosaic_size = 10; */
        if (message.customMosaicSize !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).uint32(message.customMosaicSize);
        /* optional uint32 custom_mosaic_type = 11; */
        if (message.customMosaicType !== undefined)
            writer.tag(11, runtime_1.WireType.Varint).uint32(message.customMosaicType);
        /* optional bool custom_bounce = 12; */
        if (message.customBounce !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).bool(message.customBounce);
        /* optional bool custom_magic_move_fade_unmatched_objects = 13; */
        if (message.customMagicMoveFadeUnmatchedObjects !== undefined)
            writer.tag(13, runtime_1.WireType.Varint).bool(message.customMagicMoveFadeUnmatchedObjects);
        /* optional KN.TransitionAttributesArchive.TransitionCustomAttributesTimingCurveType custom_timing_curve = 15; */
        if (message.customTimingCurve !== undefined)
            writer.tag(15, runtime_1.WireType.Varint).int32(message.customTimingCurve);
        /* optional KN.TransitionAttributesArchive.TransitionCustomAttributesTextDeliveryType custom_text_delivery_type = 16; */
        if (message.customTextDeliveryType !== undefined)
            writer.tag(16, runtime_1.WireType.Varint).int32(message.customTextDeliveryType);
        /* optional bool custom_motion_blur = 17; */
        if (message.customMotionBlur !== undefined)
            writer.tag(17, runtime_1.WireType.Varint).bool(message.customMotionBlur);
        /* optional float custom_travel_distance = 18; */
        if (message.customTravelDistance !== undefined)
            writer.tag(18, runtime_1.WireType.Bit32).float(message.customTravelDistance);
        /* optional string database_animation_type = 1 [deprecated = true]; */
        if (message.databaseAnimationType !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.databaseAnimationType);
        /* optional string database_effect = 2 [deprecated = true]; */
        if (message.databaseEffect !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.databaseEffect);
        /* optional double database_duration = 3 [deprecated = true]; */
        if (message.databaseDuration !== undefined)
            writer.tag(3, runtime_1.WireType.Bit64).double(message.databaseDuration);
        /* optional uint32 database_direction = 4 [deprecated = true]; */
        if (message.databaseDirection !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.databaseDirection);
        /* optional float database_delay = 5 [deprecated = true]; */
        if (message.databaseDelay !== undefined)
            writer.tag(5, runtime_1.WireType.Bit32).float(message.databaseDelay);
        /* optional bool database_is_automatic = 6 [deprecated = true]; */
        if (message.databaseIsAutomatic !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.databaseIsAutomatic);
        /* optional TSP.Color database_color = 7 [deprecated = true]; */
        if (message.databaseColor)
            TSPMessages_9.Color.internalBinaryWrite(message.databaseColor, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.TransitionAttributesArchive
 */
exports.TransitionAttributesArchive = new TransitionAttributesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransitionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.TransitionArchive", [
            { no: 2, name: "attributes", kind: "message", T: () => exports.TransitionAttributesArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* KN.TransitionAttributesArchive attributes */ 2:
                    message.attributes = exports.TransitionAttributesArchive.internalBinaryRead(reader, reader.uint32(), options, message.attributes);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* KN.TransitionAttributesArchive attributes = 2; */
        if (message.attributes)
            exports.TransitionAttributesArchive.internalBinaryWrite(message.attributes, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.TransitionArchive
 */
exports.TransitionArchive = new TransitionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuildChunkArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.BuildChunkArchive", [
            { no: 1, name: "build", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 2, name: "index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "delay", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "duration", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "automatic", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "referent", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "build_chunk_identifier", kind: "message", T: () => exports.BuildChunkIdentifierArchive },
            { no: 8, name: "build_id", kind: "message", T: () => TSPMessages_7.UUID }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference build */ 1:
                    message.build = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.build);
                    break;
                case /* optional uint32 index = 2 [deprecated = true];*/ 2:
                    message.index = reader.uint32();
                    break;
                case /* optional double delay */ 3:
                    message.delay = reader.double();
                    break;
                case /* optional double duration */ 4:
                    message.duration = reader.double();
                    break;
                case /* optional bool automatic */ 5:
                    message.automatic = reader.bool();
                    break;
                case /* optional bool referent */ 6:
                    message.referent = reader.bool();
                    break;
                case /* optional KN.BuildChunkIdentifierArchive build_chunk_identifier */ 7:
                    message.buildChunkIdentifier = exports.BuildChunkIdentifierArchive.internalBinaryRead(reader, reader.uint32(), options, message.buildChunkIdentifier);
                    break;
                case /* optional TSP.UUID build_id */ 8:
                    message.buildId = TSPMessages_7.UUID.internalBinaryRead(reader, reader.uint32(), options, message.buildId);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference build = 1; */
        if (message.build)
            TSPMessages_8.Reference.internalBinaryWrite(message.build, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 index = 2 [deprecated = true]; */
        if (message.index !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.index);
        /* optional double delay = 3; */
        if (message.delay !== undefined)
            writer.tag(3, runtime_1.WireType.Bit64).double(message.delay);
        /* optional double duration = 4; */
        if (message.duration !== undefined)
            writer.tag(4, runtime_1.WireType.Bit64).double(message.duration);
        /* optional bool automatic = 5; */
        if (message.automatic !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.automatic);
        /* optional bool referent = 6; */
        if (message.referent !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.referent);
        /* optional KN.BuildChunkIdentifierArchive build_chunk_identifier = 7; */
        if (message.buildChunkIdentifier)
            exports.BuildChunkIdentifierArchive.internalBinaryWrite(message.buildChunkIdentifier, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID build_id = 8; */
        if (message.buildId)
            TSPMessages_7.UUID.internalBinaryWrite(message.buildId, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.BuildChunkArchive
 */
exports.BuildChunkArchive = new BuildChunkArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuildChunkIdentifierArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.BuildChunkIdentifierArchive", [
            { no: 1, name: "build_id", kind: "message", T: () => TSPMessages_7.UUID },
            { no: 2, name: "build_chunk_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.UUID build_id */ 1:
                    message.buildId = TSPMessages_7.UUID.internalBinaryRead(reader, reader.uint32(), options, message.buildId);
                    break;
                case /* optional int32 build_chunk_id */ 2:
                    message.buildChunkId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.UUID build_id = 1; */
        if (message.buildId)
            TSPMessages_7.UUID.internalBinaryWrite(message.buildId, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional int32 build_chunk_id = 2; */
        if (message.buildChunkId !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.buildChunkId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.BuildChunkIdentifierArchive
 */
exports.BuildChunkIdentifierArchive = new BuildChunkIdentifierArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuildAttributeValueArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.BuildAttributeValueArchive", [
            { no: 1, name: "integer_value", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "double_value", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "bool_value", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "string_value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "path_source_value", kind: "message", T: () => TSDArchives_4.PathSourceArchive },
            { no: 6, name: "color_value", kind: "message", T: () => TSPMessages_9.Color },
            { no: 7, name: "type", kind: "enum", opt: true, T: () => ["KN.BuildAttributeValueArchive.BuildAttributeValueType", BuildAttributeValueArchive_BuildAttributeValueType] }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 integer_value */ 1:
                    message.integerValue = reader.uint32();
                    break;
                case /* optional double double_value */ 2:
                    message.doubleValue = reader.double();
                    break;
                case /* optional bool bool_value */ 3:
                    message.boolValue = reader.bool();
                    break;
                case /* optional string string_value */ 4:
                    message.stringValue = reader.string();
                    break;
                case /* optional TSD.PathSourceArchive path_source_value */ 5:
                    message.pathSourceValue = TSDArchives_4.PathSourceArchive.internalBinaryRead(reader, reader.uint32(), options, message.pathSourceValue);
                    break;
                case /* optional TSP.Color color_value */ 6:
                    message.colorValue = TSPMessages_9.Color.internalBinaryRead(reader, reader.uint32(), options, message.colorValue);
                    break;
                case /* optional KN.BuildAttributeValueArchive.BuildAttributeValueType type */ 7:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional uint32 integer_value = 1; */
        if (message.integerValue !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.integerValue);
        /* optional double double_value = 2; */
        if (message.doubleValue !== undefined)
            writer.tag(2, runtime_1.WireType.Bit64).double(message.doubleValue);
        /* optional bool bool_value = 3; */
        if (message.boolValue !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.boolValue);
        /* optional string string_value = 4; */
        if (message.stringValue !== undefined)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.stringValue);
        /* optional TSD.PathSourceArchive path_source_value = 5; */
        if (message.pathSourceValue)
            TSDArchives_4.PathSourceArchive.internalBinaryWrite(message.pathSourceValue, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Color color_value = 6; */
        if (message.colorValue)
            TSPMessages_9.Color.internalBinaryWrite(message.colorValue, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional KN.BuildAttributeValueArchive.BuildAttributeValueType type = 7; */
        if (message.type !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.BuildAttributeValueArchive
 */
exports.BuildAttributeValueArchive = new BuildAttributeValueArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuildAttributeTupleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.BuildAttributeTupleArchive", [
            { no: 1, name: "property", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => exports.BuildAttributeValueArchive },
            { no: 3, name: "build_id", kind: "message", T: () => TSPMessages_7.UUID },
            { no: 4, name: "build_chunk_identifier", kind: "message", T: () => exports.BuildChunkIdentifierArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string property */ 1:
                    message.property = reader.string();
                    break;
                case /* optional KN.BuildAttributeValueArchive value */ 2:
                    message.value = exports.BuildAttributeValueArchive.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                case /* optional TSP.UUID build_id */ 3:
                    message.buildId = TSPMessages_7.UUID.internalBinaryRead(reader, reader.uint32(), options, message.buildId);
                    break;
                case /* optional KN.BuildChunkIdentifierArchive build_chunk_identifier */ 4:
                    message.buildChunkIdentifier = exports.BuildChunkIdentifierArchive.internalBinaryRead(reader, reader.uint32(), options, message.buildChunkIdentifier);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string property = 1; */
        if (message.property !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.property);
        /* optional KN.BuildAttributeValueArchive value = 2; */
        if (message.value)
            exports.BuildAttributeValueArchive.internalBinaryWrite(message.value, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID build_id = 3; */
        if (message.buildId)
            TSPMessages_7.UUID.internalBinaryWrite(message.buildId, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional KN.BuildChunkIdentifierArchive build_chunk_identifier = 4; */
        if (message.buildChunkIdentifier)
            exports.BuildChunkIdentifierArchive.internalBinaryWrite(message.buildChunkIdentifier, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.BuildAttributeTupleArchive
 */
exports.BuildAttributeTupleArchive = new BuildAttributeTupleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuildAttributesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.BuildAttributesArchive", [
            { no: 18, name: "animationAttributes", kind: "message", T: () => exports.AnimationAttributesArchive },
            { no: 4, name: "eventTrigger", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "delayAutomaticAfter", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "delayAutomaticWith", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 14, name: "curveStyle", kind: "enum", opt: true, T: () => ["KN.BuildAttributesArchive.BuildAttributesCurveStyle", BuildAttributesArchive_BuildAttributesCurveStyle] },
            { no: 17, name: "ChartRotation3D", kind: "scalar", jsonName: "ChartRotation3D", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 27, name: "startOffset", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 28, name: "endOffset", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "action_rotationAngle", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 10, name: "action_rotationDirection", kind: "enum", opt: true, T: () => ["KN.BuildAttributesArchive.BuildAttributesRotationDirection", BuildAttributesArchive_BuildAttributesRotationDirection] },
            { no: 11, name: "action_scaleSize", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 12, name: "action_colorAlpha", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 13, name: "action_acceleration", kind: "enum", opt: true, T: () => ["KN.BuildAttributesArchive.BuildAttributesAcceleration", BuildAttributesArchive_BuildAttributesAcceleration] },
            { no: 22, name: "action_motionPathSource", kind: "message", T: () => TSDArchives_4.PathSourceArchive },
            { no: 19, name: "custom_bounce", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 20, name: "custom_textDelivery", kind: "enum", opt: true, T: () => ["KN.BuildAttributesArchive.BuildAttributesTextDelivery", BuildAttributesArchive_BuildAttributesTextDelivery] },
            { no: 21, name: "custom_deliveryOption", kind: "enum", opt: true, T: () => ["KN.BuildAttributesArchive.BuildAttributesDeliveryOption", BuildAttributesArchive_BuildAttributesDeliveryOption] },
            { no: 23, name: "custom_action_decay", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 24, name: "custom_action_repeatCount", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 25, name: "custom_action_scale", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 26, name: "custom_action_jiggleIntensity", kind: "enum", opt: true, T: () => ["KN.BuildAttributesArchive.ActionBuildAttributesJiggleIntensity", BuildAttributesArchive_ActionBuildAttributesJiggleIntensity] },
            { no: 29, name: "custom_motion_blur", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 30, name: "custom_include_endpoints", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 33, name: "custom_shine", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 34, name: "custom_scale_amount", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 35, name: "custom_travel_distance", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 36, name: "custom_cursor", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 37, name: "custom_align_to_path", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 1, name: "database_animationType", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "database_effect", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "database_direction", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "database_delay", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 8, name: "database_duration", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 16, name: "database_color", kind: "message", T: () => TSPMessages_9.Color },
            { no: 15, name: "motionPathString", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional KN.AnimationAttributesArchive animationAttributes */ 18:
                    message.animationAttributes = exports.AnimationAttributesArchive.internalBinaryRead(reader, reader.uint32(), options, message.animationAttributes);
                    break;
                case /* optional uint32 eventTrigger */ 4:
                    message.eventTrigger = reader.uint32();
                    break;
                case /* optional double delayAutomaticAfter = 6 [deprecated = true];*/ 6:
                    message.delayAutomaticAfter = reader.double();
                    break;
                case /* optional double delayAutomaticWith = 7 [deprecated = true];*/ 7:
                    message.delayAutomaticWith = reader.double();
                    break;
                case /* optional KN.BuildAttributesArchive.BuildAttributesCurveStyle curveStyle */ 14:
                    message.curveStyle = reader.int32();
                    break;
                case /* optional double ChartRotation3D = 17 [json_name = "ChartRotation3D"];*/ 17:
                    message.chartRotation3D = reader.double();
                    break;
                case /* optional uint32 startOffset */ 27:
                    message.startOffset = reader.uint32();
                    break;
                case /* optional uint32 endOffset */ 28:
                    message.endOffset = reader.uint32();
                    break;
                case /* optional double action_rotationAngle */ 9:
                    message.actionRotationAngle = reader.double();
                    break;
                case /* optional KN.BuildAttributesArchive.BuildAttributesRotationDirection action_rotationDirection */ 10:
                    message.actionRotationDirection = reader.int32();
                    break;
                case /* optional double action_scaleSize */ 11:
                    message.actionScaleSize = reader.double();
                    break;
                case /* optional double action_colorAlpha */ 12:
                    message.actionColorAlpha = reader.double();
                    break;
                case /* optional KN.BuildAttributesArchive.BuildAttributesAcceleration action_acceleration */ 13:
                    message.actionAcceleration = reader.int32();
                    break;
                case /* optional TSD.PathSourceArchive action_motionPathSource */ 22:
                    message.actionMotionPathSource = TSDArchives_4.PathSourceArchive.internalBinaryRead(reader, reader.uint32(), options, message.actionMotionPathSource);
                    break;
                case /* optional bool custom_bounce */ 19:
                    message.customBounce = reader.bool();
                    break;
                case /* optional KN.BuildAttributesArchive.BuildAttributesTextDelivery custom_textDelivery */ 20:
                    message.customTextDelivery = reader.int32();
                    break;
                case /* optional KN.BuildAttributesArchive.BuildAttributesDeliveryOption custom_deliveryOption */ 21:
                    message.customDeliveryOption = reader.int32();
                    break;
                case /* optional bool custom_action_decay */ 23:
                    message.customActionDecay = reader.bool();
                    break;
                case /* optional uint32 custom_action_repeatCount */ 24:
                    message.customActionRepeatCount = reader.uint32();
                    break;
                case /* optional double custom_action_scale */ 25:
                    message.customActionScale = reader.double();
                    break;
                case /* optional KN.BuildAttributesArchive.ActionBuildAttributesJiggleIntensity custom_action_jiggleIntensity */ 26:
                    message.customActionJiggleIntensity = reader.int32();
                    break;
                case /* optional bool custom_motion_blur */ 29:
                    message.customMotionBlur = reader.bool();
                    break;
                case /* optional bool custom_include_endpoints */ 30:
                    message.customIncludeEndpoints = reader.bool();
                    break;
                case /* optional bool custom_shine */ 33:
                    message.customShine = reader.bool();
                    break;
                case /* optional double custom_scale_amount */ 34:
                    message.customScaleAmount = reader.double();
                    break;
                case /* optional double custom_travel_distance */ 35:
                    message.customTravelDistance = reader.double();
                    break;
                case /* optional bool custom_cursor */ 36:
                    message.customCursor = reader.bool();
                    break;
                case /* optional bool custom_align_to_path */ 37:
                    message.customAlignToPath = reader.bool();
                    break;
                case /* optional string database_animationType = 1 [deprecated = true];*/ 1:
                    message.databaseAnimationType = reader.string();
                    break;
                case /* optional string database_effect = 2 [deprecated = true];*/ 2:
                    message.databaseEffect = reader.string();
                    break;
                case /* optional uint32 database_direction = 3 [deprecated = true];*/ 3:
                    message.databaseDirection = reader.uint32();
                    break;
                case /* optional double database_delay = 5 [deprecated = true];*/ 5:
                    message.databaseDelay = reader.double();
                    break;
                case /* optional double database_duration = 8 [deprecated = true];*/ 8:
                    message.databaseDuration = reader.double();
                    break;
                case /* optional TSP.Color database_color = 16 [deprecated = true];*/ 16:
                    message.databaseColor = TSPMessages_9.Color.internalBinaryRead(reader, reader.uint32(), options, message.databaseColor);
                    break;
                case /* optional string motionPathString = 15 [deprecated = true];*/ 15:
                    message.motionPathString = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional KN.AnimationAttributesArchive animationAttributes = 18; */
        if (message.animationAttributes)
            exports.AnimationAttributesArchive.internalBinaryWrite(message.animationAttributes, writer.tag(18, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 eventTrigger = 4; */
        if (message.eventTrigger !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.eventTrigger);
        /* optional double delayAutomaticAfter = 6 [deprecated = true]; */
        if (message.delayAutomaticAfter !== undefined)
            writer.tag(6, runtime_1.WireType.Bit64).double(message.delayAutomaticAfter);
        /* optional double delayAutomaticWith = 7 [deprecated = true]; */
        if (message.delayAutomaticWith !== undefined)
            writer.tag(7, runtime_1.WireType.Bit64).double(message.delayAutomaticWith);
        /* optional KN.BuildAttributesArchive.BuildAttributesCurveStyle curveStyle = 14; */
        if (message.curveStyle !== undefined)
            writer.tag(14, runtime_1.WireType.Varint).int32(message.curveStyle);
        /* optional double ChartRotation3D = 17 [json_name = "ChartRotation3D"]; */
        if (message.chartRotation3D !== undefined)
            writer.tag(17, runtime_1.WireType.Bit64).double(message.chartRotation3D);
        /* optional uint32 startOffset = 27; */
        if (message.startOffset !== undefined)
            writer.tag(27, runtime_1.WireType.Varint).uint32(message.startOffset);
        /* optional uint32 endOffset = 28; */
        if (message.endOffset !== undefined)
            writer.tag(28, runtime_1.WireType.Varint).uint32(message.endOffset);
        /* optional double action_rotationAngle = 9; */
        if (message.actionRotationAngle !== undefined)
            writer.tag(9, runtime_1.WireType.Bit64).double(message.actionRotationAngle);
        /* optional KN.BuildAttributesArchive.BuildAttributesRotationDirection action_rotationDirection = 10; */
        if (message.actionRotationDirection !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).int32(message.actionRotationDirection);
        /* optional double action_scaleSize = 11; */
        if (message.actionScaleSize !== undefined)
            writer.tag(11, runtime_1.WireType.Bit64).double(message.actionScaleSize);
        /* optional double action_colorAlpha = 12; */
        if (message.actionColorAlpha !== undefined)
            writer.tag(12, runtime_1.WireType.Bit64).double(message.actionColorAlpha);
        /* optional KN.BuildAttributesArchive.BuildAttributesAcceleration action_acceleration = 13; */
        if (message.actionAcceleration !== undefined)
            writer.tag(13, runtime_1.WireType.Varint).int32(message.actionAcceleration);
        /* optional TSD.PathSourceArchive action_motionPathSource = 22; */
        if (message.actionMotionPathSource)
            TSDArchives_4.PathSourceArchive.internalBinaryWrite(message.actionMotionPathSource, writer.tag(22, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool custom_bounce = 19; */
        if (message.customBounce !== undefined)
            writer.tag(19, runtime_1.WireType.Varint).bool(message.customBounce);
        /* optional KN.BuildAttributesArchive.BuildAttributesTextDelivery custom_textDelivery = 20; */
        if (message.customTextDelivery !== undefined)
            writer.tag(20, runtime_1.WireType.Varint).int32(message.customTextDelivery);
        /* optional KN.BuildAttributesArchive.BuildAttributesDeliveryOption custom_deliveryOption = 21; */
        if (message.customDeliveryOption !== undefined)
            writer.tag(21, runtime_1.WireType.Varint).int32(message.customDeliveryOption);
        /* optional bool custom_action_decay = 23; */
        if (message.customActionDecay !== undefined)
            writer.tag(23, runtime_1.WireType.Varint).bool(message.customActionDecay);
        /* optional uint32 custom_action_repeatCount = 24; */
        if (message.customActionRepeatCount !== undefined)
            writer.tag(24, runtime_1.WireType.Varint).uint32(message.customActionRepeatCount);
        /* optional double custom_action_scale = 25; */
        if (message.customActionScale !== undefined)
            writer.tag(25, runtime_1.WireType.Bit64).double(message.customActionScale);
        /* optional KN.BuildAttributesArchive.ActionBuildAttributesJiggleIntensity custom_action_jiggleIntensity = 26; */
        if (message.customActionJiggleIntensity !== undefined)
            writer.tag(26, runtime_1.WireType.Varint).int32(message.customActionJiggleIntensity);
        /* optional bool custom_motion_blur = 29; */
        if (message.customMotionBlur !== undefined)
            writer.tag(29, runtime_1.WireType.Varint).bool(message.customMotionBlur);
        /* optional bool custom_include_endpoints = 30; */
        if (message.customIncludeEndpoints !== undefined)
            writer.tag(30, runtime_1.WireType.Varint).bool(message.customIncludeEndpoints);
        /* optional bool custom_shine = 33; */
        if (message.customShine !== undefined)
            writer.tag(33, runtime_1.WireType.Varint).bool(message.customShine);
        /* optional double custom_scale_amount = 34; */
        if (message.customScaleAmount !== undefined)
            writer.tag(34, runtime_1.WireType.Bit64).double(message.customScaleAmount);
        /* optional double custom_travel_distance = 35; */
        if (message.customTravelDistance !== undefined)
            writer.tag(35, runtime_1.WireType.Bit64).double(message.customTravelDistance);
        /* optional bool custom_cursor = 36; */
        if (message.customCursor !== undefined)
            writer.tag(36, runtime_1.WireType.Varint).bool(message.customCursor);
        /* optional bool custom_align_to_path = 37; */
        if (message.customAlignToPath !== undefined)
            writer.tag(37, runtime_1.WireType.Varint).bool(message.customAlignToPath);
        /* optional string database_animationType = 1 [deprecated = true]; */
        if (message.databaseAnimationType !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.databaseAnimationType);
        /* optional string database_effect = 2 [deprecated = true]; */
        if (message.databaseEffect !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.databaseEffect);
        /* optional uint32 database_direction = 3 [deprecated = true]; */
        if (message.databaseDirection !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.databaseDirection);
        /* optional double database_delay = 5 [deprecated = true]; */
        if (message.databaseDelay !== undefined)
            writer.tag(5, runtime_1.WireType.Bit64).double(message.databaseDelay);
        /* optional double database_duration = 8 [deprecated = true]; */
        if (message.databaseDuration !== undefined)
            writer.tag(8, runtime_1.WireType.Bit64).double(message.databaseDuration);
        /* optional TSP.Color database_color = 16 [deprecated = true]; */
        if (message.databaseColor)
            TSPMessages_9.Color.internalBinaryWrite(message.databaseColor, writer.tag(16, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string motionPathString = 15 [deprecated = true]; */
        if (message.motionPathString !== undefined)
            writer.tag(15, runtime_1.WireType.LengthDelimited).string(message.motionPathString);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.BuildAttributesArchive
 */
exports.BuildAttributesArchive = new BuildAttributesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuildArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.BuildArchive", [
            { no: 1, name: "drawable", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 2, name: "delivery", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "duration", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "attributes", kind: "message", T: () => exports.BuildAttributesArchive },
            { no: 5, name: "chunk_id_seed", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = { delivery: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference drawable */ 1:
                    message.drawable = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.drawable);
                    break;
                case /* string delivery */ 2:
                    message.delivery = reader.string();
                    break;
                case /* optional double duration = 3 [deprecated = true];*/ 3:
                    message.duration = reader.double();
                    break;
                case /* KN.BuildAttributesArchive attributes */ 4:
                    message.attributes = exports.BuildAttributesArchive.internalBinaryRead(reader, reader.uint32(), options, message.attributes);
                    break;
                case /* optional int32 chunk_id_seed */ 5:
                    message.chunkIdSeed = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference drawable = 1; */
        if (message.drawable)
            TSPMessages_8.Reference.internalBinaryWrite(message.drawable, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string delivery = 2; */
        if (message.delivery !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.delivery);
        /* optional double duration = 3 [deprecated = true]; */
        if (message.duration !== undefined)
            writer.tag(3, runtime_1.WireType.Bit64).double(message.duration);
        /* KN.BuildAttributesArchive attributes = 4; */
        if (message.attributes)
            exports.BuildAttributesArchive.internalBinaryWrite(message.attributes, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional int32 chunk_id_seed = 5; */
        if (message.chunkIdSeed !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).int32(message.chunkIdSeed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.BuildArchive
 */
exports.BuildArchive = new BuildArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlaceholderArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.PlaceholderArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSWPArchives_3.ShapeInfoArchive },
            { no: 2, name: "kind", kind: "enum", opt: true, T: () => ["KN.PlaceholderArchive.Kind", PlaceholderArchive_Kind] }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSWP.ShapeInfoArchive super */ 1:
                    message.super = TSWPArchives_3.ShapeInfoArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional KN.PlaceholderArchive.Kind kind */ 2:
                    message.kind = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSWP.ShapeInfoArchive super = 1; */
        if (message.super)
            TSWPArchives_3.ShapeInfoArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional KN.PlaceholderArchive.Kind kind = 2; */
        if (message.kind !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.kind);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.PlaceholderArchive
 */
exports.PlaceholderArchive = new PlaceholderArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NoteArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.NoteArchive", [
            { no: 1, name: "containedStorage", kind: "message", T: () => TSPMessages_8.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.Reference containedStorage */ 1:
                    message.containedStorage = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.containedStorage);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.Reference containedStorage = 1; */
        if (message.containedStorage)
            TSPMessages_8.Reference.internalBinaryWrite(message.containedStorage, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.NoteArchive
 */
exports.NoteArchive = new NoteArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClassicStylesheetRecordArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.ClassicStylesheetRecordArchive", [
            { no: 1, name: "identifier_to_style_map", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSSArchives_3.StylesheetArchive_IdentifiedStyleEntry },
            { no: 2, name: "deprecated_theme", kind: "message", T: () => TSPMessages_8.Reference }
        ]);
    }
    create(value) {
        const message = { identifierToStyleMap: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSS.StylesheetArchive.IdentifiedStyleEntry identifier_to_style_map */ 1:
                    message.identifierToStyleMap.push(TSSArchives_3.StylesheetArchive_IdentifiedStyleEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Reference deprecated_theme = 2 [deprecated = true];*/ 2:
                    message.deprecatedTheme = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.deprecatedTheme);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSS.StylesheetArchive.IdentifiedStyleEntry identifier_to_style_map = 1; */
        for (let i = 0; i < message.identifierToStyleMap.length; i++)
            TSSArchives_3.StylesheetArchive_IdentifiedStyleEntry.internalBinaryWrite(message.identifierToStyleMap[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference deprecated_theme = 2 [deprecated = true]; */
        if (message.deprecatedTheme)
            TSPMessages_8.Reference.internalBinaryWrite(message.deprecatedTheme, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.ClassicStylesheetRecordArchive
 */
exports.ClassicStylesheetRecordArchive = new ClassicStylesheetRecordArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClassicThemeRecordArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.ClassicThemeRecordArchive", [
            { no: 1, name: "uuid", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "stylesheetRecord", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 3, name: "templates", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference }
        ]);
    }
    create(value) {
        const message = { templates: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* optional TSP.Reference stylesheetRecord */ 2:
                    message.stylesheetRecord = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.stylesheetRecord);
                    break;
                case /* repeated TSP.Reference templates */ 3:
                    message.templates.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string uuid = 1; */
        if (message.uuid !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.uuid);
        /* optional TSP.Reference stylesheetRecord = 2; */
        if (message.stylesheetRecord)
            TSPMessages_8.Reference.internalBinaryWrite(message.stylesheetRecord, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference templates = 3; */
        for (let i = 0; i < message.templates.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.templates[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.ClassicThemeRecordArchive
 */
exports.ClassicThemeRecordArchive = new ClassicThemeRecordArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SlideArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.SlideArchive", [
            { no: 1, name: "style", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 2, name: "builds", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 3, name: "buildChunkArchives", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.BuildChunkArchive },
            { no: 43, name: "buildChunks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 4, name: "transition", kind: "message", T: () => exports.TransitionArchive },
            { no: 5, name: "titlePlaceholder", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 6, name: "bodyPlaceholder", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 30, name: "objectPlaceholder", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 20, name: "slideNumberPlaceholder", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 7, name: "owned_drawables", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 42, name: "drawables_z_order", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 28, name: "sage_tag_to_info_map", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.SlideArchive_SageTagMapEntry },
            { no: 45, name: "instructional_text_map", kind: "message", T: () => exports.SlideArchive_InstructionalTextMap },
            { no: 10, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "titlePlaceholderGeometry", kind: "message", T: () => TSDArchives_3.GeometryArchive },
            { no: 12, name: "titlePlaceholderShapeStyleIndex", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "titlePlaceholderTextStyleIndex", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 24, name: "titleLayoutProperties", kind: "message", T: () => TSWPArchives_2.ShapeStylePropertiesArchive },
            { no: 14, name: "bodyPlaceholderGeometry", kind: "message", T: () => TSDArchives_3.GeometryArchive },
            { no: 15, name: "bodyPlaceholderShapeStyleIndex", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 16, name: "bodyPlaceholderTextStyleIndex", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 25, name: "bodyLayoutProperties", kind: "message", T: () => TSWPArchives_2.ShapeStylePropertiesArchive },
            { no: 21, name: "slideNumberPlaceholderGeometry", kind: "message", T: () => TSDArchives_3.GeometryArchive },
            { no: 22, name: "slideNumberPlaceholderShapeStyleIndex", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 23, name: "slideNumberPlaceholderTextStyleIndex", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 26, name: "slideNumberLayoutProperties", kind: "message", T: () => TSWPArchives_2.ShapeStylePropertiesArchive },
            { no: 29, name: "classicStylesheetRecord", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 31, name: "bodyParagraphStyles", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 35, name: "bodyListStyles", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 37, name: "thumbnailTextForTitlePlaceholder", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 38, name: "thumbnailTextForBodyPlaceholder", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 41, name: "slide_objects_layer_with_template", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "template_slide", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 18, name: "staticGuides", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSDArchives_2.GuideArchive },
            { no: 36, name: "userDefinedGuideStorage", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 19, name: "inDocument", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 27, name: "note", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 44, name: "infos_using_object_placeholder_geometry", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 34, name: "deprecated_objectPlaceholderVisibleForExport", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 39, name: "info_using_object_placeholder_geometry", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 40, name: "info_using_object_placeholder_geometry_matches_object_placeholder_geometry", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { builds: [], buildChunkArchives: [], buildChunks: [], ownedDrawables: [], drawablesZOrder: [], sageTagToInfoMap: [], bodyParagraphStyles: [], bodyListStyles: [], staticGuides: [], inDocument: false, infosUsingObjectPlaceholderGeometry: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.Reference style */ 1:
                    message.style = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.style);
                    break;
                case /* repeated TSP.Reference builds */ 2:
                    message.builds.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated KN.BuildChunkArchive buildChunkArchives = 3 [deprecated = true];*/ 3:
                    message.buildChunkArchives.push(exports.BuildChunkArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference buildChunks */ 43:
                    message.buildChunks.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* KN.TransitionArchive transition */ 4:
                    message.transition = exports.TransitionArchive.internalBinaryRead(reader, reader.uint32(), options, message.transition);
                    break;
                case /* optional TSP.Reference titlePlaceholder */ 5:
                    message.titlePlaceholder = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.titlePlaceholder);
                    break;
                case /* optional TSP.Reference bodyPlaceholder */ 6:
                    message.bodyPlaceholder = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.bodyPlaceholder);
                    break;
                case /* optional TSP.Reference objectPlaceholder */ 30:
                    message.objectPlaceholder = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.objectPlaceholder);
                    break;
                case /* optional TSP.Reference slideNumberPlaceholder */ 20:
                    message.slideNumberPlaceholder = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.slideNumberPlaceholder);
                    break;
                case /* repeated TSP.Reference owned_drawables */ 7:
                    message.ownedDrawables.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference drawables_z_order */ 42:
                    message.drawablesZOrder.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated KN.SlideArchive.SageTagMapEntry sage_tag_to_info_map */ 28:
                    message.sageTagToInfoMap.push(exports.SlideArchive_SageTagMapEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional KN.SlideArchive.InstructionalTextMap instructional_text_map */ 45:
                    message.instructionalTextMap = exports.SlideArchive_InstructionalTextMap.internalBinaryRead(reader, reader.uint32(), options, message.instructionalTextMap);
                    break;
                case /* optional string name */ 10:
                    message.name = reader.string();
                    break;
                case /* optional TSD.GeometryArchive titlePlaceholderGeometry */ 11:
                    message.titlePlaceholderGeometry = TSDArchives_3.GeometryArchive.internalBinaryRead(reader, reader.uint32(), options, message.titlePlaceholderGeometry);
                    break;
                case /* optional uint32 titlePlaceholderShapeStyleIndex */ 12:
                    message.titlePlaceholderShapeStyleIndex = reader.uint32();
                    break;
                case /* optional uint32 titlePlaceholderTextStyleIndex */ 13:
                    message.titlePlaceholderTextStyleIndex = reader.uint32();
                    break;
                case /* optional TSWP.ShapeStylePropertiesArchive titleLayoutProperties */ 24:
                    message.titleLayoutProperties = TSWPArchives_2.ShapeStylePropertiesArchive.internalBinaryRead(reader, reader.uint32(), options, message.titleLayoutProperties);
                    break;
                case /* optional TSD.GeometryArchive bodyPlaceholderGeometry */ 14:
                    message.bodyPlaceholderGeometry = TSDArchives_3.GeometryArchive.internalBinaryRead(reader, reader.uint32(), options, message.bodyPlaceholderGeometry);
                    break;
                case /* optional uint32 bodyPlaceholderShapeStyleIndex */ 15:
                    message.bodyPlaceholderShapeStyleIndex = reader.uint32();
                    break;
                case /* optional uint32 bodyPlaceholderTextStyleIndex */ 16:
                    message.bodyPlaceholderTextStyleIndex = reader.uint32();
                    break;
                case /* optional TSWP.ShapeStylePropertiesArchive bodyLayoutProperties */ 25:
                    message.bodyLayoutProperties = TSWPArchives_2.ShapeStylePropertiesArchive.internalBinaryRead(reader, reader.uint32(), options, message.bodyLayoutProperties);
                    break;
                case /* optional TSD.GeometryArchive slideNumberPlaceholderGeometry */ 21:
                    message.slideNumberPlaceholderGeometry = TSDArchives_3.GeometryArchive.internalBinaryRead(reader, reader.uint32(), options, message.slideNumberPlaceholderGeometry);
                    break;
                case /* optional uint32 slideNumberPlaceholderShapeStyleIndex */ 22:
                    message.slideNumberPlaceholderShapeStyleIndex = reader.uint32();
                    break;
                case /* optional uint32 slideNumberPlaceholderTextStyleIndex */ 23:
                    message.slideNumberPlaceholderTextStyleIndex = reader.uint32();
                    break;
                case /* optional TSWP.ShapeStylePropertiesArchive slideNumberLayoutProperties */ 26:
                    message.slideNumberLayoutProperties = TSWPArchives_2.ShapeStylePropertiesArchive.internalBinaryRead(reader, reader.uint32(), options, message.slideNumberLayoutProperties);
                    break;
                case /* optional TSP.Reference classicStylesheetRecord */ 29:
                    message.classicStylesheetRecord = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.classicStylesheetRecord);
                    break;
                case /* repeated TSP.Reference bodyParagraphStyles */ 31:
                    message.bodyParagraphStyles.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference bodyListStyles */ 35:
                    message.bodyListStyles.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string thumbnailTextForTitlePlaceholder */ 37:
                    message.thumbnailTextForTitlePlaceholder = reader.string();
                    break;
                case /* optional string thumbnailTextForBodyPlaceholder */ 38:
                    message.thumbnailTextForBodyPlaceholder = reader.string();
                    break;
                case /* optional bool slide_objects_layer_with_template */ 41:
                    message.slideObjectsLayerWithTemplate = reader.bool();
                    break;
                case /* optional TSP.Reference template_slide */ 17:
                    message.templateSlide = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.templateSlide);
                    break;
                case /* repeated TSD.GuideArchive staticGuides */ 18:
                    message.staticGuides.push(TSDArchives_2.GuideArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Reference userDefinedGuideStorage */ 36:
                    message.userDefinedGuideStorage = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.userDefinedGuideStorage);
                    break;
                case /* bool inDocument */ 19:
                    message.inDocument = reader.bool();
                    break;
                case /* optional TSP.Reference note */ 27:
                    message.note = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.note);
                    break;
                case /* repeated TSP.Reference infos_using_object_placeholder_geometry */ 44:
                    message.infosUsingObjectPlaceholderGeometry.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool deprecated_objectPlaceholderVisibleForExport */ 34:
                    message.deprecatedObjectPlaceholderVisibleForExport = reader.bool();
                    break;
                case /* optional TSP.Reference info_using_object_placeholder_geometry */ 39:
                    message.infoUsingObjectPlaceholderGeometry = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.infoUsingObjectPlaceholderGeometry);
                    break;
                case /* optional bool info_using_object_placeholder_geometry_matches_object_placeholder_geometry */ 40:
                    message.infoUsingObjectPlaceholderGeometryMatchesObjectPlaceholderGeometry = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.Reference style = 1; */
        if (message.style)
            TSPMessages_8.Reference.internalBinaryWrite(message.style, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference builds = 2; */
        for (let i = 0; i < message.builds.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.builds[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated KN.BuildChunkArchive buildChunkArchives = 3 [deprecated = true]; */
        for (let i = 0; i < message.buildChunkArchives.length; i++)
            exports.BuildChunkArchive.internalBinaryWrite(message.buildChunkArchives[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference buildChunks = 43; */
        for (let i = 0; i < message.buildChunks.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.buildChunks[i], writer.tag(43, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* KN.TransitionArchive transition = 4; */
        if (message.transition)
            exports.TransitionArchive.internalBinaryWrite(message.transition, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference titlePlaceholder = 5; */
        if (message.titlePlaceholder)
            TSPMessages_8.Reference.internalBinaryWrite(message.titlePlaceholder, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference bodyPlaceholder = 6; */
        if (message.bodyPlaceholder)
            TSPMessages_8.Reference.internalBinaryWrite(message.bodyPlaceholder, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference objectPlaceholder = 30; */
        if (message.objectPlaceholder)
            TSPMessages_8.Reference.internalBinaryWrite(message.objectPlaceholder, writer.tag(30, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference slideNumberPlaceholder = 20; */
        if (message.slideNumberPlaceholder)
            TSPMessages_8.Reference.internalBinaryWrite(message.slideNumberPlaceholder, writer.tag(20, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference owned_drawables = 7; */
        for (let i = 0; i < message.ownedDrawables.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.ownedDrawables[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference drawables_z_order = 42; */
        for (let i = 0; i < message.drawablesZOrder.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.drawablesZOrder[i], writer.tag(42, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated KN.SlideArchive.SageTagMapEntry sage_tag_to_info_map = 28; */
        for (let i = 0; i < message.sageTagToInfoMap.length; i++)
            exports.SlideArchive_SageTagMapEntry.internalBinaryWrite(message.sageTagToInfoMap[i], writer.tag(28, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional KN.SlideArchive.InstructionalTextMap instructional_text_map = 45; */
        if (message.instructionalTextMap)
            exports.SlideArchive_InstructionalTextMap.internalBinaryWrite(message.instructionalTextMap, writer.tag(45, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string name = 10; */
        if (message.name !== undefined)
            writer.tag(10, runtime_1.WireType.LengthDelimited).string(message.name);
        /* optional TSD.GeometryArchive titlePlaceholderGeometry = 11; */
        if (message.titlePlaceholderGeometry)
            TSDArchives_3.GeometryArchive.internalBinaryWrite(message.titlePlaceholderGeometry, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 titlePlaceholderShapeStyleIndex = 12; */
        if (message.titlePlaceholderShapeStyleIndex !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).uint32(message.titlePlaceholderShapeStyleIndex);
        /* optional uint32 titlePlaceholderTextStyleIndex = 13; */
        if (message.titlePlaceholderTextStyleIndex !== undefined)
            writer.tag(13, runtime_1.WireType.Varint).uint32(message.titlePlaceholderTextStyleIndex);
        /* optional TSWP.ShapeStylePropertiesArchive titleLayoutProperties = 24; */
        if (message.titleLayoutProperties)
            TSWPArchives_2.ShapeStylePropertiesArchive.internalBinaryWrite(message.titleLayoutProperties, writer.tag(24, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.GeometryArchive bodyPlaceholderGeometry = 14; */
        if (message.bodyPlaceholderGeometry)
            TSDArchives_3.GeometryArchive.internalBinaryWrite(message.bodyPlaceholderGeometry, writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 bodyPlaceholderShapeStyleIndex = 15; */
        if (message.bodyPlaceholderShapeStyleIndex !== undefined)
            writer.tag(15, runtime_1.WireType.Varint).uint32(message.bodyPlaceholderShapeStyleIndex);
        /* optional uint32 bodyPlaceholderTextStyleIndex = 16; */
        if (message.bodyPlaceholderTextStyleIndex !== undefined)
            writer.tag(16, runtime_1.WireType.Varint).uint32(message.bodyPlaceholderTextStyleIndex);
        /* optional TSWP.ShapeStylePropertiesArchive bodyLayoutProperties = 25; */
        if (message.bodyLayoutProperties)
            TSWPArchives_2.ShapeStylePropertiesArchive.internalBinaryWrite(message.bodyLayoutProperties, writer.tag(25, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.GeometryArchive slideNumberPlaceholderGeometry = 21; */
        if (message.slideNumberPlaceholderGeometry)
            TSDArchives_3.GeometryArchive.internalBinaryWrite(message.slideNumberPlaceholderGeometry, writer.tag(21, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 slideNumberPlaceholderShapeStyleIndex = 22; */
        if (message.slideNumberPlaceholderShapeStyleIndex !== undefined)
            writer.tag(22, runtime_1.WireType.Varint).uint32(message.slideNumberPlaceholderShapeStyleIndex);
        /* optional uint32 slideNumberPlaceholderTextStyleIndex = 23; */
        if (message.slideNumberPlaceholderTextStyleIndex !== undefined)
            writer.tag(23, runtime_1.WireType.Varint).uint32(message.slideNumberPlaceholderTextStyleIndex);
        /* optional TSWP.ShapeStylePropertiesArchive slideNumberLayoutProperties = 26; */
        if (message.slideNumberLayoutProperties)
            TSWPArchives_2.ShapeStylePropertiesArchive.internalBinaryWrite(message.slideNumberLayoutProperties, writer.tag(26, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference classicStylesheetRecord = 29; */
        if (message.classicStylesheetRecord)
            TSPMessages_8.Reference.internalBinaryWrite(message.classicStylesheetRecord, writer.tag(29, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference bodyParagraphStyles = 31; */
        for (let i = 0; i < message.bodyParagraphStyles.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.bodyParagraphStyles[i], writer.tag(31, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference bodyListStyles = 35; */
        for (let i = 0; i < message.bodyListStyles.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.bodyListStyles[i], writer.tag(35, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string thumbnailTextForTitlePlaceholder = 37; */
        if (message.thumbnailTextForTitlePlaceholder !== undefined)
            writer.tag(37, runtime_1.WireType.LengthDelimited).string(message.thumbnailTextForTitlePlaceholder);
        /* optional string thumbnailTextForBodyPlaceholder = 38; */
        if (message.thumbnailTextForBodyPlaceholder !== undefined)
            writer.tag(38, runtime_1.WireType.LengthDelimited).string(message.thumbnailTextForBodyPlaceholder);
        /* optional bool slide_objects_layer_with_template = 41; */
        if (message.slideObjectsLayerWithTemplate !== undefined)
            writer.tag(41, runtime_1.WireType.Varint).bool(message.slideObjectsLayerWithTemplate);
        /* optional TSP.Reference template_slide = 17; */
        if (message.templateSlide)
            TSPMessages_8.Reference.internalBinaryWrite(message.templateSlide, writer.tag(17, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSD.GuideArchive staticGuides = 18; */
        for (let i = 0; i < message.staticGuides.length; i++)
            TSDArchives_2.GuideArchive.internalBinaryWrite(message.staticGuides[i], writer.tag(18, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference userDefinedGuideStorage = 36; */
        if (message.userDefinedGuideStorage)
            TSPMessages_8.Reference.internalBinaryWrite(message.userDefinedGuideStorage, writer.tag(36, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool inDocument = 19; */
        if (message.inDocument !== false)
            writer.tag(19, runtime_1.WireType.Varint).bool(message.inDocument);
        /* optional TSP.Reference note = 27; */
        if (message.note)
            TSPMessages_8.Reference.internalBinaryWrite(message.note, writer.tag(27, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference infos_using_object_placeholder_geometry = 44; */
        for (let i = 0; i < message.infosUsingObjectPlaceholderGeometry.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.infosUsingObjectPlaceholderGeometry[i], writer.tag(44, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool deprecated_objectPlaceholderVisibleForExport = 34; */
        if (message.deprecatedObjectPlaceholderVisibleForExport !== undefined)
            writer.tag(34, runtime_1.WireType.Varint).bool(message.deprecatedObjectPlaceholderVisibleForExport);
        /* optional TSP.Reference info_using_object_placeholder_geometry = 39; */
        if (message.infoUsingObjectPlaceholderGeometry)
            TSPMessages_8.Reference.internalBinaryWrite(message.infoUsingObjectPlaceholderGeometry, writer.tag(39, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool info_using_object_placeholder_geometry_matches_object_placeholder_geometry = 40; */
        if (message.infoUsingObjectPlaceholderGeometryMatchesObjectPlaceholderGeometry !== undefined)
            writer.tag(40, runtime_1.WireType.Varint).bool(message.infoUsingObjectPlaceholderGeometryMatchesObjectPlaceholderGeometry);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.SlideArchive
 */
exports.SlideArchive = new SlideArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SlideArchive_SageTagMapEntry$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.SlideArchive.SageTagMapEntry", [
            { no: 1, name: "tag", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "info", kind: "message", T: () => TSPMessages_8.Reference }
        ]);
    }
    create(value) {
        const message = { tag: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tag */ 1:
                    message.tag = reader.string();
                    break;
                case /* TSP.Reference info */ 2:
                    message.info = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string tag = 1; */
        if (message.tag !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.tag);
        /* TSP.Reference info = 2; */
        if (message.info)
            TSPMessages_8.Reference.internalBinaryWrite(message.info, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.SlideArchive.SageTagMapEntry
 */
exports.SlideArchive_SageTagMapEntry = new SlideArchive_SageTagMapEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SlideArchive_InstructionalTextMap$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.SlideArchive.InstructionalTextMap", [
            { no: 1, name: "instructional_text_for_infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.SlideArchive_InstructionalTextMap_InstructionalTextMapEntry }
        ]);
    }
    create(value) {
        const message = { instructionalTextForInfos: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated KN.SlideArchive.InstructionalTextMap.InstructionalTextMapEntry instructional_text_for_infos */ 1:
                    message.instructionalTextForInfos.push(exports.SlideArchive_InstructionalTextMap_InstructionalTextMapEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated KN.SlideArchive.InstructionalTextMap.InstructionalTextMapEntry instructional_text_for_infos = 1; */
        for (let i = 0; i < message.instructionalTextForInfos.length; i++)
            exports.SlideArchive_InstructionalTextMap_InstructionalTextMapEntry.internalBinaryWrite(message.instructionalTextForInfos[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.SlideArchive.InstructionalTextMap
 */
exports.SlideArchive_InstructionalTextMap = new SlideArchive_InstructionalTextMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SlideArchive_InstructionalTextMap_InstructionalTextMapEntry$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.SlideArchive.InstructionalTextMap.InstructionalTextMapEntry", [
            { no: 1, name: "info", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 2, name: "instructional_text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { instructionalText: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference info */ 1:
                    message.info = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                case /* string instructional_text */ 2:
                    message.instructionalText = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference info = 1; */
        if (message.info)
            TSPMessages_8.Reference.internalBinaryWrite(message.info, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string instructional_text = 2; */
        if (message.instructionalText !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.instructionalText);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.SlideArchive.InstructionalTextMap.InstructionalTextMapEntry
 */
exports.SlideArchive_InstructionalTextMap_InstructionalTextMapEntry = new SlideArchive_InstructionalTextMap_InstructionalTextMapEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SlideNodeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.SlideNodeArchive", [
            { no: 1, name: "children", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 2, name: "slide", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 21, name: "depth", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 16, name: "thumbnails", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_6.DataReference },
            { no: 10, name: "thumbnailSizes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.Size },
            { no: 14, name: "thumbnailsAreDirty", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 25, name: "digests_for_datas_needing_download_for_thumbnail", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "isHidden", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "isCollapsed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "isCollapsedInOutlineView", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "hasBodyInOutlineView", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "hasBuilds", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "hasTransition", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "hasNote", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "isSlideNumberVisible", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "uniqueIdentifier", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "copyFromSlideIdentifier", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "slideSpecificHyperlinkCount", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "build_event_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 26, name: "build_event_count_cache_version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 22, name: "build_event_count_is_up_to_date", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 20, name: "has_explicit_builds", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 27, name: "has_explicit_builds_cache_version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 23, name: "has_explicit_builds_is_up_to_date", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 24, name: "slideSpecificHyperlinkMap", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.SlideNodeArchive_SlideSpecificHyperlinkMapEntry },
            { no: 28, name: "background_is_no_fill_or_color_fill_with_alpha", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 29, name: "template_slide_id", kind: "message", T: () => TSPMessages_7.UUID },
            { no: 30, name: "live_video_source_ids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.UUID },
            { no: 31, name: "live_video_source_usage_entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.LiveVideoSourceUsageEntry },
            { no: 3, name: "database_thumbnail", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 9, name: "database_thumbnails", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference }
        ]);
    }
    create(value) {
        const message = { children: [], thumbnails: [], thumbnailSizes: [], digestsForDatasNeedingDownloadForThumbnail: [], isHidden: false, hasBuilds: false, hasTransition: false, slideSpecificHyperlinkMap: [], liveVideoSourceIds: [], liveVideoSourceUsageEntries: [], databaseThumbnails: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.Reference children */ 1:
                    message.children.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Reference slide */ 2:
                    message.slide = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.slide);
                    break;
                case /* optional uint32 depth */ 21:
                    message.depth = reader.uint32();
                    break;
                case /* repeated TSP.DataReference thumbnails */ 16:
                    message.thumbnails.push(TSPMessages_6.DataReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Size thumbnailSizes */ 10:
                    message.thumbnailSizes.push(TSPMessages_5.Size.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool thumbnailsAreDirty */ 14:
                    message.thumbnailsAreDirty = reader.bool();
                    break;
                case /* repeated string digests_for_datas_needing_download_for_thumbnail */ 25:
                    message.digestsForDatasNeedingDownloadForThumbnail.push(reader.string());
                    break;
                case /* bool isHidden */ 4:
                    message.isHidden = reader.bool();
                    break;
                case /* optional bool isCollapsed = 5 [deprecated = true];*/ 5:
                    message.isCollapsed = reader.bool();
                    break;
                case /* optional bool isCollapsedInOutlineView = 17 [deprecated = true];*/ 17:
                    message.isCollapsedInOutlineView = reader.bool();
                    break;
                case /* optional bool hasBodyInOutlineView = 19 [deprecated = true];*/ 19:
                    message.hasBodyInOutlineView = reader.bool();
                    break;
                case /* bool hasBuilds = 6 [deprecated = true];*/ 6:
                    message.hasBuilds = reader.bool();
                    break;
                case /* bool hasTransition */ 7:
                    message.hasTransition = reader.bool();
                    break;
                case /* optional bool hasNote */ 8:
                    message.hasNote = reader.bool();
                    break;
                case /* optional bool isSlideNumberVisible */ 18:
                    message.isSlideNumberVisible = reader.bool();
                    break;
                case /* optional string uniqueIdentifier = 11 [deprecated = true];*/ 11:
                    message.uniqueIdentifier = reader.string();
                    break;
                case /* optional string copyFromSlideIdentifier */ 12:
                    message.copyFromSlideIdentifier = reader.string();
                    break;
                case /* optional uint32 slideSpecificHyperlinkCount = 13 [deprecated = true];*/ 13:
                    message.slideSpecificHyperlinkCount = reader.uint32();
                    break;
                case /* optional uint32 build_event_count */ 15:
                    message.buildEventCount = reader.uint32();
                    break;
                case /* optional uint32 build_event_count_cache_version */ 26:
                    message.buildEventCountCacheVersion = reader.uint32();
                    break;
                case /* optional bool build_event_count_is_up_to_date = 22 [deprecated = true];*/ 22:
                    message.buildEventCountIsUpToDate = reader.bool();
                    break;
                case /* optional bool has_explicit_builds */ 20:
                    message.hasExplicitBuilds = reader.bool();
                    break;
                case /* optional uint32 has_explicit_builds_cache_version */ 27:
                    message.hasExplicitBuildsCacheVersion = reader.uint32();
                    break;
                case /* optional bool has_explicit_builds_is_up_to_date = 23 [deprecated = true];*/ 23:
                    message.hasExplicitBuildsIsUpToDate = reader.bool();
                    break;
                case /* repeated KN.SlideNodeArchive.SlideSpecificHyperlinkMapEntry slideSpecificHyperlinkMap */ 24:
                    message.slideSpecificHyperlinkMap.push(exports.SlideNodeArchive_SlideSpecificHyperlinkMapEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool background_is_no_fill_or_color_fill_with_alpha */ 28:
                    message.backgroundIsNoFillOrColorFillWithAlpha = reader.bool();
                    break;
                case /* optional TSP.UUID template_slide_id */ 29:
                    message.templateSlideId = TSPMessages_7.UUID.internalBinaryRead(reader, reader.uint32(), options, message.templateSlideId);
                    break;
                case /* repeated TSP.UUID live_video_source_ids */ 30:
                    message.liveVideoSourceIds.push(TSPMessages_7.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated KN.LiveVideoSourceUsageEntry live_video_source_usage_entries */ 31:
                    message.liveVideoSourceUsageEntries.push(exports.LiveVideoSourceUsageEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Reference database_thumbnail = 3 [deprecated = true];*/ 3:
                    message.databaseThumbnail = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.databaseThumbnail);
                    break;
                case /* repeated TSP.Reference database_thumbnails = 9 [deprecated = true];*/ 9:
                    message.databaseThumbnails.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.Reference children = 1; */
        for (let i = 0; i < message.children.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.children[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference slide = 2; */
        if (message.slide)
            TSPMessages_8.Reference.internalBinaryWrite(message.slide, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 depth = 21; */
        if (message.depth !== undefined)
            writer.tag(21, runtime_1.WireType.Varint).uint32(message.depth);
        /* repeated TSP.DataReference thumbnails = 16; */
        for (let i = 0; i < message.thumbnails.length; i++)
            TSPMessages_6.DataReference.internalBinaryWrite(message.thumbnails[i], writer.tag(16, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Size thumbnailSizes = 10; */
        for (let i = 0; i < message.thumbnailSizes.length; i++)
            TSPMessages_5.Size.internalBinaryWrite(message.thumbnailSizes[i], writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool thumbnailsAreDirty = 14; */
        if (message.thumbnailsAreDirty !== undefined)
            writer.tag(14, runtime_1.WireType.Varint).bool(message.thumbnailsAreDirty);
        /* repeated string digests_for_datas_needing_download_for_thumbnail = 25; */
        for (let i = 0; i < message.digestsForDatasNeedingDownloadForThumbnail.length; i++)
            writer.tag(25, runtime_1.WireType.LengthDelimited).string(message.digestsForDatasNeedingDownloadForThumbnail[i]);
        /* bool isHidden = 4; */
        if (message.isHidden !== false)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.isHidden);
        /* optional bool isCollapsed = 5 [deprecated = true]; */
        if (message.isCollapsed !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.isCollapsed);
        /* optional bool isCollapsedInOutlineView = 17 [deprecated = true]; */
        if (message.isCollapsedInOutlineView !== undefined)
            writer.tag(17, runtime_1.WireType.Varint).bool(message.isCollapsedInOutlineView);
        /* optional bool hasBodyInOutlineView = 19 [deprecated = true]; */
        if (message.hasBodyInOutlineView !== undefined)
            writer.tag(19, runtime_1.WireType.Varint).bool(message.hasBodyInOutlineView);
        /* bool hasBuilds = 6 [deprecated = true]; */
        if (message.hasBuilds !== false)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.hasBuilds);
        /* bool hasTransition = 7; */
        if (message.hasTransition !== false)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.hasTransition);
        /* optional bool hasNote = 8; */
        if (message.hasNote !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.hasNote);
        /* optional bool isSlideNumberVisible = 18; */
        if (message.isSlideNumberVisible !== undefined)
            writer.tag(18, runtime_1.WireType.Varint).bool(message.isSlideNumberVisible);
        /* optional string uniqueIdentifier = 11 [deprecated = true]; */
        if (message.uniqueIdentifier !== undefined)
            writer.tag(11, runtime_1.WireType.LengthDelimited).string(message.uniqueIdentifier);
        /* optional string copyFromSlideIdentifier = 12; */
        if (message.copyFromSlideIdentifier !== undefined)
            writer.tag(12, runtime_1.WireType.LengthDelimited).string(message.copyFromSlideIdentifier);
        /* optional uint32 slideSpecificHyperlinkCount = 13 [deprecated = true]; */
        if (message.slideSpecificHyperlinkCount !== undefined)
            writer.tag(13, runtime_1.WireType.Varint).uint32(message.slideSpecificHyperlinkCount);
        /* optional uint32 build_event_count = 15; */
        if (message.buildEventCount !== undefined)
            writer.tag(15, runtime_1.WireType.Varint).uint32(message.buildEventCount);
        /* optional uint32 build_event_count_cache_version = 26; */
        if (message.buildEventCountCacheVersion !== undefined)
            writer.tag(26, runtime_1.WireType.Varint).uint32(message.buildEventCountCacheVersion);
        /* optional bool build_event_count_is_up_to_date = 22 [deprecated = true]; */
        if (message.buildEventCountIsUpToDate !== undefined)
            writer.tag(22, runtime_1.WireType.Varint).bool(message.buildEventCountIsUpToDate);
        /* optional bool has_explicit_builds = 20; */
        if (message.hasExplicitBuilds !== undefined)
            writer.tag(20, runtime_1.WireType.Varint).bool(message.hasExplicitBuilds);
        /* optional uint32 has_explicit_builds_cache_version = 27; */
        if (message.hasExplicitBuildsCacheVersion !== undefined)
            writer.tag(27, runtime_1.WireType.Varint).uint32(message.hasExplicitBuildsCacheVersion);
        /* optional bool has_explicit_builds_is_up_to_date = 23 [deprecated = true]; */
        if (message.hasExplicitBuildsIsUpToDate !== undefined)
            writer.tag(23, runtime_1.WireType.Varint).bool(message.hasExplicitBuildsIsUpToDate);
        /* repeated KN.SlideNodeArchive.SlideSpecificHyperlinkMapEntry slideSpecificHyperlinkMap = 24; */
        for (let i = 0; i < message.slideSpecificHyperlinkMap.length; i++)
            exports.SlideNodeArchive_SlideSpecificHyperlinkMapEntry.internalBinaryWrite(message.slideSpecificHyperlinkMap[i], writer.tag(24, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool background_is_no_fill_or_color_fill_with_alpha = 28; */
        if (message.backgroundIsNoFillOrColorFillWithAlpha !== undefined)
            writer.tag(28, runtime_1.WireType.Varint).bool(message.backgroundIsNoFillOrColorFillWithAlpha);
        /* optional TSP.UUID template_slide_id = 29; */
        if (message.templateSlideId)
            TSPMessages_7.UUID.internalBinaryWrite(message.templateSlideId, writer.tag(29, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID live_video_source_ids = 30; */
        for (let i = 0; i < message.liveVideoSourceIds.length; i++)
            TSPMessages_7.UUID.internalBinaryWrite(message.liveVideoSourceIds[i], writer.tag(30, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated KN.LiveVideoSourceUsageEntry live_video_source_usage_entries = 31; */
        for (let i = 0; i < message.liveVideoSourceUsageEntries.length; i++)
            exports.LiveVideoSourceUsageEntry.internalBinaryWrite(message.liveVideoSourceUsageEntries[i], writer.tag(31, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference database_thumbnail = 3 [deprecated = true]; */
        if (message.databaseThumbnail)
            TSPMessages_8.Reference.internalBinaryWrite(message.databaseThumbnail, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference database_thumbnails = 9 [deprecated = true]; */
        for (let i = 0; i < message.databaseThumbnails.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.databaseThumbnails[i], writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.SlideNodeArchive
 */
exports.SlideNodeArchive = new SlideNodeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SlideNodeArchive_SlideSpecificHyperlinkMapEntry$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.SlideNodeArchive.SlideSpecificHyperlinkMapEntry", [
            { no: 1, name: "slideNodeIDString", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "infoOrStorageIDString", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { slideNodeIDString: "", infoOrStorageIDString: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string slideNodeIDString */ 1:
                    message.slideNodeIDString = reader.string();
                    break;
                case /* repeated string infoOrStorageIDString */ 2:
                    message.infoOrStorageIDString.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string slideNodeIDString = 1; */
        if (message.slideNodeIDString !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.slideNodeIDString);
        /* repeated string infoOrStorageIDString = 2; */
        for (let i = 0; i < message.infoOrStorageIDString.length; i++)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.infoOrStorageIDString[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.SlideNodeArchive.SlideSpecificHyperlinkMapEntry
 */
exports.SlideNodeArchive_SlideSpecificHyperlinkMapEntry = new SlideNodeArchive_SlideSpecificHyperlinkMapEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DesktopUILayoutArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.DesktopUILayoutArchive", [
            { no: 1, name: "sidebar_visible", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "sidebar_view_mode", kind: "enum", opt: true, T: () => ["KN.DesktopUILayoutArchive.SidebarViewMode", DesktopUILayoutArchive_SidebarViewMode] },
            { no: 3, name: "notes_visible", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "light_table_visible", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "inspector_pane_visible", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "inspector_pane_view_mode", kind: "enum", opt: true, T: () => ["KN.DesktopUILayoutArchive.InspectorPaneViewMode", DesktopUILayoutArchive_InspectorPaneViewMode] },
            { no: 8, name: "showing_template_slides", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "inspector_pane_autohidden", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "element_list_visible", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "activity_stream_visible", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "activity_stream_was_visible", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool sidebar_visible */ 1:
                    message.sidebarVisible = reader.bool();
                    break;
                case /* optional KN.DesktopUILayoutArchive.SidebarViewMode sidebar_view_mode */ 2:
                    message.sidebarViewMode = reader.int32();
                    break;
                case /* optional bool notes_visible */ 3:
                    message.notesVisible = reader.bool();
                    break;
                case /* optional bool light_table_visible */ 5:
                    message.lightTableVisible = reader.bool();
                    break;
                case /* optional bool inspector_pane_visible */ 6:
                    message.inspectorPaneVisible = reader.bool();
                    break;
                case /* optional KN.DesktopUILayoutArchive.InspectorPaneViewMode inspector_pane_view_mode */ 7:
                    message.inspectorPaneViewMode = reader.int32();
                    break;
                case /* optional bool showing_template_slides */ 8:
                    message.showingTemplateSlides = reader.bool();
                    break;
                case /* optional bool inspector_pane_autohidden */ 9:
                    message.inspectorPaneAutohidden = reader.bool();
                    break;
                case /* optional bool element_list_visible */ 10:
                    message.elementListVisible = reader.bool();
                    break;
                case /* optional bool activity_stream_visible */ 11:
                    message.activityStreamVisible = reader.bool();
                    break;
                case /* optional bool activity_stream_was_visible */ 12:
                    message.activityStreamWasVisible = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional bool sidebar_visible = 1; */
        if (message.sidebarVisible !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.sidebarVisible);
        /* optional KN.DesktopUILayoutArchive.SidebarViewMode sidebar_view_mode = 2; */
        if (message.sidebarViewMode !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.sidebarViewMode);
        /* optional bool notes_visible = 3; */
        if (message.notesVisible !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.notesVisible);
        /* optional bool light_table_visible = 5; */
        if (message.lightTableVisible !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.lightTableVisible);
        /* optional bool inspector_pane_visible = 6; */
        if (message.inspectorPaneVisible !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.inspectorPaneVisible);
        /* optional KN.DesktopUILayoutArchive.InspectorPaneViewMode inspector_pane_view_mode = 7; */
        if (message.inspectorPaneViewMode !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).int32(message.inspectorPaneViewMode);
        /* optional bool showing_template_slides = 8; */
        if (message.showingTemplateSlides !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.showingTemplateSlides);
        /* optional bool inspector_pane_autohidden = 9; */
        if (message.inspectorPaneAutohidden !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).bool(message.inspectorPaneAutohidden);
        /* optional bool element_list_visible = 10; */
        if (message.elementListVisible !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).bool(message.elementListVisible);
        /* optional bool activity_stream_visible = 11; */
        if (message.activityStreamVisible !== undefined)
            writer.tag(11, runtime_1.WireType.Varint).bool(message.activityStreamVisible);
        /* optional bool activity_stream_was_visible = 12; */
        if (message.activityStreamWasVisible !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).bool(message.activityStreamWasVisible);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.DesktopUILayoutArchive
 */
exports.DesktopUILayoutArchive = new DesktopUILayoutArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UIStateArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.UIStateArchive", [
            { no: 1, name: "slideNodeToEdit", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 2, name: "deprecated_template_slide_node_to_apply", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 3, name: "deprecated_slideThumbnailSize", kind: "message", T: () => TSPMessages_5.Size },
            { no: 4, name: "canvasViewScale", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "canvasOffset", kind: "message", T: () => TSPMessages_4.Point },
            { no: 6, name: "selectedSlideNodes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 7, name: "iPhoneCanvasViewScale", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "iPhoneCanvasOffset", kind: "message", T: () => TSPMessages_4.Point },
            { no: 9, name: "iPhone568CanvasViewScale", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "iPhone568CanvasOffset", kind: "message", T: () => TSPMessages_4.Point },
            { no: 11, name: "desktop_ui_layout", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 12, name: "desktop_slide_view_content_fits_window", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "desktop_canvas_view_scale", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 21, name: "desktop_canvas_offset", kind: "message", T: () => TSPMessages_4.Point },
            { no: 14, name: "light_table_zoom_scale", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 15, name: "chart_ui_state", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSCHArchives_1.ChartUIState },
            { no: 16, name: "show_slide_guides", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "show_template_guides", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "shows_comments", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 39, name: "comments_printing_toggle_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "collapsed_slide_nodes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 28, name: "outline_collapsed_slide_nodes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 30, name: "outline_has_body_slide_nodes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 20, name: "shows_ruler", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 22, name: "desktop_navigator_view_width", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 23, name: "desktop_outline_view_width", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 31, name: "desktop_outline_view_default_fixed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 24, name: "desktop_main_content_size", kind: "message", T: () => TSPMessages_5.Size },
            { no: 25, name: "desktop_presenter_notes_view_height", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 26, name: "desktop_main_window_origin", kind: "message", T: () => TSPMessages_4.Point },
            { no: 27, name: "light_table_hides_skipped_slides", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 29, name: "selection_path", kind: "message", T: () => TSKArchives_4.SelectionPathArchive },
            { no: 32, name: "desktop_element_list_view_width", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 33, name: "element_list_expanded_groups", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 34, name: "shows_mobile_light_table", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 35, name: "mobile_light_table_zoom_scale", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 36, name: "mobile_light_table_hides_skipped_slides", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 37, name: "freehand_drawing_toolkit_state", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 38, name: "selection_path_transformer", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 40, name: "shows_mobile_outline", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 41, name: "editing_disabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 42, name: "desktop_activity_stream_view_width", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value) {
        const message = { selectedSlideNodes: [], chartUiState: [], collapsedSlideNodes: [], outlineCollapsedSlideNodes: [], outlineHasBodySlideNodes: [], elementListExpandedGroups: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference slideNodeToEdit = 1 [deprecated = true];*/ 1:
                    message.slideNodeToEdit = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.slideNodeToEdit);
                    break;
                case /* optional TSP.Reference deprecated_template_slide_node_to_apply */ 2:
                    message.deprecatedTemplateSlideNodeToApply = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.deprecatedTemplateSlideNodeToApply);
                    break;
                case /* optional TSP.Size deprecated_slideThumbnailSize */ 3:
                    message.deprecatedSlideThumbnailSize = TSPMessages_5.Size.internalBinaryRead(reader, reader.uint32(), options, message.deprecatedSlideThumbnailSize);
                    break;
                case /* optional float canvasViewScale */ 4:
                    message.canvasViewScale = reader.float();
                    break;
                case /* optional TSP.Point canvasOffset */ 5:
                    message.canvasOffset = TSPMessages_4.Point.internalBinaryRead(reader, reader.uint32(), options, message.canvasOffset);
                    break;
                case /* repeated TSP.Reference selectedSlideNodes = 6 [deprecated = true];*/ 6:
                    message.selectedSlideNodes.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional float iPhoneCanvasViewScale = 7 [deprecated = true];*/ 7:
                    message.iPhoneCanvasViewScale = reader.float();
                    break;
                case /* optional TSP.Point iPhoneCanvasOffset = 8 [deprecated = true];*/ 8:
                    message.iPhoneCanvasOffset = TSPMessages_4.Point.internalBinaryRead(reader, reader.uint32(), options, message.iPhoneCanvasOffset);
                    break;
                case /* optional float iPhone568CanvasViewScale = 9 [deprecated = true];*/ 9:
                    message.iPhone568CanvasViewScale = reader.float();
                    break;
                case /* optional TSP.Point iPhone568CanvasOffset = 10 [deprecated = true];*/ 10:
                    message.iPhone568CanvasOffset = TSPMessages_4.Point.internalBinaryRead(reader, reader.uint32(), options, message.iPhone568CanvasOffset);
                    break;
                case /* optional TSP.Reference desktop_ui_layout */ 11:
                    message.desktopUiLayout = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.desktopUiLayout);
                    break;
                case /* optional bool desktop_slide_view_content_fits_window */ 12:
                    message.desktopSlideViewContentFitsWindow = reader.bool();
                    break;
                case /* optional float desktop_canvas_view_scale */ 13:
                    message.desktopCanvasViewScale = reader.float();
                    break;
                case /* optional TSP.Point desktop_canvas_offset */ 21:
                    message.desktopCanvasOffset = TSPMessages_4.Point.internalBinaryRead(reader, reader.uint32(), options, message.desktopCanvasOffset);
                    break;
                case /* optional float light_table_zoom_scale */ 14:
                    message.lightTableZoomScale = reader.float();
                    break;
                case /* repeated TSCH.ChartUIState chart_ui_state */ 15:
                    message.chartUiState.push(TSCHArchives_1.ChartUIState.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool show_slide_guides */ 16:
                    message.showSlideGuides = reader.bool();
                    break;
                case /* optional bool show_template_guides */ 17:
                    message.showTemplateGuides = reader.bool();
                    break;
                case /* optional bool shows_comments */ 18:
                    message.showsComments = reader.bool();
                    break;
                case /* optional bool comments_printing_toggle_enabled */ 39:
                    message.commentsPrintingToggleEnabled = reader.bool();
                    break;
                case /* repeated TSP.Reference collapsed_slide_nodes */ 19:
                    message.collapsedSlideNodes.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference outline_collapsed_slide_nodes */ 28:
                    message.outlineCollapsedSlideNodes.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference outline_has_body_slide_nodes */ 30:
                    message.outlineHasBodySlideNodes.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool shows_ruler */ 20:
                    message.showsRuler = reader.bool();
                    break;
                case /* optional float desktop_navigator_view_width */ 22:
                    message.desktopNavigatorViewWidth = reader.float();
                    break;
                case /* optional float desktop_outline_view_width */ 23:
                    message.desktopOutlineViewWidth = reader.float();
                    break;
                case /* optional bool desktop_outline_view_default_fixed */ 31:
                    message.desktopOutlineViewDefaultFixed = reader.bool();
                    break;
                case /* optional TSP.Size desktop_main_content_size */ 24:
                    message.desktopMainContentSize = TSPMessages_5.Size.internalBinaryRead(reader, reader.uint32(), options, message.desktopMainContentSize);
                    break;
                case /* optional float desktop_presenter_notes_view_height */ 25:
                    message.desktopPresenterNotesViewHeight = reader.float();
                    break;
                case /* optional TSP.Point desktop_main_window_origin */ 26:
                    message.desktopMainWindowOrigin = TSPMessages_4.Point.internalBinaryRead(reader, reader.uint32(), options, message.desktopMainWindowOrigin);
                    break;
                case /* optional bool light_table_hides_skipped_slides */ 27:
                    message.lightTableHidesSkippedSlides = reader.bool();
                    break;
                case /* optional TSK.SelectionPathArchive selection_path */ 29:
                    message.selectionPath = TSKArchives_4.SelectionPathArchive.internalBinaryRead(reader, reader.uint32(), options, message.selectionPath);
                    break;
                case /* optional float desktop_element_list_view_width */ 32:
                    message.desktopElementListViewWidth = reader.float();
                    break;
                case /* repeated TSP.Reference element_list_expanded_groups */ 33:
                    message.elementListExpandedGroups.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool shows_mobile_light_table */ 34:
                    message.showsMobileLightTable = reader.bool();
                    break;
                case /* optional float mobile_light_table_zoom_scale */ 35:
                    message.mobileLightTableZoomScale = reader.float();
                    break;
                case /* optional bool mobile_light_table_hides_skipped_slides */ 36:
                    message.mobileLightTableHidesSkippedSlides = reader.bool();
                    break;
                case /* optional TSP.Reference freehand_drawing_toolkit_state */ 37:
                    message.freehandDrawingToolkitState = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.freehandDrawingToolkitState);
                    break;
                case /* optional TSP.Reference selection_path_transformer */ 38:
                    message.selectionPathTransformer = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.selectionPathTransformer);
                    break;
                case /* optional bool shows_mobile_outline */ 40:
                    message.showsMobileOutline = reader.bool();
                    break;
                case /* optional bool editing_disabled */ 41:
                    message.editingDisabled = reader.bool();
                    break;
                case /* optional float desktop_activity_stream_view_width */ 42:
                    message.desktopActivityStreamViewWidth = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference slideNodeToEdit = 1 [deprecated = true]; */
        if (message.slideNodeToEdit)
            TSPMessages_8.Reference.internalBinaryWrite(message.slideNodeToEdit, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference deprecated_template_slide_node_to_apply = 2; */
        if (message.deprecatedTemplateSlideNodeToApply)
            TSPMessages_8.Reference.internalBinaryWrite(message.deprecatedTemplateSlideNodeToApply, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Size deprecated_slideThumbnailSize = 3; */
        if (message.deprecatedSlideThumbnailSize)
            TSPMessages_5.Size.internalBinaryWrite(message.deprecatedSlideThumbnailSize, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional float canvasViewScale = 4; */
        if (message.canvasViewScale !== undefined)
            writer.tag(4, runtime_1.WireType.Bit32).float(message.canvasViewScale);
        /* optional TSP.Point canvasOffset = 5; */
        if (message.canvasOffset)
            TSPMessages_4.Point.internalBinaryWrite(message.canvasOffset, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference selectedSlideNodes = 6 [deprecated = true]; */
        for (let i = 0; i < message.selectedSlideNodes.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.selectedSlideNodes[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional float iPhoneCanvasViewScale = 7 [deprecated = true]; */
        if (message.iPhoneCanvasViewScale !== undefined)
            writer.tag(7, runtime_1.WireType.Bit32).float(message.iPhoneCanvasViewScale);
        /* optional TSP.Point iPhoneCanvasOffset = 8 [deprecated = true]; */
        if (message.iPhoneCanvasOffset)
            TSPMessages_4.Point.internalBinaryWrite(message.iPhoneCanvasOffset, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional float iPhone568CanvasViewScale = 9 [deprecated = true]; */
        if (message.iPhone568CanvasViewScale !== undefined)
            writer.tag(9, runtime_1.WireType.Bit32).float(message.iPhone568CanvasViewScale);
        /* optional TSP.Point iPhone568CanvasOffset = 10 [deprecated = true]; */
        if (message.iPhone568CanvasOffset)
            TSPMessages_4.Point.internalBinaryWrite(message.iPhone568CanvasOffset, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference desktop_ui_layout = 11; */
        if (message.desktopUiLayout)
            TSPMessages_8.Reference.internalBinaryWrite(message.desktopUiLayout, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool desktop_slide_view_content_fits_window = 12; */
        if (message.desktopSlideViewContentFitsWindow !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).bool(message.desktopSlideViewContentFitsWindow);
        /* optional float desktop_canvas_view_scale = 13; */
        if (message.desktopCanvasViewScale !== undefined)
            writer.tag(13, runtime_1.WireType.Bit32).float(message.desktopCanvasViewScale);
        /* optional TSP.Point desktop_canvas_offset = 21; */
        if (message.desktopCanvasOffset)
            TSPMessages_4.Point.internalBinaryWrite(message.desktopCanvasOffset, writer.tag(21, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional float light_table_zoom_scale = 14; */
        if (message.lightTableZoomScale !== undefined)
            writer.tag(14, runtime_1.WireType.Bit32).float(message.lightTableZoomScale);
        /* repeated TSCH.ChartUIState chart_ui_state = 15; */
        for (let i = 0; i < message.chartUiState.length; i++)
            TSCHArchives_1.ChartUIState.internalBinaryWrite(message.chartUiState[i], writer.tag(15, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool show_slide_guides = 16; */
        if (message.showSlideGuides !== undefined)
            writer.tag(16, runtime_1.WireType.Varint).bool(message.showSlideGuides);
        /* optional bool show_template_guides = 17; */
        if (message.showTemplateGuides !== undefined)
            writer.tag(17, runtime_1.WireType.Varint).bool(message.showTemplateGuides);
        /* optional bool shows_comments = 18; */
        if (message.showsComments !== undefined)
            writer.tag(18, runtime_1.WireType.Varint).bool(message.showsComments);
        /* optional bool comments_printing_toggle_enabled = 39; */
        if (message.commentsPrintingToggleEnabled !== undefined)
            writer.tag(39, runtime_1.WireType.Varint).bool(message.commentsPrintingToggleEnabled);
        /* repeated TSP.Reference collapsed_slide_nodes = 19; */
        for (let i = 0; i < message.collapsedSlideNodes.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.collapsedSlideNodes[i], writer.tag(19, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference outline_collapsed_slide_nodes = 28; */
        for (let i = 0; i < message.outlineCollapsedSlideNodes.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.outlineCollapsedSlideNodes[i], writer.tag(28, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference outline_has_body_slide_nodes = 30; */
        for (let i = 0; i < message.outlineHasBodySlideNodes.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.outlineHasBodySlideNodes[i], writer.tag(30, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool shows_ruler = 20; */
        if (message.showsRuler !== undefined)
            writer.tag(20, runtime_1.WireType.Varint).bool(message.showsRuler);
        /* optional float desktop_navigator_view_width = 22; */
        if (message.desktopNavigatorViewWidth !== undefined)
            writer.tag(22, runtime_1.WireType.Bit32).float(message.desktopNavigatorViewWidth);
        /* optional float desktop_outline_view_width = 23; */
        if (message.desktopOutlineViewWidth !== undefined)
            writer.tag(23, runtime_1.WireType.Bit32).float(message.desktopOutlineViewWidth);
        /* optional bool desktop_outline_view_default_fixed = 31; */
        if (message.desktopOutlineViewDefaultFixed !== undefined)
            writer.tag(31, runtime_1.WireType.Varint).bool(message.desktopOutlineViewDefaultFixed);
        /* optional TSP.Size desktop_main_content_size = 24; */
        if (message.desktopMainContentSize)
            TSPMessages_5.Size.internalBinaryWrite(message.desktopMainContentSize, writer.tag(24, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional float desktop_presenter_notes_view_height = 25; */
        if (message.desktopPresenterNotesViewHeight !== undefined)
            writer.tag(25, runtime_1.WireType.Bit32).float(message.desktopPresenterNotesViewHeight);
        /* optional TSP.Point desktop_main_window_origin = 26; */
        if (message.desktopMainWindowOrigin)
            TSPMessages_4.Point.internalBinaryWrite(message.desktopMainWindowOrigin, writer.tag(26, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool light_table_hides_skipped_slides = 27; */
        if (message.lightTableHidesSkippedSlides !== undefined)
            writer.tag(27, runtime_1.WireType.Varint).bool(message.lightTableHidesSkippedSlides);
        /* optional TSK.SelectionPathArchive selection_path = 29; */
        if (message.selectionPath)
            TSKArchives_4.SelectionPathArchive.internalBinaryWrite(message.selectionPath, writer.tag(29, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional float desktop_element_list_view_width = 32; */
        if (message.desktopElementListViewWidth !== undefined)
            writer.tag(32, runtime_1.WireType.Bit32).float(message.desktopElementListViewWidth);
        /* repeated TSP.Reference element_list_expanded_groups = 33; */
        for (let i = 0; i < message.elementListExpandedGroups.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.elementListExpandedGroups[i], writer.tag(33, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool shows_mobile_light_table = 34; */
        if (message.showsMobileLightTable !== undefined)
            writer.tag(34, runtime_1.WireType.Varint).bool(message.showsMobileLightTable);
        /* optional float mobile_light_table_zoom_scale = 35; */
        if (message.mobileLightTableZoomScale !== undefined)
            writer.tag(35, runtime_1.WireType.Bit32).float(message.mobileLightTableZoomScale);
        /* optional bool mobile_light_table_hides_skipped_slides = 36; */
        if (message.mobileLightTableHidesSkippedSlides !== undefined)
            writer.tag(36, runtime_1.WireType.Varint).bool(message.mobileLightTableHidesSkippedSlides);
        /* optional TSP.Reference freehand_drawing_toolkit_state = 37; */
        if (message.freehandDrawingToolkitState)
            TSPMessages_8.Reference.internalBinaryWrite(message.freehandDrawingToolkitState, writer.tag(37, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference selection_path_transformer = 38; */
        if (message.selectionPathTransformer)
            TSPMessages_8.Reference.internalBinaryWrite(message.selectionPathTransformer, writer.tag(38, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool shows_mobile_outline = 40; */
        if (message.showsMobileOutline !== undefined)
            writer.tag(40, runtime_1.WireType.Varint).bool(message.showsMobileOutline);
        /* optional bool editing_disabled = 41; */
        if (message.editingDisabled !== undefined)
            writer.tag(41, runtime_1.WireType.Varint).bool(message.editingDisabled);
        /* optional float desktop_activity_stream_view_width = 42; */
        if (message.desktopActivityStreamViewWidth !== undefined)
            writer.tag(42, runtime_1.WireType.Bit32).float(message.desktopActivityStreamViewWidth);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.UIStateArchive
 */
exports.UIStateArchive = new UIStateArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IOSRestorableViewStateRootArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.IOSRestorableViewStateRootArchive", [
            { no: 1, name: "saved_playback_state", kind: "message", T: () => exports.IOSSavedPlaybackStateArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional KN.IOSSavedPlaybackStateArchive saved_playback_state */ 1:
                    message.savedPlaybackState = exports.IOSSavedPlaybackStateArchive.internalBinaryRead(reader, reader.uint32(), options, message.savedPlaybackState);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional KN.IOSSavedPlaybackStateArchive saved_playback_state = 1; */
        if (message.savedPlaybackState)
            exports.IOSSavedPlaybackStateArchive.internalBinaryWrite(message.savedPlaybackState, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.IOSRestorableViewStateRootArchive
 */
exports.IOSRestorableViewStateRootArchive = new IOSRestorableViewStateRootArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IOSSavedPlaybackStateArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.IOSSavedPlaybackStateArchive", [
            { no: 1, name: "presentation_type", kind: "enum", opt: true, T: () => ["KN.IOSSavedPlaybackStateArchive.PresentationType", IOSSavedPlaybackStateArchive_PresentationType] },
            { no: 2, name: "slide_node_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "event_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "breadcrumb_trail", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "had_external_display", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "is_elapsed_time_started", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "elapsed_time_start_time", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 8, name: "recording_playback_current_time", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 9, name: "should_show_slide_navigator", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "is_multi_presenter_show", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { breadcrumbTrail: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional KN.IOSSavedPlaybackStateArchive.PresentationType presentation_type */ 1:
                    message.presentationType = reader.int32();
                    break;
                case /* optional uint32 slide_node_index */ 2:
                    message.slideNodeIndex = reader.uint32();
                    break;
                case /* optional uint32 event_index */ 3:
                    message.eventIndex = reader.uint32();
                    break;
                case /* repeated string breadcrumb_trail */ 4:
                    message.breadcrumbTrail.push(reader.string());
                    break;
                case /* optional bool had_external_display */ 5:
                    message.hadExternalDisplay = reader.bool();
                    break;
                case /* optional bool is_elapsed_time_started */ 6:
                    message.isElapsedTimeStarted = reader.bool();
                    break;
                case /* optional double elapsed_time_start_time */ 7:
                    message.elapsedTimeStartTime = reader.double();
                    break;
                case /* optional double recording_playback_current_time */ 8:
                    message.recordingPlaybackCurrentTime = reader.double();
                    break;
                case /* optional bool should_show_slide_navigator */ 9:
                    message.shouldShowSlideNavigator = reader.bool();
                    break;
                case /* optional bool is_multi_presenter_show */ 10:
                    message.isMultiPresenterShow = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional KN.IOSSavedPlaybackStateArchive.PresentationType presentation_type = 1; */
        if (message.presentationType !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.presentationType);
        /* optional uint32 slide_node_index = 2; */
        if (message.slideNodeIndex !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.slideNodeIndex);
        /* optional uint32 event_index = 3; */
        if (message.eventIndex !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.eventIndex);
        /* repeated string breadcrumb_trail = 4; */
        for (let i = 0; i < message.breadcrumbTrail.length; i++)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.breadcrumbTrail[i]);
        /* optional bool had_external_display = 5; */
        if (message.hadExternalDisplay !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.hadExternalDisplay);
        /* optional bool is_elapsed_time_started = 6; */
        if (message.isElapsedTimeStarted !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.isElapsedTimeStarted);
        /* optional double elapsed_time_start_time = 7; */
        if (message.elapsedTimeStartTime !== undefined)
            writer.tag(7, runtime_1.WireType.Bit64).double(message.elapsedTimeStartTime);
        /* optional double recording_playback_current_time = 8; */
        if (message.recordingPlaybackCurrentTime !== undefined)
            writer.tag(8, runtime_1.WireType.Bit64).double(message.recordingPlaybackCurrentTime);
        /* optional bool should_show_slide_navigator = 9; */
        if (message.shouldShowSlideNavigator !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).bool(message.shouldShowSlideNavigator);
        /* optional bool is_multi_presenter_show = 10; */
        if (message.isMultiPresenterShow !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).bool(message.isMultiPresenterShow);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.IOSSavedPlaybackStateArchive
 */
exports.IOSSavedPlaybackStateArchive = new IOSSavedPlaybackStateArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CanvasSelectionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CanvasSelectionArchive", [
            { no: 1, name: "infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 5, name: "non_interactive_infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 6, name: "infos_for_action_ghost_indexes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 3, name: "action_ghost_indexes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_3.IndexSet },
            { no: 4, name: "build_chunks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 2, name: "database_action_ghost_indexes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { infos: [], nonInteractiveInfos: [], infosForActionGhostIndexes: [], actionGhostIndexes: [], buildChunks: [], databaseActionGhostIndexes: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.Reference infos */ 1:
                    message.infos.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference non_interactive_infos */ 5:
                    message.nonInteractiveInfos.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference infos_for_action_ghost_indexes */ 6:
                    message.infosForActionGhostIndexes.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.IndexSet action_ghost_indexes */ 3:
                    message.actionGhostIndexes.push(TSPMessages_3.IndexSet.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference build_chunks */ 4:
                    message.buildChunks.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 database_action_ghost_indexes = 2 [deprecated = true];*/ 2:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.databaseActionGhostIndexes.push(reader.uint32());
                    else
                        message.databaseActionGhostIndexes.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.Reference infos = 1; */
        for (let i = 0; i < message.infos.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.infos[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference non_interactive_infos = 5; */
        for (let i = 0; i < message.nonInteractiveInfos.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.nonInteractiveInfos[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference infos_for_action_ghost_indexes = 6; */
        for (let i = 0; i < message.infosForActionGhostIndexes.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.infosForActionGhostIndexes[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.IndexSet action_ghost_indexes = 3; */
        for (let i = 0; i < message.actionGhostIndexes.length; i++)
            TSPMessages_3.IndexSet.internalBinaryWrite(message.actionGhostIndexes[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference build_chunks = 4; */
        for (let i = 0; i < message.buildChunks.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.buildChunks[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 database_action_ghost_indexes = 2 [deprecated = true]; */
        for (let i = 0; i < message.databaseActionGhostIndexes.length; i++)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.databaseActionGhostIndexes[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CanvasSelectionArchive
 */
exports.CanvasSelectionArchive = new CanvasSelectionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActionGhostSelectionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.ActionGhostSelectionArchive", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.ActionGhostSelectionArchive
 */
exports.ActionGhostSelectionArchive = new ActionGhostSelectionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ThemeCustomTimingCurveArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.ThemeCustomTimingCurveArchive", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "curve", kind: "message", T: () => TSDArchives_4.PathSourceArchive }
        ]);
    }
    create(value) {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* TSD.PathSourceArchive curve */ 2:
                    message.curve = TSDArchives_4.PathSourceArchive.internalBinaryRead(reader, reader.uint32(), options, message.curve);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* TSD.PathSourceArchive curve = 2; */
        if (message.curve)
            TSDArchives_4.PathSourceArchive.internalBinaryWrite(message.curve, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.ThemeCustomTimingCurveArchive
 */
exports.ThemeCustomTimingCurveArchive = new ThemeCustomTimingCurveArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ThemeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.ThemeArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSSArchives_2.ThemeArchive },
            { no: 2, name: "templates", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 3, name: "uuid", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "classicThemeRecords", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 5, name: "default_template_slide_node", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 6, name: "default_template_slide_node_reference", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 7, name: "default_template_slide_node_is_our_best_guess", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "custom_effect_timing_curves", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ThemeCustomTimingCurveArchive },
            { no: 9, name: "live_video_source_collection", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 10, name: "motion_background_style_presets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference }
        ]);
    }
    create(value) {
        const message = { templates: [], classicThemeRecords: [], customEffectTimingCurves: [], motionBackgroundStylePresets: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSS.ThemeArchive super */ 1:
                    message.super = TSSArchives_2.ThemeArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSP.Reference templates */ 2:
                    message.templates.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string uuid */ 3:
                    message.uuid = reader.string();
                    break;
                case /* repeated TSP.Reference classicThemeRecords */ 4:
                    message.classicThemeRecords.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Reference default_template_slide_node */ 5:
                    message.defaultTemplateSlideNode = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.defaultTemplateSlideNode);
                    break;
                case /* optional TSP.Reference default_template_slide_node_reference */ 6:
                    message.defaultTemplateSlideNodeReference = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.defaultTemplateSlideNodeReference);
                    break;
                case /* optional bool default_template_slide_node_is_our_best_guess */ 7:
                    message.defaultTemplateSlideNodeIsOurBestGuess = reader.bool();
                    break;
                case /* repeated KN.ThemeCustomTimingCurveArchive custom_effect_timing_curves */ 8:
                    message.customEffectTimingCurves.push(exports.ThemeCustomTimingCurveArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Reference live_video_source_collection */ 9:
                    message.liveVideoSourceCollection = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.liveVideoSourceCollection);
                    break;
                case /* repeated TSP.Reference motion_background_style_presets */ 10:
                    message.motionBackgroundStylePresets.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSS.ThemeArchive super = 1; */
        if (message.super)
            TSSArchives_2.ThemeArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference templates = 2; */
        for (let i = 0; i < message.templates.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.templates[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string uuid = 3; */
        if (message.uuid !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.uuid);
        /* repeated TSP.Reference classicThemeRecords = 4; */
        for (let i = 0; i < message.classicThemeRecords.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.classicThemeRecords[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference default_template_slide_node = 5; */
        if (message.defaultTemplateSlideNode)
            TSPMessages_8.Reference.internalBinaryWrite(message.defaultTemplateSlideNode, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference default_template_slide_node_reference = 6; */
        if (message.defaultTemplateSlideNodeReference)
            TSPMessages_8.Reference.internalBinaryWrite(message.defaultTemplateSlideNodeReference, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool default_template_slide_node_is_our_best_guess = 7; */
        if (message.defaultTemplateSlideNodeIsOurBestGuess !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.defaultTemplateSlideNodeIsOurBestGuess);
        /* repeated KN.ThemeCustomTimingCurveArchive custom_effect_timing_curves = 8; */
        for (let i = 0; i < message.customEffectTimingCurves.length; i++)
            exports.ThemeCustomTimingCurveArchive.internalBinaryWrite(message.customEffectTimingCurves[i], writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference live_video_source_collection = 9; */
        if (message.liveVideoSourceCollection)
            TSPMessages_8.Reference.internalBinaryWrite(message.liveVideoSourceCollection, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference motion_background_style_presets = 10; */
        for (let i = 0; i < message.motionBackgroundStylePresets.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.motionBackgroundStylePresets[i], writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.ThemeArchive
 */
exports.ThemeArchive = new ThemeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SlideTreeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.SlideTreeArchive", [
            { no: 1, name: "rootSlideNode", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 2, name: "slides", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference }
        ]);
    }
    create(value) {
        const message = { slides: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference rootSlideNode = 1 [deprecated = true];*/ 1:
                    message.rootSlideNode = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.rootSlideNode);
                    break;
                case /* repeated TSP.Reference slides */ 2:
                    message.slides.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference rootSlideNode = 1 [deprecated = true]; */
        if (message.rootSlideNode)
            TSPMessages_8.Reference.internalBinaryWrite(message.rootSlideNode, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference slides = 2; */
        for (let i = 0; i < message.slides.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.slides[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.SlideTreeArchive
 */
exports.SlideTreeArchive = new SlideTreeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShowArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.ShowArchive", [
            { no: 1, name: "uiState", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 2, name: "theme", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 3, name: "slideTree", kind: "message", T: () => exports.SlideTreeArchive },
            { no: 4, name: "size", kind: "message", T: () => TSPMessages_5.Size },
            { no: 5, name: "stylesheet", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 6, name: "slideNumbersVisible", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "recording", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 8, name: "loop_presentation", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "mode", kind: "enum", opt: true, T: () => ["KN.ShowArchive.KNShowMode", ShowArchive_KNShowMode] },
            { no: 10, name: "autoplay_transition_delay", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 11, name: "autoplay_build_delay", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 15, name: "idle_timer_active", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "idle_timer_delay", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 17, name: "soundtrack", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 18, name: "automatically_plays_upon_open", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "slideList", kind: "message", T: () => TSPMessages_8.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference uiState */ 1:
                    message.uiState = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.uiState);
                    break;
                case /* TSP.Reference theme */ 2:
                    message.theme = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.theme);
                    break;
                case /* KN.SlideTreeArchive slideTree */ 3:
                    message.slideTree = exports.SlideTreeArchive.internalBinaryRead(reader, reader.uint32(), options, message.slideTree);
                    break;
                case /* TSP.Size size */ 4:
                    message.size = TSPMessages_5.Size.internalBinaryRead(reader, reader.uint32(), options, message.size);
                    break;
                case /* TSP.Reference stylesheet */ 5:
                    message.stylesheet = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.stylesheet);
                    break;
                case /* optional bool slideNumbersVisible */ 6:
                    message.slideNumbersVisible = reader.bool();
                    break;
                case /* optional TSP.Reference recording */ 7:
                    message.recording = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.recording);
                    break;
                case /* optional bool loop_presentation */ 8:
                    message.loopPresentation = reader.bool();
                    break;
                case /* optional KN.ShowArchive.KNShowMode mode */ 9:
                    message.mode = reader.int32();
                    break;
                case /* optional double autoplay_transition_delay */ 10:
                    message.autoplayTransitionDelay = reader.double();
                    break;
                case /* optional double autoplay_build_delay */ 11:
                    message.autoplayBuildDelay = reader.double();
                    break;
                case /* optional bool idle_timer_active */ 15:
                    message.idleTimerActive = reader.bool();
                    break;
                case /* optional double idle_timer_delay */ 16:
                    message.idleTimerDelay = reader.double();
                    break;
                case /* optional TSP.Reference soundtrack */ 17:
                    message.soundtrack = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.soundtrack);
                    break;
                case /* optional bool automatically_plays_upon_open */ 18:
                    message.automaticallyPlaysUponOpen = reader.bool();
                    break;
                case /* optional TSP.Reference slideList */ 19:
                    message.slideList = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.slideList);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference uiState = 1; */
        if (message.uiState)
            TSPMessages_8.Reference.internalBinaryWrite(message.uiState, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference theme = 2; */
        if (message.theme)
            TSPMessages_8.Reference.internalBinaryWrite(message.theme, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* KN.SlideTreeArchive slideTree = 3; */
        if (message.slideTree)
            exports.SlideTreeArchive.internalBinaryWrite(message.slideTree, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Size size = 4; */
        if (message.size)
            TSPMessages_5.Size.internalBinaryWrite(message.size, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference stylesheet = 5; */
        if (message.stylesheet)
            TSPMessages_8.Reference.internalBinaryWrite(message.stylesheet, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool slideNumbersVisible = 6; */
        if (message.slideNumbersVisible !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.slideNumbersVisible);
        /* optional TSP.Reference recording = 7; */
        if (message.recording)
            TSPMessages_8.Reference.internalBinaryWrite(message.recording, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool loop_presentation = 8; */
        if (message.loopPresentation !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.loopPresentation);
        /* optional KN.ShowArchive.KNShowMode mode = 9; */
        if (message.mode !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).int32(message.mode);
        /* optional double autoplay_transition_delay = 10; */
        if (message.autoplayTransitionDelay !== undefined)
            writer.tag(10, runtime_1.WireType.Bit64).double(message.autoplayTransitionDelay);
        /* optional double autoplay_build_delay = 11; */
        if (message.autoplayBuildDelay !== undefined)
            writer.tag(11, runtime_1.WireType.Bit64).double(message.autoplayBuildDelay);
        /* optional bool idle_timer_active = 15; */
        if (message.idleTimerActive !== undefined)
            writer.tag(15, runtime_1.WireType.Varint).bool(message.idleTimerActive);
        /* optional double idle_timer_delay = 16; */
        if (message.idleTimerDelay !== undefined)
            writer.tag(16, runtime_1.WireType.Bit64).double(message.idleTimerDelay);
        /* optional TSP.Reference soundtrack = 17; */
        if (message.soundtrack)
            TSPMessages_8.Reference.internalBinaryWrite(message.soundtrack, writer.tag(17, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool automatically_plays_upon_open = 18; */
        if (message.automaticallyPlaysUponOpen !== undefined)
            writer.tag(18, runtime_1.WireType.Varint).bool(message.automaticallyPlaysUponOpen);
        /* optional TSP.Reference slideList = 19; */
        if (message.slideList)
            TSPMessages_8.Reference.internalBinaryWrite(message.slideList, writer.tag(19, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.ShowArchive
 */
exports.ShowArchive = new ShowArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.DocumentArchive", [
            { no: 3, name: "super", kind: "message", T: () => TSAArchives_1.DocumentArchive },
            { no: 2, name: "show", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 4, name: "tables_custom_format_list", kind: "message", T: () => TSPMessages_8.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSA.DocumentArchive super */ 3:
                    message.super = TSAArchives_1.DocumentArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Reference show */ 2:
                    message.show = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.show);
                    break;
                case /* optional TSP.Reference tables_custom_format_list */ 4:
                    message.tablesCustomFormatList = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.tablesCustomFormatList);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSA.DocumentArchive super = 3; */
        if (message.super)
            TSAArchives_1.DocumentArchive.internalBinaryWrite(message.super, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference show = 2; */
        if (message.show)
            TSPMessages_8.Reference.internalBinaryWrite(message.show, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference tables_custom_format_list = 4; */
        if (message.tablesCustomFormatList)
            TSPMessages_8.Reference.internalBinaryWrite(message.tablesCustomFormatList, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.DocumentArchive
 */
exports.DocumentArchive = new DocumentArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SlideStylePropertiesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.SlideStylePropertiesArchive", [
            { no: 1, name: "fill", kind: "message", T: () => TSDArchives_1.FillArchive },
            { no: 2, name: "transition", kind: "message", T: () => exports.TransitionAttributesArchive },
            { no: 3, name: "transition_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "titlePlaceholderVisibility", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "bodyPlaceholderVisibility", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "objectPlaceholderVisibility", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "slideNumberPlaceholderVisibility", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSD.FillArchive fill */ 1:
                    message.fill = TSDArchives_1.FillArchive.internalBinaryRead(reader, reader.uint32(), options, message.fill);
                    break;
                case /* optional KN.TransitionAttributesArchive transition */ 2:
                    message.transition = exports.TransitionAttributesArchive.internalBinaryRead(reader, reader.uint32(), options, message.transition);
                    break;
                case /* optional bool transition_null */ 3:
                    message.transitionNull = reader.bool();
                    break;
                case /* optional bool titlePlaceholderVisibility */ 4:
                    message.titlePlaceholderVisibility = reader.bool();
                    break;
                case /* optional bool bodyPlaceholderVisibility */ 5:
                    message.bodyPlaceholderVisibility = reader.bool();
                    break;
                case /* optional bool objectPlaceholderVisibility */ 7:
                    message.objectPlaceholderVisibility = reader.bool();
                    break;
                case /* optional bool slideNumberPlaceholderVisibility */ 6:
                    message.slideNumberPlaceholderVisibility = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSD.FillArchive fill = 1; */
        if (message.fill)
            TSDArchives_1.FillArchive.internalBinaryWrite(message.fill, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional KN.TransitionAttributesArchive transition = 2; */
        if (message.transition)
            exports.TransitionAttributesArchive.internalBinaryWrite(message.transition, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool transition_null = 3; */
        if (message.transitionNull !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.transitionNull);
        /* optional bool titlePlaceholderVisibility = 4; */
        if (message.titlePlaceholderVisibility !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.titlePlaceholderVisibility);
        /* optional bool bodyPlaceholderVisibility = 5; */
        if (message.bodyPlaceholderVisibility !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.bodyPlaceholderVisibility);
        /* optional bool objectPlaceholderVisibility = 7; */
        if (message.objectPlaceholderVisibility !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.objectPlaceholderVisibility);
        /* optional bool slideNumberPlaceholderVisibility = 6; */
        if (message.slideNumberPlaceholderVisibility !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.slideNumberPlaceholderVisibility);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.SlideStylePropertiesArchive
 */
exports.SlideStylePropertiesArchive = new SlideStylePropertiesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SlideStyleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.SlideStyleArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSSArchives_1.StyleArchive },
            { no: 10, name: "override_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "slide_properties", kind: "message", T: () => exports.SlideStylePropertiesArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSS.StyleArchive super */ 1:
                    message.super = TSSArchives_1.StyleArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional uint32 override_count */ 10:
                    message.overrideCount = reader.uint32();
                    break;
                case /* optional KN.SlideStylePropertiesArchive slide_properties */ 11:
                    message.slideProperties = exports.SlideStylePropertiesArchive.internalBinaryRead(reader, reader.uint32(), options, message.slideProperties);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSS.StyleArchive super = 1; */
        if (message.super)
            TSSArchives_1.StyleArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 override_count = 10; */
        if (message.overrideCount !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).uint32(message.overrideCount);
        /* optional KN.SlideStylePropertiesArchive slide_properties = 11; */
        if (message.slideProperties)
            exports.SlideStylePropertiesArchive.internalBinaryWrite(message.slideProperties, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.SlideStyleArchive
 */
exports.SlideStyleArchive = new SlideStyleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PasteboardNativeStorageArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.PasteboardNativeStorageArchive", [
            { no: 1, name: "drawables", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 2, name: "builds", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 3, name: "buildChunks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 4, name: "slideNodes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 12, name: "displayed_slide_nodes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 9, name: "template_slide_nodes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 10, name: "collapsedSlideNodes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 11, name: "outlineCollapsedSlideNodes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 13, name: "outlineHasBodySlideNodes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 5, name: "originalShowSize", kind: "message", T: () => TSPMessages_5.Size },
            { no: 6, name: "titleRanges", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_2.Range },
            { no: 7, name: "geometries_in_root", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSDArchives_3.GeometryArchive },
            { no: 8, name: "slide_node_unique_identifier", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "custom_effect_timing_curves", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ThemeCustomTimingCurveArchive },
            { no: 15, name: "original_slide_node_UUIDs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "slide_nodes_have_datas_needing_download", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "transition", kind: "message", T: () => exports.TransitionArchive },
            { no: 18, name: "live_video_sources", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.PasteboardNativeStorageArchive_LiveVideoSourcePair }
        ]);
    }
    create(value) {
        const message = { drawables: [], builds: [], buildChunks: [], slideNodes: [], displayedSlideNodes: [], templateSlideNodes: [], collapsedSlideNodes: [], outlineCollapsedSlideNodes: [], outlineHasBodySlideNodes: [], titleRanges: [], geometriesInRoot: [], customEffectTimingCurves: [], originalSlideNodeUUIDs: [], liveVideoSources: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.Reference drawables */ 1:
                    message.drawables.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference builds */ 2:
                    message.builds.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference buildChunks */ 3:
                    message.buildChunks.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference slideNodes */ 4:
                    message.slideNodes.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference displayed_slide_nodes */ 12:
                    message.displayedSlideNodes.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference template_slide_nodes */ 9:
                    message.templateSlideNodes.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference collapsedSlideNodes */ 10:
                    message.collapsedSlideNodes.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference outlineCollapsedSlideNodes */ 11:
                    message.outlineCollapsedSlideNodes.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference outlineHasBodySlideNodes */ 13:
                    message.outlineHasBodySlideNodes.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Size originalShowSize */ 5:
                    message.originalShowSize = TSPMessages_5.Size.internalBinaryRead(reader, reader.uint32(), options, message.originalShowSize);
                    break;
                case /* repeated TSP.Range titleRanges */ 6:
                    message.titleRanges.push(TSPMessages_2.Range.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSD.GeometryArchive geometries_in_root */ 7:
                    message.geometriesInRoot.push(TSDArchives_3.GeometryArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string slide_node_unique_identifier */ 8:
                    message.slideNodeUniqueIdentifier = reader.string();
                    break;
                case /* repeated KN.ThemeCustomTimingCurveArchive custom_effect_timing_curves */ 14:
                    message.customEffectTimingCurves.push(exports.ThemeCustomTimingCurveArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string original_slide_node_UUIDs */ 15:
                    message.originalSlideNodeUUIDs.push(reader.string());
                    break;
                case /* optional bool slide_nodes_have_datas_needing_download */ 16:
                    message.slideNodesHaveDatasNeedingDownload = reader.bool();
                    break;
                case /* optional KN.TransitionArchive transition */ 17:
                    message.transition = exports.TransitionArchive.internalBinaryRead(reader, reader.uint32(), options, message.transition);
                    break;
                case /* repeated KN.PasteboardNativeStorageArchive.LiveVideoSourcePair live_video_sources */ 18:
                    message.liveVideoSources.push(exports.PasteboardNativeStorageArchive_LiveVideoSourcePair.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.Reference drawables = 1; */
        for (let i = 0; i < message.drawables.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.drawables[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference builds = 2; */
        for (let i = 0; i < message.builds.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.builds[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference buildChunks = 3; */
        for (let i = 0; i < message.buildChunks.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.buildChunks[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference slideNodes = 4; */
        for (let i = 0; i < message.slideNodes.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.slideNodes[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference displayed_slide_nodes = 12; */
        for (let i = 0; i < message.displayedSlideNodes.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.displayedSlideNodes[i], writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference template_slide_nodes = 9; */
        for (let i = 0; i < message.templateSlideNodes.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.templateSlideNodes[i], writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference collapsedSlideNodes = 10; */
        for (let i = 0; i < message.collapsedSlideNodes.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.collapsedSlideNodes[i], writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference outlineCollapsedSlideNodes = 11; */
        for (let i = 0; i < message.outlineCollapsedSlideNodes.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.outlineCollapsedSlideNodes[i], writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference outlineHasBodySlideNodes = 13; */
        for (let i = 0; i < message.outlineHasBodySlideNodes.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.outlineHasBodySlideNodes[i], writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Size originalShowSize = 5; */
        if (message.originalShowSize)
            TSPMessages_5.Size.internalBinaryWrite(message.originalShowSize, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Range titleRanges = 6; */
        for (let i = 0; i < message.titleRanges.length; i++)
            TSPMessages_2.Range.internalBinaryWrite(message.titleRanges[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSD.GeometryArchive geometries_in_root = 7; */
        for (let i = 0; i < message.geometriesInRoot.length; i++)
            TSDArchives_3.GeometryArchive.internalBinaryWrite(message.geometriesInRoot[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string slide_node_unique_identifier = 8; */
        if (message.slideNodeUniqueIdentifier !== undefined)
            writer.tag(8, runtime_1.WireType.LengthDelimited).string(message.slideNodeUniqueIdentifier);
        /* repeated KN.ThemeCustomTimingCurveArchive custom_effect_timing_curves = 14; */
        for (let i = 0; i < message.customEffectTimingCurves.length; i++)
            exports.ThemeCustomTimingCurveArchive.internalBinaryWrite(message.customEffectTimingCurves[i], writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated string original_slide_node_UUIDs = 15; */
        for (let i = 0; i < message.originalSlideNodeUUIDs.length; i++)
            writer.tag(15, runtime_1.WireType.LengthDelimited).string(message.originalSlideNodeUUIDs[i]);
        /* optional bool slide_nodes_have_datas_needing_download = 16; */
        if (message.slideNodesHaveDatasNeedingDownload !== undefined)
            writer.tag(16, runtime_1.WireType.Varint).bool(message.slideNodesHaveDatasNeedingDownload);
        /* optional KN.TransitionArchive transition = 17; */
        if (message.transition)
            exports.TransitionArchive.internalBinaryWrite(message.transition, writer.tag(17, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated KN.PasteboardNativeStorageArchive.LiveVideoSourcePair live_video_sources = 18; */
        for (let i = 0; i < message.liveVideoSources.length; i++)
            exports.PasteboardNativeStorageArchive_LiveVideoSourcePair.internalBinaryWrite(message.liveVideoSources[i], writer.tag(18, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.PasteboardNativeStorageArchive
 */
exports.PasteboardNativeStorageArchive = new PasteboardNativeStorageArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PasteboardNativeStorageArchive_LiveVideoSourcePair$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.PasteboardNativeStorageArchive.LiveVideoSourcePair", [
            { no: 1, name: "live_video_info", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 2, name: "live_video_source", kind: "message", T: () => TSPMessages_8.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference live_video_info */ 1:
                    message.liveVideoInfo = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.liveVideoInfo);
                    break;
                case /* optional TSP.Reference live_video_source */ 2:
                    message.liveVideoSource = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.liveVideoSource);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference live_video_info = 1; */
        if (message.liveVideoInfo)
            TSPMessages_8.Reference.internalBinaryWrite(message.liveVideoInfo, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference live_video_source = 2; */
        if (message.liveVideoSource)
            TSPMessages_8.Reference.internalBinaryWrite(message.liveVideoSource, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.PasteboardNativeStorageArchive.LiveVideoSourcePair
 */
exports.PasteboardNativeStorageArchive_LiveVideoSourcePair = new PasteboardNativeStorageArchive_LiveVideoSourcePair$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PrototypeForUndoTemplateChangeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.PrototypeForUndoTemplateChangeArchive", [
            { no: 1, name: "slide_style", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 2, name: "template_slide_id", kind: "message", T: () => TSPMessages_7.UUID },
            { no: 3, name: "drawable_info_id_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.UUID },
            { no: 4, name: "placeholders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 5, name: "placeholder_tags_list", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { drawableInfoIdList: [], placeholders: [], placeholderTagsList: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference slide_style */ 1:
                    message.slideStyle = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.slideStyle);
                    break;
                case /* TSP.UUID template_slide_id */ 2:
                    message.templateSlideId = TSPMessages_7.UUID.internalBinaryRead(reader, reader.uint32(), options, message.templateSlideId);
                    break;
                case /* repeated TSP.UUID drawable_info_id_list */ 3:
                    message.drawableInfoIdList.push(TSPMessages_7.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference placeholders */ 4:
                    message.placeholders.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string placeholder_tags_list */ 5:
                    message.placeholderTagsList.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference slide_style = 1; */
        if (message.slideStyle)
            TSPMessages_8.Reference.internalBinaryWrite(message.slideStyle, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID template_slide_id = 2; */
        if (message.templateSlideId)
            TSPMessages_7.UUID.internalBinaryWrite(message.templateSlideId, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID drawable_info_id_list = 3; */
        for (let i = 0; i < message.drawableInfoIdList.length; i++)
            TSPMessages_7.UUID.internalBinaryWrite(message.drawableInfoIdList[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference placeholders = 4; */
        for (let i = 0; i < message.placeholders.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.placeholders[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated string placeholder_tags_list = 5; */
        for (let i = 0; i < message.placeholderTagsList.length; i++)
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.placeholderTagsList[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.PrototypeForUndoTemplateChangeArchive
 */
exports.PrototypeForUndoTemplateChangeArchive = new PrototypeForUndoTemplateChangeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecordingArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.RecordingArchive", [
            { no: 1, name: "event_tracks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 2, name: "movie_track", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 3, name: "duration", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "sync_state_enum", kind: "enum", opt: true, T: () => ["KN.RecordingArchive.RecordingSyncStateEnum", RecordingArchive_RecordingSyncStateEnum] },
            { no: 5, name: "modification_date", kind: "message", T: () => TSPMessages_1.Date },
            { no: 6, name: "sync_state", kind: "message", T: () => exports.RecordingSyncState },
            { no: 7, name: "correction_history", kind: "message", T: () => exports.RecordingCorrectionHistory }
        ]);
    }
    create(value) {
        const message = { eventTracks: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.Reference event_tracks */ 1:
                    message.eventTracks.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Reference movie_track */ 2:
                    message.movieTrack = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.movieTrack);
                    break;
                case /* optional double duration */ 3:
                    message.duration = reader.double();
                    break;
                case /* optional KN.RecordingArchive.RecordingSyncStateEnum sync_state_enum = 4 [deprecated = true];*/ 4:
                    message.syncStateEnum = reader.int32();
                    break;
                case /* optional TSP.Date modification_date */ 5:
                    message.modificationDate = TSPMessages_1.Date.internalBinaryRead(reader, reader.uint32(), options, message.modificationDate);
                    break;
                case /* optional KN.RecordingSyncState sync_state */ 6:
                    message.syncState = exports.RecordingSyncState.internalBinaryRead(reader, reader.uint32(), options, message.syncState);
                    break;
                case /* optional KN.RecordingCorrectionHistory correction_history */ 7:
                    message.correctionHistory = exports.RecordingCorrectionHistory.internalBinaryRead(reader, reader.uint32(), options, message.correctionHistory);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.Reference event_tracks = 1; */
        for (let i = 0; i < message.eventTracks.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.eventTracks[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference movie_track = 2; */
        if (message.movieTrack)
            TSPMessages_8.Reference.internalBinaryWrite(message.movieTrack, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional double duration = 3; */
        if (message.duration !== undefined)
            writer.tag(3, runtime_1.WireType.Bit64).double(message.duration);
        /* optional KN.RecordingArchive.RecordingSyncStateEnum sync_state_enum = 4 [deprecated = true]; */
        if (message.syncStateEnum !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).int32(message.syncStateEnum);
        /* optional TSP.Date modification_date = 5; */
        if (message.modificationDate)
            TSPMessages_1.Date.internalBinaryWrite(message.modificationDate, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional KN.RecordingSyncState sync_state = 6; */
        if (message.syncState)
            exports.RecordingSyncState.internalBinaryWrite(message.syncState, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional KN.RecordingCorrectionHistory correction_history = 7; */
        if (message.correctionHistory)
            exports.RecordingCorrectionHistory.internalBinaryWrite(message.correctionHistory, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.RecordingArchive
 */
exports.RecordingArchive = new RecordingArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecordingSyncState$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.RecordingSyncState", [
            { no: 1, name: "out_of_sync_token", kind: "message", T: () => TSPMessages_7.UUID },
            { no: 2, name: "can_clear_out_of_sync_token", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.UUID out_of_sync_token */ 1:
                    message.outOfSyncToken = TSPMessages_7.UUID.internalBinaryRead(reader, reader.uint32(), options, message.outOfSyncToken);
                    break;
                case /* optional bool can_clear_out_of_sync_token */ 2:
                    message.canClearOutOfSyncToken = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.UUID out_of_sync_token = 1; */
        if (message.outOfSyncToken)
            TSPMessages_7.UUID.internalBinaryWrite(message.outOfSyncToken, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool can_clear_out_of_sync_token = 2; */
        if (message.canClearOutOfSyncToken !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.canClearOutOfSyncToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.RecordingSyncState
 */
exports.RecordingSyncState = new RecordingSyncState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecordingCorrectionHistory$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.RecordingCorrectionHistory", [
            { no: 1, name: "did_add_missing_events_for_radar_49654305", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool did_add_missing_events_for_radar_49654305 */ 1:
                    message.didAddMissingEventsForRadar49654305 = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional bool did_add_missing_events_for_radar_49654305 = 1; */
        if (message.didAddMissingEventsForRadar49654305 !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.didAddMissingEventsForRadar49654305);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.RecordingCorrectionHistory
 */
exports.RecordingCorrectionHistory = new RecordingCorrectionHistory$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecordingEventTrackArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.RecordingEventTrackArchive", [
            { no: 1, name: "type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "events", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.RecordingEventArchive }
        ]);
    }
    create(value) {
        const message = { events: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string type */ 1:
                    message.type = reader.string();
                    break;
                case /* repeated KN.RecordingEventArchive events */ 2:
                    message.events.push(exports.RecordingEventArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string type = 1; */
        if (message.type !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.type);
        /* repeated KN.RecordingEventArchive events = 2; */
        for (let i = 0; i < message.events.length; i++)
            exports.RecordingEventArchive.internalBinaryWrite(message.events[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.RecordingEventTrackArchive
 */
exports.RecordingEventTrackArchive = new RecordingEventTrackArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecordingEventArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.RecordingEventArchive", [
            { no: 1, name: "start_time", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 1000, name: "navigation_event_archive", kind: "message", T: () => exports.RecordingNavigationEventArchive },
            { no: 1001, name: "laser_event_archive", kind: "message", T: () => exports.RecordingLaserEventArchive },
            { no: 1002, name: "pause_event_archive", kind: "message", T: () => exports.RecordingPauseEventArchive },
            { no: 1003, name: "movie_event_archive", kind: "message", T: () => exports.RecordingMovieEventArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double start_time */ 1:
                    message.startTime = reader.double();
                    break;
                case /* optional KN.RecordingNavigationEventArchive navigation_event_archive */ 1000:
                    message.navigationEventArchive = exports.RecordingNavigationEventArchive.internalBinaryRead(reader, reader.uint32(), options, message.navigationEventArchive);
                    break;
                case /* optional KN.RecordingLaserEventArchive laser_event_archive */ 1001:
                    message.laserEventArchive = exports.RecordingLaserEventArchive.internalBinaryRead(reader, reader.uint32(), options, message.laserEventArchive);
                    break;
                case /* optional KN.RecordingPauseEventArchive pause_event_archive */ 1002:
                    message.pauseEventArchive = exports.RecordingPauseEventArchive.internalBinaryRead(reader, reader.uint32(), options, message.pauseEventArchive);
                    break;
                case /* optional KN.RecordingMovieEventArchive movie_event_archive */ 1003:
                    message.movieEventArchive = exports.RecordingMovieEventArchive.internalBinaryRead(reader, reader.uint32(), options, message.movieEventArchive);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional double start_time = 1; */
        if (message.startTime !== undefined)
            writer.tag(1, runtime_1.WireType.Bit64).double(message.startTime);
        /* optional KN.RecordingNavigationEventArchive navigation_event_archive = 1000; */
        if (message.navigationEventArchive)
            exports.RecordingNavigationEventArchive.internalBinaryWrite(message.navigationEventArchive, writer.tag(1000, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional KN.RecordingLaserEventArchive laser_event_archive = 1001; */
        if (message.laserEventArchive)
            exports.RecordingLaserEventArchive.internalBinaryWrite(message.laserEventArchive, writer.tag(1001, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional KN.RecordingPauseEventArchive pause_event_archive = 1002; */
        if (message.pauseEventArchive)
            exports.RecordingPauseEventArchive.internalBinaryWrite(message.pauseEventArchive, writer.tag(1002, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional KN.RecordingMovieEventArchive movie_event_archive = 1003; */
        if (message.movieEventArchive)
            exports.RecordingMovieEventArchive.internalBinaryWrite(message.movieEventArchive, writer.tag(1003, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.RecordingEventArchive
 */
exports.RecordingEventArchive = new RecordingEventArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecordingNavigationEventArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.RecordingNavigationEventArchive", [
            { no: 4, name: "target_slide_node_id", kind: "message", T: () => TSPMessages_7.UUID },
            { no: 1, name: "target_slide_node_reference", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 2, name: "target_event_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "animation_phase", kind: "enum", opt: true, T: () => ["KN.RecordingNavigationEventArchive.RecordingNavigationEventAnimationPhase", RecordingNavigationEventArchive_RecordingNavigationEventAnimationPhase] }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.UUID target_slide_node_id */ 4:
                    message.targetSlideNodeId = TSPMessages_7.UUID.internalBinaryRead(reader, reader.uint32(), options, message.targetSlideNodeId);
                    break;
                case /* optional TSP.Reference target_slide_node_reference */ 1:
                    message.targetSlideNodeReference = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.targetSlideNodeReference);
                    break;
                case /* optional uint32 target_event_index */ 2:
                    message.targetEventIndex = reader.uint32();
                    break;
                case /* optional KN.RecordingNavigationEventArchive.RecordingNavigationEventAnimationPhase animation_phase */ 3:
                    message.animationPhase = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.UUID target_slide_node_id = 4; */
        if (message.targetSlideNodeId)
            TSPMessages_7.UUID.internalBinaryWrite(message.targetSlideNodeId, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference target_slide_node_reference = 1; */
        if (message.targetSlideNodeReference)
            TSPMessages_8.Reference.internalBinaryWrite(message.targetSlideNodeReference, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 target_event_index = 2; */
        if (message.targetEventIndex !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.targetEventIndex);
        /* optional KN.RecordingNavigationEventArchive.RecordingNavigationEventAnimationPhase animation_phase = 3; */
        if (message.animationPhase !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.animationPhase);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.RecordingNavigationEventArchive
 */
exports.RecordingNavigationEventArchive = new RecordingNavigationEventArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecordingLaserEventArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.RecordingLaserEventArchive", [
            { no: 1, name: "unscaled_location", kind: "message", T: () => TSPMessages_4.Point },
            { no: 2, name: "unit_location", kind: "message", T: () => TSPMessages_4.Point }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Point unscaled_location = 1 [deprecated = true];*/ 1:
                    message.unscaledLocation = TSPMessages_4.Point.internalBinaryRead(reader, reader.uint32(), options, message.unscaledLocation);
                    break;
                case /* optional TSP.Point unit_location */ 2:
                    message.unitLocation = TSPMessages_4.Point.internalBinaryRead(reader, reader.uint32(), options, message.unitLocation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Point unscaled_location = 1 [deprecated = true]; */
        if (message.unscaledLocation)
            TSPMessages_4.Point.internalBinaryWrite(message.unscaledLocation, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Point unit_location = 2; */
        if (message.unitLocation)
            TSPMessages_4.Point.internalBinaryWrite(message.unitLocation, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.RecordingLaserEventArchive
 */
exports.RecordingLaserEventArchive = new RecordingLaserEventArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecordingPauseEventArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.RecordingPauseEventArchive", [
            { no: 1, name: "pause_event_type", kind: "enum", opt: true, T: () => ["KN.RecordingPauseEventArchive.RecordingPauseEventType", RecordingPauseEventArchive_RecordingPauseEventType] }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional KN.RecordingPauseEventArchive.RecordingPauseEventType pause_event_type */ 1:
                    message.pauseEventType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional KN.RecordingPauseEventArchive.RecordingPauseEventType pause_event_type = 1; */
        if (message.pauseEventType !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.pauseEventType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.RecordingPauseEventArchive
 */
exports.RecordingPauseEventArchive = new RecordingPauseEventArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecordingMovieEventArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.RecordingMovieEventArchive", [
            { no: 1, name: "movie_info_reference", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 2, name: "movie_event_type", kind: "enum", opt: true, T: () => ["KN.RecordingMovieEventArchive.RecordingMovieEventType", RecordingMovieEventArchive_RecordingMovieEventType] },
            { no: 3, name: "movie_event_value", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "movie_info_that_played_across_slides_reference", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 5, name: "movie_slide_node_id", kind: "message", T: () => TSPMessages_7.UUID }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference movie_info_reference */ 1:
                    message.movieInfoReference = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.movieInfoReference);
                    break;
                case /* optional KN.RecordingMovieEventArchive.RecordingMovieEventType movie_event_type */ 2:
                    message.movieEventType = reader.int32();
                    break;
                case /* optional double movie_event_value */ 3:
                    message.movieEventValue = reader.double();
                    break;
                case /* optional TSP.Reference movie_info_that_played_across_slides_reference */ 4:
                    message.movieInfoThatPlayedAcrossSlidesReference = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.movieInfoThatPlayedAcrossSlidesReference);
                    break;
                case /* optional TSP.UUID movie_slide_node_id */ 5:
                    message.movieSlideNodeId = TSPMessages_7.UUID.internalBinaryRead(reader, reader.uint32(), options, message.movieSlideNodeId);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference movie_info_reference = 1; */
        if (message.movieInfoReference)
            TSPMessages_8.Reference.internalBinaryWrite(message.movieInfoReference, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional KN.RecordingMovieEventArchive.RecordingMovieEventType movie_event_type = 2; */
        if (message.movieEventType !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.movieEventType);
        /* optional double movie_event_value = 3; */
        if (message.movieEventValue !== undefined)
            writer.tag(3, runtime_1.WireType.Bit64).double(message.movieEventValue);
        /* optional TSP.Reference movie_info_that_played_across_slides_reference = 4; */
        if (message.movieInfoThatPlayedAcrossSlidesReference)
            TSPMessages_8.Reference.internalBinaryWrite(message.movieInfoThatPlayedAcrossSlidesReference, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID movie_slide_node_id = 5; */
        if (message.movieSlideNodeId)
            TSPMessages_7.UUID.internalBinaryWrite(message.movieSlideNodeId, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.RecordingMovieEventArchive
 */
exports.RecordingMovieEventArchive = new RecordingMovieEventArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecordingMovieTrackArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.RecordingMovieTrackArchive", [
            { no: 1, name: "movie_segments", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.MovieSegmentArchive },
            { no: 2, name: "is_movie_segment_data_trimmed_to_duration", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { movieSegments: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated KN.MovieSegmentArchive movie_segments */ 1:
                    message.movieSegments.push(exports.MovieSegmentArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool is_movie_segment_data_trimmed_to_duration */ 2:
                    message.isMovieSegmentDataTrimmedToDuration = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated KN.MovieSegmentArchive movie_segments = 1; */
        for (let i = 0; i < message.movieSegments.length; i++)
            exports.MovieSegmentArchive.internalBinaryWrite(message.movieSegments[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_movie_segment_data_trimmed_to_duration = 2; */
        if (message.isMovieSegmentDataTrimmedToDuration !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.isMovieSegmentDataTrimmedToDuration);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.RecordingMovieTrackArchive
 */
exports.RecordingMovieTrackArchive = new RecordingMovieTrackArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MovieSegmentArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.MovieSegmentArchive", [
            { no: 3, name: "movie_data", kind: "message", T: () => TSPMessages_6.DataReference },
            { no: 2, name: "start_time", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 1, name: "database_movie_data", kind: "message", T: () => TSPMessages_8.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.DataReference movie_data */ 3:
                    message.movieData = TSPMessages_6.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.movieData);
                    break;
                case /* optional double start_time */ 2:
                    message.startTime = reader.double();
                    break;
                case /* optional TSP.Reference database_movie_data */ 1:
                    message.databaseMovieData = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.databaseMovieData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.DataReference movie_data = 3; */
        if (message.movieData)
            TSPMessages_6.DataReference.internalBinaryWrite(message.movieData, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional double start_time = 2; */
        if (message.startTime !== undefined)
            writer.tag(2, runtime_1.WireType.Bit64).double(message.startTime);
        /* optional TSP.Reference database_movie_data = 1; */
        if (message.databaseMovieData)
            TSPMessages_8.Reference.internalBinaryWrite(message.databaseMovieData, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.MovieSegmentArchive
 */
exports.MovieSegmentArchive = new MovieSegmentArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Soundtrack$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.Soundtrack", [
            { no: 1, name: "volume", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "mode", kind: "enum", opt: true, T: () => ["KN.Soundtrack.SoundtrackMode", Soundtrack_SoundtrackMode] },
            { no: 3, name: "movie_media", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_6.DataReference }
        ]);
    }
    create(value) {
        const message = { movieMedia: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double volume */ 1:
                    message.volume = reader.double();
                    break;
                case /* optional KN.Soundtrack.SoundtrackMode mode */ 2:
                    message.mode = reader.int32();
                    break;
                case /* repeated TSP.DataReference movie_media */ 3:
                    message.movieMedia.push(TSPMessages_6.DataReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional double volume = 1; */
        if (message.volume !== undefined)
            writer.tag(1, runtime_1.WireType.Bit64).double(message.volume);
        /* optional KN.Soundtrack.SoundtrackMode mode = 2; */
        if (message.mode !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.mode);
        /* repeated TSP.DataReference movie_media = 3; */
        for (let i = 0; i < message.movieMedia.length; i++)
            TSPMessages_6.DataReference.internalBinaryWrite(message.movieMedia[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.Soundtrack
 */
exports.Soundtrack = new Soundtrack$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SlideNumberAttachmentArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.SlideNumberAttachmentArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSWPArchives_1.TextualAttachmentArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSWP.TextualAttachmentArchive super */ 1:
                    message.super = TSWPArchives_1.TextualAttachmentArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSWP.TextualAttachmentArchive super = 1; */
        if (message.super)
            TSWPArchives_1.TextualAttachmentArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.SlideNumberAttachmentArchive
 */
exports.SlideNumberAttachmentArchive = new SlideNumberAttachmentArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SlideCollectionSelectionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.SlideCollectionSelectionArchive", [
            { no: 1, name: "slide_nodes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 2, name: "slide_node_to_edit", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 3, name: "selected_paragraph_indexes_for_slide_nodes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.SlideCollectionSelectionArchive_OutlineSelection },
            { no: 4, name: "range_in_selected_paragraph", kind: "message", T: () => TSPMessages_2.Range }
        ]);
    }
    create(value) {
        const message = { slideNodes: [], selectedParagraphIndexesForSlideNodes: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.Reference slide_nodes */ 1:
                    message.slideNodes.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Reference slide_node_to_edit */ 2:
                    message.slideNodeToEdit = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.slideNodeToEdit);
                    break;
                case /* repeated KN.SlideCollectionSelectionArchive.OutlineSelection selected_paragraph_indexes_for_slide_nodes */ 3:
                    message.selectedParagraphIndexesForSlideNodes.push(exports.SlideCollectionSelectionArchive_OutlineSelection.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Range range_in_selected_paragraph */ 4:
                    message.rangeInSelectedParagraph = TSPMessages_2.Range.internalBinaryRead(reader, reader.uint32(), options, message.rangeInSelectedParagraph);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.Reference slide_nodes = 1; */
        for (let i = 0; i < message.slideNodes.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.slideNodes[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference slide_node_to_edit = 2; */
        if (message.slideNodeToEdit)
            TSPMessages_8.Reference.internalBinaryWrite(message.slideNodeToEdit, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated KN.SlideCollectionSelectionArchive.OutlineSelection selected_paragraph_indexes_for_slide_nodes = 3; */
        for (let i = 0; i < message.selectedParagraphIndexesForSlideNodes.length; i++)
            exports.SlideCollectionSelectionArchive_OutlineSelection.internalBinaryWrite(message.selectedParagraphIndexesForSlideNodes[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Range range_in_selected_paragraph = 4; */
        if (message.rangeInSelectedParagraph)
            TSPMessages_2.Range.internalBinaryWrite(message.rangeInSelectedParagraph, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.SlideCollectionSelectionArchive
 */
exports.SlideCollectionSelectionArchive = new SlideCollectionSelectionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SlideCollectionSelectionArchive_OutlineSelection$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.SlideCollectionSelectionArchive.OutlineSelection", [
            { no: 1, name: "slide_node", kind: "message", T: () => TSPMessages_8.Reference },
            { no: 2, name: "selected_paragraph_indexes", kind: "message", T: () => TSPMessages_3.IndexSet }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.Reference slide_node */ 1:
                    message.slideNode = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.slideNode);
                    break;
                case /* TSP.IndexSet selected_paragraph_indexes */ 2:
                    message.selectedParagraphIndexes = TSPMessages_3.IndexSet.internalBinaryRead(reader, reader.uint32(), options, message.selectedParagraphIndexes);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.Reference slide_node = 1; */
        if (message.slideNode)
            TSPMessages_8.Reference.internalBinaryWrite(message.slideNode, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.IndexSet selected_paragraph_indexes = 2; */
        if (message.selectedParagraphIndexes)
            TSPMessages_3.IndexSet.internalBinaryWrite(message.selectedParagraphIndexes, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.SlideCollectionSelectionArchive.OutlineSelection
 */
exports.SlideCollectionSelectionArchive_OutlineSelection = new SlideCollectionSelectionArchive_OutlineSelection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PresenterNotesSelectionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.PresenterNotesSelectionArchive", [
            { no: 1, name: "slide_node", kind: "message", T: () => TSPMessages_8.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference slide_node */ 1:
                    message.slideNode = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.slideNode);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference slide_node = 1; */
        if (message.slideNode)
            TSPMessages_8.Reference.internalBinaryWrite(message.slideNode, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.PresenterNotesSelectionArchive
 */
exports.PresenterNotesSelectionArchive = new PresenterNotesSelectionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MixedIdOperationArgs$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.MixedIdOperationArgs", [
            { no: 1, name: "args_list_types", kind: "enum", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ["KN.MixedIdOperationArgs.ArgsListKind", MixedIdOperationArgs_ArgsListKind] },
            { no: 2, name: "add_args_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSKArchives_3.AddIdOperationArgs },
            { no: 3, name: "show_placeholder_args_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSKArchives_2.IdPlacementOperationArgs },
            { no: 4, name: "remove_args_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSKArchives_1.RemoveIdOperationArgs },
            { no: 5, name: "hide_placeholder_args_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSKArchives_2.IdPlacementOperationArgs }
        ]);
    }
    create(value) {
        const message = { argsListTypes: [], addArgsList: [], showPlaceholderArgsList: [], removeArgsList: [], hidePlaceholderArgsList: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated KN.MixedIdOperationArgs.ArgsListKind args_list_types */ 1:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.argsListTypes.push(reader.int32());
                    else
                        message.argsListTypes.push(reader.int32());
                    break;
                case /* repeated TSK.AddIdOperationArgs add_args_list */ 2:
                    message.addArgsList.push(TSKArchives_3.AddIdOperationArgs.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSK.IdPlacementOperationArgs show_placeholder_args_list */ 3:
                    message.showPlaceholderArgsList.push(TSKArchives_2.IdPlacementOperationArgs.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSK.RemoveIdOperationArgs remove_args_list */ 4:
                    message.removeArgsList.push(TSKArchives_1.RemoveIdOperationArgs.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSK.IdPlacementOperationArgs hide_placeholder_args_list */ 5:
                    message.hidePlaceholderArgsList.push(TSKArchives_2.IdPlacementOperationArgs.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated KN.MixedIdOperationArgs.ArgsListKind args_list_types = 1; */
        for (let i = 0; i < message.argsListTypes.length; i++)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.argsListTypes[i]);
        /* repeated TSK.AddIdOperationArgs add_args_list = 2; */
        for (let i = 0; i < message.addArgsList.length; i++)
            TSKArchives_3.AddIdOperationArgs.internalBinaryWrite(message.addArgsList[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSK.IdPlacementOperationArgs show_placeholder_args_list = 3; */
        for (let i = 0; i < message.showPlaceholderArgsList.length; i++)
            TSKArchives_2.IdPlacementOperationArgs.internalBinaryWrite(message.showPlaceholderArgsList[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSK.RemoveIdOperationArgs remove_args_list = 4; */
        for (let i = 0; i < message.removeArgsList.length; i++)
            TSKArchives_1.RemoveIdOperationArgs.internalBinaryWrite(message.removeArgsList[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSK.IdPlacementOperationArgs hide_placeholder_args_list = 5; */
        for (let i = 0; i < message.hidePlaceholderArgsList.length; i++)
            TSKArchives_2.IdPlacementOperationArgs.internalBinaryWrite(message.hidePlaceholderArgsList[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.MixedIdOperationArgs
 */
exports.MixedIdOperationArgs = new MixedIdOperationArgs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LiveVideoInfo$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.LiveVideoInfo", [
            { no: 1, name: "source_id", kind: "message", T: () => TSPMessages_7.UUID },
            { no: 2, name: "is_placeholder", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "scale", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "normalized_offset", kind: "message", T: () => TSPMessages_4.Point },
            { no: 5, name: "mask_kind", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "mask_corner_radius", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "background_kind", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "background_fill", kind: "message", T: () => TSDArchives_1.FillArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.UUID source_id */ 1:
                    message.sourceId = TSPMessages_7.UUID.internalBinaryRead(reader, reader.uint32(), options, message.sourceId);
                    break;
                case /* optional bool is_placeholder */ 2:
                    message.isPlaceholder = reader.bool();
                    break;
                case /* optional double scale */ 3:
                    message.scale = reader.double();
                    break;
                case /* optional TSP.Point normalized_offset */ 4:
                    message.normalizedOffset = TSPMessages_4.Point.internalBinaryRead(reader, reader.uint32(), options, message.normalizedOffset);
                    break;
                case /* optional int32 mask_kind */ 5:
                    message.maskKind = reader.int32();
                    break;
                case /* optional double mask_corner_radius */ 6:
                    message.maskCornerRadius = reader.double();
                    break;
                case /* optional int32 background_kind */ 7:
                    message.backgroundKind = reader.int32();
                    break;
                case /* optional TSD.FillArchive background_fill */ 8:
                    message.backgroundFill = TSDArchives_1.FillArchive.internalBinaryRead(reader, reader.uint32(), options, message.backgroundFill);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.UUID source_id = 1; */
        if (message.sourceId)
            TSPMessages_7.UUID.internalBinaryWrite(message.sourceId, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_placeholder = 2; */
        if (message.isPlaceholder !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.isPlaceholder);
        /* optional double scale = 3; */
        if (message.scale !== undefined)
            writer.tag(3, runtime_1.WireType.Bit64).double(message.scale);
        /* optional TSP.Point normalized_offset = 4; */
        if (message.normalizedOffset)
            TSPMessages_4.Point.internalBinaryWrite(message.normalizedOffset, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional int32 mask_kind = 5; */
        if (message.maskKind !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).int32(message.maskKind);
        /* optional double mask_corner_radius = 6; */
        if (message.maskCornerRadius !== undefined)
            writer.tag(6, runtime_1.WireType.Bit64).double(message.maskCornerRadius);
        /* optional int32 background_kind = 7; */
        if (message.backgroundKind !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).int32(message.backgroundKind);
        /* optional TSD.FillArchive background_fill = 8; */
        if (message.backgroundFill)
            TSDArchives_1.FillArchive.internalBinaryWrite(message.backgroundFill, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.LiveVideoInfo
 */
exports.LiveVideoInfo = new LiveVideoInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LiveVideoSource$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.LiveVideoSource", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "capture_device_description", kind: "message", T: () => exports.LiveVideoCaptureDeviceDescription },
            { no: 3, name: "collaboration_command_usage_state", kind: "message", T: () => exports.LiveVideoSourceCollaborationCommandUsageState },
            { no: 4, name: "poster_image_data", kind: "message", T: () => TSPMessages_6.DataReference },
            { no: 5, name: "symbol_abbreviation_text", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "symbol_image_identifier", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "symbol_tint_color_identifier", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "is_default_source", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional KN.LiveVideoCaptureDeviceDescription capture_device_description */ 2:
                    message.captureDeviceDescription = exports.LiveVideoCaptureDeviceDescription.internalBinaryRead(reader, reader.uint32(), options, message.captureDeviceDescription);
                    break;
                case /* optional KN.LiveVideoSourceCollaborationCommandUsageState collaboration_command_usage_state */ 3:
                    message.collaborationCommandUsageState = exports.LiveVideoSourceCollaborationCommandUsageState.internalBinaryRead(reader, reader.uint32(), options, message.collaborationCommandUsageState);
                    break;
                case /* optional TSP.DataReference poster_image_data */ 4:
                    message.posterImageData = TSPMessages_6.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.posterImageData);
                    break;
                case /* optional string symbol_abbreviation_text */ 5:
                    message.symbolAbbreviationText = reader.string();
                    break;
                case /* optional int32 symbol_image_identifier */ 6:
                    message.symbolImageIdentifier = reader.int32();
                    break;
                case /* optional int32 symbol_tint_color_identifier */ 7:
                    message.symbolTintColorIdentifier = reader.int32();
                    break;
                case /* optional bool is_default_source */ 8:
                    message.isDefaultSource = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* optional KN.LiveVideoCaptureDeviceDescription capture_device_description = 2; */
        if (message.captureDeviceDescription)
            exports.LiveVideoCaptureDeviceDescription.internalBinaryWrite(message.captureDeviceDescription, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional KN.LiveVideoSourceCollaborationCommandUsageState collaboration_command_usage_state = 3; */
        if (message.collaborationCommandUsageState)
            exports.LiveVideoSourceCollaborationCommandUsageState.internalBinaryWrite(message.collaborationCommandUsageState, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference poster_image_data = 4; */
        if (message.posterImageData)
            TSPMessages_6.DataReference.internalBinaryWrite(message.posterImageData, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string symbol_abbreviation_text = 5; */
        if (message.symbolAbbreviationText !== undefined)
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.symbolAbbreviationText);
        /* optional int32 symbol_image_identifier = 6; */
        if (message.symbolImageIdentifier !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).int32(message.symbolImageIdentifier);
        /* optional int32 symbol_tint_color_identifier = 7; */
        if (message.symbolTintColorIdentifier !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).int32(message.symbolTintColorIdentifier);
        /* optional bool is_default_source = 8; */
        if (message.isDefaultSource !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.isDefaultSource);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.LiveVideoSource
 */
exports.LiveVideoSource = new LiveVideoSource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LiveVideoSourceCollaborationCommandUsageState$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.LiveVideoSourceCollaborationCommandUsageState", [
            { no: 1, name: "single_collaboration_command_usage_token", kind: "message", T: () => TSPMessages_7.UUID },
            { no: 2, name: "has_multiple_collaboration_command_usage_tokens", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.UUID single_collaboration_command_usage_token */ 1:
                    message.singleCollaborationCommandUsageToken = TSPMessages_7.UUID.internalBinaryRead(reader, reader.uint32(), options, message.singleCollaborationCommandUsageToken);
                    break;
                case /* optional bool has_multiple_collaboration_command_usage_tokens */ 2:
                    message.hasMultipleCollaborationCommandUsageTokens = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.UUID single_collaboration_command_usage_token = 1; */
        if (message.singleCollaborationCommandUsageToken)
            TSPMessages_7.UUID.internalBinaryWrite(message.singleCollaborationCommandUsageToken, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool has_multiple_collaboration_command_usage_tokens = 2; */
        if (message.hasMultipleCollaborationCommandUsageTokens !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.hasMultipleCollaborationCommandUsageTokens);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.LiveVideoSourceCollaborationCommandUsageState
 */
exports.LiveVideoSourceCollaborationCommandUsageState = new LiveVideoSourceCollaborationCommandUsageState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LiveVideoCaptureDeviceDescription$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.LiveVideoCaptureDeviceDescription", [
            { no: 1, name: "unique_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "position", kind: "enum", opt: true, T: () => ["KN.LiveVideoCaptureDeviceDescription.Position", LiveVideoCaptureDeviceDescription_Position] },
            { no: 3, name: "device_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "localized_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "is_ios_screen_recording_device", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "model_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "default_video_resolution", kind: "message", T: () => TSPMessages_5.Size }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string unique_id */ 1:
                    message.uniqueId = reader.string();
                    break;
                case /* optional KN.LiveVideoCaptureDeviceDescription.Position position */ 2:
                    message.position = reader.int32();
                    break;
                case /* optional string device_type */ 3:
                    message.deviceType = reader.string();
                    break;
                case /* optional string localized_name */ 4:
                    message.localizedName = reader.string();
                    break;
                case /* optional bool is_ios_screen_recording_device */ 5:
                    message.isIosScreenRecordingDevice = reader.bool();
                    break;
                case /* optional string model_id */ 6:
                    message.modelId = reader.string();
                    break;
                case /* optional TSP.Size default_video_resolution */ 7:
                    message.defaultVideoResolution = TSPMessages_5.Size.internalBinaryRead(reader, reader.uint32(), options, message.defaultVideoResolution);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string unique_id = 1; */
        if (message.uniqueId !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.uniqueId);
        /* optional KN.LiveVideoCaptureDeviceDescription.Position position = 2; */
        if (message.position !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.position);
        /* optional string device_type = 3; */
        if (message.deviceType !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.deviceType);
        /* optional string localized_name = 4; */
        if (message.localizedName !== undefined)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.localizedName);
        /* optional bool is_ios_screen_recording_device = 5; */
        if (message.isIosScreenRecordingDevice !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.isIosScreenRecordingDevice);
        /* optional string model_id = 6; */
        if (message.modelId !== undefined)
            writer.tag(6, runtime_1.WireType.LengthDelimited).string(message.modelId);
        /* optional TSP.Size default_video_resolution = 7; */
        if (message.defaultVideoResolution)
            TSPMessages_5.Size.internalBinaryWrite(message.defaultVideoResolution, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.LiveVideoCaptureDeviceDescription
 */
exports.LiveVideoCaptureDeviceDescription = new LiveVideoCaptureDeviceDescription$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LiveVideoSourceCollection$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.LiveVideoSourceCollection", [
            { no: 1, name: "sources", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.Reference },
            { no: 2, name: "default_source", kind: "message", T: () => TSPMessages_8.Reference }
        ]);
    }
    create(value) {
        const message = { sources: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.Reference sources */ 1:
                    message.sources.push(TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Reference default_source */ 2:
                    message.defaultSource = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.defaultSource);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.Reference sources = 1; */
        for (let i = 0; i < message.sources.length; i++)
            TSPMessages_8.Reference.internalBinaryWrite(message.sources[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference default_source = 2; */
        if (message.defaultSource)
            TSPMessages_8.Reference.internalBinaryWrite(message.defaultSource, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.LiveVideoSourceCollection
 */
exports.LiveVideoSourceCollection = new LiveVideoSourceCollection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LiveVideoSourceUsageEntry$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.LiveVideoSourceUsageEntry", [
            { no: 1, name: "background_kinds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = { backgroundKinds: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 background_kinds */ 1:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.backgroundKinds.push(reader.int32());
                    else
                        message.backgroundKinds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated int32 background_kinds = 1; */
        for (let i = 0; i < message.backgroundKinds.length; i++)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.backgroundKinds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.LiveVideoSourceUsageEntry
 */
exports.LiveVideoSourceUsageEntry = new LiveVideoSourceUsageEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MotionBackgroundStylePropertiesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.MotionBackgroundStylePropertiesArchive", [
            { no: 1, name: "background_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "variant", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "color_gradient", kind: "message", T: () => TSDArchives_1.FillArchive },
            { no: 10, name: "random_number_seed", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "color_blur_sigma", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 12, name: "noise_amplitude", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 13, name: "noise_octaves", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 14, name: "noise_scale", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 15, name: "noise_speed", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 16, name: "color_palette_offset", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 17, name: "zoom", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 18, name: "invert", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "blend_mode", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "source_blend_factor", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 21, name: "dest_blend_factor", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 22, name: "motion", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 23, name: "background_color", kind: "message", T: () => TSPMessages_9.Color },
            { no: 24, name: "foreground_color", kind: "message", T: () => TSPMessages_9.Color },
            { no: 25, name: "line_color", kind: "message", T: () => TSPMessages_9.Color },
            { no: 26, name: "point_color", kind: "message", T: () => TSPMessages_9.Color },
            { no: 27, name: "alpha", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 28, name: "border", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 29, name: "blend", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 30, name: "brightness", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 31, name: "border_lightness", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 32, name: "contrast", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 33, name: "damping", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 34, name: "density", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 35, name: "diffuse_power", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 36, name: "distortion", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 37, name: "entropy", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 38, name: "exposure", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 39, name: "filter", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 40, name: "fog_distance", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 41, name: "fog_power", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 42, name: "gamma", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 43, name: "grain_amount", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 44, name: "grain_intensity", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 45, name: "hue", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 46, name: "lightness", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 47, name: "line_alpha", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 48, name: "line_center", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 49, name: "line_fade", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 50, name: "line_fade_power", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 51, name: "line_length", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 52, name: "line_width", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 53, name: "noise_size_scale", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 54, name: "noise_size_weight", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 55, name: "noise_variance", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 56, name: "offset", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 57, name: "motion_background_opacity", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 58, name: "point_depth_alpha", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 59, name: "point_size", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 60, name: "radius", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 61, name: "refraction", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 62, name: "resolution", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 63, name: "saturation", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 64, name: "scale", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 65, name: "shadow_alpha", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 66, name: "shadow_angle", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 67, name: "shadow_offset", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 68, name: "shadow_scale", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 69, name: "shadow_value", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 70, name: "speed", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 71, name: "texture_power", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 72, name: "time", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 73, name: "draw_points", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 74, name: "draw_lines", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 75, name: "draw_shadows", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 76, name: "pixels_per_division", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 77, name: "symmetry", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 78, name: "lock_focus", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 79, name: "amplitude", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 80, name: "envelope", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 81, name: "y_offset", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 82, name: "focus", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 83, name: "blur", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 84, name: "grain_speed", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 85, name: "mesh_color", kind: "message", T: () => TSPMessages_9.Color },
            { no: 86, name: "angle", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 87, name: "mesh_line_width", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 88, name: "delta_time", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 89, name: "time_start", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 90, name: "color_contrast", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 91, name: "color_gamma", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 92, name: "color_saturation", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 93, name: "color_brightness", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 94, name: "color_hue", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 95, name: "color_vibrance", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 96, name: "noise_movement", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 97, name: "power", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 98, name: "threshold", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 99, name: "noise_scale_horizontal", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 100, name: "noise_scale_vertical", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 101, name: "noise_gain", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 102, name: "noise_lacunarity", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 103, name: "instance_count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 104, name: "extrusion", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 105, name: "noise_offset", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 106, name: "color_hue_offset", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 107, name: "shadow_hue", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 108, name: "shadow_hue_offset", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 109, name: "shadow_saturation", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 110, name: "shadow_brightness", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 111, name: "shadow_intensity", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 112, name: "shadow_power", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 113, name: "noise_octaves_iterations", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string background_name */ 1:
                    message.backgroundName = reader.string();
                    break;
                case /* optional string variant */ 2:
                    message.variant = reader.string();
                    break;
                case /* optional TSD.FillArchive color_gradient */ 3:
                    message.colorGradient = TSDArchives_1.FillArchive.internalBinaryRead(reader, reader.uint32(), options, message.colorGradient);
                    break;
                case /* optional int32 random_number_seed */ 10:
                    message.randomNumberSeed = reader.int32();
                    break;
                case /* optional double color_blur_sigma */ 11:
                    message.colorBlurSigma = reader.double();
                    break;
                case /* optional double noise_amplitude */ 12:
                    message.noiseAmplitude = reader.double();
                    break;
                case /* optional double noise_octaves */ 13:
                    message.noiseOctaves = reader.double();
                    break;
                case /* optional double noise_scale */ 14:
                    message.noiseScale = reader.double();
                    break;
                case /* optional double noise_speed */ 15:
                    message.noiseSpeed = reader.double();
                    break;
                case /* optional double color_palette_offset */ 16:
                    message.colorPaletteOffset = reader.double();
                    break;
                case /* optional double zoom */ 17:
                    message.zoom = reader.double();
                    break;
                case /* optional bool invert */ 18:
                    message.invert = reader.bool();
                    break;
                case /* optional string blend_mode */ 19:
                    message.blendMode = reader.string();
                    break;
                case /* optional string source_blend_factor */ 20:
                    message.sourceBlendFactor = reader.string();
                    break;
                case /* optional string dest_blend_factor */ 21:
                    message.destBlendFactor = reader.string();
                    break;
                case /* optional string motion */ 22:
                    message.motion = reader.string();
                    break;
                case /* optional TSP.Color background_color */ 23:
                    message.backgroundColor = TSPMessages_9.Color.internalBinaryRead(reader, reader.uint32(), options, message.backgroundColor);
                    break;
                case /* optional TSP.Color foreground_color */ 24:
                    message.foregroundColor = TSPMessages_9.Color.internalBinaryRead(reader, reader.uint32(), options, message.foregroundColor);
                    break;
                case /* optional TSP.Color line_color */ 25:
                    message.lineColor = TSPMessages_9.Color.internalBinaryRead(reader, reader.uint32(), options, message.lineColor);
                    break;
                case /* optional TSP.Color point_color */ 26:
                    message.pointColor = TSPMessages_9.Color.internalBinaryRead(reader, reader.uint32(), options, message.pointColor);
                    break;
                case /* optional double alpha */ 27:
                    message.alpha = reader.double();
                    break;
                case /* optional double border */ 28:
                    message.border = reader.double();
                    break;
                case /* optional double blend */ 29:
                    message.blend = reader.double();
                    break;
                case /* optional double brightness */ 30:
                    message.brightness = reader.double();
                    break;
                case /* optional double border_lightness */ 31:
                    message.borderLightness = reader.double();
                    break;
                case /* optional double contrast */ 32:
                    message.contrast = reader.double();
                    break;
                case /* optional double damping */ 33:
                    message.damping = reader.double();
                    break;
                case /* optional double density */ 34:
                    message.density = reader.double();
                    break;
                case /* optional double diffuse_power */ 35:
                    message.diffusePower = reader.double();
                    break;
                case /* optional double distortion */ 36:
                    message.distortion = reader.double();
                    break;
                case /* optional double entropy */ 37:
                    message.entropy = reader.double();
                    break;
                case /* optional double exposure */ 38:
                    message.exposure = reader.double();
                    break;
                case /* optional double filter */ 39:
                    message.filter = reader.double();
                    break;
                case /* optional double fog_distance */ 40:
                    message.fogDistance = reader.double();
                    break;
                case /* optional double fog_power */ 41:
                    message.fogPower = reader.double();
                    break;
                case /* optional double gamma */ 42:
                    message.gamma = reader.double();
                    break;
                case /* optional double grain_amount */ 43:
                    message.grainAmount = reader.double();
                    break;
                case /* optional double grain_intensity */ 44:
                    message.grainIntensity = reader.double();
                    break;
                case /* optional double hue */ 45:
                    message.hue = reader.double();
                    break;
                case /* optional double lightness */ 46:
                    message.lightness = reader.double();
                    break;
                case /* optional double line_alpha */ 47:
                    message.lineAlpha = reader.double();
                    break;
                case /* optional double line_center */ 48:
                    message.lineCenter = reader.double();
                    break;
                case /* optional double line_fade */ 49:
                    message.lineFade = reader.double();
                    break;
                case /* optional double line_fade_power */ 50:
                    message.lineFadePower = reader.double();
                    break;
                case /* optional double line_length */ 51:
                    message.lineLength = reader.double();
                    break;
                case /* optional double line_width */ 52:
                    message.lineWidth = reader.double();
                    break;
                case /* optional double noise_size_scale */ 53:
                    message.noiseSizeScale = reader.double();
                    break;
                case /* optional double noise_size_weight */ 54:
                    message.noiseSizeWeight = reader.double();
                    break;
                case /* optional double noise_variance */ 55:
                    message.noiseVariance = reader.double();
                    break;
                case /* optional double offset */ 56:
                    message.offset = reader.double();
                    break;
                case /* optional double motion_background_opacity */ 57:
                    message.motionBackgroundOpacity = reader.double();
                    break;
                case /* optional double point_depth_alpha */ 58:
                    message.pointDepthAlpha = reader.double();
                    break;
                case /* optional double point_size */ 59:
                    message.pointSize = reader.double();
                    break;
                case /* optional double radius */ 60:
                    message.radius = reader.double();
                    break;
                case /* optional double refraction */ 61:
                    message.refraction = reader.double();
                    break;
                case /* optional double resolution */ 62:
                    message.resolution = reader.double();
                    break;
                case /* optional double saturation */ 63:
                    message.saturation = reader.double();
                    break;
                case /* optional double scale */ 64:
                    message.scale = reader.double();
                    break;
                case /* optional double shadow_alpha */ 65:
                    message.shadowAlpha = reader.double();
                    break;
                case /* optional double shadow_angle */ 66:
                    message.shadowAngle = reader.double();
                    break;
                case /* optional double shadow_offset */ 67:
                    message.shadowOffset = reader.double();
                    break;
                case /* optional double shadow_scale */ 68:
                    message.shadowScale = reader.double();
                    break;
                case /* optional double shadow_value */ 69:
                    message.shadowValue = reader.double();
                    break;
                case /* optional double speed */ 70:
                    message.speed = reader.double();
                    break;
                case /* optional double texture_power */ 71:
                    message.texturePower = reader.double();
                    break;
                case /* optional double time */ 72:
                    message.time = reader.double();
                    break;
                case /* optional bool draw_points */ 73:
                    message.drawPoints = reader.bool();
                    break;
                case /* optional bool draw_lines */ 74:
                    message.drawLines = reader.bool();
                    break;
                case /* optional bool draw_shadows */ 75:
                    message.drawShadows = reader.bool();
                    break;
                case /* optional uint32 pixels_per_division */ 76:
                    message.pixelsPerDivision = reader.uint32();
                    break;
                case /* optional bool symmetry */ 77:
                    message.symmetry = reader.bool();
                    break;
                case /* optional bool lock_focus */ 78:
                    message.lockFocus = reader.bool();
                    break;
                case /* optional double amplitude */ 79:
                    message.amplitude = reader.double();
                    break;
                case /* optional double envelope */ 80:
                    message.envelope = reader.double();
                    break;
                case /* optional double y_offset */ 81:
                    message.yOffset = reader.double();
                    break;
                case /* optional double focus */ 82:
                    message.focus = reader.double();
                    break;
                case /* optional double blur */ 83:
                    message.blur = reader.double();
                    break;
                case /* optional double grain_speed */ 84:
                    message.grainSpeed = reader.double();
                    break;
                case /* optional TSP.Color mesh_color */ 85:
                    message.meshColor = TSPMessages_9.Color.internalBinaryRead(reader, reader.uint32(), options, message.meshColor);
                    break;
                case /* optional double angle */ 86:
                    message.angle = reader.double();
                    break;
                case /* optional double mesh_line_width */ 87:
                    message.meshLineWidth = reader.double();
                    break;
                case /* optional double delta_time */ 88:
                    message.deltaTime = reader.double();
                    break;
                case /* optional double time_start */ 89:
                    message.timeStart = reader.double();
                    break;
                case /* optional double color_contrast */ 90:
                    message.colorContrast = reader.double();
                    break;
                case /* optional double color_gamma */ 91:
                    message.colorGamma = reader.double();
                    break;
                case /* optional double color_saturation */ 92:
                    message.colorSaturation = reader.double();
                    break;
                case /* optional double color_brightness */ 93:
                    message.colorBrightness = reader.double();
                    break;
                case /* optional double color_hue */ 94:
                    message.colorHue = reader.double();
                    break;
                case /* optional double color_vibrance */ 95:
                    message.colorVibrance = reader.double();
                    break;
                case /* optional double noise_movement */ 96:
                    message.noiseMovement = reader.double();
                    break;
                case /* optional double power */ 97:
                    message.power = reader.double();
                    break;
                case /* optional double threshold */ 98:
                    message.threshold = reader.double();
                    break;
                case /* optional double noise_scale_horizontal */ 99:
                    message.noiseScaleHorizontal = reader.double();
                    break;
                case /* optional double noise_scale_vertical */ 100:
                    message.noiseScaleVertical = reader.double();
                    break;
                case /* optional double noise_gain */ 101:
                    message.noiseGain = reader.double();
                    break;
                case /* optional double noise_lacunarity */ 102:
                    message.noiseLacunarity = reader.double();
                    break;
                case /* optional int32 instance_count */ 103:
                    message.instanceCount = reader.int32();
                    break;
                case /* optional double extrusion */ 104:
                    message.extrusion = reader.double();
                    break;
                case /* optional double noise_offset */ 105:
                    message.noiseOffset = reader.double();
                    break;
                case /* optional double color_hue_offset */ 106:
                    message.colorHueOffset = reader.double();
                    break;
                case /* optional double shadow_hue */ 107:
                    message.shadowHue = reader.double();
                    break;
                case /* optional double shadow_hue_offset */ 108:
                    message.shadowHueOffset = reader.double();
                    break;
                case /* optional double shadow_saturation */ 109:
                    message.shadowSaturation = reader.double();
                    break;
                case /* optional double shadow_brightness */ 110:
                    message.shadowBrightness = reader.double();
                    break;
                case /* optional double shadow_intensity */ 111:
                    message.shadowIntensity = reader.double();
                    break;
                case /* optional double shadow_power */ 112:
                    message.shadowPower = reader.double();
                    break;
                case /* optional int32 noise_octaves_iterations */ 113:
                    message.noiseOctavesIterations = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string background_name = 1; */
        if (message.backgroundName !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.backgroundName);
        /* optional string variant = 2; */
        if (message.variant !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.variant);
        /* optional TSD.FillArchive color_gradient = 3; */
        if (message.colorGradient)
            TSDArchives_1.FillArchive.internalBinaryWrite(message.colorGradient, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional int32 random_number_seed = 10; */
        if (message.randomNumberSeed !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).int32(message.randomNumberSeed);
        /* optional double color_blur_sigma = 11; */
        if (message.colorBlurSigma !== undefined)
            writer.tag(11, runtime_1.WireType.Bit64).double(message.colorBlurSigma);
        /* optional double noise_amplitude = 12; */
        if (message.noiseAmplitude !== undefined)
            writer.tag(12, runtime_1.WireType.Bit64).double(message.noiseAmplitude);
        /* optional double noise_octaves = 13; */
        if (message.noiseOctaves !== undefined)
            writer.tag(13, runtime_1.WireType.Bit64).double(message.noiseOctaves);
        /* optional double noise_scale = 14; */
        if (message.noiseScale !== undefined)
            writer.tag(14, runtime_1.WireType.Bit64).double(message.noiseScale);
        /* optional double noise_speed = 15; */
        if (message.noiseSpeed !== undefined)
            writer.tag(15, runtime_1.WireType.Bit64).double(message.noiseSpeed);
        /* optional double color_palette_offset = 16; */
        if (message.colorPaletteOffset !== undefined)
            writer.tag(16, runtime_1.WireType.Bit64).double(message.colorPaletteOffset);
        /* optional double zoom = 17; */
        if (message.zoom !== undefined)
            writer.tag(17, runtime_1.WireType.Bit64).double(message.zoom);
        /* optional bool invert = 18; */
        if (message.invert !== undefined)
            writer.tag(18, runtime_1.WireType.Varint).bool(message.invert);
        /* optional string blend_mode = 19; */
        if (message.blendMode !== undefined)
            writer.tag(19, runtime_1.WireType.LengthDelimited).string(message.blendMode);
        /* optional string source_blend_factor = 20; */
        if (message.sourceBlendFactor !== undefined)
            writer.tag(20, runtime_1.WireType.LengthDelimited).string(message.sourceBlendFactor);
        /* optional string dest_blend_factor = 21; */
        if (message.destBlendFactor !== undefined)
            writer.tag(21, runtime_1.WireType.LengthDelimited).string(message.destBlendFactor);
        /* optional string motion = 22; */
        if (message.motion !== undefined)
            writer.tag(22, runtime_1.WireType.LengthDelimited).string(message.motion);
        /* optional TSP.Color background_color = 23; */
        if (message.backgroundColor)
            TSPMessages_9.Color.internalBinaryWrite(message.backgroundColor, writer.tag(23, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Color foreground_color = 24; */
        if (message.foregroundColor)
            TSPMessages_9.Color.internalBinaryWrite(message.foregroundColor, writer.tag(24, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Color line_color = 25; */
        if (message.lineColor)
            TSPMessages_9.Color.internalBinaryWrite(message.lineColor, writer.tag(25, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Color point_color = 26; */
        if (message.pointColor)
            TSPMessages_9.Color.internalBinaryWrite(message.pointColor, writer.tag(26, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional double alpha = 27; */
        if (message.alpha !== undefined)
            writer.tag(27, runtime_1.WireType.Bit64).double(message.alpha);
        /* optional double border = 28; */
        if (message.border !== undefined)
            writer.tag(28, runtime_1.WireType.Bit64).double(message.border);
        /* optional double blend = 29; */
        if (message.blend !== undefined)
            writer.tag(29, runtime_1.WireType.Bit64).double(message.blend);
        /* optional double brightness = 30; */
        if (message.brightness !== undefined)
            writer.tag(30, runtime_1.WireType.Bit64).double(message.brightness);
        /* optional double border_lightness = 31; */
        if (message.borderLightness !== undefined)
            writer.tag(31, runtime_1.WireType.Bit64).double(message.borderLightness);
        /* optional double contrast = 32; */
        if (message.contrast !== undefined)
            writer.tag(32, runtime_1.WireType.Bit64).double(message.contrast);
        /* optional double damping = 33; */
        if (message.damping !== undefined)
            writer.tag(33, runtime_1.WireType.Bit64).double(message.damping);
        /* optional double density = 34; */
        if (message.density !== undefined)
            writer.tag(34, runtime_1.WireType.Bit64).double(message.density);
        /* optional double diffuse_power = 35; */
        if (message.diffusePower !== undefined)
            writer.tag(35, runtime_1.WireType.Bit64).double(message.diffusePower);
        /* optional double distortion = 36; */
        if (message.distortion !== undefined)
            writer.tag(36, runtime_1.WireType.Bit64).double(message.distortion);
        /* optional double entropy = 37; */
        if (message.entropy !== undefined)
            writer.tag(37, runtime_1.WireType.Bit64).double(message.entropy);
        /* optional double exposure = 38; */
        if (message.exposure !== undefined)
            writer.tag(38, runtime_1.WireType.Bit64).double(message.exposure);
        /* optional double filter = 39; */
        if (message.filter !== undefined)
            writer.tag(39, runtime_1.WireType.Bit64).double(message.filter);
        /* optional double fog_distance = 40; */
        if (message.fogDistance !== undefined)
            writer.tag(40, runtime_1.WireType.Bit64).double(message.fogDistance);
        /* optional double fog_power = 41; */
        if (message.fogPower !== undefined)
            writer.tag(41, runtime_1.WireType.Bit64).double(message.fogPower);
        /* optional double gamma = 42; */
        if (message.gamma !== undefined)
            writer.tag(42, runtime_1.WireType.Bit64).double(message.gamma);
        /* optional double grain_amount = 43; */
        if (message.grainAmount !== undefined)
            writer.tag(43, runtime_1.WireType.Bit64).double(message.grainAmount);
        /* optional double grain_intensity = 44; */
        if (message.grainIntensity !== undefined)
            writer.tag(44, runtime_1.WireType.Bit64).double(message.grainIntensity);
        /* optional double hue = 45; */
        if (message.hue !== undefined)
            writer.tag(45, runtime_1.WireType.Bit64).double(message.hue);
        /* optional double lightness = 46; */
        if (message.lightness !== undefined)
            writer.tag(46, runtime_1.WireType.Bit64).double(message.lightness);
        /* optional double line_alpha = 47; */
        if (message.lineAlpha !== undefined)
            writer.tag(47, runtime_1.WireType.Bit64).double(message.lineAlpha);
        /* optional double line_center = 48; */
        if (message.lineCenter !== undefined)
            writer.tag(48, runtime_1.WireType.Bit64).double(message.lineCenter);
        /* optional double line_fade = 49; */
        if (message.lineFade !== undefined)
            writer.tag(49, runtime_1.WireType.Bit64).double(message.lineFade);
        /* optional double line_fade_power = 50; */
        if (message.lineFadePower !== undefined)
            writer.tag(50, runtime_1.WireType.Bit64).double(message.lineFadePower);
        /* optional double line_length = 51; */
        if (message.lineLength !== undefined)
            writer.tag(51, runtime_1.WireType.Bit64).double(message.lineLength);
        /* optional double line_width = 52; */
        if (message.lineWidth !== undefined)
            writer.tag(52, runtime_1.WireType.Bit64).double(message.lineWidth);
        /* optional double noise_size_scale = 53; */
        if (message.noiseSizeScale !== undefined)
            writer.tag(53, runtime_1.WireType.Bit64).double(message.noiseSizeScale);
        /* optional double noise_size_weight = 54; */
        if (message.noiseSizeWeight !== undefined)
            writer.tag(54, runtime_1.WireType.Bit64).double(message.noiseSizeWeight);
        /* optional double noise_variance = 55; */
        if (message.noiseVariance !== undefined)
            writer.tag(55, runtime_1.WireType.Bit64).double(message.noiseVariance);
        /* optional double offset = 56; */
        if (message.offset !== undefined)
            writer.tag(56, runtime_1.WireType.Bit64).double(message.offset);
        /* optional double motion_background_opacity = 57; */
        if (message.motionBackgroundOpacity !== undefined)
            writer.tag(57, runtime_1.WireType.Bit64).double(message.motionBackgroundOpacity);
        /* optional double point_depth_alpha = 58; */
        if (message.pointDepthAlpha !== undefined)
            writer.tag(58, runtime_1.WireType.Bit64).double(message.pointDepthAlpha);
        /* optional double point_size = 59; */
        if (message.pointSize !== undefined)
            writer.tag(59, runtime_1.WireType.Bit64).double(message.pointSize);
        /* optional double radius = 60; */
        if (message.radius !== undefined)
            writer.tag(60, runtime_1.WireType.Bit64).double(message.radius);
        /* optional double refraction = 61; */
        if (message.refraction !== undefined)
            writer.tag(61, runtime_1.WireType.Bit64).double(message.refraction);
        /* optional double resolution = 62; */
        if (message.resolution !== undefined)
            writer.tag(62, runtime_1.WireType.Bit64).double(message.resolution);
        /* optional double saturation = 63; */
        if (message.saturation !== undefined)
            writer.tag(63, runtime_1.WireType.Bit64).double(message.saturation);
        /* optional double scale = 64; */
        if (message.scale !== undefined)
            writer.tag(64, runtime_1.WireType.Bit64).double(message.scale);
        /* optional double shadow_alpha = 65; */
        if (message.shadowAlpha !== undefined)
            writer.tag(65, runtime_1.WireType.Bit64).double(message.shadowAlpha);
        /* optional double shadow_angle = 66; */
        if (message.shadowAngle !== undefined)
            writer.tag(66, runtime_1.WireType.Bit64).double(message.shadowAngle);
        /* optional double shadow_offset = 67; */
        if (message.shadowOffset !== undefined)
            writer.tag(67, runtime_1.WireType.Bit64).double(message.shadowOffset);
        /* optional double shadow_scale = 68; */
        if (message.shadowScale !== undefined)
            writer.tag(68, runtime_1.WireType.Bit64).double(message.shadowScale);
        /* optional double shadow_value = 69; */
        if (message.shadowValue !== undefined)
            writer.tag(69, runtime_1.WireType.Bit64).double(message.shadowValue);
        /* optional double speed = 70; */
        if (message.speed !== undefined)
            writer.tag(70, runtime_1.WireType.Bit64).double(message.speed);
        /* optional double texture_power = 71; */
        if (message.texturePower !== undefined)
            writer.tag(71, runtime_1.WireType.Bit64).double(message.texturePower);
        /* optional double time = 72; */
        if (message.time !== undefined)
            writer.tag(72, runtime_1.WireType.Bit64).double(message.time);
        /* optional bool draw_points = 73; */
        if (message.drawPoints !== undefined)
            writer.tag(73, runtime_1.WireType.Varint).bool(message.drawPoints);
        /* optional bool draw_lines = 74; */
        if (message.drawLines !== undefined)
            writer.tag(74, runtime_1.WireType.Varint).bool(message.drawLines);
        /* optional bool draw_shadows = 75; */
        if (message.drawShadows !== undefined)
            writer.tag(75, runtime_1.WireType.Varint).bool(message.drawShadows);
        /* optional uint32 pixels_per_division = 76; */
        if (message.pixelsPerDivision !== undefined)
            writer.tag(76, runtime_1.WireType.Varint).uint32(message.pixelsPerDivision);
        /* optional bool symmetry = 77; */
        if (message.symmetry !== undefined)
            writer.tag(77, runtime_1.WireType.Varint).bool(message.symmetry);
        /* optional bool lock_focus = 78; */
        if (message.lockFocus !== undefined)
            writer.tag(78, runtime_1.WireType.Varint).bool(message.lockFocus);
        /* optional double amplitude = 79; */
        if (message.amplitude !== undefined)
            writer.tag(79, runtime_1.WireType.Bit64).double(message.amplitude);
        /* optional double envelope = 80; */
        if (message.envelope !== undefined)
            writer.tag(80, runtime_1.WireType.Bit64).double(message.envelope);
        /* optional double y_offset = 81; */
        if (message.yOffset !== undefined)
            writer.tag(81, runtime_1.WireType.Bit64).double(message.yOffset);
        /* optional double focus = 82; */
        if (message.focus !== undefined)
            writer.tag(82, runtime_1.WireType.Bit64).double(message.focus);
        /* optional double blur = 83; */
        if (message.blur !== undefined)
            writer.tag(83, runtime_1.WireType.Bit64).double(message.blur);
        /* optional double grain_speed = 84; */
        if (message.grainSpeed !== undefined)
            writer.tag(84, runtime_1.WireType.Bit64).double(message.grainSpeed);
        /* optional TSP.Color mesh_color = 85; */
        if (message.meshColor)
            TSPMessages_9.Color.internalBinaryWrite(message.meshColor, writer.tag(85, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional double angle = 86; */
        if (message.angle !== undefined)
            writer.tag(86, runtime_1.WireType.Bit64).double(message.angle);
        /* optional double mesh_line_width = 87; */
        if (message.meshLineWidth !== undefined)
            writer.tag(87, runtime_1.WireType.Bit64).double(message.meshLineWidth);
        /* optional double delta_time = 88; */
        if (message.deltaTime !== undefined)
            writer.tag(88, runtime_1.WireType.Bit64).double(message.deltaTime);
        /* optional double time_start = 89; */
        if (message.timeStart !== undefined)
            writer.tag(89, runtime_1.WireType.Bit64).double(message.timeStart);
        /* optional double color_contrast = 90; */
        if (message.colorContrast !== undefined)
            writer.tag(90, runtime_1.WireType.Bit64).double(message.colorContrast);
        /* optional double color_gamma = 91; */
        if (message.colorGamma !== undefined)
            writer.tag(91, runtime_1.WireType.Bit64).double(message.colorGamma);
        /* optional double color_saturation = 92; */
        if (message.colorSaturation !== undefined)
            writer.tag(92, runtime_1.WireType.Bit64).double(message.colorSaturation);
        /* optional double color_brightness = 93; */
        if (message.colorBrightness !== undefined)
            writer.tag(93, runtime_1.WireType.Bit64).double(message.colorBrightness);
        /* optional double color_hue = 94; */
        if (message.colorHue !== undefined)
            writer.tag(94, runtime_1.WireType.Bit64).double(message.colorHue);
        /* optional double color_vibrance = 95; */
        if (message.colorVibrance !== undefined)
            writer.tag(95, runtime_1.WireType.Bit64).double(message.colorVibrance);
        /* optional double noise_movement = 96; */
        if (message.noiseMovement !== undefined)
            writer.tag(96, runtime_1.WireType.Bit64).double(message.noiseMovement);
        /* optional double power = 97; */
        if (message.power !== undefined)
            writer.tag(97, runtime_1.WireType.Bit64).double(message.power);
        /* optional double threshold = 98; */
        if (message.threshold !== undefined)
            writer.tag(98, runtime_1.WireType.Bit64).double(message.threshold);
        /* optional double noise_scale_horizontal = 99; */
        if (message.noiseScaleHorizontal !== undefined)
            writer.tag(99, runtime_1.WireType.Bit64).double(message.noiseScaleHorizontal);
        /* optional double noise_scale_vertical = 100; */
        if (message.noiseScaleVertical !== undefined)
            writer.tag(100, runtime_1.WireType.Bit64).double(message.noiseScaleVertical);
        /* optional double noise_gain = 101; */
        if (message.noiseGain !== undefined)
            writer.tag(101, runtime_1.WireType.Bit64).double(message.noiseGain);
        /* optional double noise_lacunarity = 102; */
        if (message.noiseLacunarity !== undefined)
            writer.tag(102, runtime_1.WireType.Bit64).double(message.noiseLacunarity);
        /* optional int32 instance_count = 103; */
        if (message.instanceCount !== undefined)
            writer.tag(103, runtime_1.WireType.Varint).int32(message.instanceCount);
        /* optional double extrusion = 104; */
        if (message.extrusion !== undefined)
            writer.tag(104, runtime_1.WireType.Bit64).double(message.extrusion);
        /* optional double noise_offset = 105; */
        if (message.noiseOffset !== undefined)
            writer.tag(105, runtime_1.WireType.Bit64).double(message.noiseOffset);
        /* optional double color_hue_offset = 106; */
        if (message.colorHueOffset !== undefined)
            writer.tag(106, runtime_1.WireType.Bit64).double(message.colorHueOffset);
        /* optional double shadow_hue = 107; */
        if (message.shadowHue !== undefined)
            writer.tag(107, runtime_1.WireType.Bit64).double(message.shadowHue);
        /* optional double shadow_hue_offset = 108; */
        if (message.shadowHueOffset !== undefined)
            writer.tag(108, runtime_1.WireType.Bit64).double(message.shadowHueOffset);
        /* optional double shadow_saturation = 109; */
        if (message.shadowSaturation !== undefined)
            writer.tag(109, runtime_1.WireType.Bit64).double(message.shadowSaturation);
        /* optional double shadow_brightness = 110; */
        if (message.shadowBrightness !== undefined)
            writer.tag(110, runtime_1.WireType.Bit64).double(message.shadowBrightness);
        /* optional double shadow_intensity = 111; */
        if (message.shadowIntensity !== undefined)
            writer.tag(111, runtime_1.WireType.Bit64).double(message.shadowIntensity);
        /* optional double shadow_power = 112; */
        if (message.shadowPower !== undefined)
            writer.tag(112, runtime_1.WireType.Bit64).double(message.shadowPower);
        /* optional int32 noise_octaves_iterations = 113; */
        if (message.noiseOctavesIterations !== undefined)
            writer.tag(113, runtime_1.WireType.Varint).int32(message.noiseOctavesIterations);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.MotionBackgroundStylePropertiesArchive
 */
exports.MotionBackgroundStylePropertiesArchive = new MotionBackgroundStylePropertiesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MotionBackgroundStyleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.MotionBackgroundStyleArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSSArchives_1.StyleArchive },
            { no: 10, name: "override_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "slide_properties", kind: "message", T: () => exports.MotionBackgroundStylePropertiesArchive },
            { no: 12, name: "poster_frame_data", kind: "message", T: () => TSPMessages_6.DataReference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSS.StyleArchive super */ 1:
                    message.super = TSSArchives_1.StyleArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional uint32 override_count */ 10:
                    message.overrideCount = reader.uint32();
                    break;
                case /* optional KN.MotionBackgroundStylePropertiesArchive slide_properties */ 11:
                    message.slideProperties = exports.MotionBackgroundStylePropertiesArchive.internalBinaryRead(reader, reader.uint32(), options, message.slideProperties);
                    break;
                case /* optional TSP.DataReference poster_frame_data */ 12:
                    message.posterFrameData = TSPMessages_6.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.posterFrameData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSS.StyleArchive super = 1; */
        if (message.super)
            TSSArchives_1.StyleArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 override_count = 10; */
        if (message.overrideCount !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).uint32(message.overrideCount);
        /* optional KN.MotionBackgroundStylePropertiesArchive slide_properties = 11; */
        if (message.slideProperties)
            exports.MotionBackgroundStylePropertiesArchive.internalBinaryWrite(message.slideProperties, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference poster_frame_data = 12; */
        if (message.posterFrameData)
            TSPMessages_6.DataReference.internalBinaryWrite(message.posterFrameData, writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.MotionBackgroundStyleArchive
 */
exports.MotionBackgroundStyleArchive = new MotionBackgroundStyleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MotionBackgroundFillArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.MotionBackgroundFillArchive", [
            { no: 1, name: "motion_background_style", kind: "message", T: () => TSPMessages_8.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.Reference motion_background_style */ 1:
                    message.motionBackgroundStyle = TSPMessages_8.Reference.internalBinaryRead(reader, reader.uint32(), options, message.motionBackgroundStyle);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.Reference motion_background_style = 1; */
        if (message.motionBackgroundStyle)
            TSPMessages_8.Reference.internalBinaryWrite(message.motionBackgroundStyle, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.MotionBackgroundFillArchive
 */
exports.MotionBackgroundFillArchive = new MotionBackgroundFillArchive$Type();
//# sourceMappingURL=KNArchives.js.map