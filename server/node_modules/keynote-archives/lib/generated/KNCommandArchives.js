"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandChangeTemplateSlideArchive = exports.CommandTemplateSetBodyStylesArchive = exports.CommandTemplateSetThumbnailTextArchive = exports.CommandShowSetSlideNumberVisibilityArchive = exports.CommandTransitionSetValueArchive = exports.CommandBuildChunkSetValueArchive = exports.CommandBuildUpdateChunkCountArchive = exports.CommandBuildUpdateChunkReferentsArchive = exports.CommandBuildSetValueArchive = exports.CommandSlideMoveBuildChunksArchive = exports.CommandSlideRemoveBuildChunkArchive = exports.CommandSlideInsertBuildChunkArchive = exports.RemoveBuildDescriptionArchive = exports.CommandSlideRemoveBuildArchive = exports.UndoObjectArchive = exports.InsertBuildDescriptionArchive = exports.CommandSlideInsertBuildArchive = exports.CommandPrimitiveRemoveTemplateArchive = exports.CommandRemoveTemplateArchive = exports.CommandPrimitiveInsertTemplateArchive = exports.CommandInsertTemplateArchive = exports.CommandMoveTemplatesArchive = exports.CommandSetThemeCustomEffectTimingCurveArchive = exports.CommandShowChangeSlideSizeArchive = exports.CommandShowChangeThemeArchive_IdentifierToStyleMap = exports.CommandShowChangeThemeArchive = exports.CommandShowRemoveSlideArchive = exports.CommandShowMoveSlideArchive = exports.CommandShowInsertSlideArchive = exports.CommandShowSetValueArchive_PropertyValue = exports.CommandShowSetValueArchive = exports.CommandShowReplaceRecordingArchive = exports.CommandShowRemoveRecordingArchive = exports.CommandShowMarkOutOfSyncRecordingIfNeededArchive = exports.CommandShowMarkOutOfSyncRecordingArchive = exports.CommandSlideSetStyleArchive = exports.CommandSlideSetBackgroundFillArchive = exports.CommandSlideNodeSetViewStatePropertyArchive = exports.CommandSlideNodeSetPropertyArchive = exports.CommandSlideMoveDrawableZOrderArchive = exports.CommandSlideRemoveDrawableArchive = exports.CommandSlidePropagateSetPlaceholderForTagArchive = exports.CommandTemplateSlideSetPlaceholderForTagArchive = exports.CommandSlideSetPlaceholdersForTagsArchive = exports.CommandSlideInsertDrawablesArchive = exports.UIStateCommandGroupArchive = exports.AnimationReferent = exports.CommandLiveVideoSourceSetValue_Property = exports.CommandLiveVideoInfoSetValue_Property = exports.CommandShowInsertSlideArchive_Kind = void 0;
exports.CommandMotionBackgroundStyleUpdatePosterFrameDataArchive = exports.CommandMotionBackgroundStyleSetValueArchive = exports.CommandThemeRemoveLiveVideoSource = exports.CommandThemeAddLiveVideoSource = exports.CommandLiveVideoStyleSetValue = exports.CommandLiveVideoSourceSetValue_PropertyValue = exports.CommandLiveVideoSourceSetValue = exports.CommandLiveVideoInfoSetValue_PropertyValue = exports.CommandLiveVideoInfoSetValue = exports.CommandLiveVideoInfoSetSource = exports.CommandLiveVideoInfoApplyPreset = exports.OutlineSelectionTransformerArchive = exports.SlideCollectionSelectionTransformerArchive = exports.SlideCollectionSelectionTransformerHelperArchive = exports.OutlineCanvasSelectionTransformerArchive = exports.NoteCanvasSelectionTransformerArchive = exports.DocumentSelectionTransformerArchive = exports.ActionGhostSelectionTransformerArchive = exports.CanvasSelectionTransformerArchive = exports.ChartInfoGeometryCommandArchive = exports.CommandSlideUpdateTemplateDrawables = exports.CommandSoundtrackSetValue_PropertyValue = exports.CommandSoundtrackSetValue = exports.CommandShowSetSoundtrack = exports.CommandSlideResetTemplateBackgroundObjectsArchive = exports.CommandSlidePrimitiveSetTemplateArchive = void 0;
const runtime_1 = require("@protobuf-ts/runtime");
const runtime_2 = require("@protobuf-ts/runtime");
const runtime_3 = require("@protobuf-ts/runtime");
const runtime_4 = require("@protobuf-ts/runtime");
const runtime_5 = require("@protobuf-ts/runtime");
const KNArchives_sos_1 = require("./KNArchives_sos");
const TSDArchives_sos_1 = require("./TSDArchives_sos");
const TSDCommandArchives_1 = require("./TSDCommandArchives");
const KNArchives_1 = require("./KNArchives");
const KNArchives_2 = require("./KNArchives");
const TSDCommandArchives_2 = require("./TSDCommandArchives");
const TSKArchives_1 = require("./TSKArchives");
const TSDCommandArchives_3 = require("./TSDCommandArchives");
const TSPMessages_1 = require("./TSPMessages");
const TSDCommandArchives_4 = require("./TSDCommandArchives");
const TSKArchives_2 = require("./TSKArchives");
const TSPMessages_2 = require("./TSPMessages");
const KNArchives_3 = require("./KNArchives");
const KNArchives_4 = require("./KNArchives");
const TSDCommandArchives_5 = require("./TSDCommandArchives");
const KNArchives_5 = require("./KNArchives");
const TSDCommandArchives_6 = require("./TSDCommandArchives");
const TSDCommandArchives_7 = require("./TSDCommandArchives");
const TSDCommandArchives_8 = require("./TSDCommandArchives");
const TSDArchives_1 = require("./TSDArchives");
const TSSArchives_1 = require("./TSSArchives");
const TSKArchives_3 = require("./TSKArchives");
const TSKArchives_4 = require("./TSKArchives");
const KNArchives_6 = require("./KNArchives");
const TSPMessages_3 = require("./TSPMessages");
const TSDArchives_2 = require("./TSDArchives");
const TSPMessages_4 = require("./TSPMessages");
const TSKArchives_5 = require("./TSKArchives");
const TSDArchives_3 = require("./TSDArchives");
const KNArchives_7 = require("./KNArchives");
const TSPMessages_5 = require("./TSPMessages");
const TSKArchives_6 = require("./TSKArchives");
const TSPMessages_6 = require("./TSPMessages");
const TSPMessages_7 = require("./TSPMessages");
const TSKArchives_7 = require("./TSKArchives");
/**
 * @generated from protobuf enum KN.CommandShowInsertSlideArchive.Kind
 */
var CommandShowInsertSlideArchive_Kind;
(function (CommandShowInsertSlideArchive_Kind) {
    /**
     * @generated from protobuf enum value: kKindInsertSlide = 0;
     */
    CommandShowInsertSlideArchive_Kind[CommandShowInsertSlideArchive_Kind["kKindInsertSlide"] = 0] = "kKindInsertSlide";
    /**
     * @generated from protobuf enum value: kKindInsertSlideForPaste = 1;
     */
    CommandShowInsertSlideArchive_Kind[CommandShowInsertSlideArchive_Kind["kKindInsertSlideForPaste"] = 1] = "kKindInsertSlideForPaste";
    /**
     * @generated from protobuf enum value: kKindInsertSlideForDuplicate = 2;
     */
    CommandShowInsertSlideArchive_Kind[CommandShowInsertSlideArchive_Kind["kKindInsertSlideForDuplicate"] = 2] = "kKindInsertSlideForDuplicate";
})(CommandShowInsertSlideArchive_Kind = exports.CommandShowInsertSlideArchive_Kind || (exports.CommandShowInsertSlideArchive_Kind = {}));
/**
 * @generated from protobuf enum KN.CommandLiveVideoInfoSetValue.Property
 */
var CommandLiveVideoInfoSetValue_Property;
(function (CommandLiveVideoInfoSetValue_Property) {
    /**
     * @generated from protobuf enum value: Scale = 0;
     */
    CommandLiveVideoInfoSetValue_Property[CommandLiveVideoInfoSetValue_Property["Scale"] = 0] = "Scale";
    /**
     * @generated from protobuf enum value: NormalizedOffset = 1;
     */
    CommandLiveVideoInfoSetValue_Property[CommandLiveVideoInfoSetValue_Property["NormalizedOffset"] = 1] = "NormalizedOffset";
    /**
     * @generated from protobuf enum value: MaskKind = 2;
     */
    CommandLiveVideoInfoSetValue_Property[CommandLiveVideoInfoSetValue_Property["MaskKind"] = 2] = "MaskKind";
    /**
     * @generated from protobuf enum value: MaskCornerRadius = 3;
     */
    CommandLiveVideoInfoSetValue_Property[CommandLiveVideoInfoSetValue_Property["MaskCornerRadius"] = 3] = "MaskCornerRadius";
    /**
     * @generated from protobuf enum value: IsPlaceholder = 4;
     */
    CommandLiveVideoInfoSetValue_Property[CommandLiveVideoInfoSetValue_Property["IsPlaceholder"] = 4] = "IsPlaceholder";
    /**
     * @generated from protobuf enum value: BackgroundKind = 5;
     */
    CommandLiveVideoInfoSetValue_Property[CommandLiveVideoInfoSetValue_Property["BackgroundKind"] = 5] = "BackgroundKind";
    /**
     * @generated from protobuf enum value: BackgroundFill = 6;
     */
    CommandLiveVideoInfoSetValue_Property[CommandLiveVideoInfoSetValue_Property["BackgroundFill"] = 6] = "BackgroundFill";
})(CommandLiveVideoInfoSetValue_Property = exports.CommandLiveVideoInfoSetValue_Property || (exports.CommandLiveVideoInfoSetValue_Property = {}));
/**
 * @generated from protobuf enum KN.CommandLiveVideoSourceSetValue.Property
 */
var CommandLiveVideoSourceSetValue_Property;
(function (CommandLiveVideoSourceSetValue_Property) {
    /**
     * @generated from protobuf enum value: SourceName = 0;
     */
    CommandLiveVideoSourceSetValue_Property[CommandLiveVideoSourceSetValue_Property["SourceName"] = 0] = "SourceName";
    /**
     * @generated from protobuf enum value: CaptureDeviceDescription = 1;
     */
    CommandLiveVideoSourceSetValue_Property[CommandLiveVideoSourceSetValue_Property["CaptureDeviceDescription"] = 1] = "CaptureDeviceDescription";
    /**
     * @generated from protobuf enum value: PosterImageData = 2;
     */
    CommandLiveVideoSourceSetValue_Property[CommandLiveVideoSourceSetValue_Property["PosterImageData"] = 2] = "PosterImageData";
    /**
     * @generated from protobuf enum value: SymbolAbbreviationText = 3;
     */
    CommandLiveVideoSourceSetValue_Property[CommandLiveVideoSourceSetValue_Property["SymbolAbbreviationText"] = 3] = "SymbolAbbreviationText";
    /**
     * @generated from protobuf enum value: SymbolImageIdentifier = 4;
     */
    CommandLiveVideoSourceSetValue_Property[CommandLiveVideoSourceSetValue_Property["SymbolImageIdentifier"] = 4] = "SymbolImageIdentifier";
    /**
     * @generated from protobuf enum value: SymbolTintColorIdentifier = 5;
     */
    CommandLiveVideoSourceSetValue_Property[CommandLiveVideoSourceSetValue_Property["SymbolTintColorIdentifier"] = 5] = "SymbolTintColorIdentifier";
})(CommandLiveVideoSourceSetValue_Property = exports.CommandLiveVideoSourceSetValue_Property || (exports.CommandLiveVideoSourceSetValue_Property = {}));
/**
 * @generated from protobuf enum KN.AnimationReferent
 */
var AnimationReferent;
(function (AnimationReferent) {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    AnimationReferent[AnimationReferent["UNSPECIFIED$"] = 0] = "UNSPECIFIED$";
    /**
     * @generated from protobuf enum value: kRelativeToStart = 1;
     */
    AnimationReferent[AnimationReferent["kRelativeToStart"] = 1] = "kRelativeToStart";
    /**
     * @generated from protobuf enum value: kRelativeToEnd = 2;
     */
    AnimationReferent[AnimationReferent["kRelativeToEnd"] = 2] = "kRelativeToEnd";
})(AnimationReferent = exports.AnimationReferent || (exports.AnimationReferent = {}));
// @generated message type with reflection information, may provide speed optimized methods
class UIStateCommandGroupArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.UIStateCommandGroupArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_7.CommandGroupArchive },
            { no: 2, name: "uiState", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 3, name: "property", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "slideNodesToEdit", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 5, name: "template_slide_nodes_to_apply", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 6, name: "thumbnailSizes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_6.Size },
            { no: 7, name: "selectedSlideNodes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 8, name: "restoreSelectedSlideNodes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference }
        ]);
    }
    create(value) {
        const message = { property: "", slideNodesToEdit: [], templateSlideNodesToApply: [], thumbnailSizes: [], selectedSlideNodes: [], restoreSelectedSlideNodes: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandGroupArchive super */ 1:
                    message.super = TSKArchives_7.CommandGroupArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Reference uiState */ 2:
                    message.uiState = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.uiState);
                    break;
                case /* string property */ 3:
                    message.property = reader.string();
                    break;
                case /* repeated TSP.Reference slideNodesToEdit */ 4:
                    message.slideNodesToEdit.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference template_slide_nodes_to_apply */ 5:
                    message.templateSlideNodesToApply.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Size thumbnailSizes */ 6:
                    message.thumbnailSizes.push(TSPMessages_6.Size.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference selectedSlideNodes */ 7:
                    message.selectedSlideNodes.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference restoreSelectedSlideNodes */ 8:
                    message.restoreSelectedSlideNodes.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandGroupArchive super = 1; */
        if (message.super)
            TSKArchives_7.CommandGroupArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference uiState = 2; */
        if (message.uiState)
            TSPMessages_7.Reference.internalBinaryWrite(message.uiState, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string property = 3; */
        if (message.property !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.property);
        /* repeated TSP.Reference slideNodesToEdit = 4; */
        for (let i = 0; i < message.slideNodesToEdit.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.slideNodesToEdit[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference template_slide_nodes_to_apply = 5; */
        for (let i = 0; i < message.templateSlideNodesToApply.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.templateSlideNodesToApply[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Size thumbnailSizes = 6; */
        for (let i = 0; i < message.thumbnailSizes.length; i++)
            TSPMessages_6.Size.internalBinaryWrite(message.thumbnailSizes[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference selectedSlideNodes = 7; */
        for (let i = 0; i < message.selectedSlideNodes.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.selectedSlideNodes[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference restoreSelectedSlideNodes = 8; */
        for (let i = 0; i < message.restoreSelectedSlideNodes.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.restoreSelectedSlideNodes[i], writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.UIStateCommandGroupArchive
 */
exports.UIStateCommandGroupArchive = new UIStateCommandGroupArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSlideInsertDrawablesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandSlideInsertDrawablesArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "slide_id", kind: "message", T: () => TSPMessages_5.UUID },
            { no: 3, name: "drawables", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 18, name: "working_drawables", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 4, name: "args_list", kind: "message", T: () => KNArchives_7.MixedIdOperationArgs },
            { no: 5, name: "update_geometry_to_match_object_placeholder", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "ids_of_drawables_using_object_placeholder_geometry", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.UUID },
            { no: 7, name: "sage_placeholder_tags_list", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "instructional_text_list", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "undo_archive", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 9, name: "is_pasting", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "insert_build_descriptions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 19, name: "working_insert_build_descriptions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 11, name: "remove_build_descriptions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 12, name: "remove_slide_specific_hyperlinks", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "custom_format_keys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.UUID },
            { no: 16, name: "saved_next_untitled_resolver_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 17, name: "geometry_of_object_placeholder_for_comparison_to_restore_link", kind: "message", T: () => TSDArchives_3.GeometryArchive }
        ]);
    }
    create(value) {
        const message = { drawables: [], workingDrawables: [], updateGeometryToMatchObjectPlaceholder: false, idsOfDrawablesUsingObjectPlaceholderGeometry: [], sagePlaceholderTagsList: [], instructionalTextList: [], insertBuildDescriptions: [], workingInsertBuildDescriptions: [], removeBuildDescriptions: [], customFormatKeys: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUID slide_id */ 2:
                    message.slideId = TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options, message.slideId);
                    break;
                case /* repeated TSP.Reference drawables */ 3:
                    message.drawables.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference working_drawables */ 18:
                    message.workingDrawables.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional KN.MixedIdOperationArgs args_list */ 4:
                    message.argsList = KNArchives_7.MixedIdOperationArgs.internalBinaryRead(reader, reader.uint32(), options, message.argsList);
                    break;
                case /* bool update_geometry_to_match_object_placeholder */ 5:
                    message.updateGeometryToMatchObjectPlaceholder = reader.bool();
                    break;
                case /* repeated TSP.UUID ids_of_drawables_using_object_placeholder_geometry */ 6:
                    message.idsOfDrawablesUsingObjectPlaceholderGeometry.push(TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string sage_placeholder_tags_list */ 7:
                    message.sagePlaceholderTagsList.push(reader.string());
                    break;
                case /* repeated string instructional_text_list */ 20:
                    message.instructionalTextList.push(reader.string());
                    break;
                case /* optional TSP.Reference undo_archive */ 8:
                    message.undoArchive = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoArchive);
                    break;
                case /* optional bool is_pasting */ 9:
                    message.isPasting = reader.bool();
                    break;
                case /* repeated TSP.Reference insert_build_descriptions */ 10:
                    message.insertBuildDescriptions.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference working_insert_build_descriptions */ 19:
                    message.workingInsertBuildDescriptions.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference remove_build_descriptions */ 11:
                    message.removeBuildDescriptions.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool remove_slide_specific_hyperlinks */ 12:
                    message.removeSlideSpecificHyperlinks = reader.bool();
                    break;
                case /* repeated TSP.UUID custom_format_keys */ 13:
                    message.customFormatKeys.push(TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 saved_next_untitled_resolver_index */ 16:
                    message.savedNextUntitledResolverIndex = reader.uint32();
                    break;
                case /* optional TSD.GeometryArchive geometry_of_object_placeholder_for_comparison_to_restore_link */ 17:
                    message.geometryOfObjectPlaceholderForComparisonToRestoreLink = TSDArchives_3.GeometryArchive.internalBinaryRead(reader, reader.uint32(), options, message.geometryOfObjectPlaceholderForComparisonToRestoreLink);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID slide_id = 2; */
        if (message.slideId)
            TSPMessages_5.UUID.internalBinaryWrite(message.slideId, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference drawables = 3; */
        for (let i = 0; i < message.drawables.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.drawables[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference working_drawables = 18; */
        for (let i = 0; i < message.workingDrawables.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.workingDrawables[i], writer.tag(18, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional KN.MixedIdOperationArgs args_list = 4; */
        if (message.argsList)
            KNArchives_7.MixedIdOperationArgs.internalBinaryWrite(message.argsList, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool update_geometry_to_match_object_placeholder = 5; */
        if (message.updateGeometryToMatchObjectPlaceholder !== false)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.updateGeometryToMatchObjectPlaceholder);
        /* repeated TSP.UUID ids_of_drawables_using_object_placeholder_geometry = 6; */
        for (let i = 0; i < message.idsOfDrawablesUsingObjectPlaceholderGeometry.length; i++)
            TSPMessages_5.UUID.internalBinaryWrite(message.idsOfDrawablesUsingObjectPlaceholderGeometry[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated string sage_placeholder_tags_list = 7; */
        for (let i = 0; i < message.sagePlaceholderTagsList.length; i++)
            writer.tag(7, runtime_1.WireType.LengthDelimited).string(message.sagePlaceholderTagsList[i]);
        /* repeated string instructional_text_list = 20; */
        for (let i = 0; i < message.instructionalTextList.length; i++)
            writer.tag(20, runtime_1.WireType.LengthDelimited).string(message.instructionalTextList[i]);
        /* optional TSP.Reference undo_archive = 8; */
        if (message.undoArchive)
            TSPMessages_7.Reference.internalBinaryWrite(message.undoArchive, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_pasting = 9; */
        if (message.isPasting !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).bool(message.isPasting);
        /* repeated TSP.Reference insert_build_descriptions = 10; */
        for (let i = 0; i < message.insertBuildDescriptions.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.insertBuildDescriptions[i], writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference working_insert_build_descriptions = 19; */
        for (let i = 0; i < message.workingInsertBuildDescriptions.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.workingInsertBuildDescriptions[i], writer.tag(19, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference remove_build_descriptions = 11; */
        for (let i = 0; i < message.removeBuildDescriptions.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.removeBuildDescriptions[i], writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool remove_slide_specific_hyperlinks = 12; */
        if (message.removeSlideSpecificHyperlinks !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).bool(message.removeSlideSpecificHyperlinks);
        /* repeated TSP.UUID custom_format_keys = 13; */
        for (let i = 0; i < message.customFormatKeys.length; i++)
            TSPMessages_5.UUID.internalBinaryWrite(message.customFormatKeys[i], writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 saved_next_untitled_resolver_index = 16; */
        if (message.savedNextUntitledResolverIndex !== undefined)
            writer.tag(16, runtime_1.WireType.Varint).uint32(message.savedNextUntitledResolverIndex);
        /* optional TSD.GeometryArchive geometry_of_object_placeholder_for_comparison_to_restore_link = 17; */
        if (message.geometryOfObjectPlaceholderForComparisonToRestoreLink)
            TSDArchives_3.GeometryArchive.internalBinaryWrite(message.geometryOfObjectPlaceholderForComparisonToRestoreLink, writer.tag(17, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandSlideInsertDrawablesArchive
 */
exports.CommandSlideInsertDrawablesArchive = new CommandSlideInsertDrawablesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSlideSetPlaceholdersForTagsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandSlideSetPlaceholdersForTagsArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "slide_id", kind: "message", T: () => TSPMessages_5.UUID },
            { no: 3, name: "infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 4, name: "tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "old_infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 5, name: "old_tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { infos: [], tags: [], oldInfos: [], oldTags: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUID slide_id */ 2:
                    message.slideId = TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options, message.slideId);
                    break;
                case /* repeated TSP.Reference infos */ 3:
                    message.infos.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string tags */ 4:
                    message.tags.push(reader.string());
                    break;
                case /* repeated TSP.Reference old_infos */ 6:
                    message.oldInfos.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string old_tags */ 5:
                    message.oldTags.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID slide_id = 2; */
        if (message.slideId)
            TSPMessages_5.UUID.internalBinaryWrite(message.slideId, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference infos = 3; */
        for (let i = 0; i < message.infos.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.infos[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated string tags = 4; */
        for (let i = 0; i < message.tags.length; i++)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.tags[i]);
        /* repeated TSP.Reference old_infos = 6; */
        for (let i = 0; i < message.oldInfos.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.oldInfos[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated string old_tags = 5; */
        for (let i = 0; i < message.oldTags.length; i++)
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.oldTags[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandSlideSetPlaceholdersForTagsArchive
 */
exports.CommandSlideSetPlaceholdersForTagsArchive = new CommandSlideSetPlaceholdersForTagsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandTemplateSlideSetPlaceholderForTagArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandTemplateSlideSetPlaceholderForTagArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandSlideSetPlaceholdersForTagsArchive },
            { no: 2, name: "placeholder_id", kind: "message", T: () => TSPMessages_5.UUID },
            { no: 3, name: "tag", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* KN.CommandSlideSetPlaceholdersForTagsArchive super */ 1:
                    message.super = exports.CommandSlideSetPlaceholdersForTagsArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUID placeholder_id */ 2:
                    message.placeholderId = TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options, message.placeholderId);
                    break;
                case /* optional string tag */ 3:
                    message.tag = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* KN.CommandSlideSetPlaceholdersForTagsArchive super = 1; */
        if (message.super)
            exports.CommandSlideSetPlaceholdersForTagsArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID placeholder_id = 2; */
        if (message.placeholderId)
            TSPMessages_5.UUID.internalBinaryWrite(message.placeholderId, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string tag = 3; */
        if (message.tag !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.tag);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandTemplateSlideSetPlaceholderForTagArchive
 */
exports.CommandTemplateSlideSetPlaceholderForTagArchive = new CommandTemplateSlideSetPlaceholderForTagArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSlidePropagateSetPlaceholderForTagArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandSlidePropagateSetPlaceholderForTagArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandSlideSetPlaceholdersForTagsArchive },
            { no: 2, name: "placeholder_id", kind: "message", T: () => TSPMessages_5.UUID },
            { no: 3, name: "original_id", kind: "message", T: () => TSPMessages_5.UUID }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* KN.CommandSlideSetPlaceholdersForTagsArchive super */ 1:
                    message.super = exports.CommandSlideSetPlaceholdersForTagsArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUID placeholder_id */ 2:
                    message.placeholderId = TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options, message.placeholderId);
                    break;
                case /* TSP.UUID original_id */ 3:
                    message.originalId = TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options, message.originalId);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* KN.CommandSlideSetPlaceholdersForTagsArchive super = 1; */
        if (message.super)
            exports.CommandSlideSetPlaceholdersForTagsArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID placeholder_id = 2; */
        if (message.placeholderId)
            TSPMessages_5.UUID.internalBinaryWrite(message.placeholderId, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID original_id = 3; */
        if (message.originalId)
            TSPMessages_5.UUID.internalBinaryWrite(message.originalId, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandSlidePropagateSetPlaceholderForTagArchive
 */
exports.CommandSlidePropagateSetPlaceholderForTagArchive = new CommandSlidePropagateSetPlaceholderForTagArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSlideRemoveDrawableArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandSlideRemoveDrawableArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "slide_id", kind: "message", T: () => TSPMessages_5.UUID },
            { no: 3, name: "sortedDrawables", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 4, name: "args_list", kind: "message", T: () => KNArchives_7.MixedIdOperationArgs },
            { no: 10, name: "drawable_indexes_for_undo", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "placeholderTags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "instructional_text_list", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "insert_build_descriptions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 7, name: "remove_build_descriptions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 8, name: "drawables_using_object_placeholder_geometry", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 9, name: "inverse_insert_hyperlink_commands", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference }
        ]);
    }
    create(value) {
        const message = { sortedDrawables: [], drawableIndexesForUndo: [], placeholderTags: [], instructionalTextList: [], insertBuildDescriptions: [], removeBuildDescriptions: [], drawablesUsingObjectPlaceholderGeometry: [], inverseInsertHyperlinkCommands: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUID slide_id */ 2:
                    message.slideId = TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options, message.slideId);
                    break;
                case /* repeated TSP.Reference sortedDrawables */ 3:
                    message.sortedDrawables.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* KN.MixedIdOperationArgs args_list */ 4:
                    message.argsList = KNArchives_7.MixedIdOperationArgs.internalBinaryRead(reader, reader.uint32(), options, message.argsList);
                    break;
                case /* repeated uint32 drawable_indexes_for_undo */ 10:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.drawableIndexesForUndo.push(reader.uint32());
                    else
                        message.drawableIndexesForUndo.push(reader.uint32());
                    break;
                case /* repeated string placeholderTags */ 5:
                    message.placeholderTags.push(reader.string());
                    break;
                case /* repeated string instructional_text_list */ 11:
                    message.instructionalTextList.push(reader.string());
                    break;
                case /* repeated TSP.Reference insert_build_descriptions */ 6:
                    message.insertBuildDescriptions.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference remove_build_descriptions */ 7:
                    message.removeBuildDescriptions.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference drawables_using_object_placeholder_geometry */ 8:
                    message.drawablesUsingObjectPlaceholderGeometry.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference inverse_insert_hyperlink_commands */ 9:
                    message.inverseInsertHyperlinkCommands.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID slide_id = 2; */
        if (message.slideId)
            TSPMessages_5.UUID.internalBinaryWrite(message.slideId, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference sortedDrawables = 3; */
        for (let i = 0; i < message.sortedDrawables.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.sortedDrawables[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* KN.MixedIdOperationArgs args_list = 4; */
        if (message.argsList)
            KNArchives_7.MixedIdOperationArgs.internalBinaryWrite(message.argsList, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 drawable_indexes_for_undo = 10; */
        for (let i = 0; i < message.drawableIndexesForUndo.length; i++)
            writer.tag(10, runtime_1.WireType.Varint).uint32(message.drawableIndexesForUndo[i]);
        /* repeated string placeholderTags = 5; */
        for (let i = 0; i < message.placeholderTags.length; i++)
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.placeholderTags[i]);
        /* repeated string instructional_text_list = 11; */
        for (let i = 0; i < message.instructionalTextList.length; i++)
            writer.tag(11, runtime_1.WireType.LengthDelimited).string(message.instructionalTextList[i]);
        /* repeated TSP.Reference insert_build_descriptions = 6; */
        for (let i = 0; i < message.insertBuildDescriptions.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.insertBuildDescriptions[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference remove_build_descriptions = 7; */
        for (let i = 0; i < message.removeBuildDescriptions.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.removeBuildDescriptions[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference drawables_using_object_placeholder_geometry = 8; */
        for (let i = 0; i < message.drawablesUsingObjectPlaceholderGeometry.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.drawablesUsingObjectPlaceholderGeometry[i], writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference inverse_insert_hyperlink_commands = 9; */
        for (let i = 0; i < message.inverseInsertHyperlinkCommands.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.inverseInsertHyperlinkCommands[i], writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandSlideRemoveDrawableArchive
 */
exports.CommandSlideRemoveDrawableArchive = new CommandSlideRemoveDrawableArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSlideMoveDrawableZOrderArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandSlideMoveDrawableZOrderArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 4, name: "old_ordered_infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 6, name: "args_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSKArchives_5.RearrangeIdOperationArgs },
            { no: 7, name: "slide_id", kind: "message", T: () => TSPMessages_5.UUID },
            { no: 8, name: "old_ordered_infos_on_slide_for_undo", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference }
        ]);
    }
    create(value) {
        const message = { oldOrderedInfos: [], argsList: [], oldOrderedInfosOnSlideForUndo: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSP.Reference old_ordered_infos */ 4:
                    message.oldOrderedInfos.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSK.RearrangeIdOperationArgs args_list */ 6:
                    message.argsList.push(TSKArchives_5.RearrangeIdOperationArgs.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* TSP.UUID slide_id */ 7:
                    message.slideId = TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options, message.slideId);
                    break;
                case /* repeated TSP.Reference old_ordered_infos_on_slide_for_undo */ 8:
                    message.oldOrderedInfosOnSlideForUndo.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference old_ordered_infos = 4; */
        for (let i = 0; i < message.oldOrderedInfos.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.oldOrderedInfos[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSK.RearrangeIdOperationArgs args_list = 6; */
        for (let i = 0; i < message.argsList.length; i++)
            TSKArchives_5.RearrangeIdOperationArgs.internalBinaryWrite(message.argsList[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID slide_id = 7; */
        if (message.slideId)
            TSPMessages_5.UUID.internalBinaryWrite(message.slideId, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference old_ordered_infos_on_slide_for_undo = 8; */
        for (let i = 0; i < message.oldOrderedInfosOnSlideForUndo.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.oldOrderedInfosOnSlideForUndo[i], writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandSlideMoveDrawableZOrderArchive
 */
exports.CommandSlideMoveDrawableZOrderArchive = new CommandSlideMoveDrawableZOrderArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSlideNodeSetPropertyArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandSlideNodeSetPropertyArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "slide_node_id_path", kind: "message", T: () => TSPMessages_4.UUIDPath },
            { no: 3, name: "property", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "old_value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { property: "", oldValue: false, value: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUIDPath slide_node_id_path */ 2:
                    message.slideNodeIdPath = TSPMessages_4.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.slideNodeIdPath);
                    break;
                case /* string property */ 3:
                    message.property = reader.string();
                    break;
                case /* bool old_value */ 4:
                    message.oldValue = reader.bool();
                    break;
                case /* bool value */ 5:
                    message.value = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUIDPath slide_node_id_path = 2; */
        if (message.slideNodeIdPath)
            TSPMessages_4.UUIDPath.internalBinaryWrite(message.slideNodeIdPath, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string property = 3; */
        if (message.property !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.property);
        /* bool old_value = 4; */
        if (message.oldValue !== false)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.oldValue);
        /* bool value = 5; */
        if (message.value !== false)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandSlideNodeSetPropertyArchive
 */
exports.CommandSlideNodeSetPropertyArchive = new CommandSlideNodeSetPropertyArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSlideNodeSetViewStatePropertyArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandSlideNodeSetViewStatePropertyArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "slide_node_id_path", kind: "message", T: () => TSPMessages_4.UUIDPath },
            { no: 3, name: "property", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "old_value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { property: "", oldValue: false, value: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUIDPath slide_node_id_path */ 2:
                    message.slideNodeIdPath = TSPMessages_4.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.slideNodeIdPath);
                    break;
                case /* string property */ 3:
                    message.property = reader.string();
                    break;
                case /* bool old_value */ 4:
                    message.oldValue = reader.bool();
                    break;
                case /* bool value */ 5:
                    message.value = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUIDPath slide_node_id_path = 2; */
        if (message.slideNodeIdPath)
            TSPMessages_4.UUIDPath.internalBinaryWrite(message.slideNodeIdPath, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string property = 3; */
        if (message.property !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.property);
        /* bool old_value = 4; */
        if (message.oldValue !== false)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.oldValue);
        /* bool value = 5; */
        if (message.value !== false)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandSlideNodeSetViewStatePropertyArchive
 */
exports.CommandSlideNodeSetViewStatePropertyArchive = new CommandSlideNodeSetViewStatePropertyArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSlideSetBackgroundFillArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandSlideSetBackgroundFillArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "slide_id_path", kind: "message", T: () => TSPMessages_4.UUIDPath },
            { no: 3, name: "old_fill", kind: "message", T: () => TSDArchives_2.FillArchive },
            { no: 4, name: "new_fill", kind: "message", T: () => TSDArchives_2.FillArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUIDPath slide_id_path */ 2:
                    message.slideIdPath = TSPMessages_4.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.slideIdPath);
                    break;
                case /* optional TSD.FillArchive old_fill */ 3:
                    message.oldFill = TSDArchives_2.FillArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldFill);
                    break;
                case /* TSD.FillArchive new_fill */ 4:
                    message.newFill = TSDArchives_2.FillArchive.internalBinaryRead(reader, reader.uint32(), options, message.newFill);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUIDPath slide_id_path = 2; */
        if (message.slideIdPath)
            TSPMessages_4.UUIDPath.internalBinaryWrite(message.slideIdPath, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.FillArchive old_fill = 3; */
        if (message.oldFill)
            TSDArchives_2.FillArchive.internalBinaryWrite(message.oldFill, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSD.FillArchive new_fill = 4; */
        if (message.newFill)
            TSDArchives_2.FillArchive.internalBinaryWrite(message.newFill, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandSlideSetBackgroundFillArchive
 */
exports.CommandSlideSetBackgroundFillArchive = new CommandSlideSetBackgroundFillArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSlideSetStyleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandSlideSetStyleArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "slide_id_path", kind: "message", T: () => TSPMessages_4.UUIDPath },
            { no: 3, name: "slide_style", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 4, name: "old_slide_style", kind: "message", T: () => TSPMessages_7.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUIDPath slide_id_path */ 2:
                    message.slideIdPath = TSPMessages_4.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.slideIdPath);
                    break;
                case /* TSP.Reference slide_style */ 3:
                    message.slideStyle = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.slideStyle);
                    break;
                case /* optional TSP.Reference old_slide_style */ 4:
                    message.oldSlideStyle = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.oldSlideStyle);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUIDPath slide_id_path = 2; */
        if (message.slideIdPath)
            TSPMessages_4.UUIDPath.internalBinaryWrite(message.slideIdPath, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference slide_style = 3; */
        if (message.slideStyle)
            TSPMessages_7.Reference.internalBinaryWrite(message.slideStyle, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference old_slide_style = 4; */
        if (message.oldSlideStyle)
            TSPMessages_7.Reference.internalBinaryWrite(message.oldSlideStyle, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandSlideSetStyleArchive
 */
exports.CommandSlideSetStyleArchive = new CommandSlideSetStyleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandShowMarkOutOfSyncRecordingArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandShowMarkOutOfSyncRecordingArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "show", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 3, name: "old_recording", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 4, name: "old_is_recording_out_of_sync", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "new_is_recording_out_of_sync", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "old_modification_date", kind: "message", T: () => TSPMessages_3.Date },
            { no: 7, name: "new_modification_date", kind: "message", T: () => TSPMessages_3.Date }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Reference show */ 2:
                    message.show = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.show);
                    break;
                case /* optional TSP.Reference old_recording */ 3:
                    message.oldRecording = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.oldRecording);
                    break;
                case /* optional bool old_is_recording_out_of_sync */ 4:
                    message.oldIsRecordingOutOfSync = reader.bool();
                    break;
                case /* optional bool new_is_recording_out_of_sync */ 5:
                    message.newIsRecordingOutOfSync = reader.bool();
                    break;
                case /* optional TSP.Date old_modification_date */ 6:
                    message.oldModificationDate = TSPMessages_3.Date.internalBinaryRead(reader, reader.uint32(), options, message.oldModificationDate);
                    break;
                case /* optional TSP.Date new_modification_date */ 7:
                    message.newModificationDate = TSPMessages_3.Date.internalBinaryRead(reader, reader.uint32(), options, message.newModificationDate);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference show = 2; */
        if (message.show)
            TSPMessages_7.Reference.internalBinaryWrite(message.show, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference old_recording = 3; */
        if (message.oldRecording)
            TSPMessages_7.Reference.internalBinaryWrite(message.oldRecording, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool old_is_recording_out_of_sync = 4; */
        if (message.oldIsRecordingOutOfSync !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.oldIsRecordingOutOfSync);
        /* optional bool new_is_recording_out_of_sync = 5; */
        if (message.newIsRecordingOutOfSync !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.newIsRecordingOutOfSync);
        /* optional TSP.Date old_modification_date = 6; */
        if (message.oldModificationDate)
            TSPMessages_3.Date.internalBinaryWrite(message.oldModificationDate, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Date new_modification_date = 7; */
        if (message.newModificationDate)
            TSPMessages_3.Date.internalBinaryWrite(message.newModificationDate, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandShowMarkOutOfSyncRecordingArchive
 */
exports.CommandShowMarkOutOfSyncRecordingArchive = new CommandShowMarkOutOfSyncRecordingArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandShowMarkOutOfSyncRecordingIfNeededArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandShowMarkOutOfSyncRecordingIfNeededArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "out_of_sync_token", kind: "message", T: () => TSPMessages_5.UUID }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.UUID out_of_sync_token */ 2:
                    message.outOfSyncToken = TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options, message.outOfSyncToken);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID out_of_sync_token = 2; */
        if (message.outOfSyncToken)
            TSPMessages_5.UUID.internalBinaryWrite(message.outOfSyncToken, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandShowMarkOutOfSyncRecordingIfNeededArchive
 */
exports.CommandShowMarkOutOfSyncRecordingIfNeededArchive = new CommandShowMarkOutOfSyncRecordingIfNeededArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandShowRemoveRecordingArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandShowRemoveRecordingArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "show", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 3, name: "old_recording", kind: "message", T: () => TSPMessages_7.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Reference show */ 2:
                    message.show = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.show);
                    break;
                case /* optional TSP.Reference old_recording */ 3:
                    message.oldRecording = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.oldRecording);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference show = 2; */
        if (message.show)
            TSPMessages_7.Reference.internalBinaryWrite(message.show, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference old_recording = 3; */
        if (message.oldRecording)
            TSPMessages_7.Reference.internalBinaryWrite(message.oldRecording, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandShowRemoveRecordingArchive
 */
exports.CommandShowRemoveRecordingArchive = new CommandShowRemoveRecordingArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandShowReplaceRecordingArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandShowReplaceRecordingArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "show", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 3, name: "replacement_recording", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 5, name: "old_recording", kind: "message", T: () => TSPMessages_7.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Reference show */ 2:
                    message.show = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.show);
                    break;
                case /* TSP.Reference replacement_recording */ 3:
                    message.replacementRecording = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.replacementRecording);
                    break;
                case /* optional TSP.Reference old_recording */ 5:
                    message.oldRecording = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.oldRecording);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference show = 2; */
        if (message.show)
            TSPMessages_7.Reference.internalBinaryWrite(message.show, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference replacement_recording = 3; */
        if (message.replacementRecording)
            TSPMessages_7.Reference.internalBinaryWrite(message.replacementRecording, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference old_recording = 5; */
        if (message.oldRecording)
            TSPMessages_7.Reference.internalBinaryWrite(message.oldRecording, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandShowReplaceRecordingArchive
 */
exports.CommandShowReplaceRecordingArchive = new CommandShowReplaceRecordingArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandShowSetValueArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandShowSetValueArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "show", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 3, name: "property", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "old_value", kind: "message", T: () => exports.CommandShowSetValueArchive_PropertyValue },
            { no: 5, name: "new_value", kind: "message", T: () => exports.CommandShowSetValueArchive_PropertyValue }
        ]);
    }
    create(value) {
        const message = { property: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Reference show */ 2:
                    message.show = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.show);
                    break;
                case /* string property */ 3:
                    message.property = reader.string();
                    break;
                case /* KN.CommandShowSetValueArchive.PropertyValue old_value */ 4:
                    message.oldValue = exports.CommandShowSetValueArchive_PropertyValue.internalBinaryRead(reader, reader.uint32(), options, message.oldValue);
                    break;
                case /* KN.CommandShowSetValueArchive.PropertyValue new_value */ 5:
                    message.newValue = exports.CommandShowSetValueArchive_PropertyValue.internalBinaryRead(reader, reader.uint32(), options, message.newValue);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference show = 2; */
        if (message.show)
            TSPMessages_7.Reference.internalBinaryWrite(message.show, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string property = 3; */
        if (message.property !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.property);
        /* KN.CommandShowSetValueArchive.PropertyValue old_value = 4; */
        if (message.oldValue)
            exports.CommandShowSetValueArchive_PropertyValue.internalBinaryWrite(message.oldValue, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* KN.CommandShowSetValueArchive.PropertyValue new_value = 5; */
        if (message.newValue)
            exports.CommandShowSetValueArchive_PropertyValue.internalBinaryWrite(message.newValue, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandShowSetValueArchive
 */
exports.CommandShowSetValueArchive = new CommandShowSetValueArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandShowSetValueArchive_PropertyValue$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandShowSetValueArchive.PropertyValue", [
            { no: 1, name: "bool_value", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "double_value", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "show_mode_value", kind: "enum", opt: true, T: () => ["KN.ShowArchive.KNShowMode", KNArchives_6.ShowArchive_KNShowMode] },
            { no: 4, name: "size_value", kind: "message", T: () => TSPMessages_6.Size }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool bool_value */ 1:
                    message.boolValue = reader.bool();
                    break;
                case /* optional double double_value */ 2:
                    message.doubleValue = reader.double();
                    break;
                case /* optional KN.ShowArchive.KNShowMode show_mode_value */ 3:
                    message.showModeValue = reader.int32();
                    break;
                case /* optional TSP.Size size_value */ 4:
                    message.sizeValue = TSPMessages_6.Size.internalBinaryRead(reader, reader.uint32(), options, message.sizeValue);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional bool bool_value = 1; */
        if (message.boolValue !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.boolValue);
        /* optional double double_value = 2; */
        if (message.doubleValue !== undefined)
            writer.tag(2, runtime_1.WireType.Bit64).double(message.doubleValue);
        /* optional KN.ShowArchive.KNShowMode show_mode_value = 3; */
        if (message.showModeValue !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.showModeValue);
        /* optional TSP.Size size_value = 4; */
        if (message.sizeValue)
            TSPMessages_6.Size.internalBinaryWrite(message.sizeValue, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandShowSetValueArchive.PropertyValue
 */
exports.CommandShowSetValueArchive_PropertyValue = new CommandShowSetValueArchive_PropertyValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandShowInsertSlideArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandShowInsertSlideArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "slide_nodes_being_inserted", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 14, name: "working_slide_nodes_being_inserted", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 3, name: "inserted_args_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSKArchives_4.AddIdOperationArgs },
            { no: 4, name: "ids_of_slide_nodes_with_depth_changes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.UUID },
            { no: 5, name: "depths_of_slide_nodes_with_depth_changes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "old_depths_of_slide_nodes_with_depth_changes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "slide_nodes_for_depth_fix_up", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 8, name: "depths_of_slide_nodes_for_depth_fix_up", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "old_depths_of_slide_nodes_for_depth_fix_up", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "kind", kind: "enum", opt: true, T: () => ["KN.CommandShowInsertSlideArchive.Kind", CommandShowInsertSlideArchive_Kind] },
            { no: 11, name: "template_slide_nodes_being_inserted", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 12, name: "custom_format_keys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.UUID },
            { no: 13, name: "collapsed_state_of_slide_nodes_being_inserted", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "undo_archive", kind: "message", T: () => TSPMessages_7.Reference }
        ]);
    }
    create(value) {
        const message = { slideNodesBeingInserted: [], workingSlideNodesBeingInserted: [], insertedArgsList: [], idsOfSlideNodesWithDepthChanges: [], depthsOfSlideNodesWithDepthChanges: [], oldDepthsOfSlideNodesWithDepthChanges: [], slideNodesForDepthFixUp: [], depthsOfSlideNodesForDepthFixUp: [], oldDepthsOfSlideNodesForDepthFixUp: [], templateSlideNodesBeingInserted: [], customFormatKeys: [], collapsedStateOfSlideNodesBeingInserted: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSP.Reference slide_nodes_being_inserted */ 2:
                    message.slideNodesBeingInserted.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference working_slide_nodes_being_inserted */ 14:
                    message.workingSlideNodesBeingInserted.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSK.AddIdOperationArgs inserted_args_list */ 3:
                    message.insertedArgsList.push(TSKArchives_4.AddIdOperationArgs.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID ids_of_slide_nodes_with_depth_changes */ 4:
                    message.idsOfSlideNodesWithDepthChanges.push(TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 depths_of_slide_nodes_with_depth_changes */ 5:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.depthsOfSlideNodesWithDepthChanges.push(reader.uint32());
                    else
                        message.depthsOfSlideNodesWithDepthChanges.push(reader.uint32());
                    break;
                case /* repeated uint32 old_depths_of_slide_nodes_with_depth_changes */ 6:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.oldDepthsOfSlideNodesWithDepthChanges.push(reader.uint32());
                    else
                        message.oldDepthsOfSlideNodesWithDepthChanges.push(reader.uint32());
                    break;
                case /* repeated TSP.Reference slide_nodes_for_depth_fix_up */ 7:
                    message.slideNodesForDepthFixUp.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 depths_of_slide_nodes_for_depth_fix_up */ 8:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.depthsOfSlideNodesForDepthFixUp.push(reader.uint32());
                    else
                        message.depthsOfSlideNodesForDepthFixUp.push(reader.uint32());
                    break;
                case /* repeated uint32 old_depths_of_slide_nodes_for_depth_fix_up */ 9:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.oldDepthsOfSlideNodesForDepthFixUp.push(reader.uint32());
                    else
                        message.oldDepthsOfSlideNodesForDepthFixUp.push(reader.uint32());
                    break;
                case /* optional KN.CommandShowInsertSlideArchive.Kind kind */ 10:
                    message.kind = reader.int32();
                    break;
                case /* repeated TSP.Reference template_slide_nodes_being_inserted */ 11:
                    message.templateSlideNodesBeingInserted.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID custom_format_keys */ 12:
                    message.customFormatKeys.push(TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated bool collapsed_state_of_slide_nodes_being_inserted */ 13:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.collapsedStateOfSlideNodesBeingInserted.push(reader.bool());
                    else
                        message.collapsedStateOfSlideNodesBeingInserted.push(reader.bool());
                    break;
                case /* optional TSP.Reference undo_archive */ 15:
                    message.undoArchive = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoArchive);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference slide_nodes_being_inserted = 2; */
        for (let i = 0; i < message.slideNodesBeingInserted.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.slideNodesBeingInserted[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference working_slide_nodes_being_inserted = 14; */
        for (let i = 0; i < message.workingSlideNodesBeingInserted.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.workingSlideNodesBeingInserted[i], writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSK.AddIdOperationArgs inserted_args_list = 3; */
        for (let i = 0; i < message.insertedArgsList.length; i++)
            TSKArchives_4.AddIdOperationArgs.internalBinaryWrite(message.insertedArgsList[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID ids_of_slide_nodes_with_depth_changes = 4; */
        for (let i = 0; i < message.idsOfSlideNodesWithDepthChanges.length; i++)
            TSPMessages_5.UUID.internalBinaryWrite(message.idsOfSlideNodesWithDepthChanges[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 depths_of_slide_nodes_with_depth_changes = 5; */
        for (let i = 0; i < message.depthsOfSlideNodesWithDepthChanges.length; i++)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.depthsOfSlideNodesWithDepthChanges[i]);
        /* repeated uint32 old_depths_of_slide_nodes_with_depth_changes = 6; */
        for (let i = 0; i < message.oldDepthsOfSlideNodesWithDepthChanges.length; i++)
            writer.tag(6, runtime_1.WireType.Varint).uint32(message.oldDepthsOfSlideNodesWithDepthChanges[i]);
        /* repeated TSP.Reference slide_nodes_for_depth_fix_up = 7; */
        for (let i = 0; i < message.slideNodesForDepthFixUp.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.slideNodesForDepthFixUp[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 depths_of_slide_nodes_for_depth_fix_up = 8; */
        for (let i = 0; i < message.depthsOfSlideNodesForDepthFixUp.length; i++)
            writer.tag(8, runtime_1.WireType.Varint).uint32(message.depthsOfSlideNodesForDepthFixUp[i]);
        /* repeated uint32 old_depths_of_slide_nodes_for_depth_fix_up = 9; */
        for (let i = 0; i < message.oldDepthsOfSlideNodesForDepthFixUp.length; i++)
            writer.tag(9, runtime_1.WireType.Varint).uint32(message.oldDepthsOfSlideNodesForDepthFixUp[i]);
        /* optional KN.CommandShowInsertSlideArchive.Kind kind = 10; */
        if (message.kind !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).int32(message.kind);
        /* repeated TSP.Reference template_slide_nodes_being_inserted = 11; */
        for (let i = 0; i < message.templateSlideNodesBeingInserted.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.templateSlideNodesBeingInserted[i], writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID custom_format_keys = 12; */
        for (let i = 0; i < message.customFormatKeys.length; i++)
            TSPMessages_5.UUID.internalBinaryWrite(message.customFormatKeys[i], writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated bool collapsed_state_of_slide_nodes_being_inserted = 13; */
        for (let i = 0; i < message.collapsedStateOfSlideNodesBeingInserted.length; i++)
            writer.tag(13, runtime_1.WireType.Varint).bool(message.collapsedStateOfSlideNodesBeingInserted[i]);
        /* optional TSP.Reference undo_archive = 15; */
        if (message.undoArchive)
            TSPMessages_7.Reference.internalBinaryWrite(message.undoArchive, writer.tag(15, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandShowInsertSlideArchive
 */
exports.CommandShowInsertSlideArchive = new CommandShowInsertSlideArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandShowMoveSlideArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandShowMoveSlideArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "slide_nodes_being_moved_linearly", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 3, name: "rearranged_args_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSKArchives_5.RearrangeIdOperationArgs },
            { no: 4, name: "ids_of_slide_nodes_with_depth_changes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.UUID },
            { no: 5, name: "depths_of_slide_nodes_with_depth_changes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "old_depths_of_slide_nodes_with_depth_changes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "slide_nodes_for_depth_fix_up", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 8, name: "depths_of_slide_nodes_for_depth_fix_up", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "old_depths_of_slide_nodes_for_depth_fix_up", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { slideNodesBeingMovedLinearly: [], rearrangedArgsList: [], idsOfSlideNodesWithDepthChanges: [], depthsOfSlideNodesWithDepthChanges: [], oldDepthsOfSlideNodesWithDepthChanges: [], slideNodesForDepthFixUp: [], depthsOfSlideNodesForDepthFixUp: [], oldDepthsOfSlideNodesForDepthFixUp: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSP.Reference slide_nodes_being_moved_linearly */ 2:
                    message.slideNodesBeingMovedLinearly.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSK.RearrangeIdOperationArgs rearranged_args_list */ 3:
                    message.rearrangedArgsList.push(TSKArchives_5.RearrangeIdOperationArgs.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID ids_of_slide_nodes_with_depth_changes */ 4:
                    message.idsOfSlideNodesWithDepthChanges.push(TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 depths_of_slide_nodes_with_depth_changes */ 5:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.depthsOfSlideNodesWithDepthChanges.push(reader.uint32());
                    else
                        message.depthsOfSlideNodesWithDepthChanges.push(reader.uint32());
                    break;
                case /* repeated uint32 old_depths_of_slide_nodes_with_depth_changes */ 6:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.oldDepthsOfSlideNodesWithDepthChanges.push(reader.uint32());
                    else
                        message.oldDepthsOfSlideNodesWithDepthChanges.push(reader.uint32());
                    break;
                case /* repeated TSP.Reference slide_nodes_for_depth_fix_up */ 7:
                    message.slideNodesForDepthFixUp.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 depths_of_slide_nodes_for_depth_fix_up */ 8:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.depthsOfSlideNodesForDepthFixUp.push(reader.uint32());
                    else
                        message.depthsOfSlideNodesForDepthFixUp.push(reader.uint32());
                    break;
                case /* repeated uint32 old_depths_of_slide_nodes_for_depth_fix_up */ 9:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.oldDepthsOfSlideNodesForDepthFixUp.push(reader.uint32());
                    else
                        message.oldDepthsOfSlideNodesForDepthFixUp.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference slide_nodes_being_moved_linearly = 2; */
        for (let i = 0; i < message.slideNodesBeingMovedLinearly.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.slideNodesBeingMovedLinearly[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSK.RearrangeIdOperationArgs rearranged_args_list = 3; */
        for (let i = 0; i < message.rearrangedArgsList.length; i++)
            TSKArchives_5.RearrangeIdOperationArgs.internalBinaryWrite(message.rearrangedArgsList[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID ids_of_slide_nodes_with_depth_changes = 4; */
        for (let i = 0; i < message.idsOfSlideNodesWithDepthChanges.length; i++)
            TSPMessages_5.UUID.internalBinaryWrite(message.idsOfSlideNodesWithDepthChanges[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 depths_of_slide_nodes_with_depth_changes = 5; */
        for (let i = 0; i < message.depthsOfSlideNodesWithDepthChanges.length; i++)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.depthsOfSlideNodesWithDepthChanges[i]);
        /* repeated uint32 old_depths_of_slide_nodes_with_depth_changes = 6; */
        for (let i = 0; i < message.oldDepthsOfSlideNodesWithDepthChanges.length; i++)
            writer.tag(6, runtime_1.WireType.Varint).uint32(message.oldDepthsOfSlideNodesWithDepthChanges[i]);
        /* repeated TSP.Reference slide_nodes_for_depth_fix_up = 7; */
        for (let i = 0; i < message.slideNodesForDepthFixUp.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.slideNodesForDepthFixUp[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 depths_of_slide_nodes_for_depth_fix_up = 8; */
        for (let i = 0; i < message.depthsOfSlideNodesForDepthFixUp.length; i++)
            writer.tag(8, runtime_1.WireType.Varint).uint32(message.depthsOfSlideNodesForDepthFixUp[i]);
        /* repeated uint32 old_depths_of_slide_nodes_for_depth_fix_up = 9; */
        for (let i = 0; i < message.oldDepthsOfSlideNodesForDepthFixUp.length; i++)
            writer.tag(9, runtime_1.WireType.Varint).uint32(message.oldDepthsOfSlideNodesForDepthFixUp[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandShowMoveSlideArchive
 */
exports.CommandShowMoveSlideArchive = new CommandShowMoveSlideArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandShowRemoveSlideArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandShowRemoveSlideArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "slide_nodes_being_removed", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 3, name: "removed_args_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSKArchives_3.RemoveIdOperationArgs },
            { no: 4, name: "ids_of_slide_nodes_with_depth_changes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.UUID },
            { no: 5, name: "depths_of_slide_nodes_with_depth_changes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "old_depths_of_slide_nodes_with_depth_changes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "slide_nodes_for_depth_fix_up", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 8, name: "depths_of_slide_nodes_for_depth_fix_up", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "old_depths_of_slide_nodes_for_depth_fix_up", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "collapsed_state_of_slide_nodes_being_removed", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { slideNodesBeingRemoved: [], removedArgsList: [], idsOfSlideNodesWithDepthChanges: [], depthsOfSlideNodesWithDepthChanges: [], oldDepthsOfSlideNodesWithDepthChanges: [], slideNodesForDepthFixUp: [], depthsOfSlideNodesForDepthFixUp: [], oldDepthsOfSlideNodesForDepthFixUp: [], collapsedStateOfSlideNodesBeingRemoved: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSP.Reference slide_nodes_being_removed */ 2:
                    message.slideNodesBeingRemoved.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSK.RemoveIdOperationArgs removed_args_list */ 3:
                    message.removedArgsList.push(TSKArchives_3.RemoveIdOperationArgs.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID ids_of_slide_nodes_with_depth_changes */ 4:
                    message.idsOfSlideNodesWithDepthChanges.push(TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 depths_of_slide_nodes_with_depth_changes */ 5:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.depthsOfSlideNodesWithDepthChanges.push(reader.uint32());
                    else
                        message.depthsOfSlideNodesWithDepthChanges.push(reader.uint32());
                    break;
                case /* repeated uint32 old_depths_of_slide_nodes_with_depth_changes */ 6:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.oldDepthsOfSlideNodesWithDepthChanges.push(reader.uint32());
                    else
                        message.oldDepthsOfSlideNodesWithDepthChanges.push(reader.uint32());
                    break;
                case /* repeated TSP.Reference slide_nodes_for_depth_fix_up */ 7:
                    message.slideNodesForDepthFixUp.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 depths_of_slide_nodes_for_depth_fix_up */ 8:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.depthsOfSlideNodesForDepthFixUp.push(reader.uint32());
                    else
                        message.depthsOfSlideNodesForDepthFixUp.push(reader.uint32());
                    break;
                case /* repeated uint32 old_depths_of_slide_nodes_for_depth_fix_up */ 9:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.oldDepthsOfSlideNodesForDepthFixUp.push(reader.uint32());
                    else
                        message.oldDepthsOfSlideNodesForDepthFixUp.push(reader.uint32());
                    break;
                case /* repeated bool collapsed_state_of_slide_nodes_being_removed */ 11:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.collapsedStateOfSlideNodesBeingRemoved.push(reader.bool());
                    else
                        message.collapsedStateOfSlideNodesBeingRemoved.push(reader.bool());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference slide_nodes_being_removed = 2; */
        for (let i = 0; i < message.slideNodesBeingRemoved.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.slideNodesBeingRemoved[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSK.RemoveIdOperationArgs removed_args_list = 3; */
        for (let i = 0; i < message.removedArgsList.length; i++)
            TSKArchives_3.RemoveIdOperationArgs.internalBinaryWrite(message.removedArgsList[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID ids_of_slide_nodes_with_depth_changes = 4; */
        for (let i = 0; i < message.idsOfSlideNodesWithDepthChanges.length; i++)
            TSPMessages_5.UUID.internalBinaryWrite(message.idsOfSlideNodesWithDepthChanges[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 depths_of_slide_nodes_with_depth_changes = 5; */
        for (let i = 0; i < message.depthsOfSlideNodesWithDepthChanges.length; i++)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.depthsOfSlideNodesWithDepthChanges[i]);
        /* repeated uint32 old_depths_of_slide_nodes_with_depth_changes = 6; */
        for (let i = 0; i < message.oldDepthsOfSlideNodesWithDepthChanges.length; i++)
            writer.tag(6, runtime_1.WireType.Varint).uint32(message.oldDepthsOfSlideNodesWithDepthChanges[i]);
        /* repeated TSP.Reference slide_nodes_for_depth_fix_up = 7; */
        for (let i = 0; i < message.slideNodesForDepthFixUp.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.slideNodesForDepthFixUp[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 depths_of_slide_nodes_for_depth_fix_up = 8; */
        for (let i = 0; i < message.depthsOfSlideNodesForDepthFixUp.length; i++)
            writer.tag(8, runtime_1.WireType.Varint).uint32(message.depthsOfSlideNodesForDepthFixUp[i]);
        /* repeated uint32 old_depths_of_slide_nodes_for_depth_fix_up = 9; */
        for (let i = 0; i < message.oldDepthsOfSlideNodesForDepthFixUp.length; i++)
            writer.tag(9, runtime_1.WireType.Varint).uint32(message.oldDepthsOfSlideNodesForDepthFixUp[i]);
        /* repeated bool collapsed_state_of_slide_nodes_being_removed = 11; */
        for (let i = 0; i < message.collapsedStateOfSlideNodesBeingRemoved.length; i++)
            writer.tag(11, runtime_1.WireType.Varint).bool(message.collapsedStateOfSlideNodesBeingRemoved[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandShowRemoveSlideArchive
 */
exports.CommandShowRemoveSlideArchive = new CommandShowRemoveSlideArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandShowChangeThemeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandShowChangeThemeArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "show", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 3, name: "theme", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 4, name: "old_theme", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 5, name: "template_identifier", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "old_template_identifier", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "identifier_to_style_map", kind: "message", T: () => exports.CommandShowChangeThemeArchive_IdentifierToStyleMap },
            { no: 8, name: "old_identifier_to_style_map", kind: "message", T: () => exports.CommandShowChangeThemeArchive_IdentifierToStyleMap }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Reference show */ 2:
                    message.show = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.show);
                    break;
                case /* TSP.Reference theme */ 3:
                    message.theme = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.theme);
                    break;
                case /* optional TSP.Reference old_theme */ 4:
                    message.oldTheme = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.oldTheme);
                    break;
                case /* optional string template_identifier */ 5:
                    message.templateIdentifier = reader.string();
                    break;
                case /* optional string old_template_identifier */ 6:
                    message.oldTemplateIdentifier = reader.string();
                    break;
                case /* optional KN.CommandShowChangeThemeArchive.IdentifierToStyleMap identifier_to_style_map */ 7:
                    message.identifierToStyleMap = exports.CommandShowChangeThemeArchive_IdentifierToStyleMap.internalBinaryRead(reader, reader.uint32(), options, message.identifierToStyleMap);
                    break;
                case /* optional KN.CommandShowChangeThemeArchive.IdentifierToStyleMap old_identifier_to_style_map */ 8:
                    message.oldIdentifierToStyleMap = exports.CommandShowChangeThemeArchive_IdentifierToStyleMap.internalBinaryRead(reader, reader.uint32(), options, message.oldIdentifierToStyleMap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference show = 2; */
        if (message.show)
            TSPMessages_7.Reference.internalBinaryWrite(message.show, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference theme = 3; */
        if (message.theme)
            TSPMessages_7.Reference.internalBinaryWrite(message.theme, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference old_theme = 4; */
        if (message.oldTheme)
            TSPMessages_7.Reference.internalBinaryWrite(message.oldTheme, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string template_identifier = 5; */
        if (message.templateIdentifier !== undefined)
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.templateIdentifier);
        /* optional string old_template_identifier = 6; */
        if (message.oldTemplateIdentifier !== undefined)
            writer.tag(6, runtime_1.WireType.LengthDelimited).string(message.oldTemplateIdentifier);
        /* optional KN.CommandShowChangeThemeArchive.IdentifierToStyleMap identifier_to_style_map = 7; */
        if (message.identifierToStyleMap)
            exports.CommandShowChangeThemeArchive_IdentifierToStyleMap.internalBinaryWrite(message.identifierToStyleMap, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional KN.CommandShowChangeThemeArchive.IdentifierToStyleMap old_identifier_to_style_map = 8; */
        if (message.oldIdentifierToStyleMap)
            exports.CommandShowChangeThemeArchive_IdentifierToStyleMap.internalBinaryWrite(message.oldIdentifierToStyleMap, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandShowChangeThemeArchive
 */
exports.CommandShowChangeThemeArchive = new CommandShowChangeThemeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandShowChangeThemeArchive_IdentifierToStyleMap$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandShowChangeThemeArchive.IdentifierToStyleMap", [
            { no: 1, name: "styles", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSSArchives_1.StylesheetArchive_IdentifiedStyleEntry }
        ]);
    }
    create(value) {
        const message = { styles: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSS.StylesheetArchive.IdentifiedStyleEntry styles */ 1:
                    message.styles.push(TSSArchives_1.StylesheetArchive_IdentifiedStyleEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSS.StylesheetArchive.IdentifiedStyleEntry styles = 1; */
        for (let i = 0; i < message.styles.length; i++)
            TSSArchives_1.StylesheetArchive_IdentifiedStyleEntry.internalBinaryWrite(message.styles[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandShowChangeThemeArchive.IdentifierToStyleMap
 */
exports.CommandShowChangeThemeArchive_IdentifierToStyleMap = new CommandShowChangeThemeArchive_IdentifierToStyleMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandShowChangeSlideSizeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandShowChangeSlideSizeArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "size", kind: "message", T: () => TSPMessages_6.Size }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Size size */ 2:
                    message.size = TSPMessages_6.Size.internalBinaryRead(reader, reader.uint32(), options, message.size);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Size size = 2; */
        if (message.size)
            TSPMessages_6.Size.internalBinaryWrite(message.size, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandShowChangeSlideSizeArchive
 */
exports.CommandShowChangeSlideSizeArchive = new CommandShowChangeSlideSizeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetThemeCustomEffectTimingCurveArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandSetThemeCustomEffectTimingCurveArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "path_source", kind: "message", T: () => TSDArchives_1.PathSourceArchive },
            { no: 4, name: "old_path_source", kind: "message", T: () => TSDArchives_1.PathSourceArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional TSD.PathSourceArchive path_source */ 3:
                    message.pathSource = TSDArchives_1.PathSourceArchive.internalBinaryRead(reader, reader.uint32(), options, message.pathSource);
                    break;
                case /* optional TSD.PathSourceArchive old_path_source */ 4:
                    message.oldPathSource = TSDArchives_1.PathSourceArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldPathSource);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.name);
        /* optional TSD.PathSourceArchive path_source = 3; */
        if (message.pathSource)
            TSDArchives_1.PathSourceArchive.internalBinaryWrite(message.pathSource, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.PathSourceArchive old_path_source = 4; */
        if (message.oldPathSource)
            TSDArchives_1.PathSourceArchive.internalBinaryWrite(message.oldPathSource, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandSetThemeCustomEffectTimingCurveArchive
 */
exports.CommandSetThemeCustomEffectTimingCurveArchive = new CommandSetThemeCustomEffectTimingCurveArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandMoveTemplatesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandMoveTemplatesArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSDCommandArchives_8.ContainerReorderChildrenCommandArchive },
            { no: 3, name: "template_slides", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 4, name: "previous_indexes_keys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 5, name: "previous_indexes_values", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "final_template_arrangement", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference }
        ]);
    }
    create(value) {
        const message = { templateSlides: [], previousIndexesKeys: [], previousIndexesValues: [], finalTemplateArrangement: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.ContainerReorderChildrenCommandArchive super */ 1:
                    message.super = TSDCommandArchives_8.ContainerReorderChildrenCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSP.Reference template_slides */ 3:
                    message.templateSlides.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference previous_indexes_keys */ 4:
                    message.previousIndexesKeys.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 previous_indexes_values */ 5:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.previousIndexesValues.push(reader.uint32());
                    else
                        message.previousIndexesValues.push(reader.uint32());
                    break;
                case /* repeated TSP.Reference final_template_arrangement */ 6:
                    message.finalTemplateArrangement.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.ContainerReorderChildrenCommandArchive super = 1; */
        if (message.super)
            TSDCommandArchives_8.ContainerReorderChildrenCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference template_slides = 3; */
        for (let i = 0; i < message.templateSlides.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.templateSlides[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference previous_indexes_keys = 4; */
        for (let i = 0; i < message.previousIndexesKeys.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.previousIndexesKeys[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 previous_indexes_values = 5; */
        for (let i = 0; i < message.previousIndexesValues.length; i++)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.previousIndexesValues[i]);
        /* repeated TSP.Reference final_template_arrangement = 6; */
        for (let i = 0; i < message.finalTemplateArrangement.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.finalTemplateArrangement[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandMoveTemplatesArchive
 */
exports.CommandMoveTemplatesArchive = new CommandMoveTemplatesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandInsertTemplateArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandInsertTemplateArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 7, name: "undo_template_change_commands", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 8, name: "set_inserted_slide_as_default_template_slide", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "undo_replacement_template_slide_node", kind: "message", T: () => TSPMessages_7.Reference }
        ]);
    }
    create(value) {
        const message = { undoTemplateChangeCommands: [], setInsertedSlideAsDefaultTemplateSlide: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSP.Reference undo_template_change_commands */ 7:
                    message.undoTemplateChangeCommands.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool set_inserted_slide_as_default_template_slide */ 8:
                    message.setInsertedSlideAsDefaultTemplateSlide = reader.bool();
                    break;
                case /* optional TSP.Reference undo_replacement_template_slide_node */ 9:
                    message.undoReplacementTemplateSlideNode = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoReplacementTemplateSlideNode);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference undo_template_change_commands = 7; */
        for (let i = 0; i < message.undoTemplateChangeCommands.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.undoTemplateChangeCommands[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool set_inserted_slide_as_default_template_slide = 8; */
        if (message.setInsertedSlideAsDefaultTemplateSlide !== false)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.setInsertedSlideAsDefaultTemplateSlide);
        /* optional TSP.Reference undo_replacement_template_slide_node = 9; */
        if (message.undoReplacementTemplateSlideNode)
            TSPMessages_7.Reference.internalBinaryWrite(message.undoReplacementTemplateSlideNode, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandInsertTemplateArchive
 */
exports.CommandInsertTemplateArchive = new CommandInsertTemplateArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandPrimitiveInsertTemplateArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandPrimitiveInsertTemplateArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSDCommandArchives_7.ContainerInsertChildrenCommandArchive },
            { no: 2, name: "was_inserted_with_drop", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "custom_format_keys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.UUID },
            { no: 4, name: "previous_classic_theme_records", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference }
        ]);
    }
    create(value) {
        const message = { wasInsertedWithDrop: false, customFormatKeys: [], previousClassicThemeRecords: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.ContainerInsertChildrenCommandArchive super */ 1:
                    message.super = TSDCommandArchives_7.ContainerInsertChildrenCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* bool was_inserted_with_drop */ 2:
                    message.wasInsertedWithDrop = reader.bool();
                    break;
                case /* repeated TSP.UUID custom_format_keys */ 3:
                    message.customFormatKeys.push(TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference previous_classic_theme_records */ 4:
                    message.previousClassicThemeRecords.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.ContainerInsertChildrenCommandArchive super = 1; */
        if (message.super)
            TSDCommandArchives_7.ContainerInsertChildrenCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool was_inserted_with_drop = 2; */
        if (message.wasInsertedWithDrop !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.wasInsertedWithDrop);
        /* repeated TSP.UUID custom_format_keys = 3; */
        for (let i = 0; i < message.customFormatKeys.length; i++)
            TSPMessages_5.UUID.internalBinaryWrite(message.customFormatKeys[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference previous_classic_theme_records = 4; */
        for (let i = 0; i < message.previousClassicThemeRecords.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.previousClassicThemeRecords[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandPrimitiveInsertTemplateArchive
 */
exports.CommandPrimitiveInsertTemplateArchive = new CommandPrimitiveInsertTemplateArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandRemoveTemplateArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandRemoveTemplateArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 5, name: "replacement_template_slide_node", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 6, name: "template_change_commands", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 7, name: "default_template_slide_node_was_replaced", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { templateChangeCommands: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference replacement_template_slide_node */ 5:
                    message.replacementTemplateSlideNode = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.replacementTemplateSlideNode);
                    break;
                case /* repeated TSP.Reference template_change_commands */ 6:
                    message.templateChangeCommands.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool default_template_slide_node_was_replaced */ 7:
                    message.defaultTemplateSlideNodeWasReplaced = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference replacement_template_slide_node = 5; */
        if (message.replacementTemplateSlideNode)
            TSPMessages_7.Reference.internalBinaryWrite(message.replacementTemplateSlideNode, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference template_change_commands = 6; */
        for (let i = 0; i < message.templateChangeCommands.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.templateChangeCommands[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool default_template_slide_node_was_replaced = 7; */
        if (message.defaultTemplateSlideNodeWasReplaced !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.defaultTemplateSlideNodeWasReplaced);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandRemoveTemplateArchive
 */
exports.CommandRemoveTemplateArchive = new CommandRemoveTemplateArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandPrimitiveRemoveTemplateArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandPrimitiveRemoveTemplateArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSDCommandArchives_6.ContainerRemoveChildrenCommandArchive },
            { no: 3, name: "previous_classic_theme_records", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference }
        ]);
    }
    create(value) {
        const message = { previousClassicThemeRecords: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.ContainerRemoveChildrenCommandArchive super */ 1:
                    message.super = TSDCommandArchives_6.ContainerRemoveChildrenCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSP.Reference previous_classic_theme_records */ 3:
                    message.previousClassicThemeRecords.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.ContainerRemoveChildrenCommandArchive super = 1; */
        if (message.super)
            TSDCommandArchives_6.ContainerRemoveChildrenCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference previous_classic_theme_records = 3; */
        for (let i = 0; i < message.previousClassicThemeRecords.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.previousClassicThemeRecords[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandPrimitiveRemoveTemplateArchive
 */
exports.CommandPrimitiveRemoveTemplateArchive = new CommandPrimitiveRemoveTemplateArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSlideInsertBuildArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandSlideInsertBuildArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "insert_build_description", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 3, name: "identifier_for_chunk_to_insert_after", kind: "message", T: () => KNArchives_5.BuildChunkIdentifierArchive },
            { no: 4, name: "should_create_chunks", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "old_tuples_to_update", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 6, name: "was_initialized_over_the_wire", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "has_been_committed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { oldTuplesToUpdate: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Reference insert_build_description */ 2:
                    message.insertBuildDescription = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.insertBuildDescription);
                    break;
                case /* optional KN.BuildChunkIdentifierArchive identifier_for_chunk_to_insert_after */ 3:
                    message.identifierForChunkToInsertAfter = KNArchives_5.BuildChunkIdentifierArchive.internalBinaryRead(reader, reader.uint32(), options, message.identifierForChunkToInsertAfter);
                    break;
                case /* optional bool should_create_chunks */ 4:
                    message.shouldCreateChunks = reader.bool();
                    break;
                case /* repeated TSP.Reference old_tuples_to_update */ 5:
                    message.oldTuplesToUpdate.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool was_initialized_over_the_wire */ 6:
                    message.wasInitializedOverTheWire = reader.bool();
                    break;
                case /* optional bool has_been_committed */ 7:
                    message.hasBeenCommitted = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference insert_build_description = 2; */
        if (message.insertBuildDescription)
            TSPMessages_7.Reference.internalBinaryWrite(message.insertBuildDescription, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional KN.BuildChunkIdentifierArchive identifier_for_chunk_to_insert_after = 3; */
        if (message.identifierForChunkToInsertAfter)
            KNArchives_5.BuildChunkIdentifierArchive.internalBinaryWrite(message.identifierForChunkToInsertAfter, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool should_create_chunks = 4; */
        if (message.shouldCreateChunks !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.shouldCreateChunks);
        /* repeated TSP.Reference old_tuples_to_update = 5; */
        for (let i = 0; i < message.oldTuplesToUpdate.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.oldTuplesToUpdate[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool was_initialized_over_the_wire = 6; */
        if (message.wasInitializedOverTheWire !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.wasInitializedOverTheWire);
        /* optional bool has_been_committed = 7; */
        if (message.hasBeenCommitted !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.hasBeenCommitted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandSlideInsertBuildArchive
 */
exports.CommandSlideInsertBuildArchive = new CommandSlideInsertBuildArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InsertBuildDescriptionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.InsertBuildDescriptionArchive", [
            { no: 1, name: "slide_id", kind: "message", T: () => TSPMessages_5.UUID },
            { no: 2, name: "build_to_insert", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 3, name: "chunks_to_insert", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 4, name: "should_assign_chunk_identifiers", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "identifers_for_chunks_to_insert_after", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => KNArchives_5.BuildChunkIdentifierArchive },
            { no: 6, name: "tuples_to_update", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 7, name: "fallback_chunk_identifiers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => KNArchives_5.BuildChunkIdentifierArchive },
            { no: 8, name: "is_for_paste", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { chunksToInsert: [], shouldAssignChunkIdentifiers: false, identifersForChunksToInsertAfter: [], tuplesToUpdate: [], fallbackChunkIdentifiers: [], isForPaste: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID slide_id */ 1:
                    message.slideId = TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options, message.slideId);
                    break;
                case /* TSP.Reference build_to_insert */ 2:
                    message.buildToInsert = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.buildToInsert);
                    break;
                case /* repeated TSP.Reference chunks_to_insert */ 3:
                    message.chunksToInsert.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool should_assign_chunk_identifiers */ 4:
                    message.shouldAssignChunkIdentifiers = reader.bool();
                    break;
                case /* repeated KN.BuildChunkIdentifierArchive identifers_for_chunks_to_insert_after */ 5:
                    message.identifersForChunksToInsertAfter.push(KNArchives_5.BuildChunkIdentifierArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference tuples_to_update */ 6:
                    message.tuplesToUpdate.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated KN.BuildChunkIdentifierArchive fallback_chunk_identifiers */ 7:
                    message.fallbackChunkIdentifiers.push(KNArchives_5.BuildChunkIdentifierArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool is_for_paste */ 8:
                    message.isForPaste = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID slide_id = 1; */
        if (message.slideId)
            TSPMessages_5.UUID.internalBinaryWrite(message.slideId, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference build_to_insert = 2; */
        if (message.buildToInsert)
            TSPMessages_7.Reference.internalBinaryWrite(message.buildToInsert, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference chunks_to_insert = 3; */
        for (let i = 0; i < message.chunksToInsert.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.chunksToInsert[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool should_assign_chunk_identifiers = 4; */
        if (message.shouldAssignChunkIdentifiers !== false)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.shouldAssignChunkIdentifiers);
        /* repeated KN.BuildChunkIdentifierArchive identifers_for_chunks_to_insert_after = 5; */
        for (let i = 0; i < message.identifersForChunksToInsertAfter.length; i++)
            KNArchives_5.BuildChunkIdentifierArchive.internalBinaryWrite(message.identifersForChunksToInsertAfter[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference tuples_to_update = 6; */
        for (let i = 0; i < message.tuplesToUpdate.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.tuplesToUpdate[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated KN.BuildChunkIdentifierArchive fallback_chunk_identifiers = 7; */
        for (let i = 0; i < message.fallbackChunkIdentifiers.length; i++)
            KNArchives_5.BuildChunkIdentifierArchive.internalBinaryWrite(message.fallbackChunkIdentifiers[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool is_for_paste = 8; */
        if (message.isForPaste !== false)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.isForPaste);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.InsertBuildDescriptionArchive
 */
exports.InsertBuildDescriptionArchive = new InsertBuildDescriptionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UndoObjectArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.UndoObjectArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSDCommandArchives_5.UndoObjectArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.UndoObjectArchive super */ 1:
                    message.super = TSDCommandArchives_5.UndoObjectArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.UndoObjectArchive super = 1; */
        if (message.super)
            TSDCommandArchives_5.UndoObjectArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.UndoObjectArchive
 */
exports.UndoObjectArchive = new UndoObjectArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSlideRemoveBuildArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandSlideRemoveBuildArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "remove_build_description", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 3, name: "build", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 4, name: "chunks_to_insert", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 5, name: "identifiers_for_chunks_to_insert_after", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => KNArchives_5.BuildChunkIdentifierArchive },
            { no: 6, name: "old_tuples_to_update", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 7, name: "fallback_chunk_identifiers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => KNArchives_5.BuildChunkIdentifierArchive }
        ]);
    }
    create(value) {
        const message = { chunksToInsert: [], identifiersForChunksToInsertAfter: [], oldTuplesToUpdate: [], fallbackChunkIdentifiers: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Reference remove_build_description */ 2:
                    message.removeBuildDescription = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.removeBuildDescription);
                    break;
                case /* optional TSP.Reference build */ 3:
                    message.build = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.build);
                    break;
                case /* repeated TSP.Reference chunks_to_insert */ 4:
                    message.chunksToInsert.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated KN.BuildChunkIdentifierArchive identifiers_for_chunks_to_insert_after */ 5:
                    message.identifiersForChunksToInsertAfter.push(KNArchives_5.BuildChunkIdentifierArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference old_tuples_to_update */ 6:
                    message.oldTuplesToUpdate.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated KN.BuildChunkIdentifierArchive fallback_chunk_identifiers */ 7:
                    message.fallbackChunkIdentifiers.push(KNArchives_5.BuildChunkIdentifierArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference remove_build_description = 2; */
        if (message.removeBuildDescription)
            TSPMessages_7.Reference.internalBinaryWrite(message.removeBuildDescription, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference build = 3; */
        if (message.build)
            TSPMessages_7.Reference.internalBinaryWrite(message.build, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference chunks_to_insert = 4; */
        for (let i = 0; i < message.chunksToInsert.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.chunksToInsert[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated KN.BuildChunkIdentifierArchive identifiers_for_chunks_to_insert_after = 5; */
        for (let i = 0; i < message.identifiersForChunksToInsertAfter.length; i++)
            KNArchives_5.BuildChunkIdentifierArchive.internalBinaryWrite(message.identifiersForChunksToInsertAfter[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference old_tuples_to_update = 6; */
        for (let i = 0; i < message.oldTuplesToUpdate.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.oldTuplesToUpdate[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated KN.BuildChunkIdentifierArchive fallback_chunk_identifiers = 7; */
        for (let i = 0; i < message.fallbackChunkIdentifiers.length; i++)
            KNArchives_5.BuildChunkIdentifierArchive.internalBinaryWrite(message.fallbackChunkIdentifiers[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandSlideRemoveBuildArchive
 */
exports.CommandSlideRemoveBuildArchive = new CommandSlideRemoveBuildArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveBuildDescriptionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.RemoveBuildDescriptionArchive", [
            { no: 1, name: "slide_id", kind: "message", T: () => TSPMessages_5.UUID },
            { no: 2, name: "build_id", kind: "message", T: () => TSPMessages_5.UUID },
            { no: 3, name: "should_remove_chunks", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "should_remove_chunk_identifiers", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "tuples_to_update", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference }
        ]);
    }
    create(value) {
        const message = { tuplesToUpdate: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.UUID slide_id */ 1:
                    message.slideId = TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options, message.slideId);
                    break;
                case /* optional TSP.UUID build_id */ 2:
                    message.buildId = TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options, message.buildId);
                    break;
                case /* optional bool should_remove_chunks */ 3:
                    message.shouldRemoveChunks = reader.bool();
                    break;
                case /* optional bool should_remove_chunk_identifiers */ 4:
                    message.shouldRemoveChunkIdentifiers = reader.bool();
                    break;
                case /* repeated TSP.Reference tuples_to_update */ 5:
                    message.tuplesToUpdate.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.UUID slide_id = 1; */
        if (message.slideId)
            TSPMessages_5.UUID.internalBinaryWrite(message.slideId, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID build_id = 2; */
        if (message.buildId)
            TSPMessages_5.UUID.internalBinaryWrite(message.buildId, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool should_remove_chunks = 3; */
        if (message.shouldRemoveChunks !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.shouldRemoveChunks);
        /* optional bool should_remove_chunk_identifiers = 4; */
        if (message.shouldRemoveChunkIdentifiers !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.shouldRemoveChunkIdentifiers);
        /* repeated TSP.Reference tuples_to_update = 5; */
        for (let i = 0; i < message.tuplesToUpdate.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.tuplesToUpdate[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.RemoveBuildDescriptionArchive
 */
exports.RemoveBuildDescriptionArchive = new RemoveBuildDescriptionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSlideInsertBuildChunkArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandSlideInsertBuildChunkArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "slide_id", kind: "message", T: () => TSPMessages_5.UUID },
            { no: 3, name: "chunk_to_insert", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 4, name: "identifier_for_chunk_to_insert_after", kind: "message", T: () => KNArchives_5.BuildChunkIdentifierArchive },
            { no: 5, name: "tuples_to_update", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 6, name: "old_tuples_to_update", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 7, name: "needs_selection_update", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "should_assign_chunk_identifier", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { tuplesToUpdate: [], oldTuplesToUpdate: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUID slide_id */ 2:
                    message.slideId = TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options, message.slideId);
                    break;
                case /* TSP.Reference chunk_to_insert */ 3:
                    message.chunkToInsert = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.chunkToInsert);
                    break;
                case /* optional KN.BuildChunkIdentifierArchive identifier_for_chunk_to_insert_after */ 4:
                    message.identifierForChunkToInsertAfter = KNArchives_5.BuildChunkIdentifierArchive.internalBinaryRead(reader, reader.uint32(), options, message.identifierForChunkToInsertAfter);
                    break;
                case /* repeated TSP.Reference tuples_to_update */ 5:
                    message.tuplesToUpdate.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference old_tuples_to_update */ 6:
                    message.oldTuplesToUpdate.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool needs_selection_update */ 7:
                    message.needsSelectionUpdate = reader.bool();
                    break;
                case /* optional bool should_assign_chunk_identifier */ 8:
                    message.shouldAssignChunkIdentifier = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID slide_id = 2; */
        if (message.slideId)
            TSPMessages_5.UUID.internalBinaryWrite(message.slideId, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference chunk_to_insert = 3; */
        if (message.chunkToInsert)
            TSPMessages_7.Reference.internalBinaryWrite(message.chunkToInsert, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional KN.BuildChunkIdentifierArchive identifier_for_chunk_to_insert_after = 4; */
        if (message.identifierForChunkToInsertAfter)
            KNArchives_5.BuildChunkIdentifierArchive.internalBinaryWrite(message.identifierForChunkToInsertAfter, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference tuples_to_update = 5; */
        for (let i = 0; i < message.tuplesToUpdate.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.tuplesToUpdate[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference old_tuples_to_update = 6; */
        for (let i = 0; i < message.oldTuplesToUpdate.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.oldTuplesToUpdate[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool needs_selection_update = 7; */
        if (message.needsSelectionUpdate !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.needsSelectionUpdate);
        /* optional bool should_assign_chunk_identifier = 8; */
        if (message.shouldAssignChunkIdentifier !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.shouldAssignChunkIdentifier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandSlideInsertBuildChunkArchive
 */
exports.CommandSlideInsertBuildChunkArchive = new CommandSlideInsertBuildChunkArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSlideRemoveBuildChunkArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandSlideRemoveBuildChunkArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "slide_id", kind: "message", T: () => TSPMessages_5.UUID },
            { no: 3, name: "removed_chunk", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 4, name: "identifier_for_chunk_to_remove", kind: "message", T: () => KNArchives_5.BuildChunkIdentifierArchive },
            { no: 5, name: "identifier_for_chunk_to_insert_after", kind: "message", T: () => KNArchives_5.BuildChunkIdentifierArchive },
            { no: 6, name: "tuples_to_update", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 7, name: "old_tuples_to_update", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 8, name: "needs_selection_update", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { tuplesToUpdate: [], oldTuplesToUpdate: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUID slide_id */ 2:
                    message.slideId = TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options, message.slideId);
                    break;
                case /* optional TSP.Reference removed_chunk */ 3:
                    message.removedChunk = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.removedChunk);
                    break;
                case /* optional KN.BuildChunkIdentifierArchive identifier_for_chunk_to_remove */ 4:
                    message.identifierForChunkToRemove = KNArchives_5.BuildChunkIdentifierArchive.internalBinaryRead(reader, reader.uint32(), options, message.identifierForChunkToRemove);
                    break;
                case /* optional KN.BuildChunkIdentifierArchive identifier_for_chunk_to_insert_after */ 5:
                    message.identifierForChunkToInsertAfter = KNArchives_5.BuildChunkIdentifierArchive.internalBinaryRead(reader, reader.uint32(), options, message.identifierForChunkToInsertAfter);
                    break;
                case /* repeated TSP.Reference tuples_to_update */ 6:
                    message.tuplesToUpdate.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference old_tuples_to_update */ 7:
                    message.oldTuplesToUpdate.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool needs_selection_update */ 8:
                    message.needsSelectionUpdate = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID slide_id = 2; */
        if (message.slideId)
            TSPMessages_5.UUID.internalBinaryWrite(message.slideId, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference removed_chunk = 3; */
        if (message.removedChunk)
            TSPMessages_7.Reference.internalBinaryWrite(message.removedChunk, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional KN.BuildChunkIdentifierArchive identifier_for_chunk_to_remove = 4; */
        if (message.identifierForChunkToRemove)
            KNArchives_5.BuildChunkIdentifierArchive.internalBinaryWrite(message.identifierForChunkToRemove, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional KN.BuildChunkIdentifierArchive identifier_for_chunk_to_insert_after = 5; */
        if (message.identifierForChunkToInsertAfter)
            KNArchives_5.BuildChunkIdentifierArchive.internalBinaryWrite(message.identifierForChunkToInsertAfter, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference tuples_to_update = 6; */
        for (let i = 0; i < message.tuplesToUpdate.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.tuplesToUpdate[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference old_tuples_to_update = 7; */
        for (let i = 0; i < message.oldTuplesToUpdate.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.oldTuplesToUpdate[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool needs_selection_update = 8; */
        if (message.needsSelectionUpdate !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.needsSelectionUpdate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandSlideRemoveBuildChunkArchive
 */
exports.CommandSlideRemoveBuildChunkArchive = new CommandSlideRemoveBuildChunkArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSlideMoveBuildChunksArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandSlideMoveBuildChunksArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "identifiers_for_chunks_to_move", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => KNArchives_5.BuildChunkIdentifierArchive },
            { no: 3, name: "identifiers_for_chunks_to_move_after", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => KNArchives_5.BuildChunkIdentifierArchive },
            { no: 4, name: "identifiers_for_chunks_to_move_after_for_undo", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => KNArchives_5.BuildChunkIdentifierArchive },
            { no: 5, name: "tuples_to_update", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 6, name: "old_tuples_to_update", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 7, name: "identifiers_for_chunks_to_move_including_clustered_inactive_chunks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => KNArchives_5.BuildChunkIdentifierArchive }
        ]);
    }
    create(value) {
        const message = { identifiersForChunksToMove: [], identifiersForChunksToMoveAfter: [], identifiersForChunksToMoveAfterForUndo: [], tuplesToUpdate: [], oldTuplesToUpdate: [], identifiersForChunksToMoveIncludingClusteredInactiveChunks: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated KN.BuildChunkIdentifierArchive identifiers_for_chunks_to_move */ 2:
                    message.identifiersForChunksToMove.push(KNArchives_5.BuildChunkIdentifierArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated KN.BuildChunkIdentifierArchive identifiers_for_chunks_to_move_after */ 3:
                    message.identifiersForChunksToMoveAfter.push(KNArchives_5.BuildChunkIdentifierArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated KN.BuildChunkIdentifierArchive identifiers_for_chunks_to_move_after_for_undo */ 4:
                    message.identifiersForChunksToMoveAfterForUndo.push(KNArchives_5.BuildChunkIdentifierArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference tuples_to_update */ 5:
                    message.tuplesToUpdate.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference old_tuples_to_update */ 6:
                    message.oldTuplesToUpdate.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated KN.BuildChunkIdentifierArchive identifiers_for_chunks_to_move_including_clustered_inactive_chunks */ 7:
                    message.identifiersForChunksToMoveIncludingClusteredInactiveChunks.push(KNArchives_5.BuildChunkIdentifierArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated KN.BuildChunkIdentifierArchive identifiers_for_chunks_to_move = 2; */
        for (let i = 0; i < message.identifiersForChunksToMove.length; i++)
            KNArchives_5.BuildChunkIdentifierArchive.internalBinaryWrite(message.identifiersForChunksToMove[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated KN.BuildChunkIdentifierArchive identifiers_for_chunks_to_move_after = 3; */
        for (let i = 0; i < message.identifiersForChunksToMoveAfter.length; i++)
            KNArchives_5.BuildChunkIdentifierArchive.internalBinaryWrite(message.identifiersForChunksToMoveAfter[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated KN.BuildChunkIdentifierArchive identifiers_for_chunks_to_move_after_for_undo = 4; */
        for (let i = 0; i < message.identifiersForChunksToMoveAfterForUndo.length; i++)
            KNArchives_5.BuildChunkIdentifierArchive.internalBinaryWrite(message.identifiersForChunksToMoveAfterForUndo[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference tuples_to_update = 5; */
        for (let i = 0; i < message.tuplesToUpdate.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.tuplesToUpdate[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference old_tuples_to_update = 6; */
        for (let i = 0; i < message.oldTuplesToUpdate.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.oldTuplesToUpdate[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated KN.BuildChunkIdentifierArchive identifiers_for_chunks_to_move_including_clustered_inactive_chunks = 7; */
        for (let i = 0; i < message.identifiersForChunksToMoveIncludingClusteredInactiveChunks.length; i++)
            KNArchives_5.BuildChunkIdentifierArchive.internalBinaryWrite(message.identifiersForChunksToMoveIncludingClusteredInactiveChunks[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandSlideMoveBuildChunksArchive
 */
exports.CommandSlideMoveBuildChunksArchive = new CommandSlideMoveBuildChunksArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandBuildSetValueArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandBuildSetValueArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "tuple", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 3, name: "chunks_to_add", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 4, name: "identifiers_for_chunks_to_insert_after", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => KNArchives_5.BuildChunkIdentifierArchive },
            { no: 5, name: "identifiers_for_chunks_to_remove", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => KNArchives_5.BuildChunkIdentifierArchive },
            { no: 6, name: "tuples_to_update", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 7, name: "old_tuple_for_main_property", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 8, name: "old_tuples_to_update_for_sub_commands", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 9, name: "identifiers_for_added_chunks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => KNArchives_5.BuildChunkIdentifierArchive },
            { no: 10, name: "generated_identifiers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => KNArchives_5.BuildChunkIdentifierArchive },
            { no: 11, name: "removed_chunks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 12, name: "identifiers_for_chunks_prior_to_removed_chunks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => KNArchives_5.BuildChunkIdentifierArchive },
            { no: 13, name: "old_chunk_ID_seed", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "old_chunk_identifiers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => KNArchives_5.BuildChunkIdentifierArchive },
            { no: 15, name: "chunks_removed_during_undo", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference }
        ]);
    }
    create(value) {
        const message = { chunksToAdd: [], identifiersForChunksToInsertAfter: [], identifiersForChunksToRemove: [], tuplesToUpdate: [], oldTuplesToUpdateForSubCommands: [], identifiersForAddedChunks: [], generatedIdentifiers: [], removedChunks: [], identifiersForChunksPriorToRemovedChunks: [], oldChunkIdentifiers: [], chunksRemovedDuringUndo: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference tuple */ 2:
                    message.tuple = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.tuple);
                    break;
                case /* repeated TSP.Reference chunks_to_add */ 3:
                    message.chunksToAdd.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated KN.BuildChunkIdentifierArchive identifiers_for_chunks_to_insert_after */ 4:
                    message.identifiersForChunksToInsertAfter.push(KNArchives_5.BuildChunkIdentifierArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated KN.BuildChunkIdentifierArchive identifiers_for_chunks_to_remove */ 5:
                    message.identifiersForChunksToRemove.push(KNArchives_5.BuildChunkIdentifierArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference tuples_to_update */ 6:
                    message.tuplesToUpdate.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Reference old_tuple_for_main_property */ 7:
                    message.oldTupleForMainProperty = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.oldTupleForMainProperty);
                    break;
                case /* repeated TSP.Reference old_tuples_to_update_for_sub_commands */ 8:
                    message.oldTuplesToUpdateForSubCommands.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated KN.BuildChunkIdentifierArchive identifiers_for_added_chunks */ 9:
                    message.identifiersForAddedChunks.push(KNArchives_5.BuildChunkIdentifierArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated KN.BuildChunkIdentifierArchive generated_identifiers */ 10:
                    message.generatedIdentifiers.push(KNArchives_5.BuildChunkIdentifierArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference removed_chunks */ 11:
                    message.removedChunks.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated KN.BuildChunkIdentifierArchive identifiers_for_chunks_prior_to_removed_chunks */ 12:
                    message.identifiersForChunksPriorToRemovedChunks.push(KNArchives_5.BuildChunkIdentifierArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 old_chunk_ID_seed */ 13:
                    message.oldChunkIDSeed = reader.uint32();
                    break;
                case /* repeated KN.BuildChunkIdentifierArchive old_chunk_identifiers */ 14:
                    message.oldChunkIdentifiers.push(KNArchives_5.BuildChunkIdentifierArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference chunks_removed_during_undo */ 15:
                    message.chunksRemovedDuringUndo.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference tuple = 2; */
        if (message.tuple)
            TSPMessages_7.Reference.internalBinaryWrite(message.tuple, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference chunks_to_add = 3; */
        for (let i = 0; i < message.chunksToAdd.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.chunksToAdd[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated KN.BuildChunkIdentifierArchive identifiers_for_chunks_to_insert_after = 4; */
        for (let i = 0; i < message.identifiersForChunksToInsertAfter.length; i++)
            KNArchives_5.BuildChunkIdentifierArchive.internalBinaryWrite(message.identifiersForChunksToInsertAfter[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated KN.BuildChunkIdentifierArchive identifiers_for_chunks_to_remove = 5; */
        for (let i = 0; i < message.identifiersForChunksToRemove.length; i++)
            KNArchives_5.BuildChunkIdentifierArchive.internalBinaryWrite(message.identifiersForChunksToRemove[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference tuples_to_update = 6; */
        for (let i = 0; i < message.tuplesToUpdate.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.tuplesToUpdate[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference old_tuple_for_main_property = 7; */
        if (message.oldTupleForMainProperty)
            TSPMessages_7.Reference.internalBinaryWrite(message.oldTupleForMainProperty, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference old_tuples_to_update_for_sub_commands = 8; */
        for (let i = 0; i < message.oldTuplesToUpdateForSubCommands.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.oldTuplesToUpdateForSubCommands[i], writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated KN.BuildChunkIdentifierArchive identifiers_for_added_chunks = 9; */
        for (let i = 0; i < message.identifiersForAddedChunks.length; i++)
            KNArchives_5.BuildChunkIdentifierArchive.internalBinaryWrite(message.identifiersForAddedChunks[i], writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated KN.BuildChunkIdentifierArchive generated_identifiers = 10; */
        for (let i = 0; i < message.generatedIdentifiers.length; i++)
            KNArchives_5.BuildChunkIdentifierArchive.internalBinaryWrite(message.generatedIdentifiers[i], writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference removed_chunks = 11; */
        for (let i = 0; i < message.removedChunks.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.removedChunks[i], writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated KN.BuildChunkIdentifierArchive identifiers_for_chunks_prior_to_removed_chunks = 12; */
        for (let i = 0; i < message.identifiersForChunksPriorToRemovedChunks.length; i++)
            KNArchives_5.BuildChunkIdentifierArchive.internalBinaryWrite(message.identifiersForChunksPriorToRemovedChunks[i], writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 old_chunk_ID_seed = 13; */
        if (message.oldChunkIDSeed !== undefined)
            writer.tag(13, runtime_1.WireType.Varint).uint32(message.oldChunkIDSeed);
        /* repeated KN.BuildChunkIdentifierArchive old_chunk_identifiers = 14; */
        for (let i = 0; i < message.oldChunkIdentifiers.length; i++)
            KNArchives_5.BuildChunkIdentifierArchive.internalBinaryWrite(message.oldChunkIdentifiers[i], writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference chunks_removed_during_undo = 15; */
        for (let i = 0; i < message.chunksRemovedDuringUndo.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.chunksRemovedDuringUndo[i], writer.tag(15, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandBuildSetValueArchive
 */
exports.CommandBuildSetValueArchive = new CommandBuildSetValueArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandBuildUpdateChunkReferentsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandBuildUpdateChunkReferentsArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "build_id", kind: "message", T: () => TSPMessages_5.UUID },
            { no: 3, name: "tuples_to_update", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 4, name: "old_tuples_to_update", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference }
        ]);
    }
    create(value) {
        const message = { tuplesToUpdate: [], oldTuplesToUpdate: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUID build_id */ 2:
                    message.buildId = TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options, message.buildId);
                    break;
                case /* repeated TSP.Reference tuples_to_update */ 3:
                    message.tuplesToUpdate.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference old_tuples_to_update */ 4:
                    message.oldTuplesToUpdate.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID build_id = 2; */
        if (message.buildId)
            TSPMessages_5.UUID.internalBinaryWrite(message.buildId, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference tuples_to_update = 3; */
        for (let i = 0; i < message.tuplesToUpdate.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.tuplesToUpdate[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference old_tuples_to_update = 4; */
        for (let i = 0; i < message.oldTuplesToUpdate.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.oldTuplesToUpdate[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandBuildUpdateChunkReferentsArchive
 */
exports.CommandBuildUpdateChunkReferentsArchive = new CommandBuildUpdateChunkReferentsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandBuildUpdateChunkCountArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandBuildUpdateChunkCountArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "slide_id", kind: "message", T: () => TSPMessages_5.UUID },
            { no: 3, name: "drawable_ids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.UUID },
            { no: 4, name: "expected_delivery_style_tuples", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 5, name: "chunks_to_add", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 6, name: "identifiers_for_chunks_to_insert_after", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => KNArchives_5.BuildChunkIdentifierArchive },
            { no: 7, name: "identifiers_for_chunks_to_remove", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => KNArchives_5.BuildChunkIdentifierArchive },
            { no: 8, name: "tuples_to_update", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 9, name: "needs_async_process_changes_selection_update", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "old_tuples_to_update", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 11, name: "identifiers_for_added_chunks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => KNArchives_5.BuildChunkIdentifierArchive },
            { no: 12, name: "generated_identifiers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => KNArchives_5.BuildChunkIdentifierArchive },
            { no: 13, name: "removed_chunks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 14, name: "identifiers_for_chunks_prior_to_removed_chunks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => KNArchives_5.BuildChunkIdentifierArchive },
            { no: 15, name: "old_delivery_style_tuples", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 16, name: "old_chunk_ID_seeds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 17, name: "old_chunk_identifiers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => KNArchives_5.BuildChunkIdentifierArchive },
            { no: 18, name: "working_builds", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 19, name: "chunks_removed_during_undo", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 20, name: "chunks_added_during_undo", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference }
        ]);
    }
    create(value) {
        const message = { drawableIds: [], expectedDeliveryStyleTuples: [], chunksToAdd: [], identifiersForChunksToInsertAfter: [], identifiersForChunksToRemove: [], tuplesToUpdate: [], oldTuplesToUpdate: [], identifiersForAddedChunks: [], generatedIdentifiers: [], removedChunks: [], identifiersForChunksPriorToRemovedChunks: [], oldDeliveryStyleTuples: [], oldChunkIDSeeds: [], oldChunkIdentifiers: [], workingBuilds: [], chunksRemovedDuringUndo: [], chunksAddedDuringUndo: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUID slide_id */ 2:
                    message.slideId = TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options, message.slideId);
                    break;
                case /* repeated TSP.UUID drawable_ids */ 3:
                    message.drawableIds.push(TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference expected_delivery_style_tuples */ 4:
                    message.expectedDeliveryStyleTuples.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference chunks_to_add */ 5:
                    message.chunksToAdd.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated KN.BuildChunkIdentifierArchive identifiers_for_chunks_to_insert_after */ 6:
                    message.identifiersForChunksToInsertAfter.push(KNArchives_5.BuildChunkIdentifierArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated KN.BuildChunkIdentifierArchive identifiers_for_chunks_to_remove */ 7:
                    message.identifiersForChunksToRemove.push(KNArchives_5.BuildChunkIdentifierArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference tuples_to_update */ 8:
                    message.tuplesToUpdate.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool needs_async_process_changes_selection_update */ 9:
                    message.needsAsyncProcessChangesSelectionUpdate = reader.bool();
                    break;
                case /* repeated TSP.Reference old_tuples_to_update */ 10:
                    message.oldTuplesToUpdate.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated KN.BuildChunkIdentifierArchive identifiers_for_added_chunks */ 11:
                    message.identifiersForAddedChunks.push(KNArchives_5.BuildChunkIdentifierArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated KN.BuildChunkIdentifierArchive generated_identifiers */ 12:
                    message.generatedIdentifiers.push(KNArchives_5.BuildChunkIdentifierArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference removed_chunks */ 13:
                    message.removedChunks.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated KN.BuildChunkIdentifierArchive identifiers_for_chunks_prior_to_removed_chunks */ 14:
                    message.identifiersForChunksPriorToRemovedChunks.push(KNArchives_5.BuildChunkIdentifierArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference old_delivery_style_tuples */ 15:
                    message.oldDeliveryStyleTuples.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 old_chunk_ID_seeds */ 16:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.oldChunkIDSeeds.push(reader.uint32());
                    else
                        message.oldChunkIDSeeds.push(reader.uint32());
                    break;
                case /* repeated KN.BuildChunkIdentifierArchive old_chunk_identifiers */ 17:
                    message.oldChunkIdentifiers.push(KNArchives_5.BuildChunkIdentifierArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference working_builds */ 18:
                    message.workingBuilds.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference chunks_removed_during_undo */ 19:
                    message.chunksRemovedDuringUndo.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference chunks_added_during_undo */ 20:
                    message.chunksAddedDuringUndo.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID slide_id = 2; */
        if (message.slideId)
            TSPMessages_5.UUID.internalBinaryWrite(message.slideId, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID drawable_ids = 3; */
        for (let i = 0; i < message.drawableIds.length; i++)
            TSPMessages_5.UUID.internalBinaryWrite(message.drawableIds[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference expected_delivery_style_tuples = 4; */
        for (let i = 0; i < message.expectedDeliveryStyleTuples.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.expectedDeliveryStyleTuples[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference chunks_to_add = 5; */
        for (let i = 0; i < message.chunksToAdd.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.chunksToAdd[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated KN.BuildChunkIdentifierArchive identifiers_for_chunks_to_insert_after = 6; */
        for (let i = 0; i < message.identifiersForChunksToInsertAfter.length; i++)
            KNArchives_5.BuildChunkIdentifierArchive.internalBinaryWrite(message.identifiersForChunksToInsertAfter[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated KN.BuildChunkIdentifierArchive identifiers_for_chunks_to_remove = 7; */
        for (let i = 0; i < message.identifiersForChunksToRemove.length; i++)
            KNArchives_5.BuildChunkIdentifierArchive.internalBinaryWrite(message.identifiersForChunksToRemove[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference tuples_to_update = 8; */
        for (let i = 0; i < message.tuplesToUpdate.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.tuplesToUpdate[i], writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool needs_async_process_changes_selection_update = 9; */
        if (message.needsAsyncProcessChangesSelectionUpdate !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).bool(message.needsAsyncProcessChangesSelectionUpdate);
        /* repeated TSP.Reference old_tuples_to_update = 10; */
        for (let i = 0; i < message.oldTuplesToUpdate.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.oldTuplesToUpdate[i], writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated KN.BuildChunkIdentifierArchive identifiers_for_added_chunks = 11; */
        for (let i = 0; i < message.identifiersForAddedChunks.length; i++)
            KNArchives_5.BuildChunkIdentifierArchive.internalBinaryWrite(message.identifiersForAddedChunks[i], writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated KN.BuildChunkIdentifierArchive generated_identifiers = 12; */
        for (let i = 0; i < message.generatedIdentifiers.length; i++)
            KNArchives_5.BuildChunkIdentifierArchive.internalBinaryWrite(message.generatedIdentifiers[i], writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference removed_chunks = 13; */
        for (let i = 0; i < message.removedChunks.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.removedChunks[i], writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated KN.BuildChunkIdentifierArchive identifiers_for_chunks_prior_to_removed_chunks = 14; */
        for (let i = 0; i < message.identifiersForChunksPriorToRemovedChunks.length; i++)
            KNArchives_5.BuildChunkIdentifierArchive.internalBinaryWrite(message.identifiersForChunksPriorToRemovedChunks[i], writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference old_delivery_style_tuples = 15; */
        for (let i = 0; i < message.oldDeliveryStyleTuples.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.oldDeliveryStyleTuples[i], writer.tag(15, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 old_chunk_ID_seeds = 16; */
        for (let i = 0; i < message.oldChunkIDSeeds.length; i++)
            writer.tag(16, runtime_1.WireType.Varint).uint32(message.oldChunkIDSeeds[i]);
        /* repeated KN.BuildChunkIdentifierArchive old_chunk_identifiers = 17; */
        for (let i = 0; i < message.oldChunkIdentifiers.length; i++)
            KNArchives_5.BuildChunkIdentifierArchive.internalBinaryWrite(message.oldChunkIdentifiers[i], writer.tag(17, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference working_builds = 18; */
        for (let i = 0; i < message.workingBuilds.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.workingBuilds[i], writer.tag(18, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference chunks_removed_during_undo = 19; */
        for (let i = 0; i < message.chunksRemovedDuringUndo.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.chunksRemovedDuringUndo[i], writer.tag(19, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference chunks_added_during_undo = 20; */
        for (let i = 0; i < message.chunksAddedDuringUndo.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.chunksAddedDuringUndo[i], writer.tag(20, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandBuildUpdateChunkCountArchive
 */
exports.CommandBuildUpdateChunkCountArchive = new CommandBuildUpdateChunkCountArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandBuildChunkSetValueArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandBuildChunkSetValueArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "tuples_to_update", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 3, name: "old_tuples_to_update", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference }
        ]);
    }
    create(value) {
        const message = { tuplesToUpdate: [], oldTuplesToUpdate: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSP.Reference tuples_to_update */ 2:
                    message.tuplesToUpdate.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference old_tuples_to_update */ 3:
                    message.oldTuplesToUpdate.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference tuples_to_update = 2; */
        for (let i = 0; i < message.tuplesToUpdate.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.tuplesToUpdate[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference old_tuples_to_update = 3; */
        for (let i = 0; i < message.oldTuplesToUpdate.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.oldTuplesToUpdate[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandBuildChunkSetValueArchive
 */
exports.CommandBuildChunkSetValueArchive = new CommandBuildChunkSetValueArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandTransitionSetValueArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandTransitionSetValueArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "slide_node_id_path", kind: "message", T: () => TSPMessages_4.UUIDPath },
            { no: 3, name: "old_attributes", kind: "message", T: () => KNArchives_4.TransitionAttributesArchive },
            { no: 4, name: "attributes", kind: "message", T: () => KNArchives_4.TransitionAttributesArchive },
            { no: 5, name: "property", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUIDPath slide_node_id_path */ 2:
                    message.slideNodeIdPath = TSPMessages_4.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.slideNodeIdPath);
                    break;
                case /* optional KN.TransitionAttributesArchive old_attributes */ 3:
                    message.oldAttributes = KNArchives_4.TransitionAttributesArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldAttributes);
                    break;
                case /* optional KN.TransitionAttributesArchive attributes */ 4:
                    message.attributes = KNArchives_4.TransitionAttributesArchive.internalBinaryRead(reader, reader.uint32(), options, message.attributes);
                    break;
                case /* optional string property */ 5:
                    message.property = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUIDPath slide_node_id_path = 2; */
        if (message.slideNodeIdPath)
            TSPMessages_4.UUIDPath.internalBinaryWrite(message.slideNodeIdPath, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional KN.TransitionAttributesArchive old_attributes = 3; */
        if (message.oldAttributes)
            KNArchives_4.TransitionAttributesArchive.internalBinaryWrite(message.oldAttributes, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional KN.TransitionAttributesArchive attributes = 4; */
        if (message.attributes)
            KNArchives_4.TransitionAttributesArchive.internalBinaryWrite(message.attributes, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string property = 5; */
        if (message.property !== undefined)
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.property);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandTransitionSetValueArchive
 */
exports.CommandTransitionSetValueArchive = new CommandTransitionSetValueArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandShowSetSlideNumberVisibilityArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandShowSetSlideNumberVisibilityArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 3, name: "slide_numbers_visible", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "ids_of_slide_nodes_to_skip", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.UUID },
            { no: 5, name: "ids_of_slide_nodes_already_correct", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.UUID },
            { no: 6, name: "is_undo", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { slideNumbersVisible: false, idsOfSlideNodesToSkip: [], idsOfSlideNodesAlreadyCorrect: [], isUndo: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* bool slide_numbers_visible */ 3:
                    message.slideNumbersVisible = reader.bool();
                    break;
                case /* repeated TSP.UUID ids_of_slide_nodes_to_skip */ 4:
                    message.idsOfSlideNodesToSkip.push(TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID ids_of_slide_nodes_already_correct */ 5:
                    message.idsOfSlideNodesAlreadyCorrect.push(TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool is_undo */ 6:
                    message.isUndo = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool slide_numbers_visible = 3; */
        if (message.slideNumbersVisible !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.slideNumbersVisible);
        /* repeated TSP.UUID ids_of_slide_nodes_to_skip = 4; */
        for (let i = 0; i < message.idsOfSlideNodesToSkip.length; i++)
            TSPMessages_5.UUID.internalBinaryWrite(message.idsOfSlideNodesToSkip[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID ids_of_slide_nodes_already_correct = 5; */
        for (let i = 0; i < message.idsOfSlideNodesAlreadyCorrect.length; i++)
            TSPMessages_5.UUID.internalBinaryWrite(message.idsOfSlideNodesAlreadyCorrect[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool is_undo = 6; */
        if (message.isUndo !== false)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.isUndo);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandShowSetSlideNumberVisibilityArchive
 */
exports.CommandShowSetSlideNumberVisibilityArchive = new CommandShowSetSlideNumberVisibilityArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandTemplateSetThumbnailTextArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandTemplateSetThumbnailTextArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "template_id", kind: "message", T: () => TSPMessages_5.UUID },
            { no: 3, name: "is_body", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "new_text", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "old_text", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { isBody: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUID template_id */ 2:
                    message.templateId = TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options, message.templateId);
                    break;
                case /* bool is_body */ 3:
                    message.isBody = reader.bool();
                    break;
                case /* optional string new_text */ 4:
                    message.newText = reader.string();
                    break;
                case /* optional string old_text */ 5:
                    message.oldText = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID template_id = 2; */
        if (message.templateId)
            TSPMessages_5.UUID.internalBinaryWrite(message.templateId, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool is_body = 3; */
        if (message.isBody !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.isBody);
        /* optional string new_text = 4; */
        if (message.newText !== undefined)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.newText);
        /* optional string old_text = 5; */
        if (message.oldText !== undefined)
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.oldText);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandTemplateSetThumbnailTextArchive
 */
exports.CommandTemplateSetThumbnailTextArchive = new CommandTemplateSetThumbnailTextArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandTemplateSetBodyStylesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandTemplateSetBodyStylesArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "template_id", kind: "message", T: () => TSPMessages_5.UUID },
            { no: 3, name: "new_paragraph_styles", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 4, name: "new_list_styles", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 5, name: "old_paragraph_styles", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference },
            { no: 6, name: "old_list_styles", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference }
        ]);
    }
    create(value) {
        const message = { newParagraphStyles: [], newListStyles: [], oldParagraphStyles: [], oldListStyles: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUID template_id */ 2:
                    message.templateId = TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options, message.templateId);
                    break;
                case /* repeated TSP.Reference new_paragraph_styles */ 3:
                    message.newParagraphStyles.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference new_list_styles */ 4:
                    message.newListStyles.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference old_paragraph_styles */ 5:
                    message.oldParagraphStyles.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference old_list_styles */ 6:
                    message.oldListStyles.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID template_id = 2; */
        if (message.templateId)
            TSPMessages_5.UUID.internalBinaryWrite(message.templateId, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference new_paragraph_styles = 3; */
        for (let i = 0; i < message.newParagraphStyles.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.newParagraphStyles[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference new_list_styles = 4; */
        for (let i = 0; i < message.newListStyles.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.newListStyles[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference old_paragraph_styles = 5; */
        for (let i = 0; i < message.oldParagraphStyles.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.oldParagraphStyles[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference old_list_styles = 6; */
        for (let i = 0; i < message.oldListStyles.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.oldListStyles[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandTemplateSetBodyStylesArchive
 */
exports.CommandTemplateSetBodyStylesArchive = new CommandTemplateSetBodyStylesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandChangeTemplateSlideArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandChangeTemplateSlideArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "slide_id_path", kind: "message", T: () => TSPMessages_4.UUIDPath },
            { no: 3, name: "template_slide_node", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 4, name: "old_template_slide_node", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 5, name: "is_undo_redo", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "target_prototype", kind: "message", T: () => TSPMessages_7.Reference }
        ]);
    }
    create(value) {
        const message = { isUndoRedo: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUIDPath slide_id_path */ 2:
                    message.slideIdPath = TSPMessages_4.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.slideIdPath);
                    break;
                case /* TSP.Reference template_slide_node */ 3:
                    message.templateSlideNode = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.templateSlideNode);
                    break;
                case /* optional TSP.Reference old_template_slide_node */ 4:
                    message.oldTemplateSlideNode = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.oldTemplateSlideNode);
                    break;
                case /* bool is_undo_redo */ 5:
                    message.isUndoRedo = reader.bool();
                    break;
                case /* optional TSP.Reference target_prototype */ 6:
                    message.targetPrototype = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.targetPrototype);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUIDPath slide_id_path = 2; */
        if (message.slideIdPath)
            TSPMessages_4.UUIDPath.internalBinaryWrite(message.slideIdPath, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference template_slide_node = 3; */
        if (message.templateSlideNode)
            TSPMessages_7.Reference.internalBinaryWrite(message.templateSlideNode, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference old_template_slide_node = 4; */
        if (message.oldTemplateSlideNode)
            TSPMessages_7.Reference.internalBinaryWrite(message.oldTemplateSlideNode, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool is_undo_redo = 5; */
        if (message.isUndoRedo !== false)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.isUndoRedo);
        /* optional TSP.Reference target_prototype = 6; */
        if (message.targetPrototype)
            TSPMessages_7.Reference.internalBinaryWrite(message.targetPrototype, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandChangeTemplateSlideArchive
 */
exports.CommandChangeTemplateSlideArchive = new CommandChangeTemplateSlideArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSlidePrimitiveSetTemplateArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandSlidePrimitiveSetTemplateArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "slide_id_path", kind: "message", T: () => TSPMessages_4.UUIDPath },
            { no: 3, name: "template_id", kind: "message", T: () => TSPMessages_5.UUID },
            { no: 4, name: "old_template_slide_node", kind: "message", T: () => TSPMessages_7.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUIDPath slide_id_path */ 2:
                    message.slideIdPath = TSPMessages_4.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.slideIdPath);
                    break;
                case /* TSP.UUID template_id */ 3:
                    message.templateId = TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options, message.templateId);
                    break;
                case /* optional TSP.Reference old_template_slide_node */ 4:
                    message.oldTemplateSlideNode = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.oldTemplateSlideNode);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUIDPath slide_id_path = 2; */
        if (message.slideIdPath)
            TSPMessages_4.UUIDPath.internalBinaryWrite(message.slideIdPath, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID template_id = 3; */
        if (message.templateId)
            TSPMessages_5.UUID.internalBinaryWrite(message.templateId, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference old_template_slide_node = 4; */
        if (message.oldTemplateSlideNode)
            TSPMessages_7.Reference.internalBinaryWrite(message.oldTemplateSlideNode, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandSlidePrimitiveSetTemplateArchive
 */
exports.CommandSlidePrimitiveSetTemplateArchive = new CommandSlidePrimitiveSetTemplateArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSlideResetTemplateBackgroundObjectsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandSlideResetTemplateBackgroundObjectsArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "slide_id_path", kind: "message", T: () => TSPMessages_4.UUIDPath }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.UUIDPath slide_id_path */ 2:
                    message.slideIdPath = TSPMessages_4.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.slideIdPath);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDPath slide_id_path = 2; */
        if (message.slideIdPath)
            TSPMessages_4.UUIDPath.internalBinaryWrite(message.slideIdPath, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandSlideResetTemplateBackgroundObjectsArchive
 */
exports.CommandSlideResetTemplateBackgroundObjectsArchive = new CommandSlideResetTemplateBackgroundObjectsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandShowSetSoundtrack$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandShowSetSoundtrack", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "show", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 3, name: "soundtrack", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 4, name: "old_soundtrack", kind: "message", T: () => TSPMessages_7.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference show */ 2:
                    message.show = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.show);
                    break;
                case /* optional TSP.Reference soundtrack */ 3:
                    message.soundtrack = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.soundtrack);
                    break;
                case /* optional TSP.Reference old_soundtrack */ 4:
                    message.oldSoundtrack = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.oldSoundtrack);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference show = 2; */
        if (message.show)
            TSPMessages_7.Reference.internalBinaryWrite(message.show, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference soundtrack = 3; */
        if (message.soundtrack)
            TSPMessages_7.Reference.internalBinaryWrite(message.soundtrack, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference old_soundtrack = 4; */
        if (message.oldSoundtrack)
            TSPMessages_7.Reference.internalBinaryWrite(message.oldSoundtrack, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandShowSetSoundtrack
 */
exports.CommandShowSetSoundtrack = new CommandShowSetSoundtrack$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSoundtrackSetValue$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandSoundtrackSetValue", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "soundtrack_id", kind: "message", T: () => TSPMessages_5.UUID },
            { no: 3, name: "property", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "old_value", kind: "message", T: () => exports.CommandSoundtrackSetValue_PropertyValue },
            { no: 5, name: "new_value", kind: "message", T: () => exports.CommandSoundtrackSetValue_PropertyValue }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.UUID soundtrack_id */ 2:
                    message.soundtrackId = TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options, message.soundtrackId);
                    break;
                case /* optional string property */ 3:
                    message.property = reader.string();
                    break;
                case /* optional KN.CommandSoundtrackSetValue.PropertyValue old_value */ 4:
                    message.oldValue = exports.CommandSoundtrackSetValue_PropertyValue.internalBinaryRead(reader, reader.uint32(), options, message.oldValue);
                    break;
                case /* optional KN.CommandSoundtrackSetValue.PropertyValue new_value */ 5:
                    message.newValue = exports.CommandSoundtrackSetValue_PropertyValue.internalBinaryRead(reader, reader.uint32(), options, message.newValue);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID soundtrack_id = 2; */
        if (message.soundtrackId)
            TSPMessages_5.UUID.internalBinaryWrite(message.soundtrackId, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string property = 3; */
        if (message.property !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.property);
        /* optional KN.CommandSoundtrackSetValue.PropertyValue old_value = 4; */
        if (message.oldValue)
            exports.CommandSoundtrackSetValue_PropertyValue.internalBinaryWrite(message.oldValue, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional KN.CommandSoundtrackSetValue.PropertyValue new_value = 5; */
        if (message.newValue)
            exports.CommandSoundtrackSetValue_PropertyValue.internalBinaryWrite(message.newValue, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandSoundtrackSetValue
 */
exports.CommandSoundtrackSetValue = new CommandSoundtrackSetValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSoundtrackSetValue_PropertyValue$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandSoundtrackSetValue.PropertyValue", [
            { no: 1, name: "double_value", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "mode_value", kind: "enum", opt: true, T: () => ["KN.Soundtrack.SoundtrackMode", KNArchives_3.Soundtrack_SoundtrackMode] },
            { no: 3, name: "media_reference_values", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_2.DataReference }
        ]);
    }
    create(value) {
        const message = { mediaReferenceValues: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double double_value */ 1:
                    message.doubleValue = reader.double();
                    break;
                case /* optional KN.Soundtrack.SoundtrackMode mode_value */ 2:
                    message.modeValue = reader.int32();
                    break;
                case /* repeated TSP.DataReference media_reference_values */ 3:
                    message.mediaReferenceValues.push(TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional double double_value = 1; */
        if (message.doubleValue !== undefined)
            writer.tag(1, runtime_1.WireType.Bit64).double(message.doubleValue);
        /* optional KN.Soundtrack.SoundtrackMode mode_value = 2; */
        if (message.modeValue !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.modeValue);
        /* repeated TSP.DataReference media_reference_values = 3; */
        for (let i = 0; i < message.mediaReferenceValues.length; i++)
            TSPMessages_2.DataReference.internalBinaryWrite(message.mediaReferenceValues[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandSoundtrackSetValue.PropertyValue
 */
exports.CommandSoundtrackSetValue_PropertyValue = new CommandSoundtrackSetValue_PropertyValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSlideUpdateTemplateDrawables$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandSlideUpdateTemplateDrawables", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "slide_id", kind: "message", T: () => TSPMessages_5.UUID },
            { no: 3, name: "id_placement_operation_args", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSKArchives_2.IdPlacementOperationArgs },
            { no: 4, name: "old_child_infos_for_undo", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_7.Reference }
        ]);
    }
    create(value) {
        const message = { idPlacementOperationArgs: [], oldChildInfosForUndo: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUID slide_id */ 2:
                    message.slideId = TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options, message.slideId);
                    break;
                case /* repeated TSK.IdPlacementOperationArgs id_placement_operation_args */ 3:
                    message.idPlacementOperationArgs.push(TSKArchives_2.IdPlacementOperationArgs.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference old_child_infos_for_undo */ 4:
                    message.oldChildInfosForUndo.push(TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID slide_id = 2; */
        if (message.slideId)
            TSPMessages_5.UUID.internalBinaryWrite(message.slideId, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSK.IdPlacementOperationArgs id_placement_operation_args = 3; */
        for (let i = 0; i < message.idPlacementOperationArgs.length; i++)
            TSKArchives_2.IdPlacementOperationArgs.internalBinaryWrite(message.idPlacementOperationArgs[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference old_child_infos_for_undo = 4; */
        for (let i = 0; i < message.oldChildInfosForUndo.length; i++)
            TSPMessages_7.Reference.internalBinaryWrite(message.oldChildInfosForUndo[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandSlideUpdateTemplateDrawables
 */
exports.CommandSlideUpdateTemplateDrawables = new CommandSlideUpdateTemplateDrawables$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChartInfoGeometryCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.ChartInfoGeometryCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSDCommandArchives_4.InfoGeometryCommandArchive },
            { no: 2, name: "previous_legend_offset", kind: "message", T: () => TSPMessages_1.Point },
            { no: 3, name: "previous_legend_size", kind: "message", T: () => TSPMessages_6.Size },
            { no: 4, name: "adjusted_legend_offset", kind: "message", T: () => TSPMessages_1.Point },
            { no: 5, name: "adjusted_legend_size", kind: "message", T: () => TSPMessages_6.Size }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoGeometryCommandArchive super */ 1:
                    message.super = TSDCommandArchives_4.InfoGeometryCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Point previous_legend_offset */ 2:
                    message.previousLegendOffset = TSPMessages_1.Point.internalBinaryRead(reader, reader.uint32(), options, message.previousLegendOffset);
                    break;
                case /* TSP.Size previous_legend_size */ 3:
                    message.previousLegendSize = TSPMessages_6.Size.internalBinaryRead(reader, reader.uint32(), options, message.previousLegendSize);
                    break;
                case /* TSP.Point adjusted_legend_offset */ 4:
                    message.adjustedLegendOffset = TSPMessages_1.Point.internalBinaryRead(reader, reader.uint32(), options, message.adjustedLegendOffset);
                    break;
                case /* TSP.Size adjusted_legend_size */ 5:
                    message.adjustedLegendSize = TSPMessages_6.Size.internalBinaryRead(reader, reader.uint32(), options, message.adjustedLegendSize);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoGeometryCommandArchive super = 1; */
        if (message.super)
            TSDCommandArchives_4.InfoGeometryCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Point previous_legend_offset = 2; */
        if (message.previousLegendOffset)
            TSPMessages_1.Point.internalBinaryWrite(message.previousLegendOffset, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Size previous_legend_size = 3; */
        if (message.previousLegendSize)
            TSPMessages_6.Size.internalBinaryWrite(message.previousLegendSize, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Point adjusted_legend_offset = 4; */
        if (message.adjustedLegendOffset)
            TSPMessages_1.Point.internalBinaryWrite(message.adjustedLegendOffset, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Size adjusted_legend_size = 5; */
        if (message.adjustedLegendSize)
            TSPMessages_6.Size.internalBinaryWrite(message.adjustedLegendSize, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.ChartInfoGeometryCommandArchive
 */
exports.ChartInfoGeometryCommandArchive = new ChartInfoGeometryCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CanvasSelectionTransformerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CanvasSelectionTransformerArchive", [
            { no: 1, name: "transformer_helper", kind: "message", T: () => TSDCommandArchives_3.InfoCollectionSelectionTransformerHelperArchive },
            { no: 2, name: "build_chunk_ids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => KNArchives_5.BuildChunkIdentifierArchive },
            { no: 3, name: "action_build_ids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.UUID },
            { no: 4, name: "originally_selected_drawable_uuids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.UUID }
        ]);
    }
    create(value) {
        const message = { buildChunkIds: [], actionBuildIds: [], originallySelectedDrawableUuids: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoCollectionSelectionTransformerHelperArchive transformer_helper */ 1:
                    message.transformerHelper = TSDCommandArchives_3.InfoCollectionSelectionTransformerHelperArchive.internalBinaryRead(reader, reader.uint32(), options, message.transformerHelper);
                    break;
                case /* repeated KN.BuildChunkIdentifierArchive build_chunk_ids */ 2:
                    message.buildChunkIds.push(KNArchives_5.BuildChunkIdentifierArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID action_build_ids */ 3:
                    message.actionBuildIds.push(TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID originally_selected_drawable_uuids */ 4:
                    message.originallySelectedDrawableUuids.push(TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoCollectionSelectionTransformerHelperArchive transformer_helper = 1; */
        if (message.transformerHelper)
            TSDCommandArchives_3.InfoCollectionSelectionTransformerHelperArchive.internalBinaryWrite(message.transformerHelper, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated KN.BuildChunkIdentifierArchive build_chunk_ids = 2; */
        for (let i = 0; i < message.buildChunkIds.length; i++)
            KNArchives_5.BuildChunkIdentifierArchive.internalBinaryWrite(message.buildChunkIds[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID action_build_ids = 3; */
        for (let i = 0; i < message.actionBuildIds.length; i++)
            TSPMessages_5.UUID.internalBinaryWrite(message.actionBuildIds[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID originally_selected_drawable_uuids = 4; */
        for (let i = 0; i < message.originallySelectedDrawableUuids.length; i++)
            TSPMessages_5.UUID.internalBinaryWrite(message.originallySelectedDrawableUuids[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CanvasSelectionTransformerArchive
 */
exports.CanvasSelectionTransformerArchive = new CanvasSelectionTransformerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActionGhostSelectionTransformerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.ActionGhostSelectionTransformerArchive", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.ActionGhostSelectionTransformerArchive
 */
exports.ActionGhostSelectionTransformerArchive = new ActionGhostSelectionTransformerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentSelectionTransformerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.DocumentSelectionTransformerArchive", [
            { no: 1, name: "document_selection", kind: "message", T: () => TSPMessages_7.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.Reference document_selection */ 1:
                    message.documentSelection = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.documentSelection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.Reference document_selection = 1; */
        if (message.documentSelection)
            TSPMessages_7.Reference.internalBinaryWrite(message.documentSelection, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.DocumentSelectionTransformerArchive
 */
exports.DocumentSelectionTransformerArchive = new DocumentSelectionTransformerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NoteCanvasSelectionTransformerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.NoteCanvasSelectionTransformerArchive", [
            { no: 1, name: "transformer_helper", kind: "message", T: () => TSDCommandArchives_3.InfoCollectionSelectionTransformerHelperArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoCollectionSelectionTransformerHelperArchive transformer_helper */ 1:
                    message.transformerHelper = TSDCommandArchives_3.InfoCollectionSelectionTransformerHelperArchive.internalBinaryRead(reader, reader.uint32(), options, message.transformerHelper);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoCollectionSelectionTransformerHelperArchive transformer_helper = 1; */
        if (message.transformerHelper)
            TSDCommandArchives_3.InfoCollectionSelectionTransformerHelperArchive.internalBinaryWrite(message.transformerHelper, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.NoteCanvasSelectionTransformerArchive
 */
exports.NoteCanvasSelectionTransformerArchive = new NoteCanvasSelectionTransformerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OutlineCanvasSelectionTransformerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.OutlineCanvasSelectionTransformerArchive", [
            { no: 1, name: "canvas_selection_transformer", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 2, name: "storage_uuid_path", kind: "message", T: () => TSPMessages_4.UUIDPath }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.Reference canvas_selection_transformer */ 1:
                    message.canvasSelectionTransformer = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.canvasSelectionTransformer);
                    break;
                case /* optional TSP.UUIDPath storage_uuid_path */ 2:
                    message.storageUuidPath = TSPMessages_4.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.storageUuidPath);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.Reference canvas_selection_transformer = 1; */
        if (message.canvasSelectionTransformer)
            TSPMessages_7.Reference.internalBinaryWrite(message.canvasSelectionTransformer, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDPath storage_uuid_path = 2; */
        if (message.storageUuidPath)
            TSPMessages_4.UUIDPath.internalBinaryWrite(message.storageUuidPath, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.OutlineCanvasSelectionTransformerArchive
 */
exports.OutlineCanvasSelectionTransformerArchive = new OutlineCanvasSelectionTransformerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SlideCollectionSelectionTransformerHelperArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.SlideCollectionSelectionTransformerHelperArchive", [
            { no: 1, name: "slide_nodes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUIDPath },
            { no: 2, name: "slide_node_to_edit", kind: "message", T: () => TSPMessages_4.UUIDPath },
            { no: 3, name: "slide_collection_is_theme", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "previous_primary_selected_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { slideNodes: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.UUIDPath slide_nodes */ 1:
                    message.slideNodes.push(TSPMessages_4.UUIDPath.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.UUIDPath slide_node_to_edit */ 2:
                    message.slideNodeToEdit = TSPMessages_4.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.slideNodeToEdit);
                    break;
                case /* optional bool slide_collection_is_theme */ 3:
                    message.slideCollectionIsTheme = reader.bool();
                    break;
                case /* optional uint32 previous_primary_selected_index */ 4:
                    message.previousPrimarySelectedIndex = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.UUIDPath slide_nodes = 1; */
        for (let i = 0; i < message.slideNodes.length; i++)
            TSPMessages_4.UUIDPath.internalBinaryWrite(message.slideNodes[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDPath slide_node_to_edit = 2; */
        if (message.slideNodeToEdit)
            TSPMessages_4.UUIDPath.internalBinaryWrite(message.slideNodeToEdit, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool slide_collection_is_theme = 3; */
        if (message.slideCollectionIsTheme !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.slideCollectionIsTheme);
        /* optional uint32 previous_primary_selected_index = 4; */
        if (message.previousPrimarySelectedIndex !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.previousPrimarySelectedIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.SlideCollectionSelectionTransformerHelperArchive
 */
exports.SlideCollectionSelectionTransformerHelperArchive = new SlideCollectionSelectionTransformerHelperArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SlideCollectionSelectionTransformerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.SlideCollectionSelectionTransformerArchive", [
            { no: 1, name: "transformer_helper", kind: "message", T: () => exports.SlideCollectionSelectionTransformerHelperArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* KN.SlideCollectionSelectionTransformerHelperArchive transformer_helper */ 1:
                    message.transformerHelper = exports.SlideCollectionSelectionTransformerHelperArchive.internalBinaryRead(reader, reader.uint32(), options, message.transformerHelper);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* KN.SlideCollectionSelectionTransformerHelperArchive transformer_helper = 1; */
        if (message.transformerHelper)
            exports.SlideCollectionSelectionTransformerHelperArchive.internalBinaryWrite(message.transformerHelper, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.SlideCollectionSelectionTransformerArchive
 */
exports.SlideCollectionSelectionTransformerArchive = new SlideCollectionSelectionTransformerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OutlineSelectionTransformerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.OutlineSelectionTransformerArchive", [
            { no: 1, name: "transformer_helper", kind: "message", T: () => exports.SlideCollectionSelectionTransformerHelperArchive },
            { no: 2, name: "can_have_range_in_selected_paragraph", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "selection_range_addresses", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSKArchives_1.RangeAddress }
        ]);
    }
    create(value) {
        const message = { selectionRangeAddresses: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* KN.SlideCollectionSelectionTransformerHelperArchive transformer_helper */ 1:
                    message.transformerHelper = exports.SlideCollectionSelectionTransformerHelperArchive.internalBinaryRead(reader, reader.uint32(), options, message.transformerHelper);
                    break;
                case /* optional bool can_have_range_in_selected_paragraph */ 2:
                    message.canHaveRangeInSelectedParagraph = reader.bool();
                    break;
                case /* repeated TSK.RangeAddress selection_range_addresses */ 3:
                    message.selectionRangeAddresses.push(TSKArchives_1.RangeAddress.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* KN.SlideCollectionSelectionTransformerHelperArchive transformer_helper = 1; */
        if (message.transformerHelper)
            exports.SlideCollectionSelectionTransformerHelperArchive.internalBinaryWrite(message.transformerHelper, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool can_have_range_in_selected_paragraph = 2; */
        if (message.canHaveRangeInSelectedParagraph !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.canHaveRangeInSelectedParagraph);
        /* repeated TSK.RangeAddress selection_range_addresses = 3; */
        for (let i = 0; i < message.selectionRangeAddresses.length; i++)
            TSKArchives_1.RangeAddress.internalBinaryWrite(message.selectionRangeAddresses[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.OutlineSelectionTransformerArchive
 */
exports.OutlineSelectionTransformerArchive = new OutlineSelectionTransformerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandLiveVideoInfoApplyPreset$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandLiveVideoInfoApplyPreset", [
            { no: 1, name: "super", kind: "message", T: () => TSDCommandArchives_2.BaseApplyPresetCommandArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.BaseApplyPresetCommandArchive super */ 1:
                    message.super = TSDCommandArchives_2.BaseApplyPresetCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.BaseApplyPresetCommandArchive super = 1; */
        if (message.super)
            TSDCommandArchives_2.BaseApplyPresetCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandLiveVideoInfoApplyPreset
 */
exports.CommandLiveVideoInfoApplyPreset = new CommandLiveVideoInfoApplyPreset$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandLiveVideoInfoSetSource$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandLiveVideoInfoSetSource", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "live_video_info_id_path", kind: "message", T: () => TSPMessages_4.UUIDPath },
            { no: 3, name: "source_id", kind: "message", T: () => TSPMessages_5.UUID },
            { no: 4, name: "local_collaboration_command_usage_token", kind: "message", T: () => TSPMessages_5.UUID },
            { no: 5, name: "working_source_old_collaboration_command_usage_state", kind: "message", T: () => KNArchives_2.LiveVideoSourceCollaborationCommandUsageState },
            { no: 6, name: "old_source", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 7, name: "old_source_id", kind: "message", T: () => TSPMessages_5.UUID }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUIDPath live_video_info_id_path */ 2:
                    message.liveVideoInfoIdPath = TSPMessages_4.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.liveVideoInfoIdPath);
                    break;
                case /* optional TSP.UUID source_id */ 3:
                    message.sourceId = TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options, message.sourceId);
                    break;
                case /* optional TSP.UUID local_collaboration_command_usage_token */ 4:
                    message.localCollaborationCommandUsageToken = TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options, message.localCollaborationCommandUsageToken);
                    break;
                case /* optional KN.LiveVideoSourceCollaborationCommandUsageState working_source_old_collaboration_command_usage_state */ 5:
                    message.workingSourceOldCollaborationCommandUsageState = KNArchives_2.LiveVideoSourceCollaborationCommandUsageState.internalBinaryRead(reader, reader.uint32(), options, message.workingSourceOldCollaborationCommandUsageState);
                    break;
                case /* optional TSP.Reference old_source */ 6:
                    message.oldSource = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.oldSource);
                    break;
                case /* optional TSP.UUID old_source_id */ 7:
                    message.oldSourceId = TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options, message.oldSourceId);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUIDPath live_video_info_id_path = 2; */
        if (message.liveVideoInfoIdPath)
            TSPMessages_4.UUIDPath.internalBinaryWrite(message.liveVideoInfoIdPath, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID source_id = 3; */
        if (message.sourceId)
            TSPMessages_5.UUID.internalBinaryWrite(message.sourceId, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID local_collaboration_command_usage_token = 4; */
        if (message.localCollaborationCommandUsageToken)
            TSPMessages_5.UUID.internalBinaryWrite(message.localCollaborationCommandUsageToken, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional KN.LiveVideoSourceCollaborationCommandUsageState working_source_old_collaboration_command_usage_state = 5; */
        if (message.workingSourceOldCollaborationCommandUsageState)
            KNArchives_2.LiveVideoSourceCollaborationCommandUsageState.internalBinaryWrite(message.workingSourceOldCollaborationCommandUsageState, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference old_source = 6; */
        if (message.oldSource)
            TSPMessages_7.Reference.internalBinaryWrite(message.oldSource, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID old_source_id = 7; */
        if (message.oldSourceId)
            TSPMessages_5.UUID.internalBinaryWrite(message.oldSourceId, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandLiveVideoInfoSetSource
 */
exports.CommandLiveVideoInfoSetSource = new CommandLiveVideoInfoSetSource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandLiveVideoInfoSetValue$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandLiveVideoInfoSetValue", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "live_video_info_id_path", kind: "message", T: () => TSPMessages_4.UUIDPath },
            { no: 3, name: "property", kind: "enum", T: () => ["KN.CommandLiveVideoInfoSetValue.Property", CommandLiveVideoInfoSetValue_Property] },
            { no: 4, name: "value", kind: "message", T: () => exports.CommandLiveVideoInfoSetValue_PropertyValue },
            { no: 5, name: "old_value", kind: "message", T: () => exports.CommandLiveVideoInfoSetValue_PropertyValue }
        ]);
    }
    create(value) {
        const message = { property: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUIDPath live_video_info_id_path */ 2:
                    message.liveVideoInfoIdPath = TSPMessages_4.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.liveVideoInfoIdPath);
                    break;
                case /* KN.CommandLiveVideoInfoSetValue.Property property */ 3:
                    message.property = reader.int32();
                    break;
                case /* optional KN.CommandLiveVideoInfoSetValue.PropertyValue value */ 4:
                    message.value = exports.CommandLiveVideoInfoSetValue_PropertyValue.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                case /* optional KN.CommandLiveVideoInfoSetValue.PropertyValue old_value */ 5:
                    message.oldValue = exports.CommandLiveVideoInfoSetValue_PropertyValue.internalBinaryRead(reader, reader.uint32(), options, message.oldValue);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUIDPath live_video_info_id_path = 2; */
        if (message.liveVideoInfoIdPath)
            TSPMessages_4.UUIDPath.internalBinaryWrite(message.liveVideoInfoIdPath, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* KN.CommandLiveVideoInfoSetValue.Property property = 3; */
        if (message.property !== 0)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.property);
        /* optional KN.CommandLiveVideoInfoSetValue.PropertyValue value = 4; */
        if (message.value)
            exports.CommandLiveVideoInfoSetValue_PropertyValue.internalBinaryWrite(message.value, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional KN.CommandLiveVideoInfoSetValue.PropertyValue old_value = 5; */
        if (message.oldValue)
            exports.CommandLiveVideoInfoSetValue_PropertyValue.internalBinaryWrite(message.oldValue, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandLiveVideoInfoSetValue
 */
exports.CommandLiveVideoInfoSetValue = new CommandLiveVideoInfoSetValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandLiveVideoInfoSetValue_PropertyValue$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandLiveVideoInfoSetValue.PropertyValue", [
            { no: 1, name: "scale", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "normalized_offset", kind: "message", T: () => TSPMessages_1.Point },
            { no: 3, name: "mask_kind", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "mask_corner_radius", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "is_placeholder", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "background_kind", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "background_fill", kind: "message", T: () => TSDArchives_2.FillArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double scale */ 1:
                    message.scale = reader.double();
                    break;
                case /* optional TSP.Point normalized_offset */ 2:
                    message.normalizedOffset = TSPMessages_1.Point.internalBinaryRead(reader, reader.uint32(), options, message.normalizedOffset);
                    break;
                case /* optional int32 mask_kind */ 3:
                    message.maskKind = reader.int32();
                    break;
                case /* optional double mask_corner_radius */ 4:
                    message.maskCornerRadius = reader.double();
                    break;
                case /* optional bool is_placeholder */ 5:
                    message.isPlaceholder = reader.bool();
                    break;
                case /* optional int32 background_kind */ 6:
                    message.backgroundKind = reader.int32();
                    break;
                case /* optional TSD.FillArchive background_fill */ 7:
                    message.backgroundFill = TSDArchives_2.FillArchive.internalBinaryRead(reader, reader.uint32(), options, message.backgroundFill);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional double scale = 1; */
        if (message.scale !== undefined)
            writer.tag(1, runtime_1.WireType.Bit64).double(message.scale);
        /* optional TSP.Point normalized_offset = 2; */
        if (message.normalizedOffset)
            TSPMessages_1.Point.internalBinaryWrite(message.normalizedOffset, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional int32 mask_kind = 3; */
        if (message.maskKind !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.maskKind);
        /* optional double mask_corner_radius = 4; */
        if (message.maskCornerRadius !== undefined)
            writer.tag(4, runtime_1.WireType.Bit64).double(message.maskCornerRadius);
        /* optional bool is_placeholder = 5; */
        if (message.isPlaceholder !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.isPlaceholder);
        /* optional int32 background_kind = 6; */
        if (message.backgroundKind !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).int32(message.backgroundKind);
        /* optional TSD.FillArchive background_fill = 7; */
        if (message.backgroundFill)
            TSDArchives_2.FillArchive.internalBinaryWrite(message.backgroundFill, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandLiveVideoInfoSetValue.PropertyValue
 */
exports.CommandLiveVideoInfoSetValue_PropertyValue = new CommandLiveVideoInfoSetValue_PropertyValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandLiveVideoSourceSetValue$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandLiveVideoSourceSetValue", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "live_video_source_id", kind: "message", T: () => TSPMessages_5.UUID },
            { no: 3, name: "property", kind: "enum", T: () => ["KN.CommandLiveVideoSourceSetValue.Property", CommandLiveVideoSourceSetValue_Property] },
            { no: 4, name: "value", kind: "message", T: () => exports.CommandLiveVideoSourceSetValue_PropertyValue },
            { no: 5, name: "old_value", kind: "message", T: () => exports.CommandLiveVideoSourceSetValue_PropertyValue }
        ]);
    }
    create(value) {
        const message = { property: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUID live_video_source_id */ 2:
                    message.liveVideoSourceId = TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options, message.liveVideoSourceId);
                    break;
                case /* KN.CommandLiveVideoSourceSetValue.Property property */ 3:
                    message.property = reader.int32();
                    break;
                case /* optional KN.CommandLiveVideoSourceSetValue.PropertyValue value */ 4:
                    message.value = exports.CommandLiveVideoSourceSetValue_PropertyValue.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                case /* optional KN.CommandLiveVideoSourceSetValue.PropertyValue old_value */ 5:
                    message.oldValue = exports.CommandLiveVideoSourceSetValue_PropertyValue.internalBinaryRead(reader, reader.uint32(), options, message.oldValue);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID live_video_source_id = 2; */
        if (message.liveVideoSourceId)
            TSPMessages_5.UUID.internalBinaryWrite(message.liveVideoSourceId, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* KN.CommandLiveVideoSourceSetValue.Property property = 3; */
        if (message.property !== 0)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.property);
        /* optional KN.CommandLiveVideoSourceSetValue.PropertyValue value = 4; */
        if (message.value)
            exports.CommandLiveVideoSourceSetValue_PropertyValue.internalBinaryWrite(message.value, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional KN.CommandLiveVideoSourceSetValue.PropertyValue old_value = 5; */
        if (message.oldValue)
            exports.CommandLiveVideoSourceSetValue_PropertyValue.internalBinaryWrite(message.oldValue, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandLiveVideoSourceSetValue
 */
exports.CommandLiveVideoSourceSetValue = new CommandLiveVideoSourceSetValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandLiveVideoSourceSetValue_PropertyValue$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandLiveVideoSourceSetValue.PropertyValue", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "capture_device_description", kind: "message", T: () => KNArchives_1.LiveVideoCaptureDeviceDescription },
            { no: 3, name: "poster_image_data", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 4, name: "symbol_abbreviation_text", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "symbol_image_identifier", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "symbol_tint_color_identifier", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional KN.LiveVideoCaptureDeviceDescription capture_device_description */ 2:
                    message.captureDeviceDescription = KNArchives_1.LiveVideoCaptureDeviceDescription.internalBinaryRead(reader, reader.uint32(), options, message.captureDeviceDescription);
                    break;
                case /* optional TSP.DataReference poster_image_data */ 3:
                    message.posterImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.posterImageData);
                    break;
                case /* optional string symbol_abbreviation_text */ 4:
                    message.symbolAbbreviationText = reader.string();
                    break;
                case /* optional int32 symbol_image_identifier */ 5:
                    message.symbolImageIdentifier = reader.int32();
                    break;
                case /* optional int32 symbol_tint_color_identifier */ 6:
                    message.symbolTintColorIdentifier = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* optional KN.LiveVideoCaptureDeviceDescription capture_device_description = 2; */
        if (message.captureDeviceDescription)
            KNArchives_1.LiveVideoCaptureDeviceDescription.internalBinaryWrite(message.captureDeviceDescription, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference poster_image_data = 3; */
        if (message.posterImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.posterImageData, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string symbol_abbreviation_text = 4; */
        if (message.symbolAbbreviationText !== undefined)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.symbolAbbreviationText);
        /* optional int32 symbol_image_identifier = 5; */
        if (message.symbolImageIdentifier !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).int32(message.symbolImageIdentifier);
        /* optional int32 symbol_tint_color_identifier = 6; */
        if (message.symbolTintColorIdentifier !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).int32(message.symbolTintColorIdentifier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandLiveVideoSourceSetValue.PropertyValue
 */
exports.CommandLiveVideoSourceSetValue_PropertyValue = new CommandLiveVideoSourceSetValue_PropertyValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandLiveVideoStyleSetValue$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandLiveVideoStyleSetValue", [
            { no: 1, name: "super", kind: "message", T: () => TSDCommandArchives_1.BaseStyleSetValueCommandArchive },
            { no: 2, name: "change", kind: "message", T: () => TSDArchives_sos_1.MediaStylePropertyChangeSetArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.BaseStyleSetValueCommandArchive super */ 1:
                    message.super = TSDCommandArchives_1.BaseStyleSetValueCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSDSOS.MediaStylePropertyChangeSetArchive change */ 2:
                    message.change = TSDArchives_sos_1.MediaStylePropertyChangeSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.change);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.BaseStyleSetValueCommandArchive super = 1; */
        if (message.super)
            TSDCommandArchives_1.BaseStyleSetValueCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSDSOS.MediaStylePropertyChangeSetArchive change = 2; */
        if (message.change)
            TSDArchives_sos_1.MediaStylePropertyChangeSetArchive.internalBinaryWrite(message.change, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandLiveVideoStyleSetValue
 */
exports.CommandLiveVideoStyleSetValue = new CommandLiveVideoStyleSetValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandThemeAddLiveVideoSource$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandThemeAddLiveVideoSource", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "live_video_source", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 3, name: "is_implicit", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference live_video_source */ 2:
                    message.liveVideoSource = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.liveVideoSource);
                    break;
                case /* optional bool is_implicit */ 3:
                    message.isImplicit = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference live_video_source = 2; */
        if (message.liveVideoSource)
            TSPMessages_7.Reference.internalBinaryWrite(message.liveVideoSource, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_implicit = 3; */
        if (message.isImplicit !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.isImplicit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandThemeAddLiveVideoSource
 */
exports.CommandThemeAddLiveVideoSource = new CommandThemeAddLiveVideoSource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandThemeRemoveLiveVideoSource$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandThemeRemoveLiveVideoSource", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "live_video_source_id", kind: "message", T: () => TSPMessages_5.UUID },
            { no: 3, name: "is_implicit", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "removed_live_video_source", kind: "message", T: () => TSPMessages_7.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUID live_video_source_id */ 2:
                    message.liveVideoSourceId = TSPMessages_5.UUID.internalBinaryRead(reader, reader.uint32(), options, message.liveVideoSourceId);
                    break;
                case /* optional bool is_implicit */ 3:
                    message.isImplicit = reader.bool();
                    break;
                case /* optional TSP.Reference removed_live_video_source */ 4:
                    message.removedLiveVideoSource = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.removedLiveVideoSource);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID live_video_source_id = 2; */
        if (message.liveVideoSourceId)
            TSPMessages_5.UUID.internalBinaryWrite(message.liveVideoSourceId, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_implicit = 3; */
        if (message.isImplicit !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.isImplicit);
        /* optional TSP.Reference removed_live_video_source = 4; */
        if (message.removedLiveVideoSource)
            TSPMessages_7.Reference.internalBinaryWrite(message.removedLiveVideoSource, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandThemeRemoveLiveVideoSource
 */
exports.CommandThemeRemoveLiveVideoSource = new CommandThemeRemoveLiveVideoSource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandMotionBackgroundStyleSetValueArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandMotionBackgroundStyleSetValueArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 4, name: "slide_id_path", kind: "message", T: () => TSPMessages_4.UUIDPath },
            { no: 2, name: "old_style", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 5, name: "old_slide_style", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 3, name: "change", kind: "message", T: () => KNArchives_sos_1.MotionBackgroundStylePropertyChangeSetArchive },
            { no: 6, name: "undo_property_change", kind: "message", T: () => KNArchives_sos_1.MotionBackgroundStylePropertyChangeSetArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUIDPath slide_id_path */ 4:
                    message.slideIdPath = TSPMessages_4.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.slideIdPath);
                    break;
                case /* optional TSP.Reference old_style */ 2:
                    message.oldStyle = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.oldStyle);
                    break;
                case /* optional TSP.Reference old_slide_style */ 5:
                    message.oldSlideStyle = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.oldSlideStyle);
                    break;
                case /* optional KNSOS.MotionBackgroundStylePropertyChangeSetArchive change */ 3:
                    message.change = KNArchives_sos_1.MotionBackgroundStylePropertyChangeSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.change);
                    break;
                case /* optional KNSOS.MotionBackgroundStylePropertyChangeSetArchive undo_property_change */ 6:
                    message.undoPropertyChange = KNArchives_sos_1.MotionBackgroundStylePropertyChangeSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.undoPropertyChange);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUIDPath slide_id_path = 4; */
        if (message.slideIdPath)
            TSPMessages_4.UUIDPath.internalBinaryWrite(message.slideIdPath, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference old_style = 2; */
        if (message.oldStyle)
            TSPMessages_7.Reference.internalBinaryWrite(message.oldStyle, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference old_slide_style = 5; */
        if (message.oldSlideStyle)
            TSPMessages_7.Reference.internalBinaryWrite(message.oldSlideStyle, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional KNSOS.MotionBackgroundStylePropertyChangeSetArchive change = 3; */
        if (message.change)
            KNArchives_sos_1.MotionBackgroundStylePropertyChangeSetArchive.internalBinaryWrite(message.change, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional KNSOS.MotionBackgroundStylePropertyChangeSetArchive undo_property_change = 6; */
        if (message.undoPropertyChange)
            KNArchives_sos_1.MotionBackgroundStylePropertyChangeSetArchive.internalBinaryWrite(message.undoPropertyChange, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandMotionBackgroundStyleSetValueArchive
 */
exports.CommandMotionBackgroundStyleSetValueArchive = new CommandMotionBackgroundStyleSetValueArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandMotionBackgroundStyleUpdatePosterFrameDataArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("KN.CommandMotionBackgroundStyleUpdatePosterFrameDataArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "motion_background_style", kind: "message", T: () => TSPMessages_7.Reference },
            { no: 3, name: "poster_image_data", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 4, name: "old_poster_image_data", kind: "message", T: () => TSPMessages_2.DataReference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference motion_background_style */ 2:
                    message.motionBackgroundStyle = TSPMessages_7.Reference.internalBinaryRead(reader, reader.uint32(), options, message.motionBackgroundStyle);
                    break;
                case /* optional TSP.DataReference poster_image_data */ 3:
                    message.posterImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.posterImageData);
                    break;
                case /* optional TSP.DataReference old_poster_image_data */ 4:
                    message.oldPosterImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.oldPosterImageData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference motion_background_style = 2; */
        if (message.motionBackgroundStyle)
            TSPMessages_7.Reference.internalBinaryWrite(message.motionBackgroundStyle, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference poster_image_data = 3; */
        if (message.posterImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.posterImageData, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference old_poster_image_data = 4; */
        if (message.oldPosterImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.oldPosterImageData, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message KN.CommandMotionBackgroundStyleUpdatePosterFrameDataArchive
 */
exports.CommandMotionBackgroundStyleUpdatePosterFrameDataArchive = new CommandMotionBackgroundStyleUpdatePosterFrameDataArchive$Type();
//# sourceMappingURL=KNCommandArchives.js.map