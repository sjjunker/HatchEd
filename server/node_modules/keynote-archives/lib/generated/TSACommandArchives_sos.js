"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VerifyTransformHistoryWithServerCommandArchive = exports.VerifyObjectsWithServerCommandArchive = exports.VerifyDrawableZOrdersWithServerCommandArchive = exports.VerifyDocumentWithServerCommandArchive = exports.VerifyActivityStreamWithServerCommandArchive = exports.CommandReapplyMasterArchive = exports.PropagateMasterChangeCommandArchive = exports.InducedVerifyDrawableZOrdersWithServerCommandArchive = void 0;
const runtime_1 = require("@protobuf-ts/runtime");
const runtime_2 = require("@protobuf-ts/runtime");
const runtime_3 = require("@protobuf-ts/runtime");
const runtime_4 = require("@protobuf-ts/runtime");
const runtime_5 = require("@protobuf-ts/runtime");
const TSPMessages_1 = require("./TSPMessages");
const TSAArchives_sos_1 = require("./TSAArchives_sos");
const TSKArchives_1 = require("./TSKArchives");
// @generated message type with reflection information, may provide speed optimized methods
class InducedVerifyDrawableZOrdersWithServerCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSASOS.InducedVerifyDrawableZOrdersWithServerCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_1.CommandArchive },
            { no: 2, name: "server_drawable_z_order_lists", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSAArchives_sos_1.DrawableZOrderListArchive },
            { no: 3, name: "server_drawable_z_order_lists_undefined", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { serverDrawableZOrderLists: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_1.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSASOS.DrawableZOrderListArchive server_drawable_z_order_lists */ 2:
                    message.serverDrawableZOrderLists.push(TSAArchives_sos_1.DrawableZOrderListArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool server_drawable_z_order_lists_undefined */ 3:
                    message.serverDrawableZOrderListsUndefined = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_1.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSASOS.DrawableZOrderListArchive server_drawable_z_order_lists = 2; */
        for (let i = 0; i < message.serverDrawableZOrderLists.length; i++)
            TSAArchives_sos_1.DrawableZOrderListArchive.internalBinaryWrite(message.serverDrawableZOrderLists[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool server_drawable_z_order_lists_undefined = 3; */
        if (message.serverDrawableZOrderListsUndefined !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.serverDrawableZOrderListsUndefined);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSASOS.InducedVerifyDrawableZOrdersWithServerCommandArchive
 */
exports.InducedVerifyDrawableZOrdersWithServerCommandArchive = new InducedVerifyDrawableZOrdersWithServerCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PropagateMasterChangeCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSASOS.PropagateMasterChangeCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_1.CommandArchive },
            { no: 2, name: "uuids_of_previously_visited_objects", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_1.UUID },
            { no: 3, name: "uuids_of_previously_visited_objects_undefined", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { uuidsOfPreviouslyVisitedObjects: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_1.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSP.UUID uuids_of_previously_visited_objects */ 2:
                    message.uuidsOfPreviouslyVisitedObjects.push(TSPMessages_1.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool uuids_of_previously_visited_objects_undefined */ 3:
                    message.uuidsOfPreviouslyVisitedObjectsUndefined = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_1.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID uuids_of_previously_visited_objects = 2; */
        for (let i = 0; i < message.uuidsOfPreviouslyVisitedObjects.length; i++)
            TSPMessages_1.UUID.internalBinaryWrite(message.uuidsOfPreviouslyVisitedObjects[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool uuids_of_previously_visited_objects_undefined = 3; */
        if (message.uuidsOfPreviouslyVisitedObjectsUndefined !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.uuidsOfPreviouslyVisitedObjectsUndefined);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSASOS.PropagateMasterChangeCommandArchive
 */
exports.PropagateMasterChangeCommandArchive = new PropagateMasterChangeCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandReapplyMasterArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSASOS.CommandReapplyMasterArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_1.CommandArchive },
            { no: 2, name: "items_to_visit", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_1.UUID },
            { no: 3, name: "items_to_visit_undefined", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "is_undo", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { itemsToVisit: [], isUndo: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_1.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSP.UUID items_to_visit */ 2:
                    message.itemsToVisit.push(TSPMessages_1.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool items_to_visit_undefined */ 3:
                    message.itemsToVisitUndefined = reader.bool();
                    break;
                case /* bool is_undo */ 4:
                    message.isUndo = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_1.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID items_to_visit = 2; */
        for (let i = 0; i < message.itemsToVisit.length; i++)
            TSPMessages_1.UUID.internalBinaryWrite(message.itemsToVisit[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool items_to_visit_undefined = 3; */
        if (message.itemsToVisitUndefined !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.itemsToVisitUndefined);
        /* bool is_undo = 4; */
        if (message.isUndo !== false)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.isUndo);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSASOS.CommandReapplyMasterArchive
 */
exports.CommandReapplyMasterArchive = new CommandReapplyMasterArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VerifyActivityStreamWithServerCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSASOS.VerifyActivityStreamWithServerCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_1.CommandArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_1.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_1.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSASOS.VerifyActivityStreamWithServerCommandArchive
 */
exports.VerifyActivityStreamWithServerCommandArchive = new VerifyActivityStreamWithServerCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VerifyDocumentWithServerCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSASOS.VerifyDocumentWithServerCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_1.CommandArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_1.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_1.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSASOS.VerifyDocumentWithServerCommandArchive
 */
exports.VerifyDocumentWithServerCommandArchive = new VerifyDocumentWithServerCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VerifyDrawableZOrdersWithServerCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSASOS.VerifyDrawableZOrdersWithServerCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_1.CommandArchive },
            { no: 2, name: "drawable_id_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_1.UUID },
            { no: 3, name: "drawable_id_list_undefined", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { drawableIdList: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_1.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSP.UUID drawable_id_list */ 2:
                    message.drawableIdList.push(TSPMessages_1.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool drawable_id_list_undefined */ 3:
                    message.drawableIdListUndefined = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_1.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID drawable_id_list = 2; */
        for (let i = 0; i < message.drawableIdList.length; i++)
            TSPMessages_1.UUID.internalBinaryWrite(message.drawableIdList[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool drawable_id_list_undefined = 3; */
        if (message.drawableIdListUndefined !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.drawableIdListUndefined);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSASOS.VerifyDrawableZOrdersWithServerCommandArchive
 */
exports.VerifyDrawableZOrdersWithServerCommandArchive = new VerifyDrawableZOrdersWithServerCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VerifyObjectsWithServerCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSASOS.VerifyObjectsWithServerCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_1.CommandArchive },
            { no: 2, name: "object_id_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_1.UUID },
            { no: 3, name: "object_id_list_undefined", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { objectIdList: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_1.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSP.UUID object_id_list */ 2:
                    message.objectIdList.push(TSPMessages_1.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool object_id_list_undefined */ 3:
                    message.objectIdListUndefined = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_1.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID object_id_list = 2; */
        for (let i = 0; i < message.objectIdList.length; i++)
            TSPMessages_1.UUID.internalBinaryWrite(message.objectIdList[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool object_id_list_undefined = 3; */
        if (message.objectIdListUndefined !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.objectIdListUndefined);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSASOS.VerifyObjectsWithServerCommandArchive
 */
exports.VerifyObjectsWithServerCommandArchive = new VerifyObjectsWithServerCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VerifyTransformHistoryWithServerCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSASOS.VerifyTransformHistoryWithServerCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_1.CommandArchive },
            { no: 2, name: "sequence_start", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "sequence_end", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = { sequenceStart: 0, sequenceEnd: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_1.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* int32 sequence_start */ 2:
                    message.sequenceStart = reader.int32();
                    break;
                case /* int32 sequence_end */ 3:
                    message.sequenceEnd = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_1.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* int32 sequence_start = 2; */
        if (message.sequenceStart !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.sequenceStart);
        /* int32 sequence_end = 3; */
        if (message.sequenceEnd !== 0)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.sequenceEnd);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSASOS.VerifyTransformHistoryWithServerCommandArchive
 */
exports.VerifyTransformHistoryWithServerCommandArchive = new VerifyTransformHistoryWithServerCommandArchive$Type();
//# sourceMappingURL=TSACommandArchives_sos.js.map