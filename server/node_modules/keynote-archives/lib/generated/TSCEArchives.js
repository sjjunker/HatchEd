"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RangeDependenciesArchive = exports.RangeBackDependencyArchive = exports.RTreeArchive = exports.RTreeNodeArchive = exports.RTreeLeafNodeContentsArchive = exports.RTreeInternalNodeContentsArchive = exports.VolatileDependenciesExpandedArchive = exports.VolatileDependenciesArchive = exports.CellDependenciesTiledArchive = exports.CellRecordTileArchive = exports.CellDependenciesExpandedArchive = exports.CellRecordExpandedArchive = exports.CellDependenciesArchive = exports.CellRecordArchive = exports.ExpandedEdgesArchive = exports.EdgesArchive = exports.EdgeArchive = exports.ReferenceArchive = exports.CoordMapperArchive_SummaryToViewEntry = exports.CoordMapperArchive_BaseToViewEntry = exports.CoordMapperArchive = exports.ReferencesToDirtyArchive = exports.UidCellRefSetArchive_OwnerEntry = exports.UidCellRefSetArchive = exports.UidCoordSetArchive_ColumnEntry = exports.UidCoordSetArchive = exports.CellRefSetArchive_OwnerEntry = exports.CellRefSetArchive = exports.CellRectArchive = exports.ColumnRowSize = exports.InternalCellRefSetArchive_OwnerEntry = exports.InternalCellRefSetArchive = exports.CellCoordSetArchive_ColumnEntry = exports.CellCoordSetArchive = exports.IndexSetArchive_IndexSetEntry = exports.IndexSetArchive = exports.InternalRangeReferenceArchive = exports.RangeReferenceArchive = exports.RelativeCellRefArchive = exports.InternalCellReferenceArchive = exports.CellReferenceArchive = exports.CellValueArchive_CellValueType = exports.GroupByChangeArchive_ChangeType = exports.ASTNodeArrayArchive_ASTUidTractPurpose = exports.ASTNodeArrayArchive_ASTNodeType = exports.CalculationEngineArchive_ExcelImportDateMode = exports.CellErrorsArchive_ErrorFlavor = exports.SpanningDependenciesExpandedArchive_RangeContext = exports.SpanningDependenciesArchive_RangeContext = exports.ReferenceArchive_ReferenceType = void 0;
exports.ASTNodeArrayArchive_ASTRowCoordinateArchive = exports.ASTNodeArrayArchive_ASTColumnCoordinateArchive = exports.ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive = exports.ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive = exports.ASTNodeArrayArchive = exports.CategoryReferenceArchive_CatRefUidList = exports.CategoryReferenceArchive = exports.PreserveColumnRowFlagsArchive = exports.CalculationEngineArchive = exports.GroupByNodeMapArchive_GroupNodesForGroupBy = exports.GroupByNodeMapArchive_CellRefsForGroupNode = exports.GroupByNodeMapArchive = exports.UuidReferenceMapArchive_CellRefsForUuid = exports.UuidReferenceMapArchive = exports.UuidSetStoreArchive_UuidSet = exports.UuidSetStoreArchive = exports.NamedReferenceManagerArchive = exports.NamesByTrackedReferenceArchive = exports.NameTrackedReferencePair = exports.RemoteDataStoreArchive = exports.StockArchive_AttributeEntry = exports.StockArchive = exports.RemoteDataValueMapArchive_RemoteDataMapEntry = exports.RemoteDataValueMapArchive = exports.RemoteDataSpecifierArchive = exports.DependencyTrackerArchive = exports.UidLookupListArchive = exports.OwnerIDMapArchive_OwnerIDMapArchiveEntry = exports.OwnerIDMapArchive = exports.SubFormulaOwnerIDArchive = exports.FormulaOwnerInfoArchive = exports.FormulaOwnerDependenciesArchive = exports.UuidReferencesArchive_TableWithUuidRef = exports.UuidReferencesArchive_UuidRef = exports.UuidReferencesArchive_TableRef = exports.UuidReferencesArchive = exports.CellErrorsArchive_ErrorForCell = exports.CellErrorsArchive = exports.WholeOwnerDependenciesExpandedArchive = exports.WholeOwnerDependenciesArchive = exports.SpanningDependenciesExpandedArchive_CellCoordRefersToExtents = exports.SpanningDependenciesExpandedArchive_ExtentRangeWithTableWithContext = exports.SpanningDependenciesExpandedArchive_ExtentRange = exports.SpanningDependenciesExpandedArchive = exports.SpanningDependenciesArchive_ReferringColumnToRemoteCells = exports.SpanningDependenciesArchive_ReferringColumnToLocalCells = exports.SpanningDependenciesArchive = exports.RangeDependenciesTiledArchive = exports.RangePrecedentsTileArchive_FromToRangeArchive = exports.RangePrecedentsTileArchive = void 0;
exports.StringCellValueArchive = exports.NumberCellValueArchive = exports.DateCellValueArchive = exports.BooleanCellValueArchive = exports.ViewTractRefArchive = exports.TrackedReferenceStoreArchive = exports.ExpandedTrackedReferenceArchive = exports.TrackedReferenceArchive = exports.FormulaRewriteCommandArchive = exports.FormulasForUndoArchive = exports.FormulaCoordPairsByOwnerArchive = exports.FormulaAtCoordArchive = exports.ExpandedCellRefObjectMapArchive = exports.ExpandedCellRefObjectPairArchive = exports.CellCoordinateVectorArchive = exports.CellCoordinateArchive = exports.HauntedOwnerArchive = exports.MergeSourceArchive = exports.RegionMovedInfoArchive = exports.RegionInfoArchive = exports.ColumnOrRowUuidsInfoArchive = exports.RewriteRangeEntryArchive = exports.IndexedUidsArchive_IndexedUid = exports.IndexedUidsArchive = exports.RewriteGroupNodeUIDInfoArchive = exports.GroupByChangeArchive_GroupingColumnChangeArchive = exports.GroupByChangeArchive = exports.RewriteTableUIDInfoArchive_TableUIDMapEntryArchive = exports.RewriteTableUIDInfoArchive = exports.OwnerUIDMapperArchive = exports.MergeOriginMovedArchive = exports.TableTransposeInfoArchive = exports.RangeCoordinateArchive = exports.FormatStructArchive = exports.FunctorArchive = exports.FormulaArchive = exports.FormulaTranslationFlagsArchive = exports.ASTNodeArrayArchive_ASTNodeArchive = exports.ASTNodeArrayArchive_ASTLetNodeWhitespace = exports.ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive = exports.ASTNodeArrayArchive_ASTColonTractArchive_ASTColonTractAbsoluteRangeArchive = exports.ASTNodeArrayArchive_ASTColonTractArchive_ASTColonTractRelativeRangeArchive = exports.ASTNodeArrayArchive_ASTColonTractArchive = exports.ASTNodeArrayArchive_ASTCategoryReferenceArchive = exports.ASTNodeArrayArchive_ASTCategoryLevels = exports.ASTNodeArrayArchive_ASTUidCoordinateArchive = exports.ASTNodeArrayArchive_ASTUidTractList = exports.ASTNodeArrayArchive_ASTStickyBits = exports.ASTNodeArrayArchive_ASTUidTract = exports.ASTNodeArrayArchive_ASTUidList = void 0;
exports.CellValueArchive = exports.ErrorCellValueArchive = void 0;
const runtime_1 = require("@protobuf-ts/runtime");
const runtime_2 = require("@protobuf-ts/runtime");
const runtime_3 = require("@protobuf-ts/runtime");
const runtime_4 = require("@protobuf-ts/runtime");
const runtime_5 = require("@protobuf-ts/runtime");
const TSKArchives_1 = require("./TSKArchives");
const TSKArchives_2 = require("./TSKArchives");
const TSPMessages_1 = require("./TSPMessages");
const TSPMessages_2 = require("./TSPMessages");
const TSPMessages_3 = require("./TSPMessages");
const TSPMessages_4 = require("./TSPMessages");
/**
 * @generated from protobuf enum TSCE.ReferenceArchive.ReferenceType
 */
var ReferenceArchive_ReferenceType;
(function (ReferenceArchive_ReferenceType) {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    ReferenceArchive_ReferenceType[ReferenceArchive_ReferenceType["UNSPECIFIED$"] = 0] = "UNSPECIFIED$";
    /**
     * @generated from protobuf enum value: CELL_REFERENCE = 1;
     */
    ReferenceArchive_ReferenceType[ReferenceArchive_ReferenceType["CELL_REFERENCE"] = 1] = "CELL_REFERENCE";
    /**
     * @generated from protobuf enum value: RANGE_REFERENCE = 2;
     */
    ReferenceArchive_ReferenceType[ReferenceArchive_ReferenceType["RANGE_REFERENCE"] = 2] = "RANGE_REFERENCE";
    /**
     * @generated from protobuf enum value: NAME_DEPENDENCY = 3;
     */
    ReferenceArchive_ReferenceType[ReferenceArchive_ReferenceType["NAME_DEPENDENCY"] = 3] = "NAME_DEPENDENCY";
})(ReferenceArchive_ReferenceType = exports.ReferenceArchive_ReferenceType || (exports.ReferenceArchive_ReferenceType = {}));
/**
 * @generated from protobuf enum TSCE.SpanningDependenciesArchive.RangeContext
 */
var SpanningDependenciesArchive_RangeContext;
(function (SpanningDependenciesArchive_RangeContext) {
    /**
     * @generated from protobuf enum value: DEFAULT = 0;
     */
    SpanningDependenciesArchive_RangeContext[SpanningDependenciesArchive_RangeContext["DEFAULT"] = 0] = "DEFAULT";
    /**
     * @generated from protobuf enum value: INCLUDE_HEADERS = 1;
     */
    SpanningDependenciesArchive_RangeContext[SpanningDependenciesArchive_RangeContext["INCLUDE_HEADERS"] = 1] = "INCLUDE_HEADERS";
})(SpanningDependenciesArchive_RangeContext = exports.SpanningDependenciesArchive_RangeContext || (exports.SpanningDependenciesArchive_RangeContext = {}));
/**
 * @generated from protobuf enum TSCE.SpanningDependenciesExpandedArchive.RangeContext
 */
var SpanningDependenciesExpandedArchive_RangeContext;
(function (SpanningDependenciesExpandedArchive_RangeContext) {
    /**
     * @generated from protobuf enum value: DEFAULT = 0;
     */
    SpanningDependenciesExpandedArchive_RangeContext[SpanningDependenciesExpandedArchive_RangeContext["DEFAULT"] = 0] = "DEFAULT";
    /**
     * @generated from protobuf enum value: INCLUDE_HEADERS = 1;
     */
    SpanningDependenciesExpandedArchive_RangeContext[SpanningDependenciesExpandedArchive_RangeContext["INCLUDE_HEADERS"] = 1] = "INCLUDE_HEADERS";
})(SpanningDependenciesExpandedArchive_RangeContext = exports.SpanningDependenciesExpandedArchive_RangeContext || (exports.SpanningDependenciesExpandedArchive_RangeContext = {}));
/**
 * @generated from protobuf enum TSCE.CellErrorsArchive.ErrorFlavor
 */
var CellErrorsArchive_ErrorFlavor;
(function (CellErrorsArchive_ErrorFlavor) {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    CellErrorsArchive_ErrorFlavor[CellErrorsArchive_ErrorFlavor["NONE"] = 0] = "NONE";
    /**
     * @generated from protobuf enum value: ERROR = 1;
     */
    CellErrorsArchive_ErrorFlavor[CellErrorsArchive_ErrorFlavor["ERROR"] = 1] = "ERROR";
    /**
     * @generated from protobuf enum value: REF_ERROR = 2;
     */
    CellErrorsArchive_ErrorFlavor[CellErrorsArchive_ErrorFlavor["REF_ERROR"] = 2] = "REF_ERROR";
    /**
     * @generated from protobuf enum value: CIRCULAR_REF_ERROR = 3;
     */
    CellErrorsArchive_ErrorFlavor[CellErrorsArchive_ErrorFlavor["CIRCULAR_REF_ERROR"] = 3] = "CIRCULAR_REF_ERROR";
    /**
     * @generated from protobuf enum value: UNSUPPORTED_FUNCTION_ERROR = 4;
     */
    CellErrorsArchive_ErrorFlavor[CellErrorsArchive_ErrorFlavor["UNSUPPORTED_FUNCTION_ERROR"] = 4] = "UNSUPPORTED_FUNCTION_ERROR";
})(CellErrorsArchive_ErrorFlavor = exports.CellErrorsArchive_ErrorFlavor || (exports.CellErrorsArchive_ErrorFlavor = {}));
/**
 * @generated from protobuf enum TSCE.CalculationEngineArchive.ExcelImportDateMode
 */
var CalculationEngineArchive_ExcelImportDateMode;
(function (CalculationEngineArchive_ExcelImportDateMode) {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    CalculationEngineArchive_ExcelImportDateMode[CalculationEngineArchive_ExcelImportDateMode["UNSPECIFIED$"] = 0] = "UNSPECIFIED$";
    /**
     * @generated from protobuf enum value: DATE_MODE_1900 = 1;
     */
    CalculationEngineArchive_ExcelImportDateMode[CalculationEngineArchive_ExcelImportDateMode["DATE_MODE_1900"] = 1] = "DATE_MODE_1900";
    /**
     * @generated from protobuf enum value: DATE_MODE_1900_LEGACY = 2;
     */
    CalculationEngineArchive_ExcelImportDateMode[CalculationEngineArchive_ExcelImportDateMode["DATE_MODE_1900_LEGACY"] = 2] = "DATE_MODE_1900_LEGACY";
    /**
     * @generated from protobuf enum value: DATE_MODE_1904_LEGACY = 3;
     */
    CalculationEngineArchive_ExcelImportDateMode[CalculationEngineArchive_ExcelImportDateMode["DATE_MODE_1904_LEGACY"] = 3] = "DATE_MODE_1904_LEGACY";
})(CalculationEngineArchive_ExcelImportDateMode = exports.CalculationEngineArchive_ExcelImportDateMode || (exports.CalculationEngineArchive_ExcelImportDateMode = {}));
/**
 * @generated from protobuf enum TSCE.ASTNodeArrayArchive.ASTNodeType
 */
var ASTNodeArrayArchive_ASTNodeType;
(function (ASTNodeArrayArchive_ASTNodeType) {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["UNSPECIFIED$"] = 0] = "UNSPECIFIED$";
    /**
     * @generated from protobuf enum value: ADDITION_NODE = 1;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["ADDITION_NODE"] = 1] = "ADDITION_NODE";
    /**
     * @generated from protobuf enum value: SUBTRACTION_NODE = 2;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["SUBTRACTION_NODE"] = 2] = "SUBTRACTION_NODE";
    /**
     * @generated from protobuf enum value: MULTIPLICATION_NODE = 3;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["MULTIPLICATION_NODE"] = 3] = "MULTIPLICATION_NODE";
    /**
     * @generated from protobuf enum value: DIVISION_NODE = 4;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["DIVISION_NODE"] = 4] = "DIVISION_NODE";
    /**
     * @generated from protobuf enum value: POWER_NODE = 5;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["POWER_NODE"] = 5] = "POWER_NODE";
    /**
     * @generated from protobuf enum value: CONCATENATION_NODE = 6;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["CONCATENATION_NODE"] = 6] = "CONCATENATION_NODE";
    /**
     * @generated from protobuf enum value: GREATER_THAN_NODE = 7;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["GREATER_THAN_NODE"] = 7] = "GREATER_THAN_NODE";
    /**
     * @generated from protobuf enum value: GREATER_THAN_OR_EQUAL_TO_NODE = 8;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["GREATER_THAN_OR_EQUAL_TO_NODE"] = 8] = "GREATER_THAN_OR_EQUAL_TO_NODE";
    /**
     * @generated from protobuf enum value: LESS_THAN_NODE = 9;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["LESS_THAN_NODE"] = 9] = "LESS_THAN_NODE";
    /**
     * @generated from protobuf enum value: LESS_THAN_OR_EQUAL_TO_NODE = 10;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["LESS_THAN_OR_EQUAL_TO_NODE"] = 10] = "LESS_THAN_OR_EQUAL_TO_NODE";
    /**
     * @generated from protobuf enum value: EQUAL_TO_NODE = 11;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["EQUAL_TO_NODE"] = 11] = "EQUAL_TO_NODE";
    /**
     * @generated from protobuf enum value: NOT_EQUAL_TO_NODE = 12;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["NOT_EQUAL_TO_NODE"] = 12] = "NOT_EQUAL_TO_NODE";
    /**
     * @generated from protobuf enum value: NEGATION_NODE = 13;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["NEGATION_NODE"] = 13] = "NEGATION_NODE";
    /**
     * @generated from protobuf enum value: PLUS_SIGN_NODE = 14;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["PLUS_SIGN_NODE"] = 14] = "PLUS_SIGN_NODE";
    /**
     * @generated from protobuf enum value: PERCENT_NODE = 15;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["PERCENT_NODE"] = 15] = "PERCENT_NODE";
    /**
     * @generated from protobuf enum value: FUNCTION_NODE = 16;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["FUNCTION_NODE"] = 16] = "FUNCTION_NODE";
    /**
     * @generated from protobuf enum value: NUMBER_NODE = 17;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["NUMBER_NODE"] = 17] = "NUMBER_NODE";
    /**
     * @generated from protobuf enum value: BOOLEAN_NODE = 18;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["BOOLEAN_NODE"] = 18] = "BOOLEAN_NODE";
    /**
     * @generated from protobuf enum value: STRING_NODE = 19;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["STRING_NODE"] = 19] = "STRING_NODE";
    /**
     * @generated from protobuf enum value: DATE_NODE = 20;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["DATE_NODE"] = 20] = "DATE_NODE";
    /**
     * @generated from protobuf enum value: DURATION_NODE = 21;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["DURATION_NODE"] = 21] = "DURATION_NODE";
    /**
     * @generated from protobuf enum value: EMPTY_ARGUMENT_NODE = 22;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["EMPTY_ARGUMENT_NODE"] = 22] = "EMPTY_ARGUMENT_NODE";
    /**
     * @generated from protobuf enum value: TOKEN_NODE = 23;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["TOKEN_NODE"] = 23] = "TOKEN_NODE";
    /**
     * @generated from protobuf enum value: ARRAY_NODE = 24;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["ARRAY_NODE"] = 24] = "ARRAY_NODE";
    /**
     * @generated from protobuf enum value: LIST_NODE = 25;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["LIST_NODE"] = 25] = "LIST_NODE";
    /**
     * @generated from protobuf enum value: THUNK_NODE = 26;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["THUNK_NODE"] = 26] = "THUNK_NODE";
    /**
     * @generated from protobuf enum value: LOCAL_CELL_REFERENCE_NODE = 27;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["LOCAL_CELL_REFERENCE_NODE"] = 27] = "LOCAL_CELL_REFERENCE_NODE";
    /**
     * @generated from protobuf enum value: CROSS_TABLE_CELL_REFERENCE_NODE = 28;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["CROSS_TABLE_CELL_REFERENCE_NODE"] = 28] = "CROSS_TABLE_CELL_REFERENCE_NODE";
    /**
     * @generated from protobuf enum value: COLON_NODE = 29;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["COLON_NODE"] = 29] = "COLON_NODE";
    /**
     * @generated from protobuf enum value: REFERENCE_ERROR_NODE = 30;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["REFERENCE_ERROR_NODE"] = 30] = "REFERENCE_ERROR_NODE";
    /**
     * @generated from protobuf enum value: UNKNOWN_FUNCTION_NODE = 31;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["UNKNOWN_FUNCTION_NODE"] = 31] = "UNKNOWN_FUNCTION_NODE";
    /**
     * @generated from protobuf enum value: APPEND_WHITESPACE_NODE = 32;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["APPEND_WHITESPACE_NODE"] = 32] = "APPEND_WHITESPACE_NODE";
    /**
     * @generated from protobuf enum value: PREPEND_WHITESPACE_NODE = 33;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["PREPEND_WHITESPACE_NODE"] = 33] = "PREPEND_WHITESPACE_NODE";
    /**
     * @generated from protobuf enum value: BEGIN_EMBEDDED_NODE_ARRAY = 34;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["BEGIN_EMBEDDED_NODE_ARRAY"] = 34] = "BEGIN_EMBEDDED_NODE_ARRAY";
    /**
     * @generated from protobuf enum value: END_THUNK_NODE = 35;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["END_THUNK_NODE"] = 35] = "END_THUNK_NODE";
    /**
     * @generated from protobuf enum value: CELL_REFERENCE_NODE = 36;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["CELL_REFERENCE_NODE"] = 36] = "CELL_REFERENCE_NODE";
    /**
     * @generated from protobuf enum value: COLON_NODE_WITH_UIDS = 45;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["COLON_NODE_WITH_UIDS"] = 45] = "COLON_NODE_WITH_UIDS";
    /**
     * @generated from protobuf enum value: REFERENCE_ERROR_WITH_UIDS = 46;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["REFERENCE_ERROR_WITH_UIDS"] = 46] = "REFERENCE_ERROR_WITH_UIDS";
    /**
     * @generated from protobuf enum value: UID_REFERENCE_NODE = 48;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["UID_REFERENCE_NODE"] = 48] = "UID_REFERENCE_NODE";
    /**
     * @generated from protobuf enum value: LET_BIND_NODE = 52;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["LET_BIND_NODE"] = 52] = "LET_BIND_NODE";
    /**
     * @generated from protobuf enum value: LET_VAR_NODE = 53;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["LET_VAR_NODE"] = 53] = "LET_VAR_NODE";
    /**
     * @generated from protobuf enum value: LET_END_SCOPE_NODE = 54;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["LET_END_SCOPE_NODE"] = 54] = "LET_END_SCOPE_NODE";
    /**
     * @generated from protobuf enum value: LINKED_CELL_REF_NODE = 63;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["LINKED_CELL_REF_NODE"] = 63] = "LINKED_CELL_REF_NODE";
    /**
     * @generated from protobuf enum value: LINKED_COLUMN_REF_NODE = 64;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["LINKED_COLUMN_REF_NODE"] = 64] = "LINKED_COLUMN_REF_NODE";
    /**
     * @generated from protobuf enum value: LINKED_ROW_REF_NODE = 65;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["LINKED_ROW_REF_NODE"] = 65] = "LINKED_ROW_REF_NODE";
    /**
     * @generated from protobuf enum value: CATEGORY_REF_NODE = 66;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["CATEGORY_REF_NODE"] = 66] = "CATEGORY_REF_NODE";
    /**
     * @generated from protobuf enum value: COLON_TRACT_NODE = 67;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["COLON_TRACT_NODE"] = 67] = "COLON_TRACT_NODE";
    /**
     * @generated from protobuf enum value: VIEW_TRACT_REF_NODE = 68;
     */
    ASTNodeArrayArchive_ASTNodeType[ASTNodeArrayArchive_ASTNodeType["VIEW_TRACT_REF_NODE"] = 68] = "VIEW_TRACT_REF_NODE";
})(ASTNodeArrayArchive_ASTNodeType = exports.ASTNodeArrayArchive_ASTNodeType || (exports.ASTNodeArrayArchive_ASTNodeType = {}));
/**
 * @generated from protobuf enum TSCE.ASTNodeArrayArchive.ASTUidTractPurpose
 */
var ASTNodeArrayArchive_ASTUidTractPurpose;
(function (ASTNodeArrayArchive_ASTUidTractPurpose) {
    /**
     * @generated from protobuf enum value: UIDS_INCLUDED = 0;
     */
    ASTNodeArrayArchive_ASTUidTractPurpose[ASTNodeArrayArchive_ASTUidTractPurpose["UIDS_INCLUDED"] = 0] = "UIDS_INCLUDED";
    /**
     * @generated from protobuf enum value: UIDS_PREMERGE = 1;
     */
    ASTNodeArrayArchive_ASTUidTractPurpose[ASTNodeArrayArchive_ASTUidTractPurpose["UIDS_PREMERGE"] = 1] = "UIDS_PREMERGE";
    /**
     * @generated from protobuf enum value: UIDS_PREMOVEREGION = 2;
     */
    ASTNodeArrayArchive_ASTUidTractPurpose[ASTNodeArrayArchive_ASTUidTractPurpose["UIDS_PREMOVEREGION"] = 2] = "UIDS_PREMOVEREGION";
    /**
     * @generated from protobuf enum value: UIDS_EXCLUDED = 3;
     */
    ASTNodeArrayArchive_ASTUidTractPurpose[ASTNodeArrayArchive_ASTUidTractPurpose["UIDS_EXCLUDED"] = 3] = "UIDS_EXCLUDED";
    /**
     * @generated from protobuf enum value: UIDS_ACTIVE = 4;
     */
    ASTNodeArrayArchive_ASTUidTractPurpose[ASTNodeArrayArchive_ASTUidTractPurpose["UIDS_ACTIVE"] = 4] = "UIDS_ACTIVE";
    /**
     * @generated from protobuf enum value: UIDS_PREMERGE_TOPLEFT = 5;
     */
    ASTNodeArrayArchive_ASTUidTractPurpose[ASTNodeArrayArchive_ASTUidTractPurpose["UIDS_PREMERGE_TOPLEFT"] = 5] = "UIDS_PREMERGE_TOPLEFT";
    /**
     * @generated from protobuf enum value: UIDS_REMOVED_BY_MOVE = 6;
     */
    ASTNodeArrayArchive_ASTUidTractPurpose[ASTNodeArrayArchive_ASTUidTractPurpose["UIDS_REMOVED_BY_MOVE"] = 6] = "UIDS_REMOVED_BY_MOVE";
    /**
     * @generated from protobuf enum value: FULLTUPLE_ROW_COLUMN_HEADER = 7;
     */
    ASTNodeArrayArchive_ASTUidTractPurpose[ASTNodeArrayArchive_ASTUidTractPurpose["FULLTUPLE_ROW_COLUMN_HEADER"] = 7] = "FULLTUPLE_ROW_COLUMN_HEADER";
    /**
     * @generated from protobuf enum value: FULLTUPLE_AGGREGATE_RULE_UID = 8;
     */
    ASTNodeArrayArchive_ASTUidTractPurpose[ASTNodeArrayArchive_ASTUidTractPurpose["FULLTUPLE_AGGREGATE_RULE_UID"] = 8] = "FULLTUPLE_AGGREGATE_RULE_UID";
    /**
     * @generated from protobuf enum value: FULLTUPLE_ROW_COLUMN_RULE_VALUE_PAIRS = 9;
     */
    ASTNodeArrayArchive_ASTUidTractPurpose[ASTNodeArrayArchive_ASTUidTractPurpose["FULLTUPLE_ROW_COLUMN_RULE_VALUE_PAIRS"] = 9] = "FULLTUPLE_ROW_COLUMN_RULE_VALUE_PAIRS";
})(ASTNodeArrayArchive_ASTUidTractPurpose = exports.ASTNodeArrayArchive_ASTUidTractPurpose || (exports.ASTNodeArrayArchive_ASTUidTractPurpose = {}));
/**
 * @generated from protobuf enum TSCE.GroupByChangeArchive.ChangeType
 */
var GroupByChangeArchive_ChangeType;
(function (GroupByChangeArchive_ChangeType) {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    GroupByChangeArchive_ChangeType[GroupByChangeArchive_ChangeType["NONE"] = 0] = "NONE";
    /**
     * @generated from protobuf enum value: GROUP_VALUE_CHANGE = 1;
     */
    GroupByChangeArchive_ChangeType[GroupByChangeArchive_ChangeType["GROUP_VALUE_CHANGE"] = 1] = "GROUP_VALUE_CHANGE";
    /**
     * @generated from protobuf enum value: GROUP_DEFINITION_CHANGE = 2;
     */
    GroupByChangeArchive_ChangeType[GroupByChangeArchive_ChangeType["GROUP_DEFINITION_CHANGE"] = 2] = "GROUP_DEFINITION_CHANGE";
    /**
     * @generated from protobuf enum value: REMOVE_GROUP_LEVEL = 3;
     */
    GroupByChangeArchive_ChangeType[GroupByChangeArchive_ChangeType["REMOVE_GROUP_LEVEL"] = 3] = "REMOVE_GROUP_LEVEL";
    /**
     * @generated from protobuf enum value: ADD_GROUP_LEVEL = 4;
     */
    GroupByChangeArchive_ChangeType[GroupByChangeArchive_ChangeType["ADD_GROUP_LEVEL"] = 4] = "ADD_GROUP_LEVEL";
    /**
     * @generated from protobuf enum value: PROMOTE = 5;
     */
    GroupByChangeArchive_ChangeType[GroupByChangeArchive_ChangeType["PROMOTE"] = 5] = "PROMOTE";
    /**
     * @generated from protobuf enum value: DEMOTE = 6;
     */
    GroupByChangeArchive_ChangeType[GroupByChangeArchive_ChangeType["DEMOTE"] = 6] = "DEMOTE";
})(GroupByChangeArchive_ChangeType = exports.GroupByChangeArchive_ChangeType || (exports.GroupByChangeArchive_ChangeType = {}));
/**
 * @generated from protobuf enum TSCE.CellValueArchive.CellValueType
 */
var CellValueArchive_CellValueType;
(function (CellValueArchive_CellValueType) {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    CellValueArchive_CellValueType[CellValueArchive_CellValueType["UNSPECIFIED$"] = 0] = "UNSPECIFIED$";
    /**
     * @generated from protobuf enum value: NIL_TYPE = 1;
     */
    CellValueArchive_CellValueType[CellValueArchive_CellValueType["NIL_TYPE"] = 1] = "NIL_TYPE";
    /**
     * @generated from protobuf enum value: BOOLEAN_TYPE = 2;
     */
    CellValueArchive_CellValueType[CellValueArchive_CellValueType["BOOLEAN_TYPE"] = 2] = "BOOLEAN_TYPE";
    /**
     * @generated from protobuf enum value: DATE_TYPE = 3;
     */
    CellValueArchive_CellValueType[CellValueArchive_CellValueType["DATE_TYPE"] = 3] = "DATE_TYPE";
    /**
     * @generated from protobuf enum value: NUMBER_TYPE = 4;
     */
    CellValueArchive_CellValueType[CellValueArchive_CellValueType["NUMBER_TYPE"] = 4] = "NUMBER_TYPE";
    /**
     * @generated from protobuf enum value: STRING_TYPE = 5;
     */
    CellValueArchive_CellValueType[CellValueArchive_CellValueType["STRING_TYPE"] = 5] = "STRING_TYPE";
})(CellValueArchive_CellValueType = exports.CellValueArchive_CellValueType || (exports.CellValueArchive_CellValueType = {}));
// @generated message type with reflection information, may provide speed optimized methods
class CellReferenceArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.CellReferenceArchive", [
            { no: 1, name: "column", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "row", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "table_id", kind: "message", T: () => TSPMessages_4.CFUUIDArchive }
        ]);
    }
    create(value) {
        const message = { column: 0, row: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 column */ 1:
                    message.column = reader.uint32();
                    break;
                case /* uint32 row */ 2:
                    message.row = reader.uint32();
                    break;
                case /* TSP.CFUUIDArchive table_id */ 3:
                    message.tableId = TSPMessages_4.CFUUIDArchive.internalBinaryRead(reader, reader.uint32(), options, message.tableId);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 column = 1; */
        if (message.column !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.column);
        /* uint32 row = 2; */
        if (message.row !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.row);
        /* TSP.CFUUIDArchive table_id = 3; */
        if (message.tableId)
            TSPMessages_4.CFUUIDArchive.internalBinaryWrite(message.tableId, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.CellReferenceArchive
 */
exports.CellReferenceArchive = new CellReferenceArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InternalCellReferenceArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.InternalCellReferenceArchive", [
            { no: 1, name: "coordinate", kind: "message", T: () => exports.CellCoordinateArchive },
            { no: 2, name: "owner_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { ownerId: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSCE.CellCoordinateArchive coordinate */ 1:
                    message.coordinate = exports.CellCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.coordinate);
                    break;
                case /* uint32 owner_id */ 2:
                    message.ownerId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSCE.CellCoordinateArchive coordinate = 1; */
        if (message.coordinate)
            exports.CellCoordinateArchive.internalBinaryWrite(message.coordinate, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 owner_id = 2; */
        if (message.ownerId !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.ownerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.InternalCellReferenceArchive
 */
exports.InternalCellReferenceArchive = new InternalCellReferenceArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelativeCellRefArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.RelativeCellRefArchive", [
            { no: 1, name: "relative_row_offset", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "relative_column_offset", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "table_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 4, name: "preserve_column", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "preserve_row", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "is_spanning_column", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "is_spanning_row", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 relative_row_offset */ 1:
                    message.relativeRowOffset = reader.int32();
                    break;
                case /* optional int32 relative_column_offset */ 2:
                    message.relativeColumnOffset = reader.int32();
                    break;
                case /* optional TSP.UUID table_uid */ 3:
                    message.tableUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.tableUid);
                    break;
                case /* optional bool preserve_column */ 4:
                    message.preserveColumn = reader.bool();
                    break;
                case /* optional bool preserve_row */ 5:
                    message.preserveRow = reader.bool();
                    break;
                case /* optional bool is_spanning_column */ 6:
                    message.isSpanningColumn = reader.bool();
                    break;
                case /* optional bool is_spanning_row */ 7:
                    message.isSpanningRow = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional int32 relative_row_offset = 1; */
        if (message.relativeRowOffset !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.relativeRowOffset);
        /* optional int32 relative_column_offset = 2; */
        if (message.relativeColumnOffset !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.relativeColumnOffset);
        /* optional TSP.UUID table_uid = 3; */
        if (message.tableUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.tableUid, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool preserve_column = 4; */
        if (message.preserveColumn !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.preserveColumn);
        /* optional bool preserve_row = 5; */
        if (message.preserveRow !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.preserveRow);
        /* optional bool is_spanning_column = 6; */
        if (message.isSpanningColumn !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.isSpanningColumn);
        /* optional bool is_spanning_row = 7; */
        if (message.isSpanningRow !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.isSpanningRow);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.RelativeCellRefArchive
 */
exports.RelativeCellRefArchive = new RelativeCellRefArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RangeReferenceArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.RangeReferenceArchive", [
            { no: 1, name: "table_id", kind: "message", T: () => TSPMessages_4.CFUUIDArchive },
            { no: 2, name: "top_left_column", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "top_left_row", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "bottom_right_column", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "bottom_right_row", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { topLeftColumn: 0, topLeftRow: 0, bottomRightColumn: 0, bottomRightRow: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.CFUUIDArchive table_id */ 1:
                    message.tableId = TSPMessages_4.CFUUIDArchive.internalBinaryRead(reader, reader.uint32(), options, message.tableId);
                    break;
                case /* uint32 top_left_column */ 2:
                    message.topLeftColumn = reader.uint32();
                    break;
                case /* uint32 top_left_row */ 3:
                    message.topLeftRow = reader.uint32();
                    break;
                case /* uint32 bottom_right_column */ 4:
                    message.bottomRightColumn = reader.uint32();
                    break;
                case /* uint32 bottom_right_row */ 5:
                    message.bottomRightRow = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.CFUUIDArchive table_id = 1; */
        if (message.tableId)
            TSPMessages_4.CFUUIDArchive.internalBinaryWrite(message.tableId, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 top_left_column = 2; */
        if (message.topLeftColumn !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.topLeftColumn);
        /* uint32 top_left_row = 3; */
        if (message.topLeftRow !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.topLeftRow);
        /* uint32 bottom_right_column = 4; */
        if (message.bottomRightColumn !== 0)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.bottomRightColumn);
        /* uint32 bottom_right_row = 5; */
        if (message.bottomRightRow !== 0)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.bottomRightRow);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.RangeReferenceArchive
 */
exports.RangeReferenceArchive = new RangeReferenceArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InternalRangeReferenceArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.InternalRangeReferenceArchive", [
            { no: 1, name: "owner_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "range", kind: "message", T: () => exports.RangeCoordinateArchive }
        ]);
    }
    create(value) {
        const message = { ownerId: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 owner_id */ 1:
                    message.ownerId = reader.uint32();
                    break;
                case /* TSCE.RangeCoordinateArchive range */ 2:
                    message.range = exports.RangeCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.range);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 owner_id = 1; */
        if (message.ownerId !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.ownerId);
        /* TSCE.RangeCoordinateArchive range = 2; */
        if (message.range)
            exports.RangeCoordinateArchive.internalBinaryWrite(message.range, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.InternalRangeReferenceArchive
 */
exports.InternalRangeReferenceArchive = new InternalRangeReferenceArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IndexSetArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.IndexSetArchive", [
            { no: 1, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.IndexSetArchive_IndexSetEntry }
        ]);
    }
    create(value) {
        const message = { entries: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSCE.IndexSetArchive.IndexSetEntry entries */ 1:
                    message.entries.push(exports.IndexSetArchive_IndexSetEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSCE.IndexSetArchive.IndexSetEntry entries = 1; */
        for (let i = 0; i < message.entries.length; i++)
            exports.IndexSetArchive_IndexSetEntry.internalBinaryWrite(message.entries[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.IndexSetArchive
 */
exports.IndexSetArchive = new IndexSetArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IndexSetArchive_IndexSetEntry$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.IndexSetArchive.IndexSetEntry", [
            { no: 1, name: "range_begin", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "range_end", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = { rangeBegin: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 range_begin */ 1:
                    message.rangeBegin = reader.int32();
                    break;
                case /* optional int32 range_end */ 2:
                    message.rangeEnd = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int32 range_begin = 1; */
        if (message.rangeBegin !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.rangeBegin);
        /* optional int32 range_end = 2; */
        if (message.rangeEnd !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.rangeEnd);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.IndexSetArchive.IndexSetEntry
 */
exports.IndexSetArchive_IndexSetEntry = new IndexSetArchive_IndexSetEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellCoordSetArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.CellCoordSetArchive", [
            { no: 1, name: "column_entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CellCoordSetArchive_ColumnEntry }
        ]);
    }
    create(value) {
        const message = { columnEntries: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSCE.CellCoordSetArchive.ColumnEntry column_entries */ 1:
                    message.columnEntries.push(exports.CellCoordSetArchive_ColumnEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSCE.CellCoordSetArchive.ColumnEntry column_entries = 1; */
        for (let i = 0; i < message.columnEntries.length; i++)
            exports.CellCoordSetArchive_ColumnEntry.internalBinaryWrite(message.columnEntries[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.CellCoordSetArchive
 */
exports.CellCoordSetArchive = new CellCoordSetArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellCoordSetArchive_ColumnEntry$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.CellCoordSetArchive.ColumnEntry", [
            { no: 1, name: "column", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "row_set", kind: "message", T: () => exports.IndexSetArchive }
        ]);
    }
    create(value) {
        const message = { column: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 column */ 1:
                    message.column = reader.uint32();
                    break;
                case /* TSCE.IndexSetArchive row_set */ 2:
                    message.rowSet = exports.IndexSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.rowSet);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 column = 1; */
        if (message.column !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.column);
        /* TSCE.IndexSetArchive row_set = 2; */
        if (message.rowSet)
            exports.IndexSetArchive.internalBinaryWrite(message.rowSet, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.CellCoordSetArchive.ColumnEntry
 */
exports.CellCoordSetArchive_ColumnEntry = new CellCoordSetArchive_ColumnEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InternalCellRefSetArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.InternalCellRefSetArchive", [
            { no: 1, name: "owner_entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.InternalCellRefSetArchive_OwnerEntry }
        ]);
    }
    create(value) {
        const message = { ownerEntries: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSCE.InternalCellRefSetArchive.OwnerEntry owner_entries */ 1:
                    message.ownerEntries.push(exports.InternalCellRefSetArchive_OwnerEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSCE.InternalCellRefSetArchive.OwnerEntry owner_entries = 1; */
        for (let i = 0; i < message.ownerEntries.length; i++)
            exports.InternalCellRefSetArchive_OwnerEntry.internalBinaryWrite(message.ownerEntries[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.InternalCellRefSetArchive
 */
exports.InternalCellRefSetArchive = new InternalCellRefSetArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InternalCellRefSetArchive_OwnerEntry$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.InternalCellRefSetArchive.OwnerEntry", [
            { no: 1, name: "owner_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "coord_set", kind: "message", T: () => exports.CellCoordSetArchive }
        ]);
    }
    create(value) {
        const message = { ownerId: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 owner_id */ 1:
                    message.ownerId = reader.uint32();
                    break;
                case /* TSCE.CellCoordSetArchive coord_set */ 2:
                    message.coordSet = exports.CellCoordSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.coordSet);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 owner_id = 1; */
        if (message.ownerId !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.ownerId);
        /* TSCE.CellCoordSetArchive coord_set = 2; */
        if (message.coordSet)
            exports.CellCoordSetArchive.internalBinaryWrite(message.coordSet, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.InternalCellRefSetArchive.OwnerEntry
 */
exports.InternalCellRefSetArchive_OwnerEntry = new InternalCellRefSetArchive_OwnerEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ColumnRowSize$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.ColumnRowSize", [
            { no: 1, name: "num_columns", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "num_rows", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 num_columns */ 1:
                    message.numColumns = reader.uint32();
                    break;
                case /* optional uint32 num_rows */ 2:
                    message.numRows = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional uint32 num_columns = 1; */
        if (message.numColumns !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.numColumns);
        /* optional uint32 num_rows = 2; */
        if (message.numRows !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.numRows);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.ColumnRowSize
 */
exports.ColumnRowSize = new ColumnRowSize$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellRectArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.CellRectArchive", [
            { no: 1, name: "origin", kind: "message", T: () => exports.CellCoordinateArchive },
            { no: 2, name: "size", kind: "message", T: () => exports.ColumnRowSize }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSCE.CellCoordinateArchive origin */ 1:
                    message.origin = exports.CellCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.origin);
                    break;
                case /* TSCE.ColumnRowSize size */ 2:
                    message.size = exports.ColumnRowSize.internalBinaryRead(reader, reader.uint32(), options, message.size);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSCE.CellCoordinateArchive origin = 1; */
        if (message.origin)
            exports.CellCoordinateArchive.internalBinaryWrite(message.origin, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSCE.ColumnRowSize size = 2; */
        if (message.size)
            exports.ColumnRowSize.internalBinaryWrite(message.size, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.CellRectArchive
 */
exports.CellRectArchive = new CellRectArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellRefSetArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.CellRefSetArchive", [
            { no: 1, name: "owner_entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CellRefSetArchive_OwnerEntry }
        ]);
    }
    create(value) {
        const message = { ownerEntries: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSCE.CellRefSetArchive.OwnerEntry owner_entries */ 1:
                    message.ownerEntries.push(exports.CellRefSetArchive_OwnerEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSCE.CellRefSetArchive.OwnerEntry owner_entries = 1; */
        for (let i = 0; i < message.ownerEntries.length; i++)
            exports.CellRefSetArchive_OwnerEntry.internalBinaryWrite(message.ownerEntries[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.CellRefSetArchive
 */
exports.CellRefSetArchive = new CellRefSetArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellRefSetArchive_OwnerEntry$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.CellRefSetArchive.OwnerEntry", [
            { no: 1, name: "owner_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 2, name: "coord_set", kind: "message", T: () => exports.CellCoordSetArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID owner_uid */ 1:
                    message.ownerUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.ownerUid);
                    break;
                case /* TSCE.CellCoordSetArchive coord_set */ 2:
                    message.coordSet = exports.CellCoordSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.coordSet);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID owner_uid = 1; */
        if (message.ownerUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.ownerUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSCE.CellCoordSetArchive coord_set = 2; */
        if (message.coordSet)
            exports.CellCoordSetArchive.internalBinaryWrite(message.coordSet, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.CellRefSetArchive.OwnerEntry
 */
exports.CellRefSetArchive_OwnerEntry = new CellRefSetArchive_OwnerEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UidCoordSetArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.UidCoordSetArchive", [
            { no: 1, name: "column_entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.UidCoordSetArchive_ColumnEntry }
        ]);
    }
    create(value) {
        const message = { columnEntries: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSCE.UidCoordSetArchive.ColumnEntry column_entries */ 1:
                    message.columnEntries.push(exports.UidCoordSetArchive_ColumnEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSCE.UidCoordSetArchive.ColumnEntry column_entries = 1; */
        for (let i = 0; i < message.columnEntries.length; i++)
            exports.UidCoordSetArchive_ColumnEntry.internalBinaryWrite(message.columnEntries[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.UidCoordSetArchive
 */
exports.UidCoordSetArchive = new UidCoordSetArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UidCoordSetArchive_ColumnEntry$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.UidCoordSetArchive.ColumnEntry", [
            { no: 1, name: "column", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 2, name: "row_set", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_3.UUID }
        ]);
    }
    create(value) {
        const message = { rowSet: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID column */ 1:
                    message.column = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.column);
                    break;
                case /* repeated TSP.UUID row_set */ 2:
                    message.rowSet.push(TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID column = 1; */
        if (message.column)
            TSPMessages_3.UUID.internalBinaryWrite(message.column, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID row_set = 2; */
        for (let i = 0; i < message.rowSet.length; i++)
            TSPMessages_3.UUID.internalBinaryWrite(message.rowSet[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.UidCoordSetArchive.ColumnEntry
 */
exports.UidCoordSetArchive_ColumnEntry = new UidCoordSetArchive_ColumnEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UidCellRefSetArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.UidCellRefSetArchive", [
            { no: 1, name: "owner_entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.UidCellRefSetArchive_OwnerEntry }
        ]);
    }
    create(value) {
        const message = { ownerEntries: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSCE.UidCellRefSetArchive.OwnerEntry owner_entries */ 1:
                    message.ownerEntries.push(exports.UidCellRefSetArchive_OwnerEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSCE.UidCellRefSetArchive.OwnerEntry owner_entries = 1; */
        for (let i = 0; i < message.ownerEntries.length; i++)
            exports.UidCellRefSetArchive_OwnerEntry.internalBinaryWrite(message.ownerEntries[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.UidCellRefSetArchive
 */
exports.UidCellRefSetArchive = new UidCellRefSetArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UidCellRefSetArchive_OwnerEntry$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.UidCellRefSetArchive.OwnerEntry", [
            { no: 1, name: "owner_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 2, name: "coord_set", kind: "message", T: () => exports.UidCoordSetArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID owner_uid */ 1:
                    message.ownerUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.ownerUid);
                    break;
                case /* TSCE.UidCoordSetArchive coord_set */ 2:
                    message.coordSet = exports.UidCoordSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.coordSet);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID owner_uid = 1; */
        if (message.ownerUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.ownerUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSCE.UidCoordSetArchive coord_set = 2; */
        if (message.coordSet)
            exports.UidCoordSetArchive.internalBinaryWrite(message.coordSet, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.UidCellRefSetArchive.OwnerEntry
 */
exports.UidCellRefSetArchive_OwnerEntry = new UidCellRefSetArchive_OwnerEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReferencesToDirtyArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.ReferencesToDirtyArchive", [
            { no: 1, name: "to_dirty_owner_ids", kind: "message", T: () => exports.IndexSetArchive },
            { no: 2, name: "to_dirty_cells", kind: "message", T: () => exports.InternalCellRefSetArchive },
            { no: 3, name: "to_dirty_cells_additional", kind: "message", T: () => exports.InternalCellRefSetArchive },
            { no: 4, name: "to_dirty_range_refs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.InternalRangeReferenceArchive },
            { no: 6, name: "calc_in_progress_cells", kind: "message", T: () => exports.InternalCellRefSetArchive },
            { no: 7, name: "to_update_precedents_cells", kind: "message", T: () => exports.InternalCellRefSetArchive }
        ]);
    }
    create(value) {
        const message = { toDirtyRangeRefs: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSCE.IndexSetArchive to_dirty_owner_ids */ 1:
                    message.toDirtyOwnerIds = exports.IndexSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.toDirtyOwnerIds);
                    break;
                case /* optional TSCE.InternalCellRefSetArchive to_dirty_cells */ 2:
                    message.toDirtyCells = exports.InternalCellRefSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.toDirtyCells);
                    break;
                case /* optional TSCE.InternalCellRefSetArchive to_dirty_cells_additional */ 3:
                    message.toDirtyCellsAdditional = exports.InternalCellRefSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.toDirtyCellsAdditional);
                    break;
                case /* repeated TSCE.InternalRangeReferenceArchive to_dirty_range_refs */ 4:
                    message.toDirtyRangeRefs.push(exports.InternalRangeReferenceArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSCE.InternalCellRefSetArchive calc_in_progress_cells */ 6:
                    message.calcInProgressCells = exports.InternalCellRefSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.calcInProgressCells);
                    break;
                case /* optional TSCE.InternalCellRefSetArchive to_update_precedents_cells */ 7:
                    message.toUpdatePrecedentsCells = exports.InternalCellRefSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.toUpdatePrecedentsCells);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSCE.IndexSetArchive to_dirty_owner_ids = 1; */
        if (message.toDirtyOwnerIds)
            exports.IndexSetArchive.internalBinaryWrite(message.toDirtyOwnerIds, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.InternalCellRefSetArchive to_dirty_cells = 2; */
        if (message.toDirtyCells)
            exports.InternalCellRefSetArchive.internalBinaryWrite(message.toDirtyCells, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.InternalCellRefSetArchive to_dirty_cells_additional = 3; */
        if (message.toDirtyCellsAdditional)
            exports.InternalCellRefSetArchive.internalBinaryWrite(message.toDirtyCellsAdditional, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.InternalRangeReferenceArchive to_dirty_range_refs = 4; */
        for (let i = 0; i < message.toDirtyRangeRefs.length; i++)
            exports.InternalRangeReferenceArchive.internalBinaryWrite(message.toDirtyRangeRefs[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.InternalCellRefSetArchive calc_in_progress_cells = 6; */
        if (message.calcInProgressCells)
            exports.InternalCellRefSetArchive.internalBinaryWrite(message.calcInProgressCells, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.InternalCellRefSetArchive to_update_precedents_cells = 7; */
        if (message.toUpdatePrecedentsCells)
            exports.InternalCellRefSetArchive.internalBinaryWrite(message.toUpdatePrecedentsCells, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.ReferencesToDirtyArchive
 */
exports.ReferencesToDirtyArchive = new ReferencesToDirtyArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CoordMapperArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.CoordMapperArchive", [
            { no: 1, name: "table_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 2, name: "summary_rows_set", kind: "message", T: () => exports.IndexSetArchive },
            { no: 3, name: "summary_columns_set", kind: "message", T: () => exports.IndexSetArchive },
            { no: 4, name: "label_rows_set", kind: "message", T: () => exports.IndexSetArchive },
            { no: 5, name: "base_to_view_row_map", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CoordMapperArchive_BaseToViewEntry },
            { no: 6, name: "base_to_view_column_map", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CoordMapperArchive_BaseToViewEntry },
            { no: 7, name: "summary_to_view_row_map", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CoordMapperArchive_SummaryToViewEntry },
            { no: 8, name: "summary_to_view_column_map", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CoordMapperArchive_SummaryToViewEntry }
        ]);
    }
    create(value) {
        const message = { baseToViewRowMap: [], baseToViewColumnMap: [], summaryToViewRowMap: [], summaryToViewColumnMap: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID table_uid */ 1:
                    message.tableUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.tableUid);
                    break;
                case /* optional TSCE.IndexSetArchive summary_rows_set */ 2:
                    message.summaryRowsSet = exports.IndexSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.summaryRowsSet);
                    break;
                case /* optional TSCE.IndexSetArchive summary_columns_set */ 3:
                    message.summaryColumnsSet = exports.IndexSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.summaryColumnsSet);
                    break;
                case /* optional TSCE.IndexSetArchive label_rows_set */ 4:
                    message.labelRowsSet = exports.IndexSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.labelRowsSet);
                    break;
                case /* repeated TSCE.CoordMapperArchive.BaseToViewEntry base_to_view_row_map */ 5:
                    message.baseToViewRowMap.push(exports.CoordMapperArchive_BaseToViewEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSCE.CoordMapperArchive.BaseToViewEntry base_to_view_column_map */ 6:
                    message.baseToViewColumnMap.push(exports.CoordMapperArchive_BaseToViewEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSCE.CoordMapperArchive.SummaryToViewEntry summary_to_view_row_map */ 7:
                    message.summaryToViewRowMap.push(exports.CoordMapperArchive_SummaryToViewEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSCE.CoordMapperArchive.SummaryToViewEntry summary_to_view_column_map */ 8:
                    message.summaryToViewColumnMap.push(exports.CoordMapperArchive_SummaryToViewEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID table_uid = 1; */
        if (message.tableUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.tableUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.IndexSetArchive summary_rows_set = 2; */
        if (message.summaryRowsSet)
            exports.IndexSetArchive.internalBinaryWrite(message.summaryRowsSet, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.IndexSetArchive summary_columns_set = 3; */
        if (message.summaryColumnsSet)
            exports.IndexSetArchive.internalBinaryWrite(message.summaryColumnsSet, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.IndexSetArchive label_rows_set = 4; */
        if (message.labelRowsSet)
            exports.IndexSetArchive.internalBinaryWrite(message.labelRowsSet, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.CoordMapperArchive.BaseToViewEntry base_to_view_row_map = 5; */
        for (let i = 0; i < message.baseToViewRowMap.length; i++)
            exports.CoordMapperArchive_BaseToViewEntry.internalBinaryWrite(message.baseToViewRowMap[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.CoordMapperArchive.BaseToViewEntry base_to_view_column_map = 6; */
        for (let i = 0; i < message.baseToViewColumnMap.length; i++)
            exports.CoordMapperArchive_BaseToViewEntry.internalBinaryWrite(message.baseToViewColumnMap[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.CoordMapperArchive.SummaryToViewEntry summary_to_view_row_map = 7; */
        for (let i = 0; i < message.summaryToViewRowMap.length; i++)
            exports.CoordMapperArchive_SummaryToViewEntry.internalBinaryWrite(message.summaryToViewRowMap[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.CoordMapperArchive.SummaryToViewEntry summary_to_view_column_map = 8; */
        for (let i = 0; i < message.summaryToViewColumnMap.length; i++)
            exports.CoordMapperArchive_SummaryToViewEntry.internalBinaryWrite(message.summaryToViewColumnMap[i], writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.CoordMapperArchive
 */
exports.CoordMapperArchive = new CoordMapperArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CoordMapperArchive_BaseToViewEntry$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.CoordMapperArchive.BaseToViewEntry", [
            { no: 1, name: "base_column_or_row", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "view_column_or_row", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { baseColumnOrRow: 0, viewColumnOrRow: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 base_column_or_row */ 1:
                    message.baseColumnOrRow = reader.uint32();
                    break;
                case /* uint32 view_column_or_row */ 2:
                    message.viewColumnOrRow = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 base_column_or_row = 1; */
        if (message.baseColumnOrRow !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.baseColumnOrRow);
        /* uint32 view_column_or_row = 2; */
        if (message.viewColumnOrRow !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.viewColumnOrRow);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.CoordMapperArchive.BaseToViewEntry
 */
exports.CoordMapperArchive_BaseToViewEntry = new CoordMapperArchive_BaseToViewEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CoordMapperArchive_SummaryToViewEntry$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.CoordMapperArchive.SummaryToViewEntry", [
            { no: 1, name: "summary_column_or_row", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "view_column_or_row", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { summaryColumnOrRow: 0, viewColumnOrRow: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 summary_column_or_row */ 1:
                    message.summaryColumnOrRow = reader.uint32();
                    break;
                case /* uint32 view_column_or_row */ 2:
                    message.viewColumnOrRow = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 summary_column_or_row = 1; */
        if (message.summaryColumnOrRow !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.summaryColumnOrRow);
        /* uint32 view_column_or_row = 2; */
        if (message.viewColumnOrRow !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.viewColumnOrRow);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.CoordMapperArchive.SummaryToViewEntry
 */
exports.CoordMapperArchive_SummaryToViewEntry = new CoordMapperArchive_SummaryToViewEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReferenceArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.ReferenceArchive", [
            { no: 1, name: "reference_type", kind: "enum", T: () => ["TSCE.ReferenceArchive.ReferenceType", ReferenceArchive_ReferenceType] },
            { no: 2, name: "cell_reference", kind: "message", T: () => exports.CellReferenceArchive },
            { no: 3, name: "range_reference", kind: "message", T: () => exports.RangeReferenceArchive }
        ]);
    }
    create(value) {
        const message = { referenceType: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSCE.ReferenceArchive.ReferenceType reference_type */ 1:
                    message.referenceType = reader.int32();
                    break;
                case /* optional TSCE.CellReferenceArchive cell_reference */ 2:
                    message.cellReference = exports.CellReferenceArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellReference);
                    break;
                case /* optional TSCE.RangeReferenceArchive range_reference */ 3:
                    message.rangeReference = exports.RangeReferenceArchive.internalBinaryRead(reader, reader.uint32(), options, message.rangeReference);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSCE.ReferenceArchive.ReferenceType reference_type = 1; */
        if (message.referenceType !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.referenceType);
        /* optional TSCE.CellReferenceArchive cell_reference = 2; */
        if (message.cellReference)
            exports.CellReferenceArchive.internalBinaryWrite(message.cellReference, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.RangeReferenceArchive range_reference = 3; */
        if (message.rangeReference)
            exports.RangeReferenceArchive.internalBinaryWrite(message.rangeReference, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.ReferenceArchive
 */
exports.ReferenceArchive = new ReferenceArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EdgeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.EdgeArchive", [
            { no: 1, name: "column", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "row", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "is_precedent", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "owner_id", kind: "message", T: () => TSPMessages_4.CFUUIDArchive }
        ]);
    }
    create(value) {
        const message = { column: 0, row: 0, isPrecedent: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 column */ 1:
                    message.column = reader.uint32();
                    break;
                case /* uint32 row */ 2:
                    message.row = reader.uint32();
                    break;
                case /* bool is_precedent */ 3:
                    message.isPrecedent = reader.bool();
                    break;
                case /* optional TSP.CFUUIDArchive owner_id */ 4:
                    message.ownerId = TSPMessages_4.CFUUIDArchive.internalBinaryRead(reader, reader.uint32(), options, message.ownerId);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 column = 1; */
        if (message.column !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.column);
        /* uint32 row = 2; */
        if (message.row !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.row);
        /* bool is_precedent = 3; */
        if (message.isPrecedent !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.isPrecedent);
        /* optional TSP.CFUUIDArchive owner_id = 4; */
        if (message.ownerId)
            TSPMessages_4.CFUUIDArchive.internalBinaryWrite(message.ownerId, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.EdgeArchive
 */
exports.EdgeArchive = new EdgeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EdgesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.EdgesArchive", [
            { no: 9, name: "packed_edge_without_owner", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "packed_edge_with_owner", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "owner_id_for_edge", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.CFUUIDArchive },
            { no: 12, name: "internal_owner_id_for_edge", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { packedEdgeWithoutOwner: [], packedEdgeWithOwner: [], ownerIdForEdge: [], internalOwnerIdForEdge: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 packed_edge_without_owner */ 9:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.packedEdgeWithoutOwner.push(reader.uint32());
                    else
                        message.packedEdgeWithoutOwner.push(reader.uint32());
                    break;
                case /* repeated uint32 packed_edge_with_owner */ 10:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.packedEdgeWithOwner.push(reader.uint32());
                    else
                        message.packedEdgeWithOwner.push(reader.uint32());
                    break;
                case /* repeated TSP.CFUUIDArchive owner_id_for_edge */ 11:
                    message.ownerIdForEdge.push(TSPMessages_4.CFUUIDArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 internal_owner_id_for_edge */ 12:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.internalOwnerIdForEdge.push(reader.uint32());
                    else
                        message.internalOwnerIdForEdge.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated uint32 packed_edge_without_owner = 9; */
        for (let i = 0; i < message.packedEdgeWithoutOwner.length; i++)
            writer.tag(9, runtime_1.WireType.Varint).uint32(message.packedEdgeWithoutOwner[i]);
        /* repeated uint32 packed_edge_with_owner = 10; */
        for (let i = 0; i < message.packedEdgeWithOwner.length; i++)
            writer.tag(10, runtime_1.WireType.Varint).uint32(message.packedEdgeWithOwner[i]);
        /* repeated TSP.CFUUIDArchive owner_id_for_edge = 11; */
        for (let i = 0; i < message.ownerIdForEdge.length; i++)
            TSPMessages_4.CFUUIDArchive.internalBinaryWrite(message.ownerIdForEdge[i], writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 internal_owner_id_for_edge = 12; */
        for (let i = 0; i < message.internalOwnerIdForEdge.length; i++)
            writer.tag(12, runtime_1.WireType.Varint).uint32(message.internalOwnerIdForEdge[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.EdgesArchive
 */
exports.EdgesArchive = new EdgesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpandedEdgesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.ExpandedEdgesArchive", [
            { no: 1, name: "edge_without_owner_rows", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "edge_without_owner_columns", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "edge_with_owner_rows", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "edge_with_owner_columns", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "internal_owner_id_for_edge", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { edgeWithoutOwnerRows: [], edgeWithoutOwnerColumns: [], edgeWithOwnerRows: [], edgeWithOwnerColumns: [], internalOwnerIdForEdge: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 edge_without_owner_rows */ 1:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.edgeWithoutOwnerRows.push(reader.uint32());
                    else
                        message.edgeWithoutOwnerRows.push(reader.uint32());
                    break;
                case /* repeated uint32 edge_without_owner_columns */ 2:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.edgeWithoutOwnerColumns.push(reader.uint32());
                    else
                        message.edgeWithoutOwnerColumns.push(reader.uint32());
                    break;
                case /* repeated uint32 edge_with_owner_rows */ 3:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.edgeWithOwnerRows.push(reader.uint32());
                    else
                        message.edgeWithOwnerRows.push(reader.uint32());
                    break;
                case /* repeated uint32 edge_with_owner_columns */ 4:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.edgeWithOwnerColumns.push(reader.uint32());
                    else
                        message.edgeWithOwnerColumns.push(reader.uint32());
                    break;
                case /* repeated uint32 internal_owner_id_for_edge */ 5:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.internalOwnerIdForEdge.push(reader.uint32());
                    else
                        message.internalOwnerIdForEdge.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated uint32 edge_without_owner_rows = 1; */
        for (let i = 0; i < message.edgeWithoutOwnerRows.length; i++)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.edgeWithoutOwnerRows[i]);
        /* repeated uint32 edge_without_owner_columns = 2; */
        for (let i = 0; i < message.edgeWithoutOwnerColumns.length; i++)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.edgeWithoutOwnerColumns[i]);
        /* repeated uint32 edge_with_owner_rows = 3; */
        for (let i = 0; i < message.edgeWithOwnerRows.length; i++)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.edgeWithOwnerRows[i]);
        /* repeated uint32 edge_with_owner_columns = 4; */
        for (let i = 0; i < message.edgeWithOwnerColumns.length; i++)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.edgeWithOwnerColumns[i]);
        /* repeated uint32 internal_owner_id_for_edge = 5; */
        for (let i = 0; i < message.internalOwnerIdForEdge.length; i++)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.internalOwnerIdForEdge[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.ExpandedEdgesArchive
 */
exports.ExpandedEdgesArchive = new ExpandedEdgesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellRecordArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.CellRecordArchive", [
            { no: 1, name: "column", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "row", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "dirty_self_plus_precedents_count", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "is_in_a_cycle", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "edge", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.EdgeArchive },
            { no: 6, name: "contains_a_formula", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "has_calculated_precedents", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "calculate_precedents_on_next_recalc", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "translate_for_excel_import_on_next_recalc", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "edges", kind: "message", T: () => exports.EdgesArchive }
        ]);
    }
    create(value) {
        const message = { column: 0, row: 0, edge: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 column */ 1:
                    message.column = reader.uint32();
                    break;
                case /* uint32 row */ 2:
                    message.row = reader.uint32();
                    break;
                case /* optional uint64 dirty_self_plus_precedents_count */ 3:
                    message.dirtySelfPlusPrecedentsCount = reader.uint64().toBigInt();
                    break;
                case /* optional bool is_in_a_cycle */ 4:
                    message.isInACycle = reader.bool();
                    break;
                case /* repeated TSCE.EdgeArchive edge = 5 [deprecated = true];*/ 5:
                    message.edge.push(exports.EdgeArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool contains_a_formula */ 6:
                    message.containsAFormula = reader.bool();
                    break;
                case /* optional bool has_calculated_precedents */ 7:
                    message.hasCalculatedPrecedents = reader.bool();
                    break;
                case /* optional bool calculate_precedents_on_next_recalc = 8 [deprecated = true];*/ 8:
                    message.calculatePrecedentsOnNextRecalc = reader.bool();
                    break;
                case /* optional bool translate_for_excel_import_on_next_recalc */ 10:
                    message.translateForExcelImportOnNextRecalc = reader.bool();
                    break;
                case /* optional TSCE.EdgesArchive edges */ 9:
                    message.edges = exports.EdgesArchive.internalBinaryRead(reader, reader.uint32(), options, message.edges);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 column = 1; */
        if (message.column !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.column);
        /* uint32 row = 2; */
        if (message.row !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.row);
        /* optional uint64 dirty_self_plus_precedents_count = 3; */
        if (message.dirtySelfPlusPrecedentsCount !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint64(message.dirtySelfPlusPrecedentsCount);
        /* optional bool is_in_a_cycle = 4; */
        if (message.isInACycle !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.isInACycle);
        /* repeated TSCE.EdgeArchive edge = 5 [deprecated = true]; */
        for (let i = 0; i < message.edge.length; i++)
            exports.EdgeArchive.internalBinaryWrite(message.edge[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool contains_a_formula = 6; */
        if (message.containsAFormula !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.containsAFormula);
        /* optional bool has_calculated_precedents = 7; */
        if (message.hasCalculatedPrecedents !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.hasCalculatedPrecedents);
        /* optional bool calculate_precedents_on_next_recalc = 8 [deprecated = true]; */
        if (message.calculatePrecedentsOnNextRecalc !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.calculatePrecedentsOnNextRecalc);
        /* optional bool translate_for_excel_import_on_next_recalc = 10; */
        if (message.translateForExcelImportOnNextRecalc !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).bool(message.translateForExcelImportOnNextRecalc);
        /* optional TSCE.EdgesArchive edges = 9; */
        if (message.edges)
            exports.EdgesArchive.internalBinaryWrite(message.edges, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.CellRecordArchive
 */
exports.CellRecordArchive = new CellRecordArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellDependenciesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.CellDependenciesArchive", [
            { no: 1, name: "cell_record", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CellRecordArchive },
            { no: 2, name: "num_dirty_cells", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { cellRecord: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSCE.CellRecordArchive cell_record */ 1:
                    message.cellRecord.push(exports.CellRecordArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 num_dirty_cells */ 2:
                    message.numDirtyCells = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSCE.CellRecordArchive cell_record = 1; */
        for (let i = 0; i < message.cellRecord.length; i++)
            exports.CellRecordArchive.internalBinaryWrite(message.cellRecord[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 num_dirty_cells = 2; */
        if (message.numDirtyCells !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.numDirtyCells);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.CellDependenciesArchive
 */
exports.CellDependenciesArchive = new CellDependenciesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellRecordExpandedArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.CellRecordExpandedArchive", [
            { no: 1, name: "column", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "row", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "dirty_self_plus_precedents_count", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "is_in_a_cycle", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "has_calculated_precedents", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "expanded_edges", kind: "message", T: () => exports.ExpandedEdgesArchive }
        ]);
    }
    create(value) {
        const message = { column: 0, row: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 column */ 1:
                    message.column = reader.uint32();
                    break;
                case /* uint32 row */ 2:
                    message.row = reader.uint32();
                    break;
                case /* optional uint64 dirty_self_plus_precedents_count */ 3:
                    message.dirtySelfPlusPrecedentsCount = reader.uint64().toBigInt();
                    break;
                case /* optional bool is_in_a_cycle */ 4:
                    message.isInACycle = reader.bool();
                    break;
                case /* optional bool has_calculated_precedents */ 5:
                    message.hasCalculatedPrecedents = reader.bool();
                    break;
                case /* optional TSCE.ExpandedEdgesArchive expanded_edges */ 6:
                    message.expandedEdges = exports.ExpandedEdgesArchive.internalBinaryRead(reader, reader.uint32(), options, message.expandedEdges);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 column = 1; */
        if (message.column !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.column);
        /* uint32 row = 2; */
        if (message.row !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.row);
        /* optional uint64 dirty_self_plus_precedents_count = 3; */
        if (message.dirtySelfPlusPrecedentsCount !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint64(message.dirtySelfPlusPrecedentsCount);
        /* optional bool is_in_a_cycle = 4; */
        if (message.isInACycle !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.isInACycle);
        /* optional bool has_calculated_precedents = 5; */
        if (message.hasCalculatedPrecedents !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.hasCalculatedPrecedents);
        /* optional TSCE.ExpandedEdgesArchive expanded_edges = 6; */
        if (message.expandedEdges)
            exports.ExpandedEdgesArchive.internalBinaryWrite(message.expandedEdges, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.CellRecordExpandedArchive
 */
exports.CellRecordExpandedArchive = new CellRecordExpandedArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellDependenciesExpandedArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.CellDependenciesExpandedArchive", [
            { no: 1, name: "cell_record", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CellRecordExpandedArchive }
        ]);
    }
    create(value) {
        const message = { cellRecord: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSCE.CellRecordExpandedArchive cell_record */ 1:
                    message.cellRecord.push(exports.CellRecordExpandedArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSCE.CellRecordExpandedArchive cell_record = 1; */
        for (let i = 0; i < message.cellRecord.length; i++)
            exports.CellRecordExpandedArchive.internalBinaryWrite(message.cellRecord[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.CellDependenciesExpandedArchive
 */
exports.CellDependenciesExpandedArchive = new CellDependenciesExpandedArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellRecordTileArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.CellRecordTileArchive", [
            { no: 1, name: "internal_owner_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "tile_column_begin", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "tile_row_begin", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "cell_records", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CellRecordExpandedArchive }
        ]);
    }
    create(value) {
        const message = { internalOwnerId: 0, tileColumnBegin: 0, tileRowBegin: 0, cellRecords: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 internal_owner_id */ 1:
                    message.internalOwnerId = reader.uint32();
                    break;
                case /* uint32 tile_column_begin */ 2:
                    message.tileColumnBegin = reader.uint32();
                    break;
                case /* uint32 tile_row_begin */ 3:
                    message.tileRowBegin = reader.uint32();
                    break;
                case /* repeated TSCE.CellRecordExpandedArchive cell_records */ 4:
                    message.cellRecords.push(exports.CellRecordExpandedArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 internal_owner_id = 1; */
        if (message.internalOwnerId !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.internalOwnerId);
        /* uint32 tile_column_begin = 2; */
        if (message.tileColumnBegin !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.tileColumnBegin);
        /* uint32 tile_row_begin = 3; */
        if (message.tileRowBegin !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.tileRowBegin);
        /* repeated TSCE.CellRecordExpandedArchive cell_records = 4; */
        for (let i = 0; i < message.cellRecords.length; i++)
            exports.CellRecordExpandedArchive.internalBinaryWrite(message.cellRecords[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.CellRecordTileArchive
 */
exports.CellRecordTileArchive = new CellRecordTileArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellDependenciesTiledArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.CellDependenciesTiledArchive", [
            { no: 1, name: "cell_record_tiles", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_2.Reference }
        ]);
    }
    create(value) {
        const message = { cellRecordTiles: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.Reference cell_record_tiles */ 1:
                    message.cellRecordTiles.push(TSPMessages_2.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.Reference cell_record_tiles = 1; */
        for (let i = 0; i < message.cellRecordTiles.length; i++)
            TSPMessages_2.Reference.internalBinaryWrite(message.cellRecordTiles[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.CellDependenciesTiledArchive
 */
exports.CellDependenciesTiledArchive = new CellDependenciesTiledArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VolatileDependenciesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.VolatileDependenciesArchive", [
            { no: 1, name: "volatile_time_cell_column", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "volatile_time_cell_row", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "volatile_random_cell_column", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "volatile_random_cell_row", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "volatile_locale_cell_column", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 16, name: "volatile_locale_cell_row", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "volatile_location_cell_column", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "volatile_location_cell_row", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "volatile_compass_cell_column", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "volatile_compass_cell_row", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 19, name: "volatile_remote_data_cell_column", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 20, name: "volatile_remote_data_cell_row", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 17, name: "volatile_sheet_table_name_cell_column", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 18, name: "volatile_sheet_table_name_cell_row", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "calculated_dependency_cell_column", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "calculated_dependency_cell_row", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "volatile_geometry_cell_reference", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CellReferenceArchive },
            { no: 11, name: "volatile_geometry_cell", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CellCoordinateArchive }
        ]);
    }
    create(value) {
        const message = { volatileTimeCellColumn: [], volatileTimeCellRow: [], volatileRandomCellColumn: [], volatileRandomCellRow: [], volatileLocaleCellColumn: [], volatileLocaleCellRow: [], volatileLocationCellColumn: [], volatileLocationCellRow: [], volatileCompassCellColumn: [], volatileCompassCellRow: [], volatileRemoteDataCellColumn: [], volatileRemoteDataCellRow: [], volatileSheetTableNameCellColumn: [], volatileSheetTableNameCellRow: [], calculatedDependencyCellColumn: [], calculatedDependencyCellRow: [], volatileGeometryCellReference: [], volatileGeometryCell: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 volatile_time_cell_column */ 1:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.volatileTimeCellColumn.push(reader.uint32());
                    else
                        message.volatileTimeCellColumn.push(reader.uint32());
                    break;
                case /* repeated uint32 volatile_time_cell_row */ 2:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.volatileTimeCellRow.push(reader.uint32());
                    else
                        message.volatileTimeCellRow.push(reader.uint32());
                    break;
                case /* repeated uint32 volatile_random_cell_column */ 3:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.volatileRandomCellColumn.push(reader.uint32());
                    else
                        message.volatileRandomCellColumn.push(reader.uint32());
                    break;
                case /* repeated uint32 volatile_random_cell_row */ 4:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.volatileRandomCellRow.push(reader.uint32());
                    else
                        message.volatileRandomCellRow.push(reader.uint32());
                    break;
                case /* repeated uint32 volatile_locale_cell_column */ 15:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.volatileLocaleCellColumn.push(reader.uint32());
                    else
                        message.volatileLocaleCellColumn.push(reader.uint32());
                    break;
                case /* repeated uint32 volatile_locale_cell_row */ 16:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.volatileLocaleCellRow.push(reader.uint32());
                    else
                        message.volatileLocaleCellRow.push(reader.uint32());
                    break;
                case /* repeated uint32 volatile_location_cell_column */ 5:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.volatileLocationCellColumn.push(reader.uint32());
                    else
                        message.volatileLocationCellColumn.push(reader.uint32());
                    break;
                case /* repeated uint32 volatile_location_cell_row */ 6:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.volatileLocationCellRow.push(reader.uint32());
                    else
                        message.volatileLocationCellRow.push(reader.uint32());
                    break;
                case /* repeated uint32 volatile_compass_cell_column */ 7:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.volatileCompassCellColumn.push(reader.uint32());
                    else
                        message.volatileCompassCellColumn.push(reader.uint32());
                    break;
                case /* repeated uint32 volatile_compass_cell_row */ 8:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.volatileCompassCellRow.push(reader.uint32());
                    else
                        message.volatileCompassCellRow.push(reader.uint32());
                    break;
                case /* repeated uint32 volatile_remote_data_cell_column */ 19:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.volatileRemoteDataCellColumn.push(reader.uint32());
                    else
                        message.volatileRemoteDataCellColumn.push(reader.uint32());
                    break;
                case /* repeated uint32 volatile_remote_data_cell_row */ 20:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.volatileRemoteDataCellRow.push(reader.uint32());
                    else
                        message.volatileRemoteDataCellRow.push(reader.uint32());
                    break;
                case /* repeated uint32 volatile_sheet_table_name_cell_column */ 17:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.volatileSheetTableNameCellColumn.push(reader.uint32());
                    else
                        message.volatileSheetTableNameCellColumn.push(reader.uint32());
                    break;
                case /* repeated uint32 volatile_sheet_table_name_cell_row */ 18:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.volatileSheetTableNameCellRow.push(reader.uint32());
                    else
                        message.volatileSheetTableNameCellRow.push(reader.uint32());
                    break;
                case /* repeated uint32 calculated_dependency_cell_column */ 9:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.calculatedDependencyCellColumn.push(reader.uint32());
                    else
                        message.calculatedDependencyCellColumn.push(reader.uint32());
                    break;
                case /* repeated uint32 calculated_dependency_cell_row */ 10:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.calculatedDependencyCellRow.push(reader.uint32());
                    else
                        message.calculatedDependencyCellRow.push(reader.uint32());
                    break;
                case /* repeated TSCE.CellReferenceArchive volatile_geometry_cell_reference */ 13:
                    message.volatileGeometryCellReference.push(exports.CellReferenceArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSCE.CellCoordinateArchive volatile_geometry_cell */ 11:
                    message.volatileGeometryCell.push(exports.CellCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated uint32 volatile_time_cell_column = 1; */
        for (let i = 0; i < message.volatileTimeCellColumn.length; i++)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.volatileTimeCellColumn[i]);
        /* repeated uint32 volatile_time_cell_row = 2; */
        for (let i = 0; i < message.volatileTimeCellRow.length; i++)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.volatileTimeCellRow[i]);
        /* repeated uint32 volatile_random_cell_column = 3; */
        for (let i = 0; i < message.volatileRandomCellColumn.length; i++)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.volatileRandomCellColumn[i]);
        /* repeated uint32 volatile_random_cell_row = 4; */
        for (let i = 0; i < message.volatileRandomCellRow.length; i++)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.volatileRandomCellRow[i]);
        /* repeated uint32 volatile_locale_cell_column = 15; */
        for (let i = 0; i < message.volatileLocaleCellColumn.length; i++)
            writer.tag(15, runtime_1.WireType.Varint).uint32(message.volatileLocaleCellColumn[i]);
        /* repeated uint32 volatile_locale_cell_row = 16; */
        for (let i = 0; i < message.volatileLocaleCellRow.length; i++)
            writer.tag(16, runtime_1.WireType.Varint).uint32(message.volatileLocaleCellRow[i]);
        /* repeated uint32 volatile_location_cell_column = 5; */
        for (let i = 0; i < message.volatileLocationCellColumn.length; i++)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.volatileLocationCellColumn[i]);
        /* repeated uint32 volatile_location_cell_row = 6; */
        for (let i = 0; i < message.volatileLocationCellRow.length; i++)
            writer.tag(6, runtime_1.WireType.Varint).uint32(message.volatileLocationCellRow[i]);
        /* repeated uint32 volatile_compass_cell_column = 7; */
        for (let i = 0; i < message.volatileCompassCellColumn.length; i++)
            writer.tag(7, runtime_1.WireType.Varint).uint32(message.volatileCompassCellColumn[i]);
        /* repeated uint32 volatile_compass_cell_row = 8; */
        for (let i = 0; i < message.volatileCompassCellRow.length; i++)
            writer.tag(8, runtime_1.WireType.Varint).uint32(message.volatileCompassCellRow[i]);
        /* repeated uint32 volatile_remote_data_cell_column = 19; */
        for (let i = 0; i < message.volatileRemoteDataCellColumn.length; i++)
            writer.tag(19, runtime_1.WireType.Varint).uint32(message.volatileRemoteDataCellColumn[i]);
        /* repeated uint32 volatile_remote_data_cell_row = 20; */
        for (let i = 0; i < message.volatileRemoteDataCellRow.length; i++)
            writer.tag(20, runtime_1.WireType.Varint).uint32(message.volatileRemoteDataCellRow[i]);
        /* repeated uint32 volatile_sheet_table_name_cell_column = 17; */
        for (let i = 0; i < message.volatileSheetTableNameCellColumn.length; i++)
            writer.tag(17, runtime_1.WireType.Varint).uint32(message.volatileSheetTableNameCellColumn[i]);
        /* repeated uint32 volatile_sheet_table_name_cell_row = 18; */
        for (let i = 0; i < message.volatileSheetTableNameCellRow.length; i++)
            writer.tag(18, runtime_1.WireType.Varint).uint32(message.volatileSheetTableNameCellRow[i]);
        /* repeated uint32 calculated_dependency_cell_column = 9; */
        for (let i = 0; i < message.calculatedDependencyCellColumn.length; i++)
            writer.tag(9, runtime_1.WireType.Varint).uint32(message.calculatedDependencyCellColumn[i]);
        /* repeated uint32 calculated_dependency_cell_row = 10; */
        for (let i = 0; i < message.calculatedDependencyCellRow.length; i++)
            writer.tag(10, runtime_1.WireType.Varint).uint32(message.calculatedDependencyCellRow[i]);
        /* repeated TSCE.CellReferenceArchive volatile_geometry_cell_reference = 13; */
        for (let i = 0; i < message.volatileGeometryCellReference.length; i++)
            exports.CellReferenceArchive.internalBinaryWrite(message.volatileGeometryCellReference[i], writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.CellCoordinateArchive volatile_geometry_cell = 11; */
        for (let i = 0; i < message.volatileGeometryCell.length; i++)
            exports.CellCoordinateArchive.internalBinaryWrite(message.volatileGeometryCell[i], writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.VolatileDependenciesArchive
 */
exports.VolatileDependenciesArchive = new VolatileDependenciesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VolatileDependenciesExpandedArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.VolatileDependenciesExpandedArchive", [
            { no: 1, name: "volatile_time_cells", kind: "message", T: () => exports.CellCoordSetArchive },
            { no: 2, name: "volatile_random_cells", kind: "message", T: () => exports.CellCoordSetArchive },
            { no: 3, name: "volatile_locale_cells", kind: "message", T: () => exports.CellCoordSetArchive },
            { no: 4, name: "volatile_sheet_table_name_cells", kind: "message", T: () => exports.CellCoordSetArchive },
            { no: 5, name: "volatile_remote_data_cells", kind: "message", T: () => exports.CellCoordSetArchive },
            { no: 7, name: "volatile_geometry_cell_refs", kind: "message", T: () => exports.InternalCellRefSetArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSCE.CellCoordSetArchive volatile_time_cells */ 1:
                    message.volatileTimeCells = exports.CellCoordSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.volatileTimeCells);
                    break;
                case /* optional TSCE.CellCoordSetArchive volatile_random_cells */ 2:
                    message.volatileRandomCells = exports.CellCoordSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.volatileRandomCells);
                    break;
                case /* optional TSCE.CellCoordSetArchive volatile_locale_cells */ 3:
                    message.volatileLocaleCells = exports.CellCoordSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.volatileLocaleCells);
                    break;
                case /* optional TSCE.CellCoordSetArchive volatile_sheet_table_name_cells */ 4:
                    message.volatileSheetTableNameCells = exports.CellCoordSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.volatileSheetTableNameCells);
                    break;
                case /* optional TSCE.CellCoordSetArchive volatile_remote_data_cells */ 5:
                    message.volatileRemoteDataCells = exports.CellCoordSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.volatileRemoteDataCells);
                    break;
                case /* optional TSCE.InternalCellRefSetArchive volatile_geometry_cell_refs */ 7:
                    message.volatileGeometryCellRefs = exports.InternalCellRefSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.volatileGeometryCellRefs);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSCE.CellCoordSetArchive volatile_time_cells = 1; */
        if (message.volatileTimeCells)
            exports.CellCoordSetArchive.internalBinaryWrite(message.volatileTimeCells, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.CellCoordSetArchive volatile_random_cells = 2; */
        if (message.volatileRandomCells)
            exports.CellCoordSetArchive.internalBinaryWrite(message.volatileRandomCells, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.CellCoordSetArchive volatile_locale_cells = 3; */
        if (message.volatileLocaleCells)
            exports.CellCoordSetArchive.internalBinaryWrite(message.volatileLocaleCells, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.CellCoordSetArchive volatile_sheet_table_name_cells = 4; */
        if (message.volatileSheetTableNameCells)
            exports.CellCoordSetArchive.internalBinaryWrite(message.volatileSheetTableNameCells, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.CellCoordSetArchive volatile_remote_data_cells = 5; */
        if (message.volatileRemoteDataCells)
            exports.CellCoordSetArchive.internalBinaryWrite(message.volatileRemoteDataCells, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.InternalCellRefSetArchive volatile_geometry_cell_refs = 7; */
        if (message.volatileGeometryCellRefs)
            exports.InternalCellRefSetArchive.internalBinaryWrite(message.volatileGeometryCellRefs, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.VolatileDependenciesExpandedArchive
 */
exports.VolatileDependenciesExpandedArchive = new VolatileDependenciesExpandedArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RTreeInternalNodeContentsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.RTreeInternalNodeContentsArchive", [
            { no: 1, name: "min", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "max", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "child", kind: "message", T: () => exports.RTreeNodeArchive }
        ]);
    }
    create(value) {
        const message = { min: [], max: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 min */ 1:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.min.push(reader.uint32());
                    else
                        message.min.push(reader.uint32());
                    break;
                case /* repeated uint32 max */ 2:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.max.push(reader.uint32());
                    else
                        message.max.push(reader.uint32());
                    break;
                case /* TSCE.RTreeNodeArchive child */ 3:
                    message.child = exports.RTreeNodeArchive.internalBinaryRead(reader, reader.uint32(), options, message.child);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated uint32 min = 1; */
        for (let i = 0; i < message.min.length; i++)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.min[i]);
        /* repeated uint32 max = 2; */
        for (let i = 0; i < message.max.length; i++)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.max[i]);
        /* TSCE.RTreeNodeArchive child = 3; */
        if (message.child)
            exports.RTreeNodeArchive.internalBinaryWrite(message.child, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.RTreeInternalNodeContentsArchive
 */
exports.RTreeInternalNodeContentsArchive = new RTreeInternalNodeContentsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RTreeLeafNodeContentsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.RTreeLeafNodeContentsArchive", [
            { no: 1, name: "min", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "max", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "cell_reference", kind: "message", T: () => exports.CellReferenceArchive }
        ]);
    }
    create(value) {
        const message = { min: [], max: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 min */ 1:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.min.push(reader.uint32());
                    else
                        message.min.push(reader.uint32());
                    break;
                case /* repeated uint32 max */ 2:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.max.push(reader.uint32());
                    else
                        message.max.push(reader.uint32());
                    break;
                case /* TSCE.CellReferenceArchive cell_reference */ 3:
                    message.cellReference = exports.CellReferenceArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellReference);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated uint32 min = 1; */
        for (let i = 0; i < message.min.length; i++)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.min[i]);
        /* repeated uint32 max = 2; */
        for (let i = 0; i < message.max.length; i++)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.max[i]);
        /* TSCE.CellReferenceArchive cell_reference = 3; */
        if (message.cellReference)
            exports.CellReferenceArchive.internalBinaryWrite(message.cellReference, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.RTreeLeafNodeContentsArchive
 */
exports.RTreeLeafNodeContentsArchive = new RTreeLeafNodeContentsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RTreeNodeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.RTreeNodeArchive", [
            { no: 1, name: "level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "internal_node_contents", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.RTreeInternalNodeContentsArchive },
            { no: 4, name: "leaf_node_contents", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.RTreeLeafNodeContentsArchive }
        ]);
    }
    create(value) {
        const message = { level: 0, count: 0, internalNodeContents: [], leafNodeContents: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 level */ 1:
                    message.level = reader.uint32();
                    break;
                case /* uint32 count */ 2:
                    message.count = reader.uint32();
                    break;
                case /* repeated TSCE.RTreeInternalNodeContentsArchive internal_node_contents */ 3:
                    message.internalNodeContents.push(exports.RTreeInternalNodeContentsArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSCE.RTreeLeafNodeContentsArchive leaf_node_contents */ 4:
                    message.leafNodeContents.push(exports.RTreeLeafNodeContentsArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 level = 1; */
        if (message.level !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.level);
        /* uint32 count = 2; */
        if (message.count !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.count);
        /* repeated TSCE.RTreeInternalNodeContentsArchive internal_node_contents = 3; */
        for (let i = 0; i < message.internalNodeContents.length; i++)
            exports.RTreeInternalNodeContentsArchive.internalBinaryWrite(message.internalNodeContents[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.RTreeLeafNodeContentsArchive leaf_node_contents = 4; */
        for (let i = 0; i < message.leafNodeContents.length; i++)
            exports.RTreeLeafNodeContentsArchive.internalBinaryWrite(message.leafNodeContents[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.RTreeNodeArchive
 */
exports.RTreeNodeArchive = new RTreeNodeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RTreeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.RTreeArchive", [
            { no: 1, name: "data_file_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "data_size", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "data_num_dims", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "data_elem_size", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "data_elem_real_size", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "data_max_nodes", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "data_min_nodes", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "root", kind: "message", T: () => exports.RTreeNodeArchive }
        ]);
    }
    create(value) {
        const message = { dataFileId: 0, dataSize: 0, dataNumDims: 0, dataElemSize: 0, dataElemRealSize: 0, dataMaxNodes: 0, dataMinNodes: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 data_file_id */ 1:
                    message.dataFileId = reader.uint32();
                    break;
                case /* uint32 data_size */ 2:
                    message.dataSize = reader.uint32();
                    break;
                case /* uint32 data_num_dims */ 3:
                    message.dataNumDims = reader.uint32();
                    break;
                case /* uint32 data_elem_size */ 4:
                    message.dataElemSize = reader.uint32();
                    break;
                case /* uint32 data_elem_real_size */ 5:
                    message.dataElemRealSize = reader.uint32();
                    break;
                case /* uint32 data_max_nodes */ 6:
                    message.dataMaxNodes = reader.uint32();
                    break;
                case /* uint32 data_min_nodes */ 7:
                    message.dataMinNodes = reader.uint32();
                    break;
                case /* TSCE.RTreeNodeArchive root */ 8:
                    message.root = exports.RTreeNodeArchive.internalBinaryRead(reader, reader.uint32(), options, message.root);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 data_file_id = 1; */
        if (message.dataFileId !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.dataFileId);
        /* uint32 data_size = 2; */
        if (message.dataSize !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.dataSize);
        /* uint32 data_num_dims = 3; */
        if (message.dataNumDims !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.dataNumDims);
        /* uint32 data_elem_size = 4; */
        if (message.dataElemSize !== 0)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.dataElemSize);
        /* uint32 data_elem_real_size = 5; */
        if (message.dataElemRealSize !== 0)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.dataElemRealSize);
        /* uint32 data_max_nodes = 6; */
        if (message.dataMaxNodes !== 0)
            writer.tag(6, runtime_1.WireType.Varint).uint32(message.dataMaxNodes);
        /* uint32 data_min_nodes = 7; */
        if (message.dataMinNodes !== 0)
            writer.tag(7, runtime_1.WireType.Varint).uint32(message.dataMinNodes);
        /* TSCE.RTreeNodeArchive root = 8; */
        if (message.root)
            exports.RTreeNodeArchive.internalBinaryWrite(message.root, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.RTreeArchive
 */
exports.RTreeArchive = new RTreeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RangeBackDependencyArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.RangeBackDependencyArchive", [
            { no: 1, name: "cell_coord_row", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "cell_coord_column", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "range_reference", kind: "message", T: () => exports.RangeReferenceArchive },
            { no: 4, name: "internal_range_reference", kind: "message", T: () => exports.InternalRangeReferenceArchive }
        ]);
    }
    create(value) {
        const message = { cellCoordRow: 0, cellCoordColumn: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 cell_coord_row */ 1:
                    message.cellCoordRow = reader.uint32();
                    break;
                case /* uint32 cell_coord_column */ 2:
                    message.cellCoordColumn = reader.uint32();
                    break;
                case /* optional TSCE.RangeReferenceArchive range_reference */ 3:
                    message.rangeReference = exports.RangeReferenceArchive.internalBinaryRead(reader, reader.uint32(), options, message.rangeReference);
                    break;
                case /* optional TSCE.InternalRangeReferenceArchive internal_range_reference */ 4:
                    message.internalRangeReference = exports.InternalRangeReferenceArchive.internalBinaryRead(reader, reader.uint32(), options, message.internalRangeReference);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 cell_coord_row = 1; */
        if (message.cellCoordRow !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.cellCoordRow);
        /* uint32 cell_coord_column = 2; */
        if (message.cellCoordColumn !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.cellCoordColumn);
        /* optional TSCE.RangeReferenceArchive range_reference = 3; */
        if (message.rangeReference)
            exports.RangeReferenceArchive.internalBinaryWrite(message.rangeReference, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.InternalRangeReferenceArchive internal_range_reference = 4; */
        if (message.internalRangeReference)
            exports.InternalRangeReferenceArchive.internalBinaryWrite(message.internalRangeReference, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.RangeBackDependencyArchive
 */
exports.RangeBackDependencyArchive = new RangeBackDependencyArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RangeDependenciesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.RangeDependenciesArchive", [
            { no: 2, name: "back_dependency", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.RangeBackDependencyArchive }
        ]);
    }
    create(value) {
        const message = { backDependency: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSCE.RangeBackDependencyArchive back_dependency */ 2:
                    message.backDependency.push(exports.RangeBackDependencyArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSCE.RangeBackDependencyArchive back_dependency = 2; */
        for (let i = 0; i < message.backDependency.length; i++)
            exports.RangeBackDependencyArchive.internalBinaryWrite(message.backDependency[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.RangeDependenciesArchive
 */
exports.RangeDependenciesArchive = new RangeDependenciesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RangePrecedentsTileArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.RangePrecedentsTileArchive", [
            { no: 1, name: "to_owner_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "from_to_range", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.RangePrecedentsTileArchive_FromToRangeArchive }
        ]);
    }
    create(value) {
        const message = { toOwnerId: 0, fromToRange: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 to_owner_id */ 1:
                    message.toOwnerId = reader.uint32();
                    break;
                case /* repeated TSCE.RangePrecedentsTileArchive.FromToRangeArchive from_to_range */ 2:
                    message.fromToRange.push(exports.RangePrecedentsTileArchive_FromToRangeArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 to_owner_id = 1; */
        if (message.toOwnerId !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.toOwnerId);
        /* repeated TSCE.RangePrecedentsTileArchive.FromToRangeArchive from_to_range = 2; */
        for (let i = 0; i < message.fromToRange.length; i++)
            exports.RangePrecedentsTileArchive_FromToRangeArchive.internalBinaryWrite(message.fromToRange[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.RangePrecedentsTileArchive
 */
exports.RangePrecedentsTileArchive = new RangePrecedentsTileArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RangePrecedentsTileArchive_FromToRangeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.RangePrecedentsTileArchive.FromToRangeArchive", [
            { no: 1, name: "from_coord", kind: "message", T: () => exports.CellCoordinateArchive },
            { no: 2, name: "refers_to_rect", kind: "message", T: () => exports.CellRectArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSCE.CellCoordinateArchive from_coord */ 1:
                    message.fromCoord = exports.CellCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.fromCoord);
                    break;
                case /* TSCE.CellRectArchive refers_to_rect */ 2:
                    message.refersToRect = exports.CellRectArchive.internalBinaryRead(reader, reader.uint32(), options, message.refersToRect);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSCE.CellCoordinateArchive from_coord = 1; */
        if (message.fromCoord)
            exports.CellCoordinateArchive.internalBinaryWrite(message.fromCoord, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSCE.CellRectArchive refers_to_rect = 2; */
        if (message.refersToRect)
            exports.CellRectArchive.internalBinaryWrite(message.refersToRect, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.RangePrecedentsTileArchive.FromToRangeArchive
 */
exports.RangePrecedentsTileArchive_FromToRangeArchive = new RangePrecedentsTileArchive_FromToRangeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RangeDependenciesTiledArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.RangeDependenciesTiledArchive", [
            { no: 1, name: "range_precedents_tile", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_2.Reference }
        ]);
    }
    create(value) {
        const message = { rangePrecedentsTile: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.Reference range_precedents_tile */ 1:
                    message.rangePrecedentsTile.push(TSPMessages_2.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.Reference range_precedents_tile = 1; */
        for (let i = 0; i < message.rangePrecedentsTile.length; i++)
            TSPMessages_2.Reference.internalBinaryWrite(message.rangePrecedentsTile[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.RangeDependenciesTiledArchive
 */
exports.RangeDependenciesTiledArchive = new RangeDependenciesTiledArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpanningDependenciesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.SpanningDependenciesArchive", [
            { no: 1, name: "column", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "range_context", kind: "enum", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ["TSCE.SpanningDependenciesArchive.RangeContext", SpanningDependenciesArchive_RangeContext] },
            { no: 3, name: "cell", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CellReferenceArchive },
            { no: 4, name: "total_range_for_deleted_table", kind: "message", T: () => exports.RangeCoordinateArchive },
            { no: 5, name: "body_range_for_deleted_table", kind: "message", T: () => exports.RangeCoordinateArchive },
            { no: 6, name: "referring_column_to_local_cells", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.SpanningDependenciesArchive_ReferringColumnToLocalCells },
            { no: 7, name: "referring_column_to_remote_cells", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.SpanningDependenciesArchive_ReferringColumnToRemoteCells }
        ]);
    }
    create(value) {
        const message = { column: [], rangeContext: [], cell: [], referringColumnToLocalCells: [], referringColumnToRemoteCells: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 column */ 1:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.column.push(reader.uint32());
                    else
                        message.column.push(reader.uint32());
                    break;
                case /* repeated TSCE.SpanningDependenciesArchive.RangeContext range_context */ 2:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.rangeContext.push(reader.int32());
                    else
                        message.rangeContext.push(reader.int32());
                    break;
                case /* repeated TSCE.CellReferenceArchive cell */ 3:
                    message.cell.push(exports.CellReferenceArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSCE.RangeCoordinateArchive total_range_for_deleted_table */ 4:
                    message.totalRangeForDeletedTable = exports.RangeCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.totalRangeForDeletedTable);
                    break;
                case /* optional TSCE.RangeCoordinateArchive body_range_for_deleted_table */ 5:
                    message.bodyRangeForDeletedTable = exports.RangeCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.bodyRangeForDeletedTable);
                    break;
                case /* repeated TSCE.SpanningDependenciesArchive.ReferringColumnToLocalCells referring_column_to_local_cells */ 6:
                    message.referringColumnToLocalCells.push(exports.SpanningDependenciesArchive_ReferringColumnToLocalCells.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSCE.SpanningDependenciesArchive.ReferringColumnToRemoteCells referring_column_to_remote_cells */ 7:
                    message.referringColumnToRemoteCells.push(exports.SpanningDependenciesArchive_ReferringColumnToRemoteCells.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated uint32 column = 1; */
        for (let i = 0; i < message.column.length; i++)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.column[i]);
        /* repeated TSCE.SpanningDependenciesArchive.RangeContext range_context = 2; */
        for (let i = 0; i < message.rangeContext.length; i++)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.rangeContext[i]);
        /* repeated TSCE.CellReferenceArchive cell = 3; */
        for (let i = 0; i < message.cell.length; i++)
            exports.CellReferenceArchive.internalBinaryWrite(message.cell[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.RangeCoordinateArchive total_range_for_deleted_table = 4; */
        if (message.totalRangeForDeletedTable)
            exports.RangeCoordinateArchive.internalBinaryWrite(message.totalRangeForDeletedTable, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.RangeCoordinateArchive body_range_for_deleted_table = 5; */
        if (message.bodyRangeForDeletedTable)
            exports.RangeCoordinateArchive.internalBinaryWrite(message.bodyRangeForDeletedTable, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.SpanningDependenciesArchive.ReferringColumnToLocalCells referring_column_to_local_cells = 6; */
        for (let i = 0; i < message.referringColumnToLocalCells.length; i++)
            exports.SpanningDependenciesArchive_ReferringColumnToLocalCells.internalBinaryWrite(message.referringColumnToLocalCells[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.SpanningDependenciesArchive.ReferringColumnToRemoteCells referring_column_to_remote_cells = 7; */
        for (let i = 0; i < message.referringColumnToRemoteCells.length; i++)
            exports.SpanningDependenciesArchive_ReferringColumnToRemoteCells.internalBinaryWrite(message.referringColumnToRemoteCells[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.SpanningDependenciesArchive
 */
exports.SpanningDependenciesArchive = new SpanningDependenciesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpanningDependenciesArchive_ReferringColumnToLocalCells$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.SpanningDependenciesArchive.ReferringColumnToLocalCells", [
            { no: 1, name: "column", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "range_context", kind: "enum", T: () => ["TSCE.SpanningDependenciesArchive.RangeContext", SpanningDependenciesArchive_RangeContext] },
            { no: 3, name: "cell_coordinate", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CellCoordinateArchive }
        ]);
    }
    create(value) {
        const message = { column: 0, rangeContext: 0, cellCoordinate: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 column */ 1:
                    message.column = reader.uint32();
                    break;
                case /* TSCE.SpanningDependenciesArchive.RangeContext range_context */ 2:
                    message.rangeContext = reader.int32();
                    break;
                case /* repeated TSCE.CellCoordinateArchive cell_coordinate */ 3:
                    message.cellCoordinate.push(exports.CellCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 column = 1; */
        if (message.column !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.column);
        /* TSCE.SpanningDependenciesArchive.RangeContext range_context = 2; */
        if (message.rangeContext !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.rangeContext);
        /* repeated TSCE.CellCoordinateArchive cell_coordinate = 3; */
        for (let i = 0; i < message.cellCoordinate.length; i++)
            exports.CellCoordinateArchive.internalBinaryWrite(message.cellCoordinate[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.SpanningDependenciesArchive.ReferringColumnToLocalCells
 */
exports.SpanningDependenciesArchive_ReferringColumnToLocalCells = new SpanningDependenciesArchive_ReferringColumnToLocalCells$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpanningDependenciesArchive_ReferringColumnToRemoteCells$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.SpanningDependenciesArchive.ReferringColumnToRemoteCells", [
            { no: 1, name: "column", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "range_context", kind: "enum", T: () => ["TSCE.SpanningDependenciesArchive.RangeContext", SpanningDependenciesArchive_RangeContext] },
            { no: 3, name: "internal_cell_reference", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.InternalCellReferenceArchive }
        ]);
    }
    create(value) {
        const message = { column: 0, rangeContext: 0, internalCellReference: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 column */ 1:
                    message.column = reader.uint32();
                    break;
                case /* TSCE.SpanningDependenciesArchive.RangeContext range_context */ 2:
                    message.rangeContext = reader.int32();
                    break;
                case /* repeated TSCE.InternalCellReferenceArchive internal_cell_reference */ 3:
                    message.internalCellReference.push(exports.InternalCellReferenceArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 column = 1; */
        if (message.column !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.column);
        /* TSCE.SpanningDependenciesArchive.RangeContext range_context = 2; */
        if (message.rangeContext !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.rangeContext);
        /* repeated TSCE.InternalCellReferenceArchive internal_cell_reference = 3; */
        for (let i = 0; i < message.internalCellReference.length; i++)
            exports.InternalCellReferenceArchive.internalBinaryWrite(message.internalCellReference[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.SpanningDependenciesArchive.ReferringColumnToRemoteCells
 */
exports.SpanningDependenciesArchive_ReferringColumnToRemoteCells = new SpanningDependenciesArchive_ReferringColumnToRemoteCells$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpanningDependenciesExpandedArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.SpanningDependenciesExpandedArchive", [
            { no: 1, name: "coord_refers_to_spans", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.SpanningDependenciesExpandedArchive_CellCoordRefersToExtents },
            { no: 2, name: "total_range_for_table", kind: "message", T: () => exports.RangeCoordinateArchive },
            { no: 3, name: "body_range_for_table", kind: "message", T: () => exports.RangeCoordinateArchive }
        ]);
    }
    create(value) {
        const message = { coordRefersToSpans: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSCE.SpanningDependenciesExpandedArchive.CellCoordRefersToExtents coord_refers_to_spans */ 1:
                    message.coordRefersToSpans.push(exports.SpanningDependenciesExpandedArchive_CellCoordRefersToExtents.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSCE.RangeCoordinateArchive total_range_for_table */ 2:
                    message.totalRangeForTable = exports.RangeCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.totalRangeForTable);
                    break;
                case /* optional TSCE.RangeCoordinateArchive body_range_for_table */ 3:
                    message.bodyRangeForTable = exports.RangeCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.bodyRangeForTable);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSCE.SpanningDependenciesExpandedArchive.CellCoordRefersToExtents coord_refers_to_spans = 1; */
        for (let i = 0; i < message.coordRefersToSpans.length; i++)
            exports.SpanningDependenciesExpandedArchive_CellCoordRefersToExtents.internalBinaryWrite(message.coordRefersToSpans[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.RangeCoordinateArchive total_range_for_table = 2; */
        if (message.totalRangeForTable)
            exports.RangeCoordinateArchive.internalBinaryWrite(message.totalRangeForTable, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.RangeCoordinateArchive body_range_for_table = 3; */
        if (message.bodyRangeForTable)
            exports.RangeCoordinateArchive.internalBinaryWrite(message.bodyRangeForTable, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.SpanningDependenciesExpandedArchive
 */
exports.SpanningDependenciesExpandedArchive = new SpanningDependenciesExpandedArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpanningDependenciesExpandedArchive_ExtentRange$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.SpanningDependenciesExpandedArchive.ExtentRange", [
            { no: 1, name: "extent_begin", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "extent_end", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { extentBegin: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 extent_begin */ 1:
                    message.extentBegin = reader.uint32();
                    break;
                case /* optional uint32 extent_end */ 2:
                    message.extentEnd = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 extent_begin = 1; */
        if (message.extentBegin !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.extentBegin);
        /* optional uint32 extent_end = 2; */
        if (message.extentEnd !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.extentEnd);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.SpanningDependenciesExpandedArchive.ExtentRange
 */
exports.SpanningDependenciesExpandedArchive_ExtentRange = new SpanningDependenciesExpandedArchive_ExtentRange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpanningDependenciesExpandedArchive_ExtentRangeWithTableWithContext$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.SpanningDependenciesExpandedArchive.ExtentRangeWithTableWithContext", [
            { no: 1, name: "owner_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "range_context", kind: "enum", T: () => ["TSCE.SpanningDependenciesExpandedArchive.RangeContext", SpanningDependenciesExpandedArchive_RangeContext] },
            { no: 3, name: "ranges", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.SpanningDependenciesExpandedArchive_ExtentRange }
        ]);
    }
    create(value) {
        const message = { ownerId: 0, rangeContext: 0, ranges: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 owner_id */ 1:
                    message.ownerId = reader.uint32();
                    break;
                case /* TSCE.SpanningDependenciesExpandedArchive.RangeContext range_context */ 2:
                    message.rangeContext = reader.int32();
                    break;
                case /* repeated TSCE.SpanningDependenciesExpandedArchive.ExtentRange ranges */ 3:
                    message.ranges.push(exports.SpanningDependenciesExpandedArchive_ExtentRange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 owner_id = 1; */
        if (message.ownerId !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.ownerId);
        /* TSCE.SpanningDependenciesExpandedArchive.RangeContext range_context = 2; */
        if (message.rangeContext !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.rangeContext);
        /* repeated TSCE.SpanningDependenciesExpandedArchive.ExtentRange ranges = 3; */
        for (let i = 0; i < message.ranges.length; i++)
            exports.SpanningDependenciesExpandedArchive_ExtentRange.internalBinaryWrite(message.ranges[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.SpanningDependenciesExpandedArchive.ExtentRangeWithTableWithContext
 */
exports.SpanningDependenciesExpandedArchive_ExtentRangeWithTableWithContext = new SpanningDependenciesExpandedArchive_ExtentRangeWithTableWithContext$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpanningDependenciesExpandedArchive_CellCoordRefersToExtents$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.SpanningDependenciesExpandedArchive.CellCoordRefersToExtents", [
            { no: 1, name: "coordinate", kind: "message", T: () => exports.CellCoordinateArchive },
            { no: 2, name: "ranges_by_table_context", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.SpanningDependenciesExpandedArchive_ExtentRangeWithTableWithContext }
        ]);
    }
    create(value) {
        const message = { rangesByTableContext: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSCE.CellCoordinateArchive coordinate */ 1:
                    message.coordinate = exports.CellCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.coordinate);
                    break;
                case /* repeated TSCE.SpanningDependenciesExpandedArchive.ExtentRangeWithTableWithContext ranges_by_table_context */ 2:
                    message.rangesByTableContext.push(exports.SpanningDependenciesExpandedArchive_ExtentRangeWithTableWithContext.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSCE.CellCoordinateArchive coordinate = 1; */
        if (message.coordinate)
            exports.CellCoordinateArchive.internalBinaryWrite(message.coordinate, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.SpanningDependenciesExpandedArchive.ExtentRangeWithTableWithContext ranges_by_table_context = 2; */
        for (let i = 0; i < message.rangesByTableContext.length; i++)
            exports.SpanningDependenciesExpandedArchive_ExtentRangeWithTableWithContext.internalBinaryWrite(message.rangesByTableContext[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.SpanningDependenciesExpandedArchive.CellCoordRefersToExtents
 */
exports.SpanningDependenciesExpandedArchive_CellCoordRefersToExtents = new SpanningDependenciesExpandedArchive_CellCoordRefersToExtents$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WholeOwnerDependenciesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.WholeOwnerDependenciesArchive", [
            { no: 1, name: "dependent_cell", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.InternalCellReferenceArchive }
        ]);
    }
    create(value) {
        const message = { dependentCell: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSCE.InternalCellReferenceArchive dependent_cell */ 1:
                    message.dependentCell.push(exports.InternalCellReferenceArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSCE.InternalCellReferenceArchive dependent_cell = 1; */
        for (let i = 0; i < message.dependentCell.length; i++)
            exports.InternalCellReferenceArchive.internalBinaryWrite(message.dependentCell[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.WholeOwnerDependenciesArchive
 */
exports.WholeOwnerDependenciesArchive = new WholeOwnerDependenciesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WholeOwnerDependenciesExpandedArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.WholeOwnerDependenciesExpandedArchive", [
            { no: 1, name: "dependent_cells", kind: "message", T: () => exports.InternalCellRefSetArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSCE.InternalCellRefSetArchive dependent_cells */ 1:
                    message.dependentCells = exports.InternalCellRefSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.dependentCells);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSCE.InternalCellRefSetArchive dependent_cells = 1; */
        if (message.dependentCells)
            exports.InternalCellRefSetArchive.internalBinaryWrite(message.dependentCells, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.WholeOwnerDependenciesExpandedArchive
 */
exports.WholeOwnerDependenciesExpandedArchive = new WholeOwnerDependenciesExpandedArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellErrorsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.CellErrorsArchive", [
            { no: 1, name: "errors", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CellErrorsArchive_ErrorForCell }
        ]);
    }
    create(value) {
        const message = { errors: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSCE.CellErrorsArchive.ErrorForCell errors */ 1:
                    message.errors.push(exports.CellErrorsArchive_ErrorForCell.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSCE.CellErrorsArchive.ErrorForCell errors = 1; */
        for (let i = 0; i < message.errors.length; i++)
            exports.CellErrorsArchive_ErrorForCell.internalBinaryWrite(message.errors[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.CellErrorsArchive
 */
exports.CellErrorsArchive = new CellErrorsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellErrorsArchive_ErrorForCell$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.CellErrorsArchive.ErrorForCell", [
            { no: 1, name: "coordinate", kind: "message", T: () => exports.CellCoordinateArchive },
            { no: 2, name: "error_flavor", kind: "enum", T: () => ["TSCE.CellErrorsArchive.ErrorFlavor", CellErrorsArchive_ErrorFlavor] },
            { no: 3, name: "err_due_to_cell", kind: "message", T: () => exports.InternalCellReferenceArchive }
        ]);
    }
    create(value) {
        const message = { errorFlavor: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSCE.CellCoordinateArchive coordinate */ 1:
                    message.coordinate = exports.CellCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.coordinate);
                    break;
                case /* TSCE.CellErrorsArchive.ErrorFlavor error_flavor */ 2:
                    message.errorFlavor = reader.int32();
                    break;
                case /* optional TSCE.InternalCellReferenceArchive err_due_to_cell */ 3:
                    message.errDueToCell = exports.InternalCellReferenceArchive.internalBinaryRead(reader, reader.uint32(), options, message.errDueToCell);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSCE.CellCoordinateArchive coordinate = 1; */
        if (message.coordinate)
            exports.CellCoordinateArchive.internalBinaryWrite(message.coordinate, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSCE.CellErrorsArchive.ErrorFlavor error_flavor = 2; */
        if (message.errorFlavor !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.errorFlavor);
        /* optional TSCE.InternalCellReferenceArchive err_due_to_cell = 3; */
        if (message.errDueToCell)
            exports.InternalCellReferenceArchive.internalBinaryWrite(message.errDueToCell, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.CellErrorsArchive.ErrorForCell
 */
exports.CellErrorsArchive_ErrorForCell = new CellErrorsArchive_ErrorForCell$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UuidReferencesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.UuidReferencesArchive", [
            { no: 1, name: "table_refs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.UuidReferencesArchive_TableRef },
            { no: 2, name: "table_uuid_refs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.UuidReferencesArchive_TableWithUuidRef }
        ]);
    }
    create(value) {
        const message = { tableRefs: [], tableUuidRefs: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSCE.UuidReferencesArchive.TableRef table_refs */ 1:
                    message.tableRefs.push(exports.UuidReferencesArchive_TableRef.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSCE.UuidReferencesArchive.TableWithUuidRef table_uuid_refs */ 2:
                    message.tableUuidRefs.push(exports.UuidReferencesArchive_TableWithUuidRef.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSCE.UuidReferencesArchive.TableRef table_refs = 1; */
        for (let i = 0; i < message.tableRefs.length; i++)
            exports.UuidReferencesArchive_TableRef.internalBinaryWrite(message.tableRefs[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.UuidReferencesArchive.TableWithUuidRef table_uuid_refs = 2; */
        for (let i = 0; i < message.tableUuidRefs.length; i++)
            exports.UuidReferencesArchive_TableWithUuidRef.internalBinaryWrite(message.tableUuidRefs[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.UuidReferencesArchive
 */
exports.UuidReferencesArchive = new UuidReferencesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UuidReferencesArchive_TableRef$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.UuidReferencesArchive.TableRef", [
            { no: 1, name: "owner_uuid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 2, name: "coord_set", kind: "message", T: () => exports.CellCoordSetArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID owner_uuid */ 1:
                    message.ownerUuid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.ownerUuid);
                    break;
                case /* optional TSCE.CellCoordSetArchive coord_set */ 2:
                    message.coordSet = exports.CellCoordSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.coordSet);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID owner_uuid = 1; */
        if (message.ownerUuid)
            TSPMessages_3.UUID.internalBinaryWrite(message.ownerUuid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.CellCoordSetArchive coord_set = 2; */
        if (message.coordSet)
            exports.CellCoordSetArchive.internalBinaryWrite(message.coordSet, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.UuidReferencesArchive.TableRef
 */
exports.UuidReferencesArchive_TableRef = new UuidReferencesArchive_TableRef$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UuidReferencesArchive_UuidRef$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.UuidReferencesArchive.UuidRef", [
            { no: 1, name: "uuid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 2, name: "coord_set", kind: "message", T: () => exports.CellCoordSetArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID uuid */ 1:
                    message.uuid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.uuid);
                    break;
                case /* optional TSCE.CellCoordSetArchive coord_set */ 2:
                    message.coordSet = exports.CellCoordSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.coordSet);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID uuid = 1; */
        if (message.uuid)
            TSPMessages_3.UUID.internalBinaryWrite(message.uuid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.CellCoordSetArchive coord_set = 2; */
        if (message.coordSet)
            exports.CellCoordSetArchive.internalBinaryWrite(message.coordSet, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.UuidReferencesArchive.UuidRef
 */
exports.UuidReferencesArchive_UuidRef = new UuidReferencesArchive_UuidRef$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UuidReferencesArchive_TableWithUuidRef$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.UuidReferencesArchive.TableWithUuidRef", [
            { no: 1, name: "owner_uuid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 2, name: "uuid_refs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.UuidReferencesArchive_UuidRef }
        ]);
    }
    create(value) {
        const message = { uuidRefs: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID owner_uuid */ 1:
                    message.ownerUuid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.ownerUuid);
                    break;
                case /* repeated TSCE.UuidReferencesArchive.UuidRef uuid_refs */ 2:
                    message.uuidRefs.push(exports.UuidReferencesArchive_UuidRef.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID owner_uuid = 1; */
        if (message.ownerUuid)
            TSPMessages_3.UUID.internalBinaryWrite(message.ownerUuid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.UuidReferencesArchive.UuidRef uuid_refs = 2; */
        for (let i = 0; i < message.uuidRefs.length; i++)
            exports.UuidReferencesArchive_UuidRef.internalBinaryWrite(message.uuidRefs[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.UuidReferencesArchive.TableWithUuidRef
 */
exports.UuidReferencesArchive_TableWithUuidRef = new UuidReferencesArchive_TableWithUuidRef$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormulaOwnerDependenciesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.FormulaOwnerDependenciesArchive", [
            { no: 1, name: "formula_owner_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 2, name: "internal_formula_owner_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "owner_kind", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "cell_dependencies", kind: "message", T: () => exports.CellDependenciesExpandedArchive },
            { no: 5, name: "range_dependencies", kind: "message", T: () => exports.RangeDependenciesArchive },
            { no: 6, name: "volatile_dependencies", kind: "message", T: () => exports.VolatileDependenciesExpandedArchive },
            { no: 7, name: "spanning_column_dependencies", kind: "message", T: () => exports.SpanningDependenciesExpandedArchive },
            { no: 8, name: "spanning_row_dependencies", kind: "message", T: () => exports.SpanningDependenciesExpandedArchive },
            { no: 9, name: "whole_owner_dependencies", kind: "message", T: () => exports.WholeOwnerDependenciesExpandedArchive },
            { no: 10, name: "cell_errors", kind: "message", T: () => exports.CellErrorsArchive },
            { no: 11, name: "formula_owner", kind: "message", T: () => TSPMessages_2.Reference },
            { no: 12, name: "base_owner_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 13, name: "tiled_cell_dependencies", kind: "message", T: () => exports.CellDependenciesTiledArchive },
            { no: 14, name: "uuid_references", kind: "message", T: () => exports.UuidReferencesArchive },
            { no: 15, name: "tiled_range_dependencies", kind: "message", T: () => exports.RangeDependenciesTiledArchive }
        ]);
    }
    create(value) {
        const message = { internalFormulaOwnerId: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID formula_owner_uid */ 1:
                    message.formulaOwnerUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.formulaOwnerUid);
                    break;
                case /* uint32 internal_formula_owner_id */ 2:
                    message.internalFormulaOwnerId = reader.uint32();
                    break;
                case /* optional uint32 owner_kind */ 3:
                    message.ownerKind = reader.uint32();
                    break;
                case /* optional TSCE.CellDependenciesExpandedArchive cell_dependencies */ 4:
                    message.cellDependencies = exports.CellDependenciesExpandedArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellDependencies);
                    break;
                case /* optional TSCE.RangeDependenciesArchive range_dependencies */ 5:
                    message.rangeDependencies = exports.RangeDependenciesArchive.internalBinaryRead(reader, reader.uint32(), options, message.rangeDependencies);
                    break;
                case /* optional TSCE.VolatileDependenciesExpandedArchive volatile_dependencies */ 6:
                    message.volatileDependencies = exports.VolatileDependenciesExpandedArchive.internalBinaryRead(reader, reader.uint32(), options, message.volatileDependencies);
                    break;
                case /* optional TSCE.SpanningDependenciesExpandedArchive spanning_column_dependencies */ 7:
                    message.spanningColumnDependencies = exports.SpanningDependenciesExpandedArchive.internalBinaryRead(reader, reader.uint32(), options, message.spanningColumnDependencies);
                    break;
                case /* optional TSCE.SpanningDependenciesExpandedArchive spanning_row_dependencies */ 8:
                    message.spanningRowDependencies = exports.SpanningDependenciesExpandedArchive.internalBinaryRead(reader, reader.uint32(), options, message.spanningRowDependencies);
                    break;
                case /* optional TSCE.WholeOwnerDependenciesExpandedArchive whole_owner_dependencies */ 9:
                    message.wholeOwnerDependencies = exports.WholeOwnerDependenciesExpandedArchive.internalBinaryRead(reader, reader.uint32(), options, message.wholeOwnerDependencies);
                    break;
                case /* optional TSCE.CellErrorsArchive cell_errors */ 10:
                    message.cellErrors = exports.CellErrorsArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellErrors);
                    break;
                case /* optional TSP.Reference formula_owner */ 11:
                    message.formulaOwner = TSPMessages_2.Reference.internalBinaryRead(reader, reader.uint32(), options, message.formulaOwner);
                    break;
                case /* optional TSP.UUID base_owner_uid */ 12:
                    message.baseOwnerUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.baseOwnerUid);
                    break;
                case /* optional TSCE.CellDependenciesTiledArchive tiled_cell_dependencies */ 13:
                    message.tiledCellDependencies = exports.CellDependenciesTiledArchive.internalBinaryRead(reader, reader.uint32(), options, message.tiledCellDependencies);
                    break;
                case /* optional TSCE.UuidReferencesArchive uuid_references */ 14:
                    message.uuidReferences = exports.UuidReferencesArchive.internalBinaryRead(reader, reader.uint32(), options, message.uuidReferences);
                    break;
                case /* optional TSCE.RangeDependenciesTiledArchive tiled_range_dependencies */ 15:
                    message.tiledRangeDependencies = exports.RangeDependenciesTiledArchive.internalBinaryRead(reader, reader.uint32(), options, message.tiledRangeDependencies);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID formula_owner_uid = 1; */
        if (message.formulaOwnerUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.formulaOwnerUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 internal_formula_owner_id = 2; */
        if (message.internalFormulaOwnerId !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.internalFormulaOwnerId);
        /* optional uint32 owner_kind = 3; */
        if (message.ownerKind !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.ownerKind);
        /* optional TSCE.CellDependenciesExpandedArchive cell_dependencies = 4; */
        if (message.cellDependencies)
            exports.CellDependenciesExpandedArchive.internalBinaryWrite(message.cellDependencies, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.RangeDependenciesArchive range_dependencies = 5; */
        if (message.rangeDependencies)
            exports.RangeDependenciesArchive.internalBinaryWrite(message.rangeDependencies, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.VolatileDependenciesExpandedArchive volatile_dependencies = 6; */
        if (message.volatileDependencies)
            exports.VolatileDependenciesExpandedArchive.internalBinaryWrite(message.volatileDependencies, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.SpanningDependenciesExpandedArchive spanning_column_dependencies = 7; */
        if (message.spanningColumnDependencies)
            exports.SpanningDependenciesExpandedArchive.internalBinaryWrite(message.spanningColumnDependencies, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.SpanningDependenciesExpandedArchive spanning_row_dependencies = 8; */
        if (message.spanningRowDependencies)
            exports.SpanningDependenciesExpandedArchive.internalBinaryWrite(message.spanningRowDependencies, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.WholeOwnerDependenciesExpandedArchive whole_owner_dependencies = 9; */
        if (message.wholeOwnerDependencies)
            exports.WholeOwnerDependenciesExpandedArchive.internalBinaryWrite(message.wholeOwnerDependencies, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.CellErrorsArchive cell_errors = 10; */
        if (message.cellErrors)
            exports.CellErrorsArchive.internalBinaryWrite(message.cellErrors, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference formula_owner = 11; */
        if (message.formulaOwner)
            TSPMessages_2.Reference.internalBinaryWrite(message.formulaOwner, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID base_owner_uid = 12; */
        if (message.baseOwnerUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.baseOwnerUid, writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.CellDependenciesTiledArchive tiled_cell_dependencies = 13; */
        if (message.tiledCellDependencies)
            exports.CellDependenciesTiledArchive.internalBinaryWrite(message.tiledCellDependencies, writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.UuidReferencesArchive uuid_references = 14; */
        if (message.uuidReferences)
            exports.UuidReferencesArchive.internalBinaryWrite(message.uuidReferences, writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.RangeDependenciesTiledArchive tiled_range_dependencies = 15; */
        if (message.tiledRangeDependencies)
            exports.RangeDependenciesTiledArchive.internalBinaryWrite(message.tiledRangeDependencies, writer.tag(15, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.FormulaOwnerDependenciesArchive
 */
exports.FormulaOwnerDependenciesArchive = new FormulaOwnerDependenciesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormulaOwnerInfoArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.FormulaOwnerInfoArchive", [
            { no: 1, name: "formula_owner_id", kind: "message", T: () => TSPMessages_4.CFUUIDArchive },
            { no: 2, name: "cell_dependencies", kind: "message", T: () => exports.CellDependenciesArchive },
            { no: 3, name: "range_dependencies", kind: "message", T: () => exports.RangeDependenciesArchive },
            { no: 4, name: "volatile_dependencies", kind: "message", T: () => exports.VolatileDependenciesArchive },
            { no: 5, name: "spanning_column_dependencies", kind: "message", T: () => exports.SpanningDependenciesArchive },
            { no: 6, name: "spanning_row_dependencies", kind: "message", T: () => exports.SpanningDependenciesArchive },
            { no: 8, name: "whole_owner_dependencies", kind: "message", T: () => exports.WholeOwnerDependenciesArchive },
            { no: 9, name: "cell_errors", kind: "message", T: () => exports.CellErrorsArchive },
            { no: 7, name: "formula_owner", kind: "message", T: () => TSPMessages_2.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.CFUUIDArchive formula_owner_id */ 1:
                    message.formulaOwnerId = TSPMessages_4.CFUUIDArchive.internalBinaryRead(reader, reader.uint32(), options, message.formulaOwnerId);
                    break;
                case /* optional TSCE.CellDependenciesArchive cell_dependencies */ 2:
                    message.cellDependencies = exports.CellDependenciesArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellDependencies);
                    break;
                case /* optional TSCE.RangeDependenciesArchive range_dependencies */ 3:
                    message.rangeDependencies = exports.RangeDependenciesArchive.internalBinaryRead(reader, reader.uint32(), options, message.rangeDependencies);
                    break;
                case /* optional TSCE.VolatileDependenciesArchive volatile_dependencies */ 4:
                    message.volatileDependencies = exports.VolatileDependenciesArchive.internalBinaryRead(reader, reader.uint32(), options, message.volatileDependencies);
                    break;
                case /* optional TSCE.SpanningDependenciesArchive spanning_column_dependencies */ 5:
                    message.spanningColumnDependencies = exports.SpanningDependenciesArchive.internalBinaryRead(reader, reader.uint32(), options, message.spanningColumnDependencies);
                    break;
                case /* optional TSCE.SpanningDependenciesArchive spanning_row_dependencies */ 6:
                    message.spanningRowDependencies = exports.SpanningDependenciesArchive.internalBinaryRead(reader, reader.uint32(), options, message.spanningRowDependencies);
                    break;
                case /* optional TSCE.WholeOwnerDependenciesArchive whole_owner_dependencies */ 8:
                    message.wholeOwnerDependencies = exports.WholeOwnerDependenciesArchive.internalBinaryRead(reader, reader.uint32(), options, message.wholeOwnerDependencies);
                    break;
                case /* optional TSCE.CellErrorsArchive cell_errors */ 9:
                    message.cellErrors = exports.CellErrorsArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellErrors);
                    break;
                case /* optional TSP.Reference formula_owner */ 7:
                    message.formulaOwner = TSPMessages_2.Reference.internalBinaryRead(reader, reader.uint32(), options, message.formulaOwner);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.CFUUIDArchive formula_owner_id = 1; */
        if (message.formulaOwnerId)
            TSPMessages_4.CFUUIDArchive.internalBinaryWrite(message.formulaOwnerId, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.CellDependenciesArchive cell_dependencies = 2; */
        if (message.cellDependencies)
            exports.CellDependenciesArchive.internalBinaryWrite(message.cellDependencies, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.RangeDependenciesArchive range_dependencies = 3; */
        if (message.rangeDependencies)
            exports.RangeDependenciesArchive.internalBinaryWrite(message.rangeDependencies, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.VolatileDependenciesArchive volatile_dependencies = 4; */
        if (message.volatileDependencies)
            exports.VolatileDependenciesArchive.internalBinaryWrite(message.volatileDependencies, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.SpanningDependenciesArchive spanning_column_dependencies = 5; */
        if (message.spanningColumnDependencies)
            exports.SpanningDependenciesArchive.internalBinaryWrite(message.spanningColumnDependencies, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.SpanningDependenciesArchive spanning_row_dependencies = 6; */
        if (message.spanningRowDependencies)
            exports.SpanningDependenciesArchive.internalBinaryWrite(message.spanningRowDependencies, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.WholeOwnerDependenciesArchive whole_owner_dependencies = 8; */
        if (message.wholeOwnerDependencies)
            exports.WholeOwnerDependenciesArchive.internalBinaryWrite(message.wholeOwnerDependencies, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.CellErrorsArchive cell_errors = 9; */
        if (message.cellErrors)
            exports.CellErrorsArchive.internalBinaryWrite(message.cellErrors, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference formula_owner = 7; */
        if (message.formulaOwner)
            TSPMessages_2.Reference.internalBinaryWrite(message.formulaOwner, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.FormulaOwnerInfoArchive
 */
exports.FormulaOwnerInfoArchive = new FormulaOwnerInfoArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubFormulaOwnerIDArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.SubFormulaOwnerIDArchive", [
            { no: 1, name: "base_owner_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 2, name: "owner_kind", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { ownerKind: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID base_owner_uid */ 1:
                    message.baseOwnerUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.baseOwnerUid);
                    break;
                case /* uint32 owner_kind */ 2:
                    message.ownerKind = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID base_owner_uid = 1; */
        if (message.baseOwnerUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.baseOwnerUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 owner_kind = 2; */
        if (message.ownerKind !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.ownerKind);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.SubFormulaOwnerIDArchive
 */
exports.SubFormulaOwnerIDArchive = new SubFormulaOwnerIDArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OwnerIDMapArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.OwnerIDMapArchive", [
            { no: 1, name: "map_entry", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.OwnerIDMapArchive_OwnerIDMapArchiveEntry },
            { no: 2, name: "unregistered_internal_owner_id", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { mapEntry: [], unregisteredInternalOwnerId: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSCE.OwnerIDMapArchive.OwnerIDMapArchiveEntry map_entry */ 1:
                    message.mapEntry.push(exports.OwnerIDMapArchive_OwnerIDMapArchiveEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 unregistered_internal_owner_id */ 2:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unregisteredInternalOwnerId.push(reader.uint32());
                    else
                        message.unregisteredInternalOwnerId.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSCE.OwnerIDMapArchive.OwnerIDMapArchiveEntry map_entry = 1; */
        for (let i = 0; i < message.mapEntry.length; i++)
            exports.OwnerIDMapArchive_OwnerIDMapArchiveEntry.internalBinaryWrite(message.mapEntry[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 unregistered_internal_owner_id = 2; */
        for (let i = 0; i < message.unregisteredInternalOwnerId.length; i++)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.unregisteredInternalOwnerId[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.OwnerIDMapArchive
 */
exports.OwnerIDMapArchive = new OwnerIDMapArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OwnerIDMapArchive_OwnerIDMapArchiveEntry$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.OwnerIDMapArchive.OwnerIDMapArchiveEntry", [
            { no: 1, name: "internal_owner_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "owner_id", kind: "message", T: () => TSPMessages_4.CFUUIDArchive }
        ]);
    }
    create(value) {
        const message = { internalOwnerId: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 internal_owner_id */ 1:
                    message.internalOwnerId = reader.uint32();
                    break;
                case /* TSP.CFUUIDArchive owner_id */ 2:
                    message.ownerId = TSPMessages_4.CFUUIDArchive.internalBinaryRead(reader, reader.uint32(), options, message.ownerId);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 internal_owner_id = 1; */
        if (message.internalOwnerId !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.internalOwnerId);
        /* TSP.CFUUIDArchive owner_id = 2; */
        if (message.ownerId)
            TSPMessages_4.CFUUIDArchive.internalBinaryWrite(message.ownerId, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.OwnerIDMapArchive.OwnerIDMapArchiveEntry
 */
exports.OwnerIDMapArchive_OwnerIDMapArchiveEntry = new OwnerIDMapArchive_OwnerIDMapArchiveEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UidLookupListArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.UidLookupListArchive", [
            { no: 1, name: "uuids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_3.UUID }
        ]);
    }
    create(value) {
        const message = { uuids: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.UUID uuids */ 1:
                    message.uuids.push(TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.UUID uuids = 1; */
        for (let i = 0; i < message.uuids.length; i++)
            TSPMessages_3.UUID.internalBinaryWrite(message.uuids[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.UidLookupListArchive
 */
exports.UidLookupListArchive = new UidLookupListArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DependencyTrackerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.DependencyTrackerArchive", [
            { no: 1, name: "formula_owner_info", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.FormulaOwnerInfoArchive },
            { no: 2, name: "dirty_leaf", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CellReferenceArchive },
            { no: 3, name: "owner_id_map", kind: "message", T: () => exports.OwnerIDMapArchive },
            { no: 4, name: "internal_dirty_leaf", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.InternalCellReferenceArchive },
            { no: 5, name: "number_of_formulas", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "formula_owner_dependencies", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_2.Reference }
        ]);
    }
    create(value) {
        const message = { formulaOwnerInfo: [], dirtyLeaf: [], internalDirtyLeaf: [], formulaOwnerDependencies: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSCE.FormulaOwnerInfoArchive formula_owner_info */ 1:
                    message.formulaOwnerInfo.push(exports.FormulaOwnerInfoArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSCE.CellReferenceArchive dirty_leaf = 2 [deprecated = true];*/ 2:
                    message.dirtyLeaf.push(exports.CellReferenceArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSCE.OwnerIDMapArchive owner_id_map */ 3:
                    message.ownerIdMap = exports.OwnerIDMapArchive.internalBinaryRead(reader, reader.uint32(), options, message.ownerIdMap);
                    break;
                case /* repeated TSCE.InternalCellReferenceArchive internal_dirty_leaf = 4 [deprecated = true];*/ 4:
                    message.internalDirtyLeaf.push(exports.InternalCellReferenceArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint64 number_of_formulas */ 5:
                    message.numberOfFormulas = reader.uint64().toBigInt();
                    break;
                case /* repeated TSP.Reference formula_owner_dependencies */ 6:
                    message.formulaOwnerDependencies.push(TSPMessages_2.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSCE.FormulaOwnerInfoArchive formula_owner_info = 1; */
        for (let i = 0; i < message.formulaOwnerInfo.length; i++)
            exports.FormulaOwnerInfoArchive.internalBinaryWrite(message.formulaOwnerInfo[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.CellReferenceArchive dirty_leaf = 2 [deprecated = true]; */
        for (let i = 0; i < message.dirtyLeaf.length; i++)
            exports.CellReferenceArchive.internalBinaryWrite(message.dirtyLeaf[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.OwnerIDMapArchive owner_id_map = 3; */
        if (message.ownerIdMap)
            exports.OwnerIDMapArchive.internalBinaryWrite(message.ownerIdMap, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.InternalCellReferenceArchive internal_dirty_leaf = 4 [deprecated = true]; */
        for (let i = 0; i < message.internalDirtyLeaf.length; i++)
            exports.InternalCellReferenceArchive.internalBinaryWrite(message.internalDirtyLeaf[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint64 number_of_formulas = 5; */
        if (message.numberOfFormulas !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).uint64(message.numberOfFormulas);
        /* repeated TSP.Reference formula_owner_dependencies = 6; */
        for (let i = 0; i < message.formulaOwnerDependencies.length; i++)
            TSPMessages_2.Reference.internalBinaryWrite(message.formulaOwnerDependencies[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.DependencyTrackerArchive
 */
exports.DependencyTrackerArchive = new DependencyTrackerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoteDataSpecifierArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.RemoteDataSpecifierArchive", [
            { no: 1, name: "function_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "attribute", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "date", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value) {
        const message = { functionIndex: 0, symbol: "", attribute: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 function_index */ 1:
                    message.functionIndex = reader.uint32();
                    break;
                case /* string symbol */ 2:
                    message.symbol = reader.string();
                    break;
                case /* uint32 attribute */ 3:
                    message.attribute = reader.uint32();
                    break;
                case /* optional double date */ 4:
                    message.date = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 function_index = 1; */
        if (message.functionIndex !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.functionIndex);
        /* string symbol = 2; */
        if (message.symbol !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.symbol);
        /* uint32 attribute = 3; */
        if (message.attribute !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.attribute);
        /* optional double date = 4; */
        if (message.date !== undefined)
            writer.tag(4, runtime_1.WireType.Bit64).double(message.date);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.RemoteDataSpecifierArchive
 */
exports.RemoteDataSpecifierArchive = new RemoteDataSpecifierArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoteDataValueMapArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.RemoteDataValueMapArchive", [
            { no: 1, name: "entry", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.RemoteDataValueMapArchive_RemoteDataMapEntry }
        ]);
    }
    create(value) {
        const message = { entry: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSCE.RemoteDataValueMapArchive.RemoteDataMapEntry entry */ 1:
                    message.entry.push(exports.RemoteDataValueMapArchive_RemoteDataMapEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSCE.RemoteDataValueMapArchive.RemoteDataMapEntry entry = 1; */
        for (let i = 0; i < message.entry.length; i++)
            exports.RemoteDataValueMapArchive_RemoteDataMapEntry.internalBinaryWrite(message.entry[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.RemoteDataValueMapArchive
 */
exports.RemoteDataValueMapArchive = new RemoteDataValueMapArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoteDataValueMapArchive_RemoteDataMapEntry$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.RemoteDataValueMapArchive.RemoteDataMapEntry", [
            { no: 1, name: "specifier", kind: "message", T: () => exports.RemoteDataSpecifierArchive },
            { no: 2, name: "value", kind: "message", T: () => exports.CellValueArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSCE.RemoteDataSpecifierArchive specifier */ 1:
                    message.specifier = exports.RemoteDataSpecifierArchive.internalBinaryRead(reader, reader.uint32(), options, message.specifier);
                    break;
                case /* TSCE.CellValueArchive value */ 2:
                    message.value = exports.CellValueArchive.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSCE.RemoteDataSpecifierArchive specifier = 1; */
        if (message.specifier)
            exports.RemoteDataSpecifierArchive.internalBinaryWrite(message.specifier, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSCE.CellValueArchive value = 2; */
        if (message.value)
            exports.CellValueArchive.internalBinaryWrite(message.value, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.RemoteDataValueMapArchive.RemoteDataMapEntry
 */
exports.RemoteDataValueMapArchive_RemoteDataMapEntry = new RemoteDataValueMapArchive_RemoteDataMapEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StockArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.StockArchive", [
            { no: 1, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "date", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "attribute", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.StockArchive_AttributeEntry }
        ]);
    }
    create(value) {
        const message = { symbol: "", attribute: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string symbol */ 1:
                    message.symbol = reader.string();
                    break;
                case /* optional double date */ 2:
                    message.date = reader.double();
                    break;
                case /* repeated TSCE.StockArchive.AttributeEntry attribute */ 3:
                    message.attribute.push(exports.StockArchive_AttributeEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string symbol = 1; */
        if (message.symbol !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.symbol);
        /* optional double date = 2; */
        if (message.date !== undefined)
            writer.tag(2, runtime_1.WireType.Bit64).double(message.date);
        /* repeated TSCE.StockArchive.AttributeEntry attribute = 3; */
        for (let i = 0; i < message.attribute.length; i++)
            exports.StockArchive_AttributeEntry.internalBinaryWrite(message.attribute[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.StockArchive
 */
exports.StockArchive = new StockArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StockArchive_AttributeEntry$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.StockArchive.AttributeEntry", [
            { no: 1, name: "attribute", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { attribute: 0, value: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 attribute */ 1:
                    message.attribute = reader.uint32();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 attribute = 1; */
        if (message.attribute !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.attribute);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.StockArchive.AttributeEntry
 */
exports.StockArchive_AttributeEntry = new StockArchive_AttributeEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoteDataStoreArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.RemoteDataStoreArchive", [
            { no: 1, name: "value_map", kind: "message", T: () => exports.RemoteDataValueMapArchive },
            { no: 2, name: "stocks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.StockArchive }
        ]);
    }
    create(value) {
        const message = { stocks: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSCE.RemoteDataValueMapArchive value_map */ 1:
                    message.valueMap = exports.RemoteDataValueMapArchive.internalBinaryRead(reader, reader.uint32(), options, message.valueMap);
                    break;
                case /* repeated TSCE.StockArchive stocks */ 2:
                    message.stocks.push(exports.StockArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSCE.RemoteDataValueMapArchive value_map = 1; */
        if (message.valueMap)
            exports.RemoteDataValueMapArchive.internalBinaryWrite(message.valueMap, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.StockArchive stocks = 2; */
        for (let i = 0; i < message.stocks.length; i++)
            exports.StockArchive.internalBinaryWrite(message.stocks[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.RemoteDataStoreArchive
 */
exports.RemoteDataStoreArchive = new RemoteDataStoreArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NameTrackedReferencePair$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.NameTrackedReferencePair", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "tracked_reference", kind: "message", T: () => TSPMessages_2.Reference },
            { no: 3, name: "tracked_reference_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional TSP.Reference tracked_reference */ 2:
                    message.trackedReference = TSPMessages_2.Reference.internalBinaryRead(reader, reader.uint32(), options, message.trackedReference);
                    break;
                case /* optional uint32 tracked_reference_id */ 3:
                    message.trackedReferenceId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* optional TSP.Reference tracked_reference = 2; */
        if (message.trackedReference)
            TSPMessages_2.Reference.internalBinaryWrite(message.trackedReference, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 tracked_reference_id = 3; */
        if (message.trackedReferenceId !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.trackedReferenceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.NameTrackedReferencePair
 */
exports.NameTrackedReferencePair = new NameTrackedReferencePair$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NamesByTrackedReferenceArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.NamesByTrackedReferenceArchive", [
            { no: 1, name: "table_id", kind: "message", T: () => TSPMessages_4.CFUUIDArchive },
            { no: 2, name: "name_tracked_reference_pair", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.NameTrackedReferencePair }
        ]);
    }
    create(value) {
        const message = { nameTrackedReferencePair: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.CFUUIDArchive table_id */ 1:
                    message.tableId = TSPMessages_4.CFUUIDArchive.internalBinaryRead(reader, reader.uint32(), options, message.tableId);
                    break;
                case /* repeated TSCE.NameTrackedReferencePair name_tracked_reference_pair */ 2:
                    message.nameTrackedReferencePair.push(exports.NameTrackedReferencePair.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.CFUUIDArchive table_id = 1; */
        if (message.tableId)
            TSPMessages_4.CFUUIDArchive.internalBinaryWrite(message.tableId, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.NameTrackedReferencePair name_tracked_reference_pair = 2; */
        for (let i = 0; i < message.nameTrackedReferencePair.length; i++)
            exports.NameTrackedReferencePair.internalBinaryWrite(message.nameTrackedReferencePair[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.NamesByTrackedReferenceArchive
 */
exports.NamesByTrackedReferenceArchive = new NamesByTrackedReferenceArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NamedReferenceManagerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.NamedReferenceManagerArchive", [
            { no: 1, name: "reference_tracker", kind: "message", T: () => TSPMessages_2.Reference },
            { no: 2, name: "names_by_tracked_reference_by_table", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.NamesByTrackedReferenceArchive }
        ]);
    }
    create(value) {
        const message = { namesByTrackedReferenceByTable: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.Reference reference_tracker */ 1:
                    message.referenceTracker = TSPMessages_2.Reference.internalBinaryRead(reader, reader.uint32(), options, message.referenceTracker);
                    break;
                case /* repeated TSCE.NamesByTrackedReferenceArchive names_by_tracked_reference_by_table = 2 [deprecated = true];*/ 2:
                    message.namesByTrackedReferenceByTable.push(exports.NamesByTrackedReferenceArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.Reference reference_tracker = 1; */
        if (message.referenceTracker)
            TSPMessages_2.Reference.internalBinaryWrite(message.referenceTracker, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.NamesByTrackedReferenceArchive names_by_tracked_reference_by_table = 2 [deprecated = true]; */
        for (let i = 0; i < message.namesByTrackedReferenceByTable.length; i++)
            exports.NamesByTrackedReferenceArchive.internalBinaryWrite(message.namesByTrackedReferenceByTable[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.NamedReferenceManagerArchive
 */
exports.NamedReferenceManagerArchive = new NamedReferenceManagerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UuidSetStoreArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.UuidSetStoreArchive", [
            { no: 1, name: "uuidSet", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.UuidSetStoreArchive_UuidSet }
        ]);
    }
    create(value) {
        const message = { uuidSet: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSCE.UuidSetStoreArchive.UuidSet uuidSet */ 1:
                    message.uuidSet.push(exports.UuidSetStoreArchive_UuidSet.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSCE.UuidSetStoreArchive.UuidSet uuidSet = 1; */
        for (let i = 0; i < message.uuidSet.length; i++)
            exports.UuidSetStoreArchive_UuidSet.internalBinaryWrite(message.uuidSet[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.UuidSetStoreArchive
 */
exports.UuidSetStoreArchive = new UuidSetStoreArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UuidSetStoreArchive_UuidSet$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.UuidSetStoreArchive.UuidSet", [
            { no: 1, name: "uuid", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_3.UUID },
            { no: 2, name: "index_of_set", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { uuid: [], indexOfSet: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.UUID uuid */ 1:
                    message.uuid.push(TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 index_of_set */ 2:
                    message.indexOfSet = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.UUID uuid = 1; */
        for (let i = 0; i < message.uuid.length; i++)
            TSPMessages_3.UUID.internalBinaryWrite(message.uuid[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 index_of_set = 2; */
        if (message.indexOfSet !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.indexOfSet);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.UuidSetStoreArchive.UuidSet
 */
exports.UuidSetStoreArchive_UuidSet = new UuidSetStoreArchive_UuidSet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UuidReferenceMapArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.UuidReferenceMapArchive", [
            { no: 1, name: "cell_refs_for_uuid", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.UuidReferenceMapArchive_CellRefsForUuid }
        ]);
    }
    create(value) {
        const message = { cellRefsForUuid: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSCE.UuidReferenceMapArchive.CellRefsForUuid cell_refs_for_uuid */ 1:
                    message.cellRefsForUuid.push(exports.UuidReferenceMapArchive_CellRefsForUuid.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSCE.UuidReferenceMapArchive.CellRefsForUuid cell_refs_for_uuid = 1; */
        for (let i = 0; i < message.cellRefsForUuid.length; i++)
            exports.UuidReferenceMapArchive_CellRefsForUuid.internalBinaryWrite(message.cellRefsForUuid[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.UuidReferenceMapArchive
 */
exports.UuidReferenceMapArchive = new UuidReferenceMapArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UuidReferenceMapArchive_CellRefsForUuid$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.UuidReferenceMapArchive.CellRefsForUuid", [
            { no: 1, name: "uuid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 2, name: "cell_ref", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.InternalCellReferenceArchive },
            { no: 3, name: "cell_refs", kind: "message", T: () => exports.InternalCellRefSetArchive }
        ]);
    }
    create(value) {
        const message = { cellRef: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID uuid */ 1:
                    message.uuid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.uuid);
                    break;
                case /* repeated TSCE.InternalCellReferenceArchive cell_ref */ 2:
                    message.cellRef.push(exports.InternalCellReferenceArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSCE.InternalCellRefSetArchive cell_refs */ 3:
                    message.cellRefs = exports.InternalCellRefSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellRefs);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID uuid = 1; */
        if (message.uuid)
            TSPMessages_3.UUID.internalBinaryWrite(message.uuid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.InternalCellReferenceArchive cell_ref = 2; */
        for (let i = 0; i < message.cellRef.length; i++)
            exports.InternalCellReferenceArchive.internalBinaryWrite(message.cellRef[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.InternalCellRefSetArchive cell_refs = 3; */
        if (message.cellRefs)
            exports.InternalCellRefSetArchive.internalBinaryWrite(message.cellRefs, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.UuidReferenceMapArchive.CellRefsForUuid
 */
exports.UuidReferenceMapArchive_CellRefsForUuid = new UuidReferenceMapArchive_CellRefsForUuid$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupByNodeMapArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.GroupByNodeMapArchive", [
            { no: 1, name: "refs_for_group_by", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.GroupByNodeMapArchive_GroupNodesForGroupBy }
        ]);
    }
    create(value) {
        const message = { refsForGroupBy: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSCE.GroupByNodeMapArchive.GroupNodesForGroupBy refs_for_group_by */ 1:
                    message.refsForGroupBy.push(exports.GroupByNodeMapArchive_GroupNodesForGroupBy.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSCE.GroupByNodeMapArchive.GroupNodesForGroupBy refs_for_group_by = 1; */
        for (let i = 0; i < message.refsForGroupBy.length; i++)
            exports.GroupByNodeMapArchive_GroupNodesForGroupBy.internalBinaryWrite(message.refsForGroupBy[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.GroupByNodeMapArchive
 */
exports.GroupByNodeMapArchive = new GroupByNodeMapArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupByNodeMapArchive_CellRefsForGroupNode$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.GroupByNodeMapArchive.CellRefsForGroupNode", [
            { no: 1, name: "group_node_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 3, name: "cell_refs", kind: "message", T: () => exports.InternalCellRefSetArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID group_node_uid */ 1:
                    message.groupNodeUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.groupNodeUid);
                    break;
                case /* optional TSCE.InternalCellRefSetArchive cell_refs */ 3:
                    message.cellRefs = exports.InternalCellRefSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellRefs);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID group_node_uid = 1; */
        if (message.groupNodeUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.groupNodeUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.InternalCellRefSetArchive cell_refs = 3; */
        if (message.cellRefs)
            exports.InternalCellRefSetArchive.internalBinaryWrite(message.cellRefs, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.GroupByNodeMapArchive.CellRefsForGroupNode
 */
exports.GroupByNodeMapArchive_CellRefsForGroupNode = new GroupByNodeMapArchive_CellRefsForGroupNode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupByNodeMapArchive_GroupNodesForGroupBy$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.GroupByNodeMapArchive.GroupNodesForGroupBy", [
            { no: 1, name: "group_by_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 2, name: "refs_for_group_node", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.GroupByNodeMapArchive_CellRefsForGroupNode }
        ]);
    }
    create(value) {
        const message = { refsForGroupNode: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID group_by_uid */ 1:
                    message.groupByUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.groupByUid);
                    break;
                case /* repeated TSCE.GroupByNodeMapArchive.CellRefsForGroupNode refs_for_group_node */ 2:
                    message.refsForGroupNode.push(exports.GroupByNodeMapArchive_CellRefsForGroupNode.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID group_by_uid = 1; */
        if (message.groupByUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.groupByUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.GroupByNodeMapArchive.CellRefsForGroupNode refs_for_group_node = 2; */
        for (let i = 0; i < message.refsForGroupNode.length; i++)
            exports.GroupByNodeMapArchive_CellRefsForGroupNode.internalBinaryWrite(message.refsForGroupNode[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.GroupByNodeMapArchive.GroupNodesForGroupBy
 */
exports.GroupByNodeMapArchive_GroupNodesForGroupBy = new GroupByNodeMapArchive_GroupNodesForGroupBy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CalculationEngineArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.CalculationEngineArchive", [
            { no: 1, name: "base_date_1904", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "dependency_tracker", kind: "message", T: () => exports.DependencyTrackerArchive },
            { no: 3, name: "named_reference_manager", kind: "message", T: () => TSPMessages_2.Reference },
            { no: 4, name: "excel_import_date_mode", kind: "enum", opt: true, T: () => ["TSCE.CalculationEngineArchive.ExcelImportDateMode", CalculationEngineArchive_ExcelImportDateMode] },
            { no: 5, name: "saved_locale_identifier_for_4_2", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "document_random_seed", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "uuid_reference_map", kind: "message", T: () => exports.UuidReferenceMapArchive },
            { no: 9, name: "document_timestamp", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 10, name: "document_timezone", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "table_uid_history", kind: "message", T: () => exports.RewriteTableUIDInfoArchive },
            { no: 12, name: "remote_data_store", kind: "message", T: () => TSPMessages_2.Reference },
            { no: 13, name: "group_node_map", kind: "message", T: () => exports.GroupByNodeMapArchive },
            { no: 14, name: "header_name_manager", kind: "message", T: () => TSPMessages_2.Reference },
            { no: 15, name: "refs_to_dirty", kind: "message", T: () => TSPMessages_2.Reference },
            { no: 16, name: "saved_locale_identifier", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "begin_tracking_names_legacy_nrm", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_3.UUID },
            { no: 18, name: "end_tracking_names_legacy_nrm", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_3.UUID }
        ]);
    }
    create(value) {
        const message = { beginTrackingNamesLegacyNrm: [], endTrackingNamesLegacyNrm: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool base_date_1904 */ 1:
                    message.baseDate1904 = reader.bool();
                    break;
                case /* TSCE.DependencyTrackerArchive dependency_tracker */ 2:
                    message.dependencyTracker = exports.DependencyTrackerArchive.internalBinaryRead(reader, reader.uint32(), options, message.dependencyTracker);
                    break;
                case /* optional TSP.Reference named_reference_manager */ 3:
                    message.namedReferenceManager = TSPMessages_2.Reference.internalBinaryRead(reader, reader.uint32(), options, message.namedReferenceManager);
                    break;
                case /* optional TSCE.CalculationEngineArchive.ExcelImportDateMode excel_import_date_mode */ 4:
                    message.excelImportDateMode = reader.int32();
                    break;
                case /* optional string saved_locale_identifier_for_4_2 */ 5:
                    message.savedLocaleIdentifierFor42 = reader.string();
                    break;
                case /* optional uint64 document_random_seed */ 6:
                    message.documentRandomSeed = reader.uint64().toBigInt();
                    break;
                case /* optional TSCE.UuidReferenceMapArchive uuid_reference_map */ 7:
                    message.uuidReferenceMap = exports.UuidReferenceMapArchive.internalBinaryRead(reader, reader.uint32(), options, message.uuidReferenceMap);
                    break;
                case /* optional double document_timestamp */ 9:
                    message.documentTimestamp = reader.double();
                    break;
                case /* optional string document_timezone */ 10:
                    message.documentTimezone = reader.string();
                    break;
                case /* optional TSCE.RewriteTableUIDInfoArchive table_uid_history */ 11:
                    message.tableUidHistory = exports.RewriteTableUIDInfoArchive.internalBinaryRead(reader, reader.uint32(), options, message.tableUidHistory);
                    break;
                case /* optional TSP.Reference remote_data_store */ 12:
                    message.remoteDataStore = TSPMessages_2.Reference.internalBinaryRead(reader, reader.uint32(), options, message.remoteDataStore);
                    break;
                case /* optional TSCE.GroupByNodeMapArchive group_node_map */ 13:
                    message.groupNodeMap = exports.GroupByNodeMapArchive.internalBinaryRead(reader, reader.uint32(), options, message.groupNodeMap);
                    break;
                case /* optional TSP.Reference header_name_manager */ 14:
                    message.headerNameManager = TSPMessages_2.Reference.internalBinaryRead(reader, reader.uint32(), options, message.headerNameManager);
                    break;
                case /* optional TSP.Reference refs_to_dirty */ 15:
                    message.refsToDirty = TSPMessages_2.Reference.internalBinaryRead(reader, reader.uint32(), options, message.refsToDirty);
                    break;
                case /* optional string saved_locale_identifier */ 16:
                    message.savedLocaleIdentifier = reader.string();
                    break;
                case /* repeated TSP.UUID begin_tracking_names_legacy_nrm */ 17:
                    message.beginTrackingNamesLegacyNrm.push(TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID end_tracking_names_legacy_nrm */ 18:
                    message.endTrackingNamesLegacyNrm.push(TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional bool base_date_1904 = 1; */
        if (message.baseDate1904 !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.baseDate1904);
        /* TSCE.DependencyTrackerArchive dependency_tracker = 2; */
        if (message.dependencyTracker)
            exports.DependencyTrackerArchive.internalBinaryWrite(message.dependencyTracker, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference named_reference_manager = 3; */
        if (message.namedReferenceManager)
            TSPMessages_2.Reference.internalBinaryWrite(message.namedReferenceManager, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.CalculationEngineArchive.ExcelImportDateMode excel_import_date_mode = 4; */
        if (message.excelImportDateMode !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).int32(message.excelImportDateMode);
        /* optional string saved_locale_identifier_for_4_2 = 5; */
        if (message.savedLocaleIdentifierFor42 !== undefined)
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.savedLocaleIdentifierFor42);
        /* optional uint64 document_random_seed = 6; */
        if (message.documentRandomSeed !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).uint64(message.documentRandomSeed);
        /* optional TSCE.UuidReferenceMapArchive uuid_reference_map = 7; */
        if (message.uuidReferenceMap)
            exports.UuidReferenceMapArchive.internalBinaryWrite(message.uuidReferenceMap, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional double document_timestamp = 9; */
        if (message.documentTimestamp !== undefined)
            writer.tag(9, runtime_1.WireType.Bit64).double(message.documentTimestamp);
        /* optional string document_timezone = 10; */
        if (message.documentTimezone !== undefined)
            writer.tag(10, runtime_1.WireType.LengthDelimited).string(message.documentTimezone);
        /* optional TSCE.RewriteTableUIDInfoArchive table_uid_history = 11; */
        if (message.tableUidHistory)
            exports.RewriteTableUIDInfoArchive.internalBinaryWrite(message.tableUidHistory, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference remote_data_store = 12; */
        if (message.remoteDataStore)
            TSPMessages_2.Reference.internalBinaryWrite(message.remoteDataStore, writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.GroupByNodeMapArchive group_node_map = 13; */
        if (message.groupNodeMap)
            exports.GroupByNodeMapArchive.internalBinaryWrite(message.groupNodeMap, writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference header_name_manager = 14; */
        if (message.headerNameManager)
            TSPMessages_2.Reference.internalBinaryWrite(message.headerNameManager, writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference refs_to_dirty = 15; */
        if (message.refsToDirty)
            TSPMessages_2.Reference.internalBinaryWrite(message.refsToDirty, writer.tag(15, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string saved_locale_identifier = 16; */
        if (message.savedLocaleIdentifier !== undefined)
            writer.tag(16, runtime_1.WireType.LengthDelimited).string(message.savedLocaleIdentifier);
        /* repeated TSP.UUID begin_tracking_names_legacy_nrm = 17; */
        for (let i = 0; i < message.beginTrackingNamesLegacyNrm.length; i++)
            TSPMessages_3.UUID.internalBinaryWrite(message.beginTrackingNamesLegacyNrm[i], writer.tag(17, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID end_tracking_names_legacy_nrm = 18; */
        for (let i = 0; i < message.endTrackingNamesLegacyNrm.length; i++)
            TSPMessages_3.UUID.internalBinaryWrite(message.endTrackingNamesLegacyNrm[i], writer.tag(18, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.CalculationEngineArchive
 */
exports.CalculationEngineArchive = new CalculationEngineArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PreserveColumnRowFlagsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.PreserveColumnRowFlagsArchive", [
            { no: 1, name: "begin_row_is_absolute", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "begin_column_is_absolute", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "end_row_is_absolute", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "end_column_is_absolute", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { beginRowIsAbsolute: false, beginColumnIsAbsolute: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool begin_row_is_absolute */ 1:
                    message.beginRowIsAbsolute = reader.bool();
                    break;
                case /* bool begin_column_is_absolute */ 2:
                    message.beginColumnIsAbsolute = reader.bool();
                    break;
                case /* optional bool end_row_is_absolute */ 3:
                    message.endRowIsAbsolute = reader.bool();
                    break;
                case /* optional bool end_column_is_absolute */ 4:
                    message.endColumnIsAbsolute = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool begin_row_is_absolute = 1; */
        if (message.beginRowIsAbsolute !== false)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.beginRowIsAbsolute);
        /* bool begin_column_is_absolute = 2; */
        if (message.beginColumnIsAbsolute !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.beginColumnIsAbsolute);
        /* optional bool end_row_is_absolute = 3; */
        if (message.endRowIsAbsolute !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.endRowIsAbsolute);
        /* optional bool end_column_is_absolute = 4; */
        if (message.endColumnIsAbsolute !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.endColumnIsAbsolute);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.PreserveColumnRowFlagsArchive
 */
exports.PreserveColumnRowFlagsArchive = new PreserveColumnRowFlagsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CategoryReferenceArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.CategoryReferenceArchive", [
            { no: 1, name: "group_by_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 2, name: "column_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 3, name: "aggregate_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "group_level", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 6, name: "group_uids", kind: "message", T: () => exports.CategoryReferenceArchive_CatRefUidList },
            { no: 7, name: "preserve_flags", kind: "message", T: () => exports.PreserveColumnRowFlagsArchive },
            { no: 8, name: "relative_column", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "relative_group_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 10, name: "absolute_group_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 11, name: "option_refers_to_pivot_rows", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "option_refers_to_pivot_columns", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "agg_index_level", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "option_show_aggregate_name", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { aggregateType: 0, groupLevel: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID group_by_uid */ 1:
                    message.groupByUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.groupByUid);
                    break;
                case /* TSP.UUID column_uid */ 2:
                    message.columnUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.columnUid);
                    break;
                case /* uint32 aggregate_type */ 3:
                    message.aggregateType = reader.uint32();
                    break;
                case /* sint32 group_level */ 4:
                    message.groupLevel = reader.sint32();
                    break;
                case /* optional TSCE.CategoryReferenceArchive.CatRefUidList group_uids */ 6:
                    message.groupUids = exports.CategoryReferenceArchive_CatRefUidList.internalBinaryRead(reader, reader.uint32(), options, message.groupUids);
                    break;
                case /* optional TSCE.PreserveColumnRowFlagsArchive preserve_flags */ 7:
                    message.preserveFlags = exports.PreserveColumnRowFlagsArchive.internalBinaryRead(reader, reader.uint32(), options, message.preserveFlags);
                    break;
                case /* optional int32 relative_column */ 8:
                    message.relativeColumn = reader.int32();
                    break;
                case /* optional TSP.UUID relative_group_uid */ 9:
                    message.relativeGroupUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.relativeGroupUid);
                    break;
                case /* optional TSP.UUID absolute_group_uid */ 10:
                    message.absoluteGroupUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.absoluteGroupUid);
                    break;
                case /* optional bool option_refers_to_pivot_rows */ 11:
                    message.optionRefersToPivotRows = reader.bool();
                    break;
                case /* optional bool option_refers_to_pivot_columns */ 12:
                    message.optionRefersToPivotColumns = reader.bool();
                    break;
                case /* optional uint32 agg_index_level */ 13:
                    message.aggIndexLevel = reader.uint32();
                    break;
                case /* optional bool option_show_aggregate_name */ 14:
                    message.optionShowAggregateName = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID group_by_uid = 1; */
        if (message.groupByUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.groupByUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID column_uid = 2; */
        if (message.columnUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.columnUid, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 aggregate_type = 3; */
        if (message.aggregateType !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.aggregateType);
        /* sint32 group_level = 4; */
        if (message.groupLevel !== 0)
            writer.tag(4, runtime_1.WireType.Varint).sint32(message.groupLevel);
        /* optional TSCE.CategoryReferenceArchive.CatRefUidList group_uids = 6; */
        if (message.groupUids)
            exports.CategoryReferenceArchive_CatRefUidList.internalBinaryWrite(message.groupUids, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.PreserveColumnRowFlagsArchive preserve_flags = 7; */
        if (message.preserveFlags)
            exports.PreserveColumnRowFlagsArchive.internalBinaryWrite(message.preserveFlags, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional int32 relative_column = 8; */
        if (message.relativeColumn !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).int32(message.relativeColumn);
        /* optional TSP.UUID relative_group_uid = 9; */
        if (message.relativeGroupUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.relativeGroupUid, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID absolute_group_uid = 10; */
        if (message.absoluteGroupUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.absoluteGroupUid, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool option_refers_to_pivot_rows = 11; */
        if (message.optionRefersToPivotRows !== undefined)
            writer.tag(11, runtime_1.WireType.Varint).bool(message.optionRefersToPivotRows);
        /* optional bool option_refers_to_pivot_columns = 12; */
        if (message.optionRefersToPivotColumns !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).bool(message.optionRefersToPivotColumns);
        /* optional uint32 agg_index_level = 13; */
        if (message.aggIndexLevel !== undefined)
            writer.tag(13, runtime_1.WireType.Varint).uint32(message.aggIndexLevel);
        /* optional bool option_show_aggregate_name = 14; */
        if (message.optionShowAggregateName !== undefined)
            writer.tag(14, runtime_1.WireType.Varint).bool(message.optionShowAggregateName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.CategoryReferenceArchive
 */
exports.CategoryReferenceArchive = new CategoryReferenceArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CategoryReferenceArchive_CatRefUidList$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.CategoryReferenceArchive.CatRefUidList", [
            { no: 1, name: "uid", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_3.UUID }
        ]);
    }
    create(value) {
        const message = { uid: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.UUID uid */ 1:
                    message.uid.push(TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.UUID uid = 1; */
        for (let i = 0; i < message.uid.length; i++)
            TSPMessages_3.UUID.internalBinaryWrite(message.uid[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.CategoryReferenceArchive.CatRefUidList
 */
exports.CategoryReferenceArchive_CatRefUidList = new CategoryReferenceArchive_CatRefUidList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ASTNodeArrayArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.ASTNodeArrayArchive", [
            { no: 1, name: "AST_node", kind: "message", jsonName: "ASTNode", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ASTNodeArrayArchive_ASTNodeArchive }
        ]);
    }
    create(value) {
        const message = { aSTNode: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSCE.ASTNodeArrayArchive.ASTNodeArchive AST_node = 1 [json_name = "ASTNode"];*/ 1:
                    message.aSTNode.push(exports.ASTNodeArrayArchive_ASTNodeArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSCE.ASTNodeArrayArchive.ASTNodeArchive AST_node = 1 [json_name = "ASTNode"]; */
        for (let i = 0; i < message.aSTNode.length; i++)
            exports.ASTNodeArrayArchive_ASTNodeArchive.internalBinaryWrite(message.aSTNode[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.ASTNodeArrayArchive
 */
exports.ASTNodeArrayArchive = new ASTNodeArrayArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.ASTNodeArrayArchive.ASTLocalCellReferenceNodeArchive", [
            { no: 1, name: "row_handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "column_handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "row_is_sticky", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "column_is_sticky", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { rowHandle: 0, columnHandle: 0, rowIsSticky: 0, columnIsSticky: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 row_handle */ 1:
                    message.rowHandle = reader.uint32();
                    break;
                case /* uint32 column_handle */ 2:
                    message.columnHandle = reader.uint32();
                    break;
                case /* uint32 row_is_sticky */ 3:
                    message.rowIsSticky = reader.uint32();
                    break;
                case /* uint32 column_is_sticky */ 4:
                    message.columnIsSticky = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 row_handle = 1; */
        if (message.rowHandle !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.rowHandle);
        /* uint32 column_handle = 2; */
        if (message.columnHandle !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.columnHandle);
        /* uint32 row_is_sticky = 3; */
        if (message.rowIsSticky !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.rowIsSticky);
        /* uint32 column_is_sticky = 4; */
        if (message.columnIsSticky !== 0)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.columnIsSticky);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.ASTNodeArrayArchive.ASTLocalCellReferenceNodeArchive
 */
exports.ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive = new ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.ASTNodeArrayArchive.ASTCrossTableCellReferenceNodeArchive", [
            { no: 1, name: "row_handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "column_handle", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "row_is_sticky", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "column_is_sticky", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "table_id", kind: "message", T: () => TSPMessages_4.CFUUIDArchive },
            { no: 6, name: "AST_reference_whitespace_after_sheet_name", kind: "scalar", jsonName: "ASTReferenceWhitespaceAfterSheetName", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "AST_reference_whitespace_before_table_name", kind: "scalar", jsonName: "ASTReferenceWhitespaceBeforeTableName", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "AST_reference_whitespace_after_table_name", kind: "scalar", jsonName: "ASTReferenceWhitespaceAfterTableName", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "AST_reference_whitespace_before_cell_address", kind: "scalar", jsonName: "ASTReferenceWhitespaceBeforeCellAddress", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { rowHandle: 0, columnHandle: 0, rowIsSticky: 0, columnIsSticky: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 row_handle */ 1:
                    message.rowHandle = reader.uint32();
                    break;
                case /* uint32 column_handle */ 2:
                    message.columnHandle = reader.uint32();
                    break;
                case /* uint32 row_is_sticky */ 3:
                    message.rowIsSticky = reader.uint32();
                    break;
                case /* uint32 column_is_sticky */ 4:
                    message.columnIsSticky = reader.uint32();
                    break;
                case /* TSP.CFUUIDArchive table_id */ 5:
                    message.tableId = TSPMessages_4.CFUUIDArchive.internalBinaryRead(reader, reader.uint32(), options, message.tableId);
                    break;
                case /* optional string AST_reference_whitespace_after_sheet_name = 6 [json_name = "ASTReferenceWhitespaceAfterSheetName"];*/ 6:
                    message.aSTReferenceWhitespaceAfterSheetName = reader.string();
                    break;
                case /* optional string AST_reference_whitespace_before_table_name = 7 [json_name = "ASTReferenceWhitespaceBeforeTableName"];*/ 7:
                    message.aSTReferenceWhitespaceBeforeTableName = reader.string();
                    break;
                case /* optional string AST_reference_whitespace_after_table_name = 8 [json_name = "ASTReferenceWhitespaceAfterTableName"];*/ 8:
                    message.aSTReferenceWhitespaceAfterTableName = reader.string();
                    break;
                case /* optional string AST_reference_whitespace_before_cell_address = 9 [json_name = "ASTReferenceWhitespaceBeforeCellAddress"];*/ 9:
                    message.aSTReferenceWhitespaceBeforeCellAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 row_handle = 1; */
        if (message.rowHandle !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.rowHandle);
        /* uint32 column_handle = 2; */
        if (message.columnHandle !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.columnHandle);
        /* uint32 row_is_sticky = 3; */
        if (message.rowIsSticky !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.rowIsSticky);
        /* uint32 column_is_sticky = 4; */
        if (message.columnIsSticky !== 0)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.columnIsSticky);
        /* TSP.CFUUIDArchive table_id = 5; */
        if (message.tableId)
            TSPMessages_4.CFUUIDArchive.internalBinaryWrite(message.tableId, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string AST_reference_whitespace_after_sheet_name = 6 [json_name = "ASTReferenceWhitespaceAfterSheetName"]; */
        if (message.aSTReferenceWhitespaceAfterSheetName !== undefined)
            writer.tag(6, runtime_1.WireType.LengthDelimited).string(message.aSTReferenceWhitespaceAfterSheetName);
        /* optional string AST_reference_whitespace_before_table_name = 7 [json_name = "ASTReferenceWhitespaceBeforeTableName"]; */
        if (message.aSTReferenceWhitespaceBeforeTableName !== undefined)
            writer.tag(7, runtime_1.WireType.LengthDelimited).string(message.aSTReferenceWhitespaceBeforeTableName);
        /* optional string AST_reference_whitespace_after_table_name = 8 [json_name = "ASTReferenceWhitespaceAfterTableName"]; */
        if (message.aSTReferenceWhitespaceAfterTableName !== undefined)
            writer.tag(8, runtime_1.WireType.LengthDelimited).string(message.aSTReferenceWhitespaceAfterTableName);
        /* optional string AST_reference_whitespace_before_cell_address = 9 [json_name = "ASTReferenceWhitespaceBeforeCellAddress"]; */
        if (message.aSTReferenceWhitespaceBeforeCellAddress !== undefined)
            writer.tag(9, runtime_1.WireType.LengthDelimited).string(message.aSTReferenceWhitespaceBeforeCellAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.ASTNodeArrayArchive.ASTCrossTableCellReferenceNodeArchive
 */
exports.ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive = new ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ASTNodeArrayArchive_ASTColumnCoordinateArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.ASTNodeArrayArchive.ASTColumnCoordinateArchive", [
            { no: 1, name: "column", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 2, name: "absolute", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { column: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint32 column */ 1:
                    message.column = reader.sint32();
                    break;
                case /* optional bool absolute */ 2:
                    message.absolute = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* sint32 column = 1; */
        if (message.column !== 0)
            writer.tag(1, runtime_1.WireType.Varint).sint32(message.column);
        /* optional bool absolute = 2; */
        if (message.absolute !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.absolute);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.ASTNodeArrayArchive.ASTColumnCoordinateArchive
 */
exports.ASTNodeArrayArchive_ASTColumnCoordinateArchive = new ASTNodeArrayArchive_ASTColumnCoordinateArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ASTNodeArrayArchive_ASTRowCoordinateArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.ASTNodeArrayArchive.ASTRowCoordinateArchive", [
            { no: 1, name: "row", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 2, name: "absolute", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { row: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint32 row */ 1:
                    message.row = reader.sint32();
                    break;
                case /* optional bool absolute */ 2:
                    message.absolute = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* sint32 row = 1; */
        if (message.row !== 0)
            writer.tag(1, runtime_1.WireType.Varint).sint32(message.row);
        /* optional bool absolute = 2; */
        if (message.absolute !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.absolute);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.ASTNodeArrayArchive.ASTRowCoordinateArchive
 */
exports.ASTNodeArrayArchive_ASTRowCoordinateArchive = new ASTNodeArrayArchive_ASTRowCoordinateArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ASTNodeArrayArchive_ASTUidList$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.ASTNodeArrayArchive.ASTUidList", [
            { no: 1, name: "uid", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_3.UUID }
        ]);
    }
    create(value) {
        const message = { uid: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.UUID uid */ 1:
                    message.uid.push(TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.UUID uid = 1; */
        for (let i = 0; i < message.uid.length; i++)
            TSPMessages_3.UUID.internalBinaryWrite(message.uid[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.ASTNodeArrayArchive.ASTUidList
 */
exports.ASTNodeArrayArchive_ASTUidList = new ASTNodeArrayArchive_ASTUidList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ASTNodeArrayArchive_ASTUidTract$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.ASTNodeArrayArchive.ASTUidTract", [
            { no: 1, name: "columnUids", kind: "message", T: () => exports.ASTNodeArrayArchive_ASTUidList },
            { no: 2, name: "rowUids", kind: "message", T: () => exports.ASTNodeArrayArchive_ASTUidList },
            { no: 3, name: "is_range_ref", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "purpose", kind: "enum", opt: true, T: () => ["TSCE.ASTNodeArrayArchive.ASTUidTractPurpose", ASTNodeArrayArchive_ASTUidTractPurpose] },
            { no: 5, name: "preserve_rectangular", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSCE.ASTNodeArrayArchive.ASTUidList columnUids */ 1:
                    message.columnUids = exports.ASTNodeArrayArchive_ASTUidList.internalBinaryRead(reader, reader.uint32(), options, message.columnUids);
                    break;
                case /* TSCE.ASTNodeArrayArchive.ASTUidList rowUids */ 2:
                    message.rowUids = exports.ASTNodeArrayArchive_ASTUidList.internalBinaryRead(reader, reader.uint32(), options, message.rowUids);
                    break;
                case /* optional bool is_range_ref */ 3:
                    message.isRangeRef = reader.bool();
                    break;
                case /* optional TSCE.ASTNodeArrayArchive.ASTUidTractPurpose purpose */ 4:
                    message.purpose = reader.int32();
                    break;
                case /* optional bool preserve_rectangular */ 5:
                    message.preserveRectangular = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSCE.ASTNodeArrayArchive.ASTUidList columnUids = 1; */
        if (message.columnUids)
            exports.ASTNodeArrayArchive_ASTUidList.internalBinaryWrite(message.columnUids, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSCE.ASTNodeArrayArchive.ASTUidList rowUids = 2; */
        if (message.rowUids)
            exports.ASTNodeArrayArchive_ASTUidList.internalBinaryWrite(message.rowUids, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_range_ref = 3; */
        if (message.isRangeRef !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.isRangeRef);
        /* optional TSCE.ASTNodeArrayArchive.ASTUidTractPurpose purpose = 4; */
        if (message.purpose !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).int32(message.purpose);
        /* optional bool preserve_rectangular = 5; */
        if (message.preserveRectangular !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.preserveRectangular);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.ASTNodeArrayArchive.ASTUidTract
 */
exports.ASTNodeArrayArchive_ASTUidTract = new ASTNodeArrayArchive_ASTUidTract$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ASTNodeArrayArchive_ASTStickyBits$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.ASTNodeArrayArchive.ASTStickyBits", [
            { no: 1, name: "begin_row_is_absolute", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "begin_column_is_absolute", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "end_row_is_absolute", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "end_column_is_absolute", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { beginRowIsAbsolute: false, beginColumnIsAbsolute: false, endRowIsAbsolute: false, endColumnIsAbsolute: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool begin_row_is_absolute */ 1:
                    message.beginRowIsAbsolute = reader.bool();
                    break;
                case /* bool begin_column_is_absolute */ 2:
                    message.beginColumnIsAbsolute = reader.bool();
                    break;
                case /* bool end_row_is_absolute */ 3:
                    message.endRowIsAbsolute = reader.bool();
                    break;
                case /* bool end_column_is_absolute */ 4:
                    message.endColumnIsAbsolute = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool begin_row_is_absolute = 1; */
        if (message.beginRowIsAbsolute !== false)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.beginRowIsAbsolute);
        /* bool begin_column_is_absolute = 2; */
        if (message.beginColumnIsAbsolute !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.beginColumnIsAbsolute);
        /* bool end_row_is_absolute = 3; */
        if (message.endRowIsAbsolute !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.endRowIsAbsolute);
        /* bool end_column_is_absolute = 4; */
        if (message.endColumnIsAbsolute !== false)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.endColumnIsAbsolute);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.ASTNodeArrayArchive.ASTStickyBits
 */
exports.ASTNodeArrayArchive_ASTStickyBits = new ASTNodeArrayArchive_ASTStickyBits$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ASTNodeArrayArchive_ASTUidTractList$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.ASTNodeArrayArchive.ASTUidTractList", [
            { no: 1, name: "tract", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ASTNodeArrayArchive_ASTUidTract },
            { no: 2, name: "sticky_bits", kind: "message", T: () => exports.ASTNodeArrayArchive_ASTStickyBits }
        ]);
    }
    create(value) {
        const message = { tract: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSCE.ASTNodeArrayArchive.ASTUidTract tract */ 1:
                    message.tract.push(exports.ASTNodeArrayArchive_ASTUidTract.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* TSCE.ASTNodeArrayArchive.ASTStickyBits sticky_bits */ 2:
                    message.stickyBits = exports.ASTNodeArrayArchive_ASTStickyBits.internalBinaryRead(reader, reader.uint32(), options, message.stickyBits);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSCE.ASTNodeArrayArchive.ASTUidTract tract = 1; */
        for (let i = 0; i < message.tract.length; i++)
            exports.ASTNodeArrayArchive_ASTUidTract.internalBinaryWrite(message.tract[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSCE.ASTNodeArrayArchive.ASTStickyBits sticky_bits = 2; */
        if (message.stickyBits)
            exports.ASTNodeArrayArchive_ASTStickyBits.internalBinaryWrite(message.stickyBits, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.ASTNodeArrayArchive.ASTUidTractList
 */
exports.ASTNodeArrayArchive_ASTUidTractList = new ASTNodeArrayArchive_ASTUidTractList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ASTNodeArrayArchive_ASTUidCoordinateArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.ASTNodeArrayArchive.ASTUidCoordinateArchive", [
            { no: 1, name: "column_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 2, name: "row_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 3, name: "column_absolute", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "row_absolute", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { columnAbsolute: false, rowAbsolute: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID column_uid */ 1:
                    message.columnUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.columnUid);
                    break;
                case /* TSP.UUID row_uid */ 2:
                    message.rowUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.rowUid);
                    break;
                case /* bool column_absolute */ 3:
                    message.columnAbsolute = reader.bool();
                    break;
                case /* bool row_absolute */ 4:
                    message.rowAbsolute = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID column_uid = 1; */
        if (message.columnUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.columnUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID row_uid = 2; */
        if (message.rowUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.rowUid, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool column_absolute = 3; */
        if (message.columnAbsolute !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.columnAbsolute);
        /* bool row_absolute = 4; */
        if (message.rowAbsolute !== false)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.rowAbsolute);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.ASTNodeArrayArchive.ASTUidCoordinateArchive
 */
exports.ASTNodeArrayArchive_ASTUidCoordinateArchive = new ASTNodeArrayArchive_ASTUidCoordinateArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ASTNodeArrayArchive_ASTCategoryLevels$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.ASTNodeArrayArchive.ASTCategoryLevels", [
            { no: 1, name: "AST_column_group_level", kind: "scalar", jsonName: "ASTColumnGroupLevel", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "AST_row_group_level", kind: "scalar", jsonName: "ASTRowGroupLevel", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "AST_agg_index_level", kind: "scalar", jsonName: "ASTAggIndexLevel", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { aSTColumnGroupLevel: 0, aSTRowGroupLevel: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 AST_column_group_level = 1 [json_name = "ASTColumnGroupLevel"];*/ 1:
                    message.aSTColumnGroupLevel = reader.uint32();
                    break;
                case /* uint32 AST_row_group_level = 2 [json_name = "ASTRowGroupLevel"];*/ 2:
                    message.aSTRowGroupLevel = reader.uint32();
                    break;
                case /* optional uint32 AST_agg_index_level = 3 [json_name = "ASTAggIndexLevel"];*/ 3:
                    message.aSTAggIndexLevel = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 AST_column_group_level = 1 [json_name = "ASTColumnGroupLevel"]; */
        if (message.aSTColumnGroupLevel !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.aSTColumnGroupLevel);
        /* uint32 AST_row_group_level = 2 [json_name = "ASTRowGroupLevel"]; */
        if (message.aSTRowGroupLevel !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.aSTRowGroupLevel);
        /* optional uint32 AST_agg_index_level = 3 [json_name = "ASTAggIndexLevel"]; */
        if (message.aSTAggIndexLevel !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.aSTAggIndexLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.ASTNodeArrayArchive.ASTCategoryLevels
 */
exports.ASTNodeArrayArchive_ASTCategoryLevels = new ASTNodeArrayArchive_ASTCategoryLevels$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ASTNodeArrayArchive_ASTCategoryReferenceArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.ASTNodeArrayArchive.ASTCategoryReferenceArchive", [
            { no: 1, name: "category_ref", kind: "message", T: () => exports.CategoryReferenceArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSCE.CategoryReferenceArchive category_ref */ 1:
                    message.categoryRef = exports.CategoryReferenceArchive.internalBinaryRead(reader, reader.uint32(), options, message.categoryRef);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSCE.CategoryReferenceArchive category_ref = 1; */
        if (message.categoryRef)
            exports.CategoryReferenceArchive.internalBinaryWrite(message.categoryRef, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.ASTNodeArrayArchive.ASTCategoryReferenceArchive
 */
exports.ASTNodeArrayArchive_ASTCategoryReferenceArchive = new ASTNodeArrayArchive_ASTCategoryReferenceArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ASTNodeArrayArchive_ASTColonTractArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.ASTNodeArrayArchive.ASTColonTractArchive", [
            { no: 1, name: "relative_column", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ASTNodeArrayArchive_ASTColonTractArchive_ASTColonTractRelativeRangeArchive },
            { no: 2, name: "relative_row", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ASTNodeArrayArchive_ASTColonTractArchive_ASTColonTractRelativeRangeArchive },
            { no: 3, name: "absolute_column", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ASTNodeArrayArchive_ASTColonTractArchive_ASTColonTractAbsoluteRangeArchive },
            { no: 4, name: "absolute_row", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ASTNodeArrayArchive_ASTColonTractArchive_ASTColonTractAbsoluteRangeArchive },
            { no: 5, name: "preserve_rectangular", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { relativeColumn: [], relativeRow: [], absoluteColumn: [], absoluteRow: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSCE.ASTNodeArrayArchive.ASTColonTractArchive.ASTColonTractRelativeRangeArchive relative_column */ 1:
                    message.relativeColumn.push(exports.ASTNodeArrayArchive_ASTColonTractArchive_ASTColonTractRelativeRangeArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSCE.ASTNodeArrayArchive.ASTColonTractArchive.ASTColonTractRelativeRangeArchive relative_row */ 2:
                    message.relativeRow.push(exports.ASTNodeArrayArchive_ASTColonTractArchive_ASTColonTractRelativeRangeArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSCE.ASTNodeArrayArchive.ASTColonTractArchive.ASTColonTractAbsoluteRangeArchive absolute_column */ 3:
                    message.absoluteColumn.push(exports.ASTNodeArrayArchive_ASTColonTractArchive_ASTColonTractAbsoluteRangeArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSCE.ASTNodeArrayArchive.ASTColonTractArchive.ASTColonTractAbsoluteRangeArchive absolute_row */ 4:
                    message.absoluteRow.push(exports.ASTNodeArrayArchive_ASTColonTractArchive_ASTColonTractAbsoluteRangeArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool preserve_rectangular */ 5:
                    message.preserveRectangular = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSCE.ASTNodeArrayArchive.ASTColonTractArchive.ASTColonTractRelativeRangeArchive relative_column = 1; */
        for (let i = 0; i < message.relativeColumn.length; i++)
            exports.ASTNodeArrayArchive_ASTColonTractArchive_ASTColonTractRelativeRangeArchive.internalBinaryWrite(message.relativeColumn[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.ASTNodeArrayArchive.ASTColonTractArchive.ASTColonTractRelativeRangeArchive relative_row = 2; */
        for (let i = 0; i < message.relativeRow.length; i++)
            exports.ASTNodeArrayArchive_ASTColonTractArchive_ASTColonTractRelativeRangeArchive.internalBinaryWrite(message.relativeRow[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.ASTNodeArrayArchive.ASTColonTractArchive.ASTColonTractAbsoluteRangeArchive absolute_column = 3; */
        for (let i = 0; i < message.absoluteColumn.length; i++)
            exports.ASTNodeArrayArchive_ASTColonTractArchive_ASTColonTractAbsoluteRangeArchive.internalBinaryWrite(message.absoluteColumn[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.ASTNodeArrayArchive.ASTColonTractArchive.ASTColonTractAbsoluteRangeArchive absolute_row = 4; */
        for (let i = 0; i < message.absoluteRow.length; i++)
            exports.ASTNodeArrayArchive_ASTColonTractArchive_ASTColonTractAbsoluteRangeArchive.internalBinaryWrite(message.absoluteRow[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool preserve_rectangular = 5; */
        if (message.preserveRectangular !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.preserveRectangular);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.ASTNodeArrayArchive.ASTColonTractArchive
 */
exports.ASTNodeArrayArchive_ASTColonTractArchive = new ASTNodeArrayArchive_ASTColonTractArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ASTNodeArrayArchive_ASTColonTractArchive_ASTColonTractRelativeRangeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.ASTNodeArrayArchive.ASTColonTractArchive.ASTColonTractRelativeRangeArchive", [
            { no: 1, name: "range_begin", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "range_end", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = { rangeBegin: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 range_begin */ 1:
                    message.rangeBegin = reader.int32();
                    break;
                case /* optional int32 range_end */ 2:
                    message.rangeEnd = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int32 range_begin = 1; */
        if (message.rangeBegin !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.rangeBegin);
        /* optional int32 range_end = 2; */
        if (message.rangeEnd !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.rangeEnd);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.ASTNodeArrayArchive.ASTColonTractArchive.ASTColonTractRelativeRangeArchive
 */
exports.ASTNodeArrayArchive_ASTColonTractArchive_ASTColonTractRelativeRangeArchive = new ASTNodeArrayArchive_ASTColonTractArchive_ASTColonTractRelativeRangeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ASTNodeArrayArchive_ASTColonTractArchive_ASTColonTractAbsoluteRangeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.ASTNodeArrayArchive.ASTColonTractArchive.ASTColonTractAbsoluteRangeArchive", [
            { no: 1, name: "range_begin", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "range_end", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { rangeBegin: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 range_begin */ 1:
                    message.rangeBegin = reader.uint32();
                    break;
                case /* optional uint32 range_end */ 2:
                    message.rangeEnd = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 range_begin = 1; */
        if (message.rangeBegin !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.rangeBegin);
        /* optional uint32 range_end = 2; */
        if (message.rangeEnd !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.rangeEnd);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.ASTNodeArrayArchive.ASTColonTractArchive.ASTColonTractAbsoluteRangeArchive
 */
exports.ASTNodeArrayArchive_ASTColonTractArchive_ASTColonTractAbsoluteRangeArchive = new ASTNodeArrayArchive_ASTColonTractArchive_ASTColonTractAbsoluteRangeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.ASTNodeArrayArchive.ASTCrossTableReferenceExtraInfoArchive", [
            { no: 1, name: "table_id", kind: "message", T: () => TSPMessages_4.CFUUIDArchive },
            { no: 2, name: "AST_reference_whitespace_after_sheet_name", kind: "scalar", jsonName: "ASTReferenceWhitespaceAfterSheetName", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "AST_reference_whitespace_before_table_name", kind: "scalar", jsonName: "ASTReferenceWhitespaceBeforeTableName", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "AST_reference_whitespace_after_table_name", kind: "scalar", jsonName: "ASTReferenceWhitespaceAfterTableName", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "AST_reference_whitespace_before_cell_address", kind: "scalar", jsonName: "ASTReferenceWhitespaceBeforeCellAddress", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.CFUUIDArchive table_id */ 1:
                    message.tableId = TSPMessages_4.CFUUIDArchive.internalBinaryRead(reader, reader.uint32(), options, message.tableId);
                    break;
                case /* optional string AST_reference_whitespace_after_sheet_name = 2 [json_name = "ASTReferenceWhitespaceAfterSheetName"];*/ 2:
                    message.aSTReferenceWhitespaceAfterSheetName = reader.string();
                    break;
                case /* optional string AST_reference_whitespace_before_table_name = 3 [json_name = "ASTReferenceWhitespaceBeforeTableName"];*/ 3:
                    message.aSTReferenceWhitespaceBeforeTableName = reader.string();
                    break;
                case /* optional string AST_reference_whitespace_after_table_name = 4 [json_name = "ASTReferenceWhitespaceAfterTableName"];*/ 4:
                    message.aSTReferenceWhitespaceAfterTableName = reader.string();
                    break;
                case /* optional string AST_reference_whitespace_before_cell_address = 5 [json_name = "ASTReferenceWhitespaceBeforeCellAddress"];*/ 5:
                    message.aSTReferenceWhitespaceBeforeCellAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.CFUUIDArchive table_id = 1; */
        if (message.tableId)
            TSPMessages_4.CFUUIDArchive.internalBinaryWrite(message.tableId, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string AST_reference_whitespace_after_sheet_name = 2 [json_name = "ASTReferenceWhitespaceAfterSheetName"]; */
        if (message.aSTReferenceWhitespaceAfterSheetName !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.aSTReferenceWhitespaceAfterSheetName);
        /* optional string AST_reference_whitespace_before_table_name = 3 [json_name = "ASTReferenceWhitespaceBeforeTableName"]; */
        if (message.aSTReferenceWhitespaceBeforeTableName !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.aSTReferenceWhitespaceBeforeTableName);
        /* optional string AST_reference_whitespace_after_table_name = 4 [json_name = "ASTReferenceWhitespaceAfterTableName"]; */
        if (message.aSTReferenceWhitespaceAfterTableName !== undefined)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.aSTReferenceWhitespaceAfterTableName);
        /* optional string AST_reference_whitespace_before_cell_address = 5 [json_name = "ASTReferenceWhitespaceBeforeCellAddress"]; */
        if (message.aSTReferenceWhitespaceBeforeCellAddress !== undefined)
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.aSTReferenceWhitespaceBeforeCellAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.ASTNodeArrayArchive.ASTCrossTableReferenceExtraInfoArchive
 */
exports.ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive = new ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ASTNodeArrayArchive_ASTLetNodeWhitespace$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.ASTNodeArrayArchive.ASTLetNodeWhitespace", [
            { no: 1, name: "AST_let_whitespace_after_let", kind: "scalar", jsonName: "ASTLetWhitespaceAfterLet", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "AST_let_whitespace_after_identifier", kind: "scalar", jsonName: "ASTLetWhitespaceAfterIdentifier", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "AST_let_whitespace_after_equals", kind: "scalar", jsonName: "ASTLetWhitespaceAfterEquals", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "AST_let_whitespace_after_delimiter", kind: "scalar", jsonName: "ASTLetWhitespaceAfterDelimiter", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string AST_let_whitespace_after_let = 1 [json_name = "ASTLetWhitespaceAfterLet"];*/ 1:
                    message.aSTLetWhitespaceAfterLet = reader.string();
                    break;
                case /* optional string AST_let_whitespace_after_identifier = 2 [json_name = "ASTLetWhitespaceAfterIdentifier"];*/ 2:
                    message.aSTLetWhitespaceAfterIdentifier = reader.string();
                    break;
                case /* optional string AST_let_whitespace_after_equals = 3 [json_name = "ASTLetWhitespaceAfterEquals"];*/ 3:
                    message.aSTLetWhitespaceAfterEquals = reader.string();
                    break;
                case /* optional string AST_let_whitespace_after_delimiter = 4 [json_name = "ASTLetWhitespaceAfterDelimiter"];*/ 4:
                    message.aSTLetWhitespaceAfterDelimiter = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string AST_let_whitespace_after_let = 1 [json_name = "ASTLetWhitespaceAfterLet"]; */
        if (message.aSTLetWhitespaceAfterLet !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.aSTLetWhitespaceAfterLet);
        /* optional string AST_let_whitespace_after_identifier = 2 [json_name = "ASTLetWhitespaceAfterIdentifier"]; */
        if (message.aSTLetWhitespaceAfterIdentifier !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.aSTLetWhitespaceAfterIdentifier);
        /* optional string AST_let_whitespace_after_equals = 3 [json_name = "ASTLetWhitespaceAfterEquals"]; */
        if (message.aSTLetWhitespaceAfterEquals !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.aSTLetWhitespaceAfterEquals);
        /* optional string AST_let_whitespace_after_delimiter = 4 [json_name = "ASTLetWhitespaceAfterDelimiter"]; */
        if (message.aSTLetWhitespaceAfterDelimiter !== undefined)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.aSTLetWhitespaceAfterDelimiter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.ASTNodeArrayArchive.ASTLetNodeWhitespace
 */
exports.ASTNodeArrayArchive_ASTLetNodeWhitespace = new ASTNodeArrayArchive_ASTLetNodeWhitespace$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ASTNodeArrayArchive_ASTNodeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.ASTNodeArrayArchive.ASTNodeArchive", [
            { no: 1, name: "AST_node_type", kind: "enum", jsonName: "ASTNodeType", T: () => ["TSCE.ASTNodeArrayArchive.ASTNodeType", ASTNodeArrayArchive_ASTNodeType] },
            { no: 2, name: "AST_function_node_index", kind: "scalar", jsonName: "ASTFunctionNodeIndex", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "AST_function_node_numArgs", kind: "scalar", jsonName: "ASTFunctionNodeNumArgs", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "AST_number_node_number", kind: "scalar", jsonName: "ASTNumberNodeNumber", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "AST_boolean_node_boolean", kind: "scalar", jsonName: "ASTBooleanNodeBoolean", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "AST_string_node_string", kind: "scalar", jsonName: "ASTStringNodeString", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "AST_date_node_dateNum", kind: "scalar", jsonName: "ASTDateNodeDateNum", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 19, name: "AST_date_node_suppress_date_format", kind: "scalar", jsonName: "ASTDateNodeSuppressDateFormat", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 20, name: "AST_date_node_suppress_time_format", kind: "scalar", jsonName: "ASTDateNodeSuppressTimeFormat", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "AST_date_node_date_time_format", kind: "scalar", jsonName: "ASTDateNodeDateTimeFormat", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "AST_duration_node_unitNum", kind: "scalar", jsonName: "ASTDurationNodeUnitNum", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 9, name: "AST_duration_node_unit", kind: "scalar", jsonName: "ASTDurationNodeUnit", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 22, name: "AST_duration_node_style", kind: "scalar", jsonName: "ASTDurationNodeStyle", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 23, name: "AST_duration_node_duration_unit_largest", kind: "scalar", jsonName: "ASTDurationNodeDurationUnitLargest", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 24, name: "AST_duration_node_duration_unit_smallest", kind: "scalar", jsonName: "ASTDurationNodeDurationUnitSmallest", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 29, name: "AST_duration_node_use_automatic_units", kind: "scalar", jsonName: "ASTDurationNodeUseAutomaticUnits", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "AST_token_node_boolean", kind: "scalar", jsonName: "ASTTokenNodeBoolean", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "AST_array_node_numCol", kind: "scalar", jsonName: "ASTArrayNodeNumCol", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "AST_array_node_numRow", kind: "scalar", jsonName: "ASTArrayNodeNumRow", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "AST_list_node_numArgs", kind: "scalar", jsonName: "ASTListNodeNumArgs", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "AST_thunk_node_array", kind: "message", jsonName: "ASTThunkNodeArray", T: () => exports.ASTNodeArrayArchive },
            { no: 15, name: "AST_local_cell_reference_node_reference", kind: "message", jsonName: "ASTLocalCellReferenceNodeReference", T: () => exports.ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive },
            { no: 16, name: "AST_cross_table_cell_reference_node_reference", kind: "message", jsonName: "ASTCrossTableCellReferenceNodeReference", T: () => exports.ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive },
            { no: 17, name: "AST_unknown_function_node_string", kind: "scalar", jsonName: "ASTUnknownFunctionNodeString", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "AST_unknown_function_node_numArgs", kind: "scalar", jsonName: "ASTUnknownFunctionNodeNumArgs", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 25, name: "AST_whitespace", kind: "scalar", jsonName: "ASTWhitespace", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 26, name: "AST_column", kind: "message", jsonName: "ASTColumn", T: () => exports.ASTNodeArrayArchive_ASTColumnCoordinateArchive },
            { no: 27, name: "AST_row", kind: "message", jsonName: "ASTRow", T: () => exports.ASTNodeArrayArchive_ASTRowCoordinateArchive },
            { no: 28, name: "AST_cross_table_reference_extra_info", kind: "message", jsonName: "ASTCrossTableReferenceExtraInfo", T: () => exports.ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive },
            { no: 30, name: "AST_uid_coordinate", kind: "message", jsonName: "ASTUidCoordinate", T: () => exports.ASTNodeArrayArchive_ASTUidCoordinateArchive },
            { no: 33, name: "AST_sticky_bits", kind: "message", jsonName: "ASTStickyBits", T: () => exports.ASTNodeArrayArchive_ASTStickyBits },
            { no: 41, name: "AST_frozen_sticky_bits", kind: "message", jsonName: "ASTFrozenStickyBits", T: () => exports.ASTNodeArrayArchive_ASTStickyBits },
            { no: 34, name: "AST_let_identifier", kind: "scalar", jsonName: "ASTLetIdentifier", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 35, name: "AST_let_e2", kind: "message", jsonName: "ASTLetE2", T: () => exports.ASTNodeArrayArchive },
            { no: 36, name: "AST_let_whitespace", kind: "message", jsonName: "ASTLetWhitespace", T: () => exports.ASTNodeArrayArchive_ASTLetNodeWhitespace },
            { no: 37, name: "AST_symbol", kind: "scalar", jsonName: "ASTSymbol", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 38, name: "AST_tract_list", kind: "message", jsonName: "ASTTractList", T: () => exports.ASTNodeArrayArchive_ASTUidTractList },
            { no: 39, name: "AST_category_ref", kind: "message", jsonName: "ASTCategoryRef", T: () => exports.ASTNodeArrayArchive_ASTCategoryReferenceArchive },
            { no: 40, name: "AST_colon_tract", kind: "message", jsonName: "ASTColonTract", T: () => exports.ASTNodeArrayArchive_ASTColonTractArchive },
            { no: 42, name: "AST_number_node_decimal_low", kind: "scalar", jsonName: "ASTNumberNodeDecimalLow", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 43, name: "AST_number_node_decimal_high", kind: "scalar", jsonName: "ASTNumberNodeDecimalHigh", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 44, name: "AST_category_levels", kind: "message", jsonName: "ASTCategoryLevels", T: () => exports.ASTNodeArrayArchive_ASTCategoryLevels }
        ]);
    }
    create(value) {
        const message = { aSTNodeType: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSCE.ASTNodeArrayArchive.ASTNodeType AST_node_type = 1 [json_name = "ASTNodeType"];*/ 1:
                    message.aSTNodeType = reader.int32();
                    break;
                case /* optional uint32 AST_function_node_index = 2 [json_name = "ASTFunctionNodeIndex"];*/ 2:
                    message.aSTFunctionNodeIndex = reader.uint32();
                    break;
                case /* optional uint32 AST_function_node_numArgs = 3 [json_name = "ASTFunctionNodeNumArgs"];*/ 3:
                    message.aSTFunctionNodeNumArgs = reader.uint32();
                    break;
                case /* optional double AST_number_node_number = 4 [json_name = "ASTNumberNodeNumber"];*/ 4:
                    message.aSTNumberNodeNumber = reader.double();
                    break;
                case /* optional bool AST_boolean_node_boolean = 5 [json_name = "ASTBooleanNodeBoolean"];*/ 5:
                    message.aSTBooleanNodeBoolean = reader.bool();
                    break;
                case /* optional string AST_string_node_string = 6 [json_name = "ASTStringNodeString"];*/ 6:
                    message.aSTStringNodeString = reader.string();
                    break;
                case /* optional double AST_date_node_dateNum = 7 [json_name = "ASTDateNodeDateNum"];*/ 7:
                    message.aSTDateNodeDateNum = reader.double();
                    break;
                case /* optional bool AST_date_node_suppress_date_format = 19 [json_name = "ASTDateNodeSuppressDateFormat"];*/ 19:
                    message.aSTDateNodeSuppressDateFormat = reader.bool();
                    break;
                case /* optional bool AST_date_node_suppress_time_format = 20 [json_name = "ASTDateNodeSuppressTimeFormat"];*/ 20:
                    message.aSTDateNodeSuppressTimeFormat = reader.bool();
                    break;
                case /* optional string AST_date_node_date_time_format = 21 [json_name = "ASTDateNodeDateTimeFormat"];*/ 21:
                    message.aSTDateNodeDateTimeFormat = reader.string();
                    break;
                case /* optional double AST_duration_node_unitNum = 8 [json_name = "ASTDurationNodeUnitNum"];*/ 8:
                    message.aSTDurationNodeUnitNum = reader.double();
                    break;
                case /* optional int32 AST_duration_node_unit = 9 [json_name = "ASTDurationNodeUnit"];*/ 9:
                    message.aSTDurationNodeUnit = reader.int32();
                    break;
                case /* optional uint32 AST_duration_node_style = 22 [json_name = "ASTDurationNodeStyle"];*/ 22:
                    message.aSTDurationNodeStyle = reader.uint32();
                    break;
                case /* optional uint32 AST_duration_node_duration_unit_largest = 23 [json_name = "ASTDurationNodeDurationUnitLargest"];*/ 23:
                    message.aSTDurationNodeDurationUnitLargest = reader.uint32();
                    break;
                case /* optional uint32 AST_duration_node_duration_unit_smallest = 24 [json_name = "ASTDurationNodeDurationUnitSmallest"];*/ 24:
                    message.aSTDurationNodeDurationUnitSmallest = reader.uint32();
                    break;
                case /* optional bool AST_duration_node_use_automatic_units = 29 [json_name = "ASTDurationNodeUseAutomaticUnits"];*/ 29:
                    message.aSTDurationNodeUseAutomaticUnits = reader.bool();
                    break;
                case /* optional bool AST_token_node_boolean = 10 [json_name = "ASTTokenNodeBoolean"];*/ 10:
                    message.aSTTokenNodeBoolean = reader.bool();
                    break;
                case /* optional uint32 AST_array_node_numCol = 11 [json_name = "ASTArrayNodeNumCol"];*/ 11:
                    message.aSTArrayNodeNumCol = reader.uint32();
                    break;
                case /* optional uint32 AST_array_node_numRow = 12 [json_name = "ASTArrayNodeNumRow"];*/ 12:
                    message.aSTArrayNodeNumRow = reader.uint32();
                    break;
                case /* optional uint32 AST_list_node_numArgs = 13 [json_name = "ASTListNodeNumArgs"];*/ 13:
                    message.aSTListNodeNumArgs = reader.uint32();
                    break;
                case /* optional TSCE.ASTNodeArrayArchive AST_thunk_node_array = 14 [json_name = "ASTThunkNodeArray"];*/ 14:
                    message.aSTThunkNodeArray = exports.ASTNodeArrayArchive.internalBinaryRead(reader, reader.uint32(), options, message.aSTThunkNodeArray);
                    break;
                case /* optional TSCE.ASTNodeArrayArchive.ASTLocalCellReferenceNodeArchive AST_local_cell_reference_node_reference = 15 [json_name = "ASTLocalCellReferenceNodeReference"];*/ 15:
                    message.aSTLocalCellReferenceNodeReference = exports.ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive.internalBinaryRead(reader, reader.uint32(), options, message.aSTLocalCellReferenceNodeReference);
                    break;
                case /* optional TSCE.ASTNodeArrayArchive.ASTCrossTableCellReferenceNodeArchive AST_cross_table_cell_reference_node_reference = 16 [json_name = "ASTCrossTableCellReferenceNodeReference"];*/ 16:
                    message.aSTCrossTableCellReferenceNodeReference = exports.ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive.internalBinaryRead(reader, reader.uint32(), options, message.aSTCrossTableCellReferenceNodeReference);
                    break;
                case /* optional string AST_unknown_function_node_string = 17 [json_name = "ASTUnknownFunctionNodeString"];*/ 17:
                    message.aSTUnknownFunctionNodeString = reader.string();
                    break;
                case /* optional uint32 AST_unknown_function_node_numArgs = 18 [json_name = "ASTUnknownFunctionNodeNumArgs"];*/ 18:
                    message.aSTUnknownFunctionNodeNumArgs = reader.uint32();
                    break;
                case /* optional string AST_whitespace = 25 [json_name = "ASTWhitespace"];*/ 25:
                    message.aSTWhitespace = reader.string();
                    break;
                case /* optional TSCE.ASTNodeArrayArchive.ASTColumnCoordinateArchive AST_column = 26 [json_name = "ASTColumn"];*/ 26:
                    message.aSTColumn = exports.ASTNodeArrayArchive_ASTColumnCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.aSTColumn);
                    break;
                case /* optional TSCE.ASTNodeArrayArchive.ASTRowCoordinateArchive AST_row = 27 [json_name = "ASTRow"];*/ 27:
                    message.aSTRow = exports.ASTNodeArrayArchive_ASTRowCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.aSTRow);
                    break;
                case /* optional TSCE.ASTNodeArrayArchive.ASTCrossTableReferenceExtraInfoArchive AST_cross_table_reference_extra_info = 28 [json_name = "ASTCrossTableReferenceExtraInfo"];*/ 28:
                    message.aSTCrossTableReferenceExtraInfo = exports.ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive.internalBinaryRead(reader, reader.uint32(), options, message.aSTCrossTableReferenceExtraInfo);
                    break;
                case /* optional TSCE.ASTNodeArrayArchive.ASTUidCoordinateArchive AST_uid_coordinate = 30 [json_name = "ASTUidCoordinate"];*/ 30:
                    message.aSTUidCoordinate = exports.ASTNodeArrayArchive_ASTUidCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.aSTUidCoordinate);
                    break;
                case /* optional TSCE.ASTNodeArrayArchive.ASTStickyBits AST_sticky_bits = 33 [json_name = "ASTStickyBits"];*/ 33:
                    message.aSTStickyBits = exports.ASTNodeArrayArchive_ASTStickyBits.internalBinaryRead(reader, reader.uint32(), options, message.aSTStickyBits);
                    break;
                case /* optional TSCE.ASTNodeArrayArchive.ASTStickyBits AST_frozen_sticky_bits = 41 [json_name = "ASTFrozenStickyBits"];*/ 41:
                    message.aSTFrozenStickyBits = exports.ASTNodeArrayArchive_ASTStickyBits.internalBinaryRead(reader, reader.uint32(), options, message.aSTFrozenStickyBits);
                    break;
                case /* optional string AST_let_identifier = 34 [json_name = "ASTLetIdentifier"];*/ 34:
                    message.aSTLetIdentifier = reader.string();
                    break;
                case /* optional TSCE.ASTNodeArrayArchive AST_let_e2 = 35 [json_name = "ASTLetE2"];*/ 35:
                    message.aSTLetE2 = exports.ASTNodeArrayArchive.internalBinaryRead(reader, reader.uint32(), options, message.aSTLetE2);
                    break;
                case /* optional TSCE.ASTNodeArrayArchive.ASTLetNodeWhitespace AST_let_whitespace = 36 [json_name = "ASTLetWhitespace"];*/ 36:
                    message.aSTLetWhitespace = exports.ASTNodeArrayArchive_ASTLetNodeWhitespace.internalBinaryRead(reader, reader.uint32(), options, message.aSTLetWhitespace);
                    break;
                case /* optional uint32 AST_symbol = 37 [json_name = "ASTSymbol"];*/ 37:
                    message.aSTSymbol = reader.uint32();
                    break;
                case /* optional TSCE.ASTNodeArrayArchive.ASTUidTractList AST_tract_list = 38 [json_name = "ASTTractList"];*/ 38:
                    message.aSTTractList = exports.ASTNodeArrayArchive_ASTUidTractList.internalBinaryRead(reader, reader.uint32(), options, message.aSTTractList);
                    break;
                case /* optional TSCE.ASTNodeArrayArchive.ASTCategoryReferenceArchive AST_category_ref = 39 [json_name = "ASTCategoryRef"];*/ 39:
                    message.aSTCategoryRef = exports.ASTNodeArrayArchive_ASTCategoryReferenceArchive.internalBinaryRead(reader, reader.uint32(), options, message.aSTCategoryRef);
                    break;
                case /* optional TSCE.ASTNodeArrayArchive.ASTColonTractArchive AST_colon_tract = 40 [json_name = "ASTColonTract"];*/ 40:
                    message.aSTColonTract = exports.ASTNodeArrayArchive_ASTColonTractArchive.internalBinaryRead(reader, reader.uint32(), options, message.aSTColonTract);
                    break;
                case /* optional uint64 AST_number_node_decimal_low = 42 [json_name = "ASTNumberNodeDecimalLow"];*/ 42:
                    message.aSTNumberNodeDecimalLow = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 AST_number_node_decimal_high = 43 [json_name = "ASTNumberNodeDecimalHigh"];*/ 43:
                    message.aSTNumberNodeDecimalHigh = reader.uint64().toBigInt();
                    break;
                case /* optional TSCE.ASTNodeArrayArchive.ASTCategoryLevels AST_category_levels = 44 [json_name = "ASTCategoryLevels"];*/ 44:
                    message.aSTCategoryLevels = exports.ASTNodeArrayArchive_ASTCategoryLevels.internalBinaryRead(reader, reader.uint32(), options, message.aSTCategoryLevels);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSCE.ASTNodeArrayArchive.ASTNodeType AST_node_type = 1 [json_name = "ASTNodeType"]; */
        if (message.aSTNodeType !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.aSTNodeType);
        /* optional uint32 AST_function_node_index = 2 [json_name = "ASTFunctionNodeIndex"]; */
        if (message.aSTFunctionNodeIndex !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.aSTFunctionNodeIndex);
        /* optional uint32 AST_function_node_numArgs = 3 [json_name = "ASTFunctionNodeNumArgs"]; */
        if (message.aSTFunctionNodeNumArgs !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.aSTFunctionNodeNumArgs);
        /* optional double AST_number_node_number = 4 [json_name = "ASTNumberNodeNumber"]; */
        if (message.aSTNumberNodeNumber !== undefined)
            writer.tag(4, runtime_1.WireType.Bit64).double(message.aSTNumberNodeNumber);
        /* optional bool AST_boolean_node_boolean = 5 [json_name = "ASTBooleanNodeBoolean"]; */
        if (message.aSTBooleanNodeBoolean !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.aSTBooleanNodeBoolean);
        /* optional string AST_string_node_string = 6 [json_name = "ASTStringNodeString"]; */
        if (message.aSTStringNodeString !== undefined)
            writer.tag(6, runtime_1.WireType.LengthDelimited).string(message.aSTStringNodeString);
        /* optional double AST_date_node_dateNum = 7 [json_name = "ASTDateNodeDateNum"]; */
        if (message.aSTDateNodeDateNum !== undefined)
            writer.tag(7, runtime_1.WireType.Bit64).double(message.aSTDateNodeDateNum);
        /* optional bool AST_date_node_suppress_date_format = 19 [json_name = "ASTDateNodeSuppressDateFormat"]; */
        if (message.aSTDateNodeSuppressDateFormat !== undefined)
            writer.tag(19, runtime_1.WireType.Varint).bool(message.aSTDateNodeSuppressDateFormat);
        /* optional bool AST_date_node_suppress_time_format = 20 [json_name = "ASTDateNodeSuppressTimeFormat"]; */
        if (message.aSTDateNodeSuppressTimeFormat !== undefined)
            writer.tag(20, runtime_1.WireType.Varint).bool(message.aSTDateNodeSuppressTimeFormat);
        /* optional string AST_date_node_date_time_format = 21 [json_name = "ASTDateNodeDateTimeFormat"]; */
        if (message.aSTDateNodeDateTimeFormat !== undefined)
            writer.tag(21, runtime_1.WireType.LengthDelimited).string(message.aSTDateNodeDateTimeFormat);
        /* optional double AST_duration_node_unitNum = 8 [json_name = "ASTDurationNodeUnitNum"]; */
        if (message.aSTDurationNodeUnitNum !== undefined)
            writer.tag(8, runtime_1.WireType.Bit64).double(message.aSTDurationNodeUnitNum);
        /* optional int32 AST_duration_node_unit = 9 [json_name = "ASTDurationNodeUnit"]; */
        if (message.aSTDurationNodeUnit !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).int32(message.aSTDurationNodeUnit);
        /* optional uint32 AST_duration_node_style = 22 [json_name = "ASTDurationNodeStyle"]; */
        if (message.aSTDurationNodeStyle !== undefined)
            writer.tag(22, runtime_1.WireType.Varint).uint32(message.aSTDurationNodeStyle);
        /* optional uint32 AST_duration_node_duration_unit_largest = 23 [json_name = "ASTDurationNodeDurationUnitLargest"]; */
        if (message.aSTDurationNodeDurationUnitLargest !== undefined)
            writer.tag(23, runtime_1.WireType.Varint).uint32(message.aSTDurationNodeDurationUnitLargest);
        /* optional uint32 AST_duration_node_duration_unit_smallest = 24 [json_name = "ASTDurationNodeDurationUnitSmallest"]; */
        if (message.aSTDurationNodeDurationUnitSmallest !== undefined)
            writer.tag(24, runtime_1.WireType.Varint).uint32(message.aSTDurationNodeDurationUnitSmallest);
        /* optional bool AST_duration_node_use_automatic_units = 29 [json_name = "ASTDurationNodeUseAutomaticUnits"]; */
        if (message.aSTDurationNodeUseAutomaticUnits !== undefined)
            writer.tag(29, runtime_1.WireType.Varint).bool(message.aSTDurationNodeUseAutomaticUnits);
        /* optional bool AST_token_node_boolean = 10 [json_name = "ASTTokenNodeBoolean"]; */
        if (message.aSTTokenNodeBoolean !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).bool(message.aSTTokenNodeBoolean);
        /* optional uint32 AST_array_node_numCol = 11 [json_name = "ASTArrayNodeNumCol"]; */
        if (message.aSTArrayNodeNumCol !== undefined)
            writer.tag(11, runtime_1.WireType.Varint).uint32(message.aSTArrayNodeNumCol);
        /* optional uint32 AST_array_node_numRow = 12 [json_name = "ASTArrayNodeNumRow"]; */
        if (message.aSTArrayNodeNumRow !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).uint32(message.aSTArrayNodeNumRow);
        /* optional uint32 AST_list_node_numArgs = 13 [json_name = "ASTListNodeNumArgs"]; */
        if (message.aSTListNodeNumArgs !== undefined)
            writer.tag(13, runtime_1.WireType.Varint).uint32(message.aSTListNodeNumArgs);
        /* optional TSCE.ASTNodeArrayArchive AST_thunk_node_array = 14 [json_name = "ASTThunkNodeArray"]; */
        if (message.aSTThunkNodeArray)
            exports.ASTNodeArrayArchive.internalBinaryWrite(message.aSTThunkNodeArray, writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.ASTNodeArrayArchive.ASTLocalCellReferenceNodeArchive AST_local_cell_reference_node_reference = 15 [json_name = "ASTLocalCellReferenceNodeReference"]; */
        if (message.aSTLocalCellReferenceNodeReference)
            exports.ASTNodeArrayArchive_ASTLocalCellReferenceNodeArchive.internalBinaryWrite(message.aSTLocalCellReferenceNodeReference, writer.tag(15, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.ASTNodeArrayArchive.ASTCrossTableCellReferenceNodeArchive AST_cross_table_cell_reference_node_reference = 16 [json_name = "ASTCrossTableCellReferenceNodeReference"]; */
        if (message.aSTCrossTableCellReferenceNodeReference)
            exports.ASTNodeArrayArchive_ASTCrossTableCellReferenceNodeArchive.internalBinaryWrite(message.aSTCrossTableCellReferenceNodeReference, writer.tag(16, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string AST_unknown_function_node_string = 17 [json_name = "ASTUnknownFunctionNodeString"]; */
        if (message.aSTUnknownFunctionNodeString !== undefined)
            writer.tag(17, runtime_1.WireType.LengthDelimited).string(message.aSTUnknownFunctionNodeString);
        /* optional uint32 AST_unknown_function_node_numArgs = 18 [json_name = "ASTUnknownFunctionNodeNumArgs"]; */
        if (message.aSTUnknownFunctionNodeNumArgs !== undefined)
            writer.tag(18, runtime_1.WireType.Varint).uint32(message.aSTUnknownFunctionNodeNumArgs);
        /* optional string AST_whitespace = 25 [json_name = "ASTWhitespace"]; */
        if (message.aSTWhitespace !== undefined)
            writer.tag(25, runtime_1.WireType.LengthDelimited).string(message.aSTWhitespace);
        /* optional TSCE.ASTNodeArrayArchive.ASTColumnCoordinateArchive AST_column = 26 [json_name = "ASTColumn"]; */
        if (message.aSTColumn)
            exports.ASTNodeArrayArchive_ASTColumnCoordinateArchive.internalBinaryWrite(message.aSTColumn, writer.tag(26, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.ASTNodeArrayArchive.ASTRowCoordinateArchive AST_row = 27 [json_name = "ASTRow"]; */
        if (message.aSTRow)
            exports.ASTNodeArrayArchive_ASTRowCoordinateArchive.internalBinaryWrite(message.aSTRow, writer.tag(27, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.ASTNodeArrayArchive.ASTCrossTableReferenceExtraInfoArchive AST_cross_table_reference_extra_info = 28 [json_name = "ASTCrossTableReferenceExtraInfo"]; */
        if (message.aSTCrossTableReferenceExtraInfo)
            exports.ASTNodeArrayArchive_ASTCrossTableReferenceExtraInfoArchive.internalBinaryWrite(message.aSTCrossTableReferenceExtraInfo, writer.tag(28, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.ASTNodeArrayArchive.ASTUidCoordinateArchive AST_uid_coordinate = 30 [json_name = "ASTUidCoordinate"]; */
        if (message.aSTUidCoordinate)
            exports.ASTNodeArrayArchive_ASTUidCoordinateArchive.internalBinaryWrite(message.aSTUidCoordinate, writer.tag(30, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.ASTNodeArrayArchive.ASTStickyBits AST_sticky_bits = 33 [json_name = "ASTStickyBits"]; */
        if (message.aSTStickyBits)
            exports.ASTNodeArrayArchive_ASTStickyBits.internalBinaryWrite(message.aSTStickyBits, writer.tag(33, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.ASTNodeArrayArchive.ASTStickyBits AST_frozen_sticky_bits = 41 [json_name = "ASTFrozenStickyBits"]; */
        if (message.aSTFrozenStickyBits)
            exports.ASTNodeArrayArchive_ASTStickyBits.internalBinaryWrite(message.aSTFrozenStickyBits, writer.tag(41, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string AST_let_identifier = 34 [json_name = "ASTLetIdentifier"]; */
        if (message.aSTLetIdentifier !== undefined)
            writer.tag(34, runtime_1.WireType.LengthDelimited).string(message.aSTLetIdentifier);
        /* optional TSCE.ASTNodeArrayArchive AST_let_e2 = 35 [json_name = "ASTLetE2"]; */
        if (message.aSTLetE2)
            exports.ASTNodeArrayArchive.internalBinaryWrite(message.aSTLetE2, writer.tag(35, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.ASTNodeArrayArchive.ASTLetNodeWhitespace AST_let_whitespace = 36 [json_name = "ASTLetWhitespace"]; */
        if (message.aSTLetWhitespace)
            exports.ASTNodeArrayArchive_ASTLetNodeWhitespace.internalBinaryWrite(message.aSTLetWhitespace, writer.tag(36, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 AST_symbol = 37 [json_name = "ASTSymbol"]; */
        if (message.aSTSymbol !== undefined)
            writer.tag(37, runtime_1.WireType.Varint).uint32(message.aSTSymbol);
        /* optional TSCE.ASTNodeArrayArchive.ASTUidTractList AST_tract_list = 38 [json_name = "ASTTractList"]; */
        if (message.aSTTractList)
            exports.ASTNodeArrayArchive_ASTUidTractList.internalBinaryWrite(message.aSTTractList, writer.tag(38, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.ASTNodeArrayArchive.ASTCategoryReferenceArchive AST_category_ref = 39 [json_name = "ASTCategoryRef"]; */
        if (message.aSTCategoryRef)
            exports.ASTNodeArrayArchive_ASTCategoryReferenceArchive.internalBinaryWrite(message.aSTCategoryRef, writer.tag(39, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.ASTNodeArrayArchive.ASTColonTractArchive AST_colon_tract = 40 [json_name = "ASTColonTract"]; */
        if (message.aSTColonTract)
            exports.ASTNodeArrayArchive_ASTColonTractArchive.internalBinaryWrite(message.aSTColonTract, writer.tag(40, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint64 AST_number_node_decimal_low = 42 [json_name = "ASTNumberNodeDecimalLow"]; */
        if (message.aSTNumberNodeDecimalLow !== undefined)
            writer.tag(42, runtime_1.WireType.Varint).uint64(message.aSTNumberNodeDecimalLow);
        /* optional uint64 AST_number_node_decimal_high = 43 [json_name = "ASTNumberNodeDecimalHigh"]; */
        if (message.aSTNumberNodeDecimalHigh !== undefined)
            writer.tag(43, runtime_1.WireType.Varint).uint64(message.aSTNumberNodeDecimalHigh);
        /* optional TSCE.ASTNodeArrayArchive.ASTCategoryLevels AST_category_levels = 44 [json_name = "ASTCategoryLevels"]; */
        if (message.aSTCategoryLevels)
            exports.ASTNodeArrayArchive_ASTCategoryLevels.internalBinaryWrite(message.aSTCategoryLevels, writer.tag(44, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.ASTNodeArrayArchive.ASTNodeArchive
 */
exports.ASTNodeArrayArchive_ASTNodeArchive = new ASTNodeArrayArchive_ASTNodeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormulaTranslationFlagsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.FormulaTranslationFlagsArchive", [
            { no: 1, name: "excel_import_translation", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "number_to_date_coercion_removal_translation", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "contains_uid_form_references", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "contains_frozen_references", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "returns_percent_formatted", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool excel_import_translation */ 1:
                    message.excelImportTranslation = reader.bool();
                    break;
                case /* optional bool number_to_date_coercion_removal_translation */ 2:
                    message.numberToDateCoercionRemovalTranslation = reader.bool();
                    break;
                case /* optional bool contains_uid_form_references */ 3:
                    message.containsUidFormReferences = reader.bool();
                    break;
                case /* optional bool contains_frozen_references */ 4:
                    message.containsFrozenReferences = reader.bool();
                    break;
                case /* optional bool returns_percent_formatted */ 5:
                    message.returnsPercentFormatted = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional bool excel_import_translation = 1; */
        if (message.excelImportTranslation !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.excelImportTranslation);
        /* optional bool number_to_date_coercion_removal_translation = 2; */
        if (message.numberToDateCoercionRemovalTranslation !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.numberToDateCoercionRemovalTranslation);
        /* optional bool contains_uid_form_references = 3; */
        if (message.containsUidFormReferences !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.containsUidFormReferences);
        /* optional bool contains_frozen_references = 4; */
        if (message.containsFrozenReferences !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.containsFrozenReferences);
        /* optional bool returns_percent_formatted = 5; */
        if (message.returnsPercentFormatted !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.returnsPercentFormatted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.FormulaTranslationFlagsArchive
 */
exports.FormulaTranslationFlagsArchive = new FormulaTranslationFlagsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormulaArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.FormulaArchive", [
            { no: 1, name: "AST_node_array", kind: "message", jsonName: "ASTNodeArray", T: () => exports.ASTNodeArrayArchive },
            { no: 2, name: "host_column", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "host_row", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "host_column_is_negative", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "host_row_is_negative", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "translation_flags", kind: "message", T: () => exports.FormulaTranslationFlagsArchive },
            { no: 7, name: "host_table_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 8, name: "host_column_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 9, name: "host_row_uid", kind: "message", T: () => TSPMessages_3.UUID }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSCE.ASTNodeArrayArchive AST_node_array = 1 [json_name = "ASTNodeArray"];*/ 1:
                    message.aSTNodeArray = exports.ASTNodeArrayArchive.internalBinaryRead(reader, reader.uint32(), options, message.aSTNodeArray);
                    break;
                case /* optional uint32 host_column */ 2:
                    message.hostColumn = reader.uint32();
                    break;
                case /* optional uint32 host_row */ 3:
                    message.hostRow = reader.uint32();
                    break;
                case /* optional bool host_column_is_negative */ 4:
                    message.hostColumnIsNegative = reader.bool();
                    break;
                case /* optional bool host_row_is_negative */ 5:
                    message.hostRowIsNegative = reader.bool();
                    break;
                case /* optional TSCE.FormulaTranslationFlagsArchive translation_flags */ 6:
                    message.translationFlags = exports.FormulaTranslationFlagsArchive.internalBinaryRead(reader, reader.uint32(), options, message.translationFlags);
                    break;
                case /* optional TSP.UUID host_table_uid */ 7:
                    message.hostTableUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.hostTableUid);
                    break;
                case /* optional TSP.UUID host_column_uid */ 8:
                    message.hostColumnUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.hostColumnUid);
                    break;
                case /* optional TSP.UUID host_row_uid */ 9:
                    message.hostRowUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.hostRowUid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSCE.ASTNodeArrayArchive AST_node_array = 1 [json_name = "ASTNodeArray"]; */
        if (message.aSTNodeArray)
            exports.ASTNodeArrayArchive.internalBinaryWrite(message.aSTNodeArray, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 host_column = 2; */
        if (message.hostColumn !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.hostColumn);
        /* optional uint32 host_row = 3; */
        if (message.hostRow !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.hostRow);
        /* optional bool host_column_is_negative = 4; */
        if (message.hostColumnIsNegative !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.hostColumnIsNegative);
        /* optional bool host_row_is_negative = 5; */
        if (message.hostRowIsNegative !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.hostRowIsNegative);
        /* optional TSCE.FormulaTranslationFlagsArchive translation_flags = 6; */
        if (message.translationFlags)
            exports.FormulaTranslationFlagsArchive.internalBinaryWrite(message.translationFlags, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID host_table_uid = 7; */
        if (message.hostTableUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.hostTableUid, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID host_column_uid = 8; */
        if (message.hostColumnUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.hostColumnUid, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID host_row_uid = 9; */
        if (message.hostRowUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.hostRowUid, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.FormulaArchive
 */
exports.FormulaArchive = new FormulaArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FunctorArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.FunctorArchive", [
            { no: 1, name: "formula", kind: "message", T: () => exports.FormulaArchive },
            { no: 2, name: "num_args", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { numArgs: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSCE.FormulaArchive formula */ 1:
                    message.formula = exports.FormulaArchive.internalBinaryRead(reader, reader.uint32(), options, message.formula);
                    break;
                case /* uint32 num_args */ 2:
                    message.numArgs = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSCE.FormulaArchive formula = 1; */
        if (message.formula)
            exports.FormulaArchive.internalBinaryWrite(message.formula, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 num_args = 2; */
        if (message.numArgs !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.numArgs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.FunctorArchive
 */
exports.FunctorArchive = new FunctorArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormatStructArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.FormatStructArchive", [
            { no: 1, name: "format_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "decimal_places", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "currency_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "negative_style", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "show_thousands_separator", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "use_accounting_style", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "duration_style", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "base", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "base_places", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "base_use_minus_sign", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "fraction_accuracy", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "suppress_date_format", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "suppress_time_format", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "date_time_format", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "duration_unit_largest", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 16, name: "duration_unit_smallest", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { formatType: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 format_type */ 1:
                    message.formatType = reader.uint32();
                    break;
                case /* optional uint32 decimal_places */ 2:
                    message.decimalPlaces = reader.uint32();
                    break;
                case /* optional string currency_code */ 3:
                    message.currencyCode = reader.string();
                    break;
                case /* optional uint32 negative_style */ 4:
                    message.negativeStyle = reader.uint32();
                    break;
                case /* optional bool show_thousands_separator */ 5:
                    message.showThousandsSeparator = reader.bool();
                    break;
                case /* optional bool use_accounting_style */ 6:
                    message.useAccountingStyle = reader.bool();
                    break;
                case /* optional uint32 duration_style */ 7:
                    message.durationStyle = reader.uint32();
                    break;
                case /* optional uint32 base */ 8:
                    message.base = reader.uint32();
                    break;
                case /* optional uint32 base_places */ 9:
                    message.basePlaces = reader.uint32();
                    break;
                case /* optional bool base_use_minus_sign */ 10:
                    message.baseUseMinusSign = reader.bool();
                    break;
                case /* optional uint32 fraction_accuracy */ 11:
                    message.fractionAccuracy = reader.uint32();
                    break;
                case /* optional bool suppress_date_format */ 12:
                    message.suppressDateFormat = reader.bool();
                    break;
                case /* optional bool suppress_time_format */ 13:
                    message.suppressTimeFormat = reader.bool();
                    break;
                case /* optional string date_time_format */ 14:
                    message.dateTimeFormat = reader.string();
                    break;
                case /* optional uint32 duration_unit_largest */ 15:
                    message.durationUnitLargest = reader.uint32();
                    break;
                case /* optional uint32 duration_unit_smallest */ 16:
                    message.durationUnitSmallest = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 format_type = 1; */
        if (message.formatType !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.formatType);
        /* optional uint32 decimal_places = 2; */
        if (message.decimalPlaces !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.decimalPlaces);
        /* optional string currency_code = 3; */
        if (message.currencyCode !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.currencyCode);
        /* optional uint32 negative_style = 4; */
        if (message.negativeStyle !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.negativeStyle);
        /* optional bool show_thousands_separator = 5; */
        if (message.showThousandsSeparator !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.showThousandsSeparator);
        /* optional bool use_accounting_style = 6; */
        if (message.useAccountingStyle !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.useAccountingStyle);
        /* optional uint32 duration_style = 7; */
        if (message.durationStyle !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).uint32(message.durationStyle);
        /* optional uint32 base = 8; */
        if (message.base !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).uint32(message.base);
        /* optional uint32 base_places = 9; */
        if (message.basePlaces !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).uint32(message.basePlaces);
        /* optional bool base_use_minus_sign = 10; */
        if (message.baseUseMinusSign !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).bool(message.baseUseMinusSign);
        /* optional uint32 fraction_accuracy = 11; */
        if (message.fractionAccuracy !== undefined)
            writer.tag(11, runtime_1.WireType.Varint).uint32(message.fractionAccuracy);
        /* optional bool suppress_date_format = 12; */
        if (message.suppressDateFormat !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).bool(message.suppressDateFormat);
        /* optional bool suppress_time_format = 13; */
        if (message.suppressTimeFormat !== undefined)
            writer.tag(13, runtime_1.WireType.Varint).bool(message.suppressTimeFormat);
        /* optional string date_time_format = 14; */
        if (message.dateTimeFormat !== undefined)
            writer.tag(14, runtime_1.WireType.LengthDelimited).string(message.dateTimeFormat);
        /* optional uint32 duration_unit_largest = 15; */
        if (message.durationUnitLargest !== undefined)
            writer.tag(15, runtime_1.WireType.Varint).uint32(message.durationUnitLargest);
        /* optional uint32 duration_unit_smallest = 16; */
        if (message.durationUnitSmallest !== undefined)
            writer.tag(16, runtime_1.WireType.Varint).uint32(message.durationUnitSmallest);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.FormatStructArchive
 */
exports.FormatStructArchive = new FormatStructArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RangeCoordinateArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.RangeCoordinateArchive", [
            { no: 1, name: "top_left_column", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "top_left_row", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "bottom_right_column", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "bottom_right_row", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { topLeftColumn: 0, topLeftRow: 0, bottomRightColumn: 0, bottomRightRow: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 top_left_column */ 1:
                    message.topLeftColumn = reader.uint32();
                    break;
                case /* uint32 top_left_row */ 2:
                    message.topLeftRow = reader.uint32();
                    break;
                case /* uint32 bottom_right_column */ 3:
                    message.bottomRightColumn = reader.uint32();
                    break;
                case /* uint32 bottom_right_row */ 4:
                    message.bottomRightRow = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 top_left_column = 1; */
        if (message.topLeftColumn !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.topLeftColumn);
        /* uint32 top_left_row = 2; */
        if (message.topLeftRow !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.topLeftRow);
        /* uint32 bottom_right_column = 3; */
        if (message.bottomRightColumn !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.bottomRightColumn);
        /* uint32 bottom_right_row = 4; */
        if (message.bottomRightRow !== 0)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.bottomRightRow);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.RangeCoordinateArchive
 */
exports.RangeCoordinateArchive = new RangeCoordinateArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TableTransposeInfoArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.TableTransposeInfoArchive", [
            { no: 3, name: "number_of_footer_rows", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "body_range_for_transposed_table", kind: "message", T: () => exports.RangeCoordinateArchive }
        ]);
    }
    create(value) {
        const message = { numberOfFooterRows: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 number_of_footer_rows */ 3:
                    message.numberOfFooterRows = reader.uint32();
                    break;
                case /* TSCE.RangeCoordinateArchive body_range_for_transposed_table */ 4:
                    message.bodyRangeForTransposedTable = exports.RangeCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.bodyRangeForTransposedTable);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 number_of_footer_rows = 3; */
        if (message.numberOfFooterRows !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.numberOfFooterRows);
        /* TSCE.RangeCoordinateArchive body_range_for_transposed_table = 4; */
        if (message.bodyRangeForTransposedTable)
            exports.RangeCoordinateArchive.internalBinaryWrite(message.bodyRangeForTransposedTable, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.TableTransposeInfoArchive
 */
exports.TableTransposeInfoArchive = new TableTransposeInfoArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MergeOriginMovedArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.MergeOriginMovedArchive", [
            { no: 1, name: "src_column", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "src_row", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "dst_column", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "dst_row", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { srcColumn: [], srcRow: [], dstColumn: [], dstRow: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 src_column */ 1:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.srcColumn.push(reader.uint32());
                    else
                        message.srcColumn.push(reader.uint32());
                    break;
                case /* repeated uint32 src_row */ 2:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.srcRow.push(reader.uint32());
                    else
                        message.srcRow.push(reader.uint32());
                    break;
                case /* repeated uint32 dst_column */ 3:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.dstColumn.push(reader.uint32());
                    else
                        message.dstColumn.push(reader.uint32());
                    break;
                case /* repeated uint32 dst_row */ 4:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.dstRow.push(reader.uint32());
                    else
                        message.dstRow.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated uint32 src_column = 1; */
        for (let i = 0; i < message.srcColumn.length; i++)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.srcColumn[i]);
        /* repeated uint32 src_row = 2; */
        for (let i = 0; i < message.srcRow.length; i++)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.srcRow[i]);
        /* repeated uint32 dst_column = 3; */
        for (let i = 0; i < message.dstColumn.length; i++)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.dstColumn[i]);
        /* repeated uint32 dst_row = 4; */
        for (let i = 0; i < message.dstRow.length; i++)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.dstRow[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.MergeOriginMovedArchive
 */
exports.MergeOriginMovedArchive = new MergeOriginMovedArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OwnerUIDMapperArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.OwnerUIDMapperArchive", [
            { no: 1, name: "table_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 2, name: "next_table_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 3, name: "hidden_state_for_rows_owner_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 4, name: "next_hidden_state_for_rows_owner_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 5, name: "hidden_state_for_columns_owner_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 6, name: "next_hidden_state_for_columns_owner_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 7, name: "conditional_style_owner_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 8, name: "next_conditional_style_owner_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 9, name: "sort_rule_reference_tracker_owner_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 10, name: "next_sort_rule_reference_tracker_owner_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 11, name: "merge_owner_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 12, name: "next_merge_owner_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 15, name: "category_aggregates_owner_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 16, name: "next_category_aggregates_owner_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 17, name: "group_by_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 18, name: "next_group_by_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 19, name: "pencil_annotation_owner_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 20, name: "next_pencil_annotation_owner_uid", kind: "message", T: () => TSPMessages_3.UUID }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID table_uid */ 1:
                    message.tableUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.tableUid);
                    break;
                case /* TSP.UUID next_table_uid */ 2:
                    message.nextTableUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.nextTableUid);
                    break;
                case /* TSP.UUID hidden_state_for_rows_owner_uid */ 3:
                    message.hiddenStateForRowsOwnerUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.hiddenStateForRowsOwnerUid);
                    break;
                case /* TSP.UUID next_hidden_state_for_rows_owner_uid */ 4:
                    message.nextHiddenStateForRowsOwnerUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.nextHiddenStateForRowsOwnerUid);
                    break;
                case /* TSP.UUID hidden_state_for_columns_owner_uid */ 5:
                    message.hiddenStateForColumnsOwnerUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.hiddenStateForColumnsOwnerUid);
                    break;
                case /* TSP.UUID next_hidden_state_for_columns_owner_uid */ 6:
                    message.nextHiddenStateForColumnsOwnerUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.nextHiddenStateForColumnsOwnerUid);
                    break;
                case /* TSP.UUID conditional_style_owner_uid */ 7:
                    message.conditionalStyleOwnerUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.conditionalStyleOwnerUid);
                    break;
                case /* TSP.UUID next_conditional_style_owner_uid */ 8:
                    message.nextConditionalStyleOwnerUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.nextConditionalStyleOwnerUid);
                    break;
                case /* TSP.UUID sort_rule_reference_tracker_owner_uid */ 9:
                    message.sortRuleReferenceTrackerOwnerUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.sortRuleReferenceTrackerOwnerUid);
                    break;
                case /* TSP.UUID next_sort_rule_reference_tracker_owner_uid */ 10:
                    message.nextSortRuleReferenceTrackerOwnerUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.nextSortRuleReferenceTrackerOwnerUid);
                    break;
                case /* TSP.UUID merge_owner_uid */ 11:
                    message.mergeOwnerUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.mergeOwnerUid);
                    break;
                case /* TSP.UUID next_merge_owner_uid */ 12:
                    message.nextMergeOwnerUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.nextMergeOwnerUid);
                    break;
                case /* TSP.UUID category_aggregates_owner_uid */ 15:
                    message.categoryAggregatesOwnerUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.categoryAggregatesOwnerUid);
                    break;
                case /* TSP.UUID next_category_aggregates_owner_uid */ 16:
                    message.nextCategoryAggregatesOwnerUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.nextCategoryAggregatesOwnerUid);
                    break;
                case /* TSP.UUID group_by_uid */ 17:
                    message.groupByUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.groupByUid);
                    break;
                case /* TSP.UUID next_group_by_uid */ 18:
                    message.nextGroupByUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.nextGroupByUid);
                    break;
                case /* TSP.UUID pencil_annotation_owner_uid */ 19:
                    message.pencilAnnotationOwnerUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.pencilAnnotationOwnerUid);
                    break;
                case /* TSP.UUID next_pencil_annotation_owner_uid */ 20:
                    message.nextPencilAnnotationOwnerUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.nextPencilAnnotationOwnerUid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID table_uid = 1; */
        if (message.tableUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.tableUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID next_table_uid = 2; */
        if (message.nextTableUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.nextTableUid, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID hidden_state_for_rows_owner_uid = 3; */
        if (message.hiddenStateForRowsOwnerUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.hiddenStateForRowsOwnerUid, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID next_hidden_state_for_rows_owner_uid = 4; */
        if (message.nextHiddenStateForRowsOwnerUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.nextHiddenStateForRowsOwnerUid, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID hidden_state_for_columns_owner_uid = 5; */
        if (message.hiddenStateForColumnsOwnerUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.hiddenStateForColumnsOwnerUid, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID next_hidden_state_for_columns_owner_uid = 6; */
        if (message.nextHiddenStateForColumnsOwnerUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.nextHiddenStateForColumnsOwnerUid, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID conditional_style_owner_uid = 7; */
        if (message.conditionalStyleOwnerUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.conditionalStyleOwnerUid, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID next_conditional_style_owner_uid = 8; */
        if (message.nextConditionalStyleOwnerUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.nextConditionalStyleOwnerUid, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID sort_rule_reference_tracker_owner_uid = 9; */
        if (message.sortRuleReferenceTrackerOwnerUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.sortRuleReferenceTrackerOwnerUid, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID next_sort_rule_reference_tracker_owner_uid = 10; */
        if (message.nextSortRuleReferenceTrackerOwnerUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.nextSortRuleReferenceTrackerOwnerUid, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID merge_owner_uid = 11; */
        if (message.mergeOwnerUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.mergeOwnerUid, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID next_merge_owner_uid = 12; */
        if (message.nextMergeOwnerUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.nextMergeOwnerUid, writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID category_aggregates_owner_uid = 15; */
        if (message.categoryAggregatesOwnerUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.categoryAggregatesOwnerUid, writer.tag(15, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID next_category_aggregates_owner_uid = 16; */
        if (message.nextCategoryAggregatesOwnerUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.nextCategoryAggregatesOwnerUid, writer.tag(16, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID group_by_uid = 17; */
        if (message.groupByUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.groupByUid, writer.tag(17, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID next_group_by_uid = 18; */
        if (message.nextGroupByUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.nextGroupByUid, writer.tag(18, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID pencil_annotation_owner_uid = 19; */
        if (message.pencilAnnotationOwnerUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.pencilAnnotationOwnerUid, writer.tag(19, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID next_pencil_annotation_owner_uid = 20; */
        if (message.nextPencilAnnotationOwnerUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.nextPencilAnnotationOwnerUid, writer.tag(20, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.OwnerUIDMapperArchive
 */
exports.OwnerUIDMapperArchive = new OwnerUIDMapperArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RewriteTableUIDInfoArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.RewriteTableUIDInfoArchive", [
            { no: 1, name: "table_uid_map", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.RewriteTableUIDInfoArchive_TableUIDMapEntryArchive }
        ]);
    }
    create(value) {
        const message = { tableUidMap: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSCE.RewriteTableUIDInfoArchive.TableUIDMapEntryArchive table_uid_map */ 1:
                    message.tableUidMap.push(exports.RewriteTableUIDInfoArchive_TableUIDMapEntryArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSCE.RewriteTableUIDInfoArchive.TableUIDMapEntryArchive table_uid_map = 1; */
        for (let i = 0; i < message.tableUidMap.length; i++)
            exports.RewriteTableUIDInfoArchive_TableUIDMapEntryArchive.internalBinaryWrite(message.tableUidMap[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.RewriteTableUIDInfoArchive
 */
exports.RewriteTableUIDInfoArchive = new RewriteTableUIDInfoArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RewriteTableUIDInfoArchive_TableUIDMapEntryArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.RewriteTableUIDInfoArchive.TableUIDMapEntryArchive", [
            { no: 1, name: "prev_table_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 2, name: "new_table_uid", kind: "message", T: () => TSPMessages_3.UUID }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID prev_table_uid */ 1:
                    message.prevTableUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.prevTableUid);
                    break;
                case /* TSP.UUID new_table_uid */ 2:
                    message.newTableUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.newTableUid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID prev_table_uid = 1; */
        if (message.prevTableUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.prevTableUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID new_table_uid = 2; */
        if (message.newTableUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.newTableUid, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.RewriteTableUIDInfoArchive.TableUIDMapEntryArchive
 */
exports.RewriteTableUIDInfoArchive_TableUIDMapEntryArchive = new RewriteTableUIDInfoArchive_TableUIDMapEntryArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupByChangeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.GroupByChangeArchive", [
            { no: 1, name: "change_type", kind: "enum", T: () => ["TSCE.GroupByChangeArchive.ChangeType", GroupByChangeArchive_ChangeType] },
            { no: 2, name: "group_by_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 3, name: "previous_level", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "updated_level", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "previous_to_updated_map", kind: "message", T: () => TSPMessages_1.UUIDMapArchive },
            { no: 6, name: "updated_to_previous_map", kind: "message", T: () => TSPMessages_1.UUIDMapArchive },
            { no: 7, name: "removed_group_uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_3.UUID },
            { no: 8, name: "grouping_column_changes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.GroupByChangeArchive_GroupingColumnChangeArchive }
        ]);
    }
    create(value) {
        const message = { changeType: 0, removedGroupUids: [], groupingColumnChanges: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSCE.GroupByChangeArchive.ChangeType change_type */ 1:
                    message.changeType = reader.int32();
                    break;
                case /* TSP.UUID group_by_uid */ 2:
                    message.groupByUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.groupByUid);
                    break;
                case /* optional uint32 previous_level */ 3:
                    message.previousLevel = reader.uint32();
                    break;
                case /* optional uint32 updated_level */ 4:
                    message.updatedLevel = reader.uint32();
                    break;
                case /* optional TSP.UUIDMapArchive previous_to_updated_map */ 5:
                    message.previousToUpdatedMap = TSPMessages_1.UUIDMapArchive.internalBinaryRead(reader, reader.uint32(), options, message.previousToUpdatedMap);
                    break;
                case /* optional TSP.UUIDMapArchive updated_to_previous_map */ 6:
                    message.updatedToPreviousMap = TSPMessages_1.UUIDMapArchive.internalBinaryRead(reader, reader.uint32(), options, message.updatedToPreviousMap);
                    break;
                case /* repeated TSP.UUID removed_group_uids */ 7:
                    message.removedGroupUids.push(TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSCE.GroupByChangeArchive.GroupingColumnChangeArchive grouping_column_changes */ 8:
                    message.groupingColumnChanges.push(exports.GroupByChangeArchive_GroupingColumnChangeArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSCE.GroupByChangeArchive.ChangeType change_type = 1; */
        if (message.changeType !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.changeType);
        /* TSP.UUID group_by_uid = 2; */
        if (message.groupByUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.groupByUid, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 previous_level = 3; */
        if (message.previousLevel !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.previousLevel);
        /* optional uint32 updated_level = 4; */
        if (message.updatedLevel !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.updatedLevel);
        /* optional TSP.UUIDMapArchive previous_to_updated_map = 5; */
        if (message.previousToUpdatedMap)
            TSPMessages_1.UUIDMapArchive.internalBinaryWrite(message.previousToUpdatedMap, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDMapArchive updated_to_previous_map = 6; */
        if (message.updatedToPreviousMap)
            TSPMessages_1.UUIDMapArchive.internalBinaryWrite(message.updatedToPreviousMap, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID removed_group_uids = 7; */
        for (let i = 0; i < message.removedGroupUids.length; i++)
            TSPMessages_3.UUID.internalBinaryWrite(message.removedGroupUids[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.GroupByChangeArchive.GroupingColumnChangeArchive grouping_column_changes = 8; */
        for (let i = 0; i < message.groupingColumnChanges.length; i++)
            exports.GroupByChangeArchive_GroupingColumnChangeArchive.internalBinaryWrite(message.groupingColumnChanges[i], writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.GroupByChangeArchive
 */
exports.GroupByChangeArchive = new GroupByChangeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupByChangeArchive_GroupingColumnChangeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.GroupByChangeArchive.GroupingColumnChangeArchive", [
            { no: 1, name: "old_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "new_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { oldLevel: 0, newLevel: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 old_level */ 1:
                    message.oldLevel = reader.uint32();
                    break;
                case /* uint32 new_level */ 2:
                    message.newLevel = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 old_level = 1; */
        if (message.oldLevel !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.oldLevel);
        /* uint32 new_level = 2; */
        if (message.newLevel !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.newLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.GroupByChangeArchive.GroupingColumnChangeArchive
 */
exports.GroupByChangeArchive_GroupingColumnChangeArchive = new GroupByChangeArchive_GroupingColumnChangeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RewriteGroupNodeUIDInfoArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.RewriteGroupNodeUIDInfoArchive", [
            { no: 1, name: "group_by_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 2, name: "group_node_uid_map", kind: "message", T: () => TSPMessages_1.UUIDMapArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.UUID group_by_uid */ 1:
                    message.groupByUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.groupByUid);
                    break;
                case /* TSP.UUIDMapArchive group_node_uid_map */ 2:
                    message.groupNodeUidMap = TSPMessages_1.UUIDMapArchive.internalBinaryRead(reader, reader.uint32(), options, message.groupNodeUidMap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.UUID group_by_uid = 1; */
        if (message.groupByUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.groupByUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUIDMapArchive group_node_uid_map = 2; */
        if (message.groupNodeUidMap)
            TSPMessages_1.UUIDMapArchive.internalBinaryWrite(message.groupNodeUidMap, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.RewriteGroupNodeUIDInfoArchive
 */
exports.RewriteGroupNodeUIDInfoArchive = new RewriteGroupNodeUIDInfoArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IndexedUidsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.IndexedUidsArchive", [
            { no: 1, name: "uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.IndexedUidsArchive_IndexedUid }
        ]);
    }
    create(value) {
        const message = { uids: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSCE.IndexedUidsArchive.IndexedUid uids */ 1:
                    message.uids.push(exports.IndexedUidsArchive_IndexedUid.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSCE.IndexedUidsArchive.IndexedUid uids = 1; */
        for (let i = 0; i < message.uids.length; i++)
            exports.IndexedUidsArchive_IndexedUid.internalBinaryWrite(message.uids[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.IndexedUidsArchive
 */
exports.IndexedUidsArchive = new IndexedUidsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IndexedUidsArchive_IndexedUid$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.IndexedUidsArchive.IndexedUid", [
            { no: 1, name: "uid_for_index", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 2, name: "index_for_uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { indexForUid: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID uid_for_index */ 1:
                    message.uidForIndex = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.uidForIndex);
                    break;
                case /* uint32 index_for_uid */ 2:
                    message.indexForUid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID uid_for_index = 1; */
        if (message.uidForIndex)
            TSPMessages_3.UUID.internalBinaryWrite(message.uidForIndex, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 index_for_uid = 2; */
        if (message.indexForUid !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.indexForUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.IndexedUidsArchive.IndexedUid
 */
exports.IndexedUidsArchive_IndexedUid = new IndexedUidsArchive_IndexedUid$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RewriteRangeEntryArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.RewriteRangeEntryArchive", [
            { no: 1, name: "range_location", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "range_length", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "range_uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_3.UUID },
            { no: 4, name: "offset", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { rangeLocation: 0, rangeLength: 0, rangeUids: [], offset: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 range_location */ 1:
                    message.rangeLocation = reader.uint32();
                    break;
                case /* uint32 range_length */ 2:
                    message.rangeLength = reader.uint32();
                    break;
                case /* repeated TSP.UUID range_uids */ 3:
                    message.rangeUids.push(TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 offset */ 4:
                    message.offset = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 range_location = 1; */
        if (message.rangeLocation !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.rangeLocation);
        /* uint32 range_length = 2; */
        if (message.rangeLength !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.rangeLength);
        /* repeated TSP.UUID range_uids = 3; */
        for (let i = 0; i < message.rangeUids.length; i++)
            TSPMessages_3.UUID.internalBinaryWrite(message.rangeUids[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 offset = 4; */
        if (message.offset !== 0)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.offset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.RewriteRangeEntryArchive
 */
exports.RewriteRangeEntryArchive = new RewriteRangeEntryArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ColumnOrRowUuidsInfoArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.ColumnOrRowUuidsInfoArchive", [
            { no: 1, name: "is_rows", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "table_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 3, name: "cond_style_owner_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 4, name: "group_by_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 5, name: "uids", kind: "message", T: () => exports.IndexedUidsArchive },
            { no: 6, name: "range_entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.RewriteRangeEntryArchive },
            { no: 7, name: "table_range", kind: "message", T: () => exports.RangeCoordinateArchive },
            { no: 8, name: "insert_at_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 9, name: "insert_opposite_uid", kind: "message", T: () => TSPMessages_3.UUID }
        ]);
    }
    create(value) {
        const message = { isRows: false, rangeEntries: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_rows */ 1:
                    message.isRows = reader.bool();
                    break;
                case /* TSP.UUID table_uid */ 2:
                    message.tableUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.tableUid);
                    break;
                case /* TSP.UUID cond_style_owner_uid */ 3:
                    message.condStyleOwnerUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.condStyleOwnerUid);
                    break;
                case /* TSP.UUID group_by_uid */ 4:
                    message.groupByUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.groupByUid);
                    break;
                case /* TSCE.IndexedUidsArchive uids */ 5:
                    message.uids = exports.IndexedUidsArchive.internalBinaryRead(reader, reader.uint32(), options, message.uids);
                    break;
                case /* repeated TSCE.RewriteRangeEntryArchive range_entries */ 6:
                    message.rangeEntries.push(exports.RewriteRangeEntryArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* TSCE.RangeCoordinateArchive table_range */ 7:
                    message.tableRange = exports.RangeCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.tableRange);
                    break;
                case /* optional TSP.UUID insert_at_uid */ 8:
                    message.insertAtUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.insertAtUid);
                    break;
                case /* optional TSP.UUID insert_opposite_uid */ 9:
                    message.insertOppositeUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.insertOppositeUid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool is_rows = 1; */
        if (message.isRows !== false)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.isRows);
        /* TSP.UUID table_uid = 2; */
        if (message.tableUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.tableUid, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID cond_style_owner_uid = 3; */
        if (message.condStyleOwnerUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.condStyleOwnerUid, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID group_by_uid = 4; */
        if (message.groupByUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.groupByUid, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSCE.IndexedUidsArchive uids = 5; */
        if (message.uids)
            exports.IndexedUidsArchive.internalBinaryWrite(message.uids, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.RewriteRangeEntryArchive range_entries = 6; */
        for (let i = 0; i < message.rangeEntries.length; i++)
            exports.RewriteRangeEntryArchive.internalBinaryWrite(message.rangeEntries[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSCE.RangeCoordinateArchive table_range = 7; */
        if (message.tableRange)
            exports.RangeCoordinateArchive.internalBinaryWrite(message.tableRange, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID insert_at_uid = 8; */
        if (message.insertAtUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.insertAtUid, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID insert_opposite_uid = 9; */
        if (message.insertOppositeUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.insertOppositeUid, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.ColumnOrRowUuidsInfoArchive
 */
exports.ColumnOrRowUuidsInfoArchive = new ColumnOrRowUuidsInfoArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegionInfoArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.RegionInfoArchive", [
            { no: 1, name: "table_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 2, name: "column_uids", kind: "message", T: () => exports.IndexedUidsArchive },
            { no: 3, name: "row_uids", kind: "message", T: () => exports.IndexedUidsArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID table_uid */ 1:
                    message.tableUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.tableUid);
                    break;
                case /* TSCE.IndexedUidsArchive column_uids */ 2:
                    message.columnUids = exports.IndexedUidsArchive.internalBinaryRead(reader, reader.uint32(), options, message.columnUids);
                    break;
                case /* TSCE.IndexedUidsArchive row_uids */ 3:
                    message.rowUids = exports.IndexedUidsArchive.internalBinaryRead(reader, reader.uint32(), options, message.rowUids);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID table_uid = 1; */
        if (message.tableUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.tableUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSCE.IndexedUidsArchive column_uids = 2; */
        if (message.columnUids)
            exports.IndexedUidsArchive.internalBinaryWrite(message.columnUids, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSCE.IndexedUidsArchive row_uids = 3; */
        if (message.rowUids)
            exports.IndexedUidsArchive.internalBinaryWrite(message.rowUids, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.RegionInfoArchive
 */
exports.RegionInfoArchive = new RegionInfoArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegionMovedInfoArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.RegionMovedInfoArchive", [
            { no: 1, name: "src_region", kind: "message", T: () => exports.RegionInfoArchive },
            { no: 2, name: "dst_region", kind: "message", T: () => exports.RegionInfoArchive },
            { no: 3, name: "span_rows", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "span_columns", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "original_src_region", kind: "message", T: () => exports.RegionInfoArchive },
            { no: 6, name: "final_dest_table_uid", kind: "message", T: () => TSPMessages_3.UUID }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSCE.RegionInfoArchive src_region */ 1:
                    message.srcRegion = exports.RegionInfoArchive.internalBinaryRead(reader, reader.uint32(), options, message.srcRegion);
                    break;
                case /* TSCE.RegionInfoArchive dst_region */ 2:
                    message.dstRegion = exports.RegionInfoArchive.internalBinaryRead(reader, reader.uint32(), options, message.dstRegion);
                    break;
                case /* optional bool span_rows */ 3:
                    message.spanRows = reader.bool();
                    break;
                case /* optional bool span_columns */ 4:
                    message.spanColumns = reader.bool();
                    break;
                case /* optional TSCE.RegionInfoArchive original_src_region */ 5:
                    message.originalSrcRegion = exports.RegionInfoArchive.internalBinaryRead(reader, reader.uint32(), options, message.originalSrcRegion);
                    break;
                case /* optional TSP.UUID final_dest_table_uid */ 6:
                    message.finalDestTableUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.finalDestTableUid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSCE.RegionInfoArchive src_region = 1; */
        if (message.srcRegion)
            exports.RegionInfoArchive.internalBinaryWrite(message.srcRegion, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSCE.RegionInfoArchive dst_region = 2; */
        if (message.dstRegion)
            exports.RegionInfoArchive.internalBinaryWrite(message.dstRegion, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool span_rows = 3; */
        if (message.spanRows !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.spanRows);
        /* optional bool span_columns = 4; */
        if (message.spanColumns !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.spanColumns);
        /* optional TSCE.RegionInfoArchive original_src_region = 5; */
        if (message.originalSrcRegion)
            exports.RegionInfoArchive.internalBinaryWrite(message.originalSrcRegion, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID final_dest_table_uid = 6; */
        if (message.finalDestTableUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.finalDestTableUid, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.RegionMovedInfoArchive
 */
exports.RegionMovedInfoArchive = new RegionMovedInfoArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MergeSourceArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.MergeSourceArchive", [
            { no: 1, name: "coord_column", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "coord_row", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { coordColumn: 0, coordRow: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 coord_column */ 1:
                    message.coordColumn = reader.uint32();
                    break;
                case /* uint32 coord_row */ 2:
                    message.coordRow = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 coord_column = 1; */
        if (message.coordColumn !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.coordColumn);
        /* uint32 coord_row = 2; */
        if (message.coordRow !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.coordRow);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.MergeSourceArchive
 */
exports.MergeSourceArchive = new MergeSourceArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HauntedOwnerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.HauntedOwnerArchive", [
            { no: 1, name: "owner_uid", kind: "message", T: () => TSPMessages_3.UUID }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID owner_uid */ 1:
                    message.ownerUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.ownerUid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID owner_uid = 1; */
        if (message.ownerUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.ownerUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.HauntedOwnerArchive
 */
exports.HauntedOwnerArchive = new HauntedOwnerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellCoordinateArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.CellCoordinateArchive", [
            { no: 1, name: "packedData", kind: "scalar", opt: true, T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "column", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "row", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional fixed32 packedData */ 1:
                    message.packedData = reader.fixed32();
                    break;
                case /* optional uint32 column */ 2:
                    message.column = reader.uint32();
                    break;
                case /* optional uint32 row */ 3:
                    message.row = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional fixed32 packedData = 1; */
        if (message.packedData !== undefined)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.packedData);
        /* optional uint32 column = 2; */
        if (message.column !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.column);
        /* optional uint32 row = 3; */
        if (message.row !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.row);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.CellCoordinateArchive
 */
exports.CellCoordinateArchive = new CellCoordinateArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellCoordinateVectorArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.CellCoordinateVectorArchive", [
            { no: 1, name: "cell_coord", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CellCoordinateArchive }
        ]);
    }
    create(value) {
        const message = { cellCoord: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSCE.CellCoordinateArchive cell_coord */ 1:
                    message.cellCoord.push(exports.CellCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSCE.CellCoordinateArchive cell_coord = 1; */
        for (let i = 0; i < message.cellCoord.length; i++)
            exports.CellCoordinateArchive.internalBinaryWrite(message.cellCoord[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.CellCoordinateVectorArchive
 */
exports.CellCoordinateVectorArchive = new CellCoordinateVectorArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpandedCellRefObjectPairArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.ExpandedCellRefObjectPairArchive", [
            { no: 1, name: "cell_ref", kind: "message", T: () => exports.CellReferenceArchive },
            { no: 2, name: "object", kind: "message", T: () => TSPMessages_2.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSCE.CellReferenceArchive cell_ref */ 1:
                    message.cellRef = exports.CellReferenceArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellRef);
                    break;
                case /* TSP.Reference object */ 2:
                    message.object = TSPMessages_2.Reference.internalBinaryRead(reader, reader.uint32(), options, message.object);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSCE.CellReferenceArchive cell_ref = 1; */
        if (message.cellRef)
            exports.CellReferenceArchive.internalBinaryWrite(message.cellRef, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference object = 2; */
        if (message.object)
            TSPMessages_2.Reference.internalBinaryWrite(message.object, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.ExpandedCellRefObjectPairArchive
 */
exports.ExpandedCellRefObjectPairArchive = new ExpandedCellRefObjectPairArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpandedCellRefObjectMapArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.ExpandedCellRefObjectMapArchive", [
            { no: 1, name: "cell_ref_object_pair", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ExpandedCellRefObjectPairArchive }
        ]);
    }
    create(value) {
        const message = { cellRefObjectPair: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSCE.ExpandedCellRefObjectPairArchive cell_ref_object_pair */ 1:
                    message.cellRefObjectPair.push(exports.ExpandedCellRefObjectPairArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSCE.ExpandedCellRefObjectPairArchive cell_ref_object_pair = 1; */
        for (let i = 0; i < message.cellRefObjectPair.length; i++)
            exports.ExpandedCellRefObjectPairArchive.internalBinaryWrite(message.cellRefObjectPair[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.ExpandedCellRefObjectMapArchive
 */
exports.ExpandedCellRefObjectMapArchive = new ExpandedCellRefObjectMapArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormulaAtCoordArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.FormulaAtCoordArchive", [
            { no: 1, name: "column", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "row", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "formula", kind: "message", T: () => exports.FormulaArchive },
            { no: 4, name: "repeat_previous_formula", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { column: 0, row: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 column */ 1:
                    message.column = reader.uint32();
                    break;
                case /* uint32 row */ 2:
                    message.row = reader.uint32();
                    break;
                case /* optional TSCE.FormulaArchive formula */ 3:
                    message.formula = exports.FormulaArchive.internalBinaryRead(reader, reader.uint32(), options, message.formula);
                    break;
                case /* optional bool repeat_previous_formula */ 4:
                    message.repeatPreviousFormula = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 column = 1; */
        if (message.column !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.column);
        /* uint32 row = 2; */
        if (message.row !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.row);
        /* optional TSCE.FormulaArchive formula = 3; */
        if (message.formula)
            exports.FormulaArchive.internalBinaryWrite(message.formula, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool repeat_previous_formula = 4; */
        if (message.repeatPreviousFormula !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.repeatPreviousFormula);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.FormulaAtCoordArchive
 */
exports.FormulaAtCoordArchive = new FormulaAtCoordArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormulaCoordPairsByOwnerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.FormulaCoordPairsByOwnerArchive", [
            { no: 1, name: "owner_kind", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "owner_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 3, name: "formula_at_coords", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.FormulaAtCoordArchive }
        ]);
    }
    create(value) {
        const message = { ownerKind: 0, formulaAtCoords: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 owner_kind */ 1:
                    message.ownerKind = reader.uint32();
                    break;
                case /* optional TSP.UUID owner_uid */ 2:
                    message.ownerUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.ownerUid);
                    break;
                case /* repeated TSCE.FormulaAtCoordArchive formula_at_coords */ 3:
                    message.formulaAtCoords.push(exports.FormulaAtCoordArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 owner_kind = 1; */
        if (message.ownerKind !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.ownerKind);
        /* optional TSP.UUID owner_uid = 2; */
        if (message.ownerUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.ownerUid, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.FormulaAtCoordArchive formula_at_coords = 3; */
        for (let i = 0; i < message.formulaAtCoords.length; i++)
            exports.FormulaAtCoordArchive.internalBinaryWrite(message.formulaAtCoords[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.FormulaCoordPairsByOwnerArchive
 */
exports.FormulaCoordPairsByOwnerArchive = new FormulaCoordPairsByOwnerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormulasForUndoArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.FormulasForUndoArchive", [
            { no: 1, name: "formulas_for_owner", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.FormulaCoordPairsByOwnerArchive }
        ]);
    }
    create(value) {
        const message = { formulasForOwner: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSCE.FormulaCoordPairsByOwnerArchive formulas_for_owner */ 1:
                    message.formulasForOwner.push(exports.FormulaCoordPairsByOwnerArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSCE.FormulaCoordPairsByOwnerArchive formulas_for_owner = 1; */
        for (let i = 0; i < message.formulasForOwner.length; i++)
            exports.FormulaCoordPairsByOwnerArchive.internalBinaryWrite(message.formulasForOwner[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.FormulasForUndoArchive
 */
exports.FormulasForUndoArchive = new FormulasForUndoArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormulaRewriteCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.FormulaRewriteCommandArchive", [
            { no: 1, name: "table_rewrite_command", kind: "message", T: () => TSPMessages_2.Reference },
            { no: 2, name: "super", kind: "message", T: () => TSKArchives_2.CommandArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference table_rewrite_command */ 1:
                    message.tableRewriteCommand = TSPMessages_2.Reference.internalBinaryRead(reader, reader.uint32(), options, message.tableRewriteCommand);
                    break;
                case /* optional TSK.CommandArchive super */ 2:
                    message.super = TSKArchives_2.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference table_rewrite_command = 1; */
        if (message.tableRewriteCommand)
            TSPMessages_2.Reference.internalBinaryWrite(message.tableRewriteCommand, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.CommandArchive super = 2; */
        if (message.super)
            TSKArchives_2.CommandArchive.internalBinaryWrite(message.super, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.FormulaRewriteCommandArchive
 */
exports.FormulaRewriteCommandArchive = new FormulaRewriteCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackedReferenceArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.TrackedReferenceArchive", [
            { no: 1, name: "ast", kind: "message", T: () => exports.ASTNodeArrayArchive },
            { no: 2, name: "formula_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { formulaId: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSCE.ASTNodeArrayArchive ast */ 1:
                    message.ast = exports.ASTNodeArrayArchive.internalBinaryRead(reader, reader.uint32(), options, message.ast);
                    break;
                case /* uint32 formula_id */ 2:
                    message.formulaId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSCE.ASTNodeArrayArchive ast = 1; */
        if (message.ast)
            exports.ASTNodeArrayArchive.internalBinaryWrite(message.ast, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 formula_id = 2; */
        if (message.formulaId !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.formulaId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.TrackedReferenceArchive
 */
exports.TrackedReferenceArchive = new TrackedReferenceArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpandedTrackedReferenceArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.ExpandedTrackedReferenceArchive", [
            { no: 1, name: "ast", kind: "message", T: () => exports.ASTNodeArrayArchive },
            { no: 2, name: "formula_column", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "formula_row", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { formulaColumn: 0, formulaRow: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSCE.ASTNodeArrayArchive ast */ 1:
                    message.ast = exports.ASTNodeArrayArchive.internalBinaryRead(reader, reader.uint32(), options, message.ast);
                    break;
                case /* uint32 formula_column */ 2:
                    message.formulaColumn = reader.uint32();
                    break;
                case /* uint32 formula_row */ 3:
                    message.formulaRow = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSCE.ASTNodeArrayArchive ast = 1; */
        if (message.ast)
            exports.ASTNodeArrayArchive.internalBinaryWrite(message.ast, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 formula_column = 2; */
        if (message.formulaColumn !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.formulaColumn);
        /* uint32 formula_row = 3; */
        if (message.formulaRow !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.formulaRow);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.ExpandedTrackedReferenceArchive
 */
exports.ExpandedTrackedReferenceArchive = new ExpandedTrackedReferenceArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrackedReferenceStoreArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.TrackedReferenceStoreArchive", [
            { no: 1, name: "uuid", kind: "message", T: () => TSPMessages_4.CFUUIDArchive },
            { no: 2, name: "tracked_reference", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_2.Reference },
            { no: 3, name: "contained_tracked_reference", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.TrackedReferenceArchive },
            { no: 4, name: "contained_expanded_tracked_reference", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ExpandedTrackedReferenceArchive }
        ]);
    }
    create(value) {
        const message = { trackedReference: [], containedTrackedReference: [], containedExpandedTrackedReference: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.CFUUIDArchive uuid */ 1:
                    message.uuid = TSPMessages_4.CFUUIDArchive.internalBinaryRead(reader, reader.uint32(), options, message.uuid);
                    break;
                case /* repeated TSP.Reference tracked_reference = 2 [deprecated = true];*/ 2:
                    message.trackedReference.push(TSPMessages_2.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSCE.TrackedReferenceArchive contained_tracked_reference */ 3:
                    message.containedTrackedReference.push(exports.TrackedReferenceArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSCE.ExpandedTrackedReferenceArchive contained_expanded_tracked_reference */ 4:
                    message.containedExpandedTrackedReference.push(exports.ExpandedTrackedReferenceArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.CFUUIDArchive uuid = 1; */
        if (message.uuid)
            TSPMessages_4.CFUUIDArchive.internalBinaryWrite(message.uuid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference tracked_reference = 2 [deprecated = true]; */
        for (let i = 0; i < message.trackedReference.length; i++)
            TSPMessages_2.Reference.internalBinaryWrite(message.trackedReference[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.TrackedReferenceArchive contained_tracked_reference = 3; */
        for (let i = 0; i < message.containedTrackedReference.length; i++)
            exports.TrackedReferenceArchive.internalBinaryWrite(message.containedTrackedReference[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.ExpandedTrackedReferenceArchive contained_expanded_tracked_reference = 4; */
        for (let i = 0; i < message.containedExpandedTrackedReference.length; i++)
            exports.ExpandedTrackedReferenceArchive.internalBinaryWrite(message.containedExpandedTrackedReference[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.TrackedReferenceStoreArchive
 */
exports.TrackedReferenceStoreArchive = new TrackedReferenceStoreArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ViewTractRefArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.ViewTractRefArchive", [
            { no: 1, name: "table_uid", kind: "message", T: () => TSPMessages_3.UUID },
            { no: 2, name: "uid_tract", kind: "message", T: () => exports.ASTNodeArrayArchive_ASTUidTract },
            { no: 3, name: "preserve_flags", kind: "message", T: () => exports.PreserveColumnRowFlagsArchive },
            { no: 4, name: "agg_index_level", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "column_group_level", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ },
            { no: 6, name: "row_group_level", kind: "scalar", opt: true, T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID table_uid */ 1:
                    message.tableUid = TSPMessages_3.UUID.internalBinaryRead(reader, reader.uint32(), options, message.tableUid);
                    break;
                case /* optional TSCE.ASTNodeArrayArchive.ASTUidTract uid_tract */ 2:
                    message.uidTract = exports.ASTNodeArrayArchive_ASTUidTract.internalBinaryRead(reader, reader.uint32(), options, message.uidTract);
                    break;
                case /* optional TSCE.PreserveColumnRowFlagsArchive preserve_flags */ 3:
                    message.preserveFlags = exports.PreserveColumnRowFlagsArchive.internalBinaryRead(reader, reader.uint32(), options, message.preserveFlags);
                    break;
                case /* optional uint32 agg_index_level */ 4:
                    message.aggIndexLevel = reader.uint32();
                    break;
                case /* optional sint32 column_group_level */ 5:
                    message.columnGroupLevel = reader.sint32();
                    break;
                case /* optional sint32 row_group_level */ 6:
                    message.rowGroupLevel = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID table_uid = 1; */
        if (message.tableUid)
            TSPMessages_3.UUID.internalBinaryWrite(message.tableUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.ASTNodeArrayArchive.ASTUidTract uid_tract = 2; */
        if (message.uidTract)
            exports.ASTNodeArrayArchive_ASTUidTract.internalBinaryWrite(message.uidTract, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.PreserveColumnRowFlagsArchive preserve_flags = 3; */
        if (message.preserveFlags)
            exports.PreserveColumnRowFlagsArchive.internalBinaryWrite(message.preserveFlags, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 agg_index_level = 4; */
        if (message.aggIndexLevel !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.aggIndexLevel);
        /* optional sint32 column_group_level = 5; */
        if (message.columnGroupLevel !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).sint32(message.columnGroupLevel);
        /* optional sint32 row_group_level = 6; */
        if (message.rowGroupLevel !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).sint32(message.rowGroupLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.ViewTractRefArchive
 */
exports.ViewTractRefArchive = new ViewTractRefArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BooleanCellValueArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.BooleanCellValueArchive", [
            { no: 1, name: "value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "format", kind: "message", T: () => TSKArchives_1.FormatStructArchive },
            { no: 3, name: "format_is_explicit", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { value: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool value */ 1:
                    message.value = reader.bool();
                    break;
                case /* optional TSK.FormatStructArchive format */ 2:
                    message.format = TSKArchives_1.FormatStructArchive.internalBinaryRead(reader, reader.uint32(), options, message.format);
                    break;
                case /* optional bool format_is_explicit */ 3:
                    message.formatIsExplicit = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool value = 1; */
        if (message.value !== false)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.value);
        /* optional TSK.FormatStructArchive format = 2; */
        if (message.format)
            TSKArchives_1.FormatStructArchive.internalBinaryWrite(message.format, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool format_is_explicit = 3; */
        if (message.formatIsExplicit !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.formatIsExplicit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.BooleanCellValueArchive
 */
exports.BooleanCellValueArchive = new BooleanCellValueArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DateCellValueArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.DateCellValueArchive", [
            { no: 1, name: "value", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "format", kind: "message", T: () => TSKArchives_1.FormatStructArchive },
            { no: 3, name: "format_is_implicit", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "format_is_explicit", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { value: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double value */ 1:
                    message.value = reader.double();
                    break;
                case /* TSK.FormatStructArchive format */ 2:
                    message.format = TSKArchives_1.FormatStructArchive.internalBinaryRead(reader, reader.uint32(), options, message.format);
                    break;
                case /* optional bool format_is_implicit = 3 [deprecated = true];*/ 3:
                    message.formatIsImplicit = reader.bool();
                    break;
                case /* optional bool format_is_explicit */ 4:
                    message.formatIsExplicit = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* double value = 1; */
        if (message.value !== 0)
            writer.tag(1, runtime_1.WireType.Bit64).double(message.value);
        /* TSK.FormatStructArchive format = 2; */
        if (message.format)
            TSKArchives_1.FormatStructArchive.internalBinaryWrite(message.format, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool format_is_implicit = 3 [deprecated = true]; */
        if (message.formatIsImplicit !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.formatIsImplicit);
        /* optional bool format_is_explicit = 4; */
        if (message.formatIsExplicit !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.formatIsExplicit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.DateCellValueArchive
 */
exports.DateCellValueArchive = new DateCellValueArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NumberCellValueArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.NumberCellValueArchive", [
            { no: 1, name: "value", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "unit_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "currency_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "format", kind: "message", T: () => TSKArchives_1.FormatStructArchive },
            { no: 4, name: "format_is_implicit", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "format_is_explicit", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "decimal_low", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "decimal_high", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double value */ 1:
                    message.value = reader.double();
                    break;
                case /* optional int32 unit_index */ 2:
                    message.unitIndex = reader.int32();
                    break;
                case /* optional string currency_code */ 5:
                    message.currencyCode = reader.string();
                    break;
                case /* TSK.FormatStructArchive format */ 3:
                    message.format = TSKArchives_1.FormatStructArchive.internalBinaryRead(reader, reader.uint32(), options, message.format);
                    break;
                case /* optional bool format_is_implicit = 4 [deprecated = true];*/ 4:
                    message.formatIsImplicit = reader.bool();
                    break;
                case /* optional bool format_is_explicit */ 6:
                    message.formatIsExplicit = reader.bool();
                    break;
                case /* optional uint64 decimal_low */ 7:
                    message.decimalLow = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 decimal_high */ 8:
                    message.decimalHigh = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional double value = 1; */
        if (message.value !== undefined)
            writer.tag(1, runtime_1.WireType.Bit64).double(message.value);
        /* optional int32 unit_index = 2; */
        if (message.unitIndex !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.unitIndex);
        /* optional string currency_code = 5; */
        if (message.currencyCode !== undefined)
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.currencyCode);
        /* TSK.FormatStructArchive format = 3; */
        if (message.format)
            TSKArchives_1.FormatStructArchive.internalBinaryWrite(message.format, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool format_is_implicit = 4 [deprecated = true]; */
        if (message.formatIsImplicit !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.formatIsImplicit);
        /* optional bool format_is_explicit = 6; */
        if (message.formatIsExplicit !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.formatIsExplicit);
        /* optional uint64 decimal_low = 7; */
        if (message.decimalLow !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).uint64(message.decimalLow);
        /* optional uint64 decimal_high = 8; */
        if (message.decimalHigh !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).uint64(message.decimalHigh);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.NumberCellValueArchive
 */
exports.NumberCellValueArchive = new NumberCellValueArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StringCellValueArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.StringCellValueArchive", [
            { no: 1, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "format", kind: "message", T: () => TSKArchives_1.FormatStructArchive },
            { no: 3, name: "format_is_implicit", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "format_is_explicit", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "is_regex", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "is_case_sensitive_regex", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { value: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string value */ 1:
                    message.value = reader.string();
                    break;
                case /* TSK.FormatStructArchive format */ 2:
                    message.format = TSKArchives_1.FormatStructArchive.internalBinaryRead(reader, reader.uint32(), options, message.format);
                    break;
                case /* optional bool format_is_implicit = 3 [deprecated = true];*/ 3:
                    message.formatIsImplicit = reader.bool();
                    break;
                case /* optional bool format_is_explicit */ 4:
                    message.formatIsExplicit = reader.bool();
                    break;
                case /* optional bool is_regex */ 5:
                    message.isRegex = reader.bool();
                    break;
                case /* optional bool is_case_sensitive_regex */ 6:
                    message.isCaseSensitiveRegex = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string value = 1; */
        if (message.value !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.value);
        /* TSK.FormatStructArchive format = 2; */
        if (message.format)
            TSKArchives_1.FormatStructArchive.internalBinaryWrite(message.format, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool format_is_implicit = 3 [deprecated = true]; */
        if (message.formatIsImplicit !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.formatIsImplicit);
        /* optional bool format_is_explicit = 4; */
        if (message.formatIsExplicit !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.formatIsExplicit);
        /* optional bool is_regex = 5; */
        if (message.isRegex !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.isRegex);
        /* optional bool is_case_sensitive_regex = 6; */
        if (message.isCaseSensitiveRegex !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.isCaseSensitiveRegex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.StringCellValueArchive
 */
exports.StringCellValueArchive = new StringCellValueArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ErrorCellValueArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.ErrorCellValueArchive", [
            { no: 1, name: "error_type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "extra_info_int", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "extra_info_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "extra_info_double", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value) {
        const message = { errorType: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 error_type */ 1:
                    message.errorType = reader.int32();
                    break;
                case /* optional int32 extra_info_int */ 3:
                    message.extraInfoInt = reader.int32();
                    break;
                case /* optional string extra_info_string */ 4:
                    message.extraInfoString = reader.string();
                    break;
                case /* optional double extra_info_double */ 5:
                    message.extraInfoDouble = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int32 error_type = 1; */
        if (message.errorType !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.errorType);
        /* optional int32 extra_info_int = 3; */
        if (message.extraInfoInt !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.extraInfoInt);
        /* optional string extra_info_string = 4; */
        if (message.extraInfoString !== undefined)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.extraInfoString);
        /* optional double extra_info_double = 5; */
        if (message.extraInfoDouble !== undefined)
            writer.tag(5, runtime_1.WireType.Bit64).double(message.extraInfoDouble);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.ErrorCellValueArchive
 */
exports.ErrorCellValueArchive = new ErrorCellValueArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellValueArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCE.CellValueArchive", [
            { no: 1, name: "cell_value_type", kind: "enum", T: () => ["TSCE.CellValueArchive.CellValueType", CellValueArchive_CellValueType] },
            { no: 2, name: "boolean_value", kind: "message", T: () => exports.BooleanCellValueArchive },
            { no: 3, name: "date_value", kind: "message", T: () => exports.DateCellValueArchive },
            { no: 4, name: "number_value", kind: "message", T: () => exports.NumberCellValueArchive },
            { no: 5, name: "string_value", kind: "message", T: () => exports.StringCellValueArchive },
            { no: 6, name: "error_value", kind: "message", T: () => exports.ErrorCellValueArchive }
        ]);
    }
    create(value) {
        const message = { cellValueType: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSCE.CellValueArchive.CellValueType cell_value_type */ 1:
                    message.cellValueType = reader.int32();
                    break;
                case /* optional TSCE.BooleanCellValueArchive boolean_value */ 2:
                    message.booleanValue = exports.BooleanCellValueArchive.internalBinaryRead(reader, reader.uint32(), options, message.booleanValue);
                    break;
                case /* optional TSCE.DateCellValueArchive date_value */ 3:
                    message.dateValue = exports.DateCellValueArchive.internalBinaryRead(reader, reader.uint32(), options, message.dateValue);
                    break;
                case /* optional TSCE.NumberCellValueArchive number_value */ 4:
                    message.numberValue = exports.NumberCellValueArchive.internalBinaryRead(reader, reader.uint32(), options, message.numberValue);
                    break;
                case /* optional TSCE.StringCellValueArchive string_value */ 5:
                    message.stringValue = exports.StringCellValueArchive.internalBinaryRead(reader, reader.uint32(), options, message.stringValue);
                    break;
                case /* optional TSCE.ErrorCellValueArchive error_value */ 6:
                    message.errorValue = exports.ErrorCellValueArchive.internalBinaryRead(reader, reader.uint32(), options, message.errorValue);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSCE.CellValueArchive.CellValueType cell_value_type = 1; */
        if (message.cellValueType !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.cellValueType);
        /* optional TSCE.BooleanCellValueArchive boolean_value = 2; */
        if (message.booleanValue)
            exports.BooleanCellValueArchive.internalBinaryWrite(message.booleanValue, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.DateCellValueArchive date_value = 3; */
        if (message.dateValue)
            exports.DateCellValueArchive.internalBinaryWrite(message.dateValue, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.NumberCellValueArchive number_value = 4; */
        if (message.numberValue)
            exports.NumberCellValueArchive.internalBinaryWrite(message.numberValue, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.StringCellValueArchive string_value = 5; */
        if (message.stringValue)
            exports.StringCellValueArchive.internalBinaryWrite(message.stringValue, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.ErrorCellValueArchive error_value = 6; */
        if (message.errorValue)
            exports.ErrorCellValueArchive.internalBinaryWrite(message.errorValue, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCE.CellValueArchive
 */
exports.CellValueArchive = new CellValueArchive$Type();
//# sourceMappingURL=TSCEArchives.js.map