"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReferenceLineNonStyleArchive = exports.ReferenceLineStyleArchive = exports.GridRow = exports.GridValue = exports.ChartSeriesNonStyleArchive = exports.ChartSeriesStyleArchive = exports.ChartAxisNonStyleArchive = exports.ChartAxisStyleArchive = exports.LegendNonStyleArchive = exports.LegendStyleArchive = exports.ChartNonStyleArchive = exports.ChartStyleArchive = exports.DEPRECATEDChart3DFillArchive = exports.ChartsNSArrayOfNSNumberDoubleArchive = exports.ChartsNSNumberDoubleArchive = exports.RectArchive = exports.FractionAccuracy = exports.NegativeNumberStyle = exports.NumberValueType = exports.SeriesDirection = exports.ScatterFormat = exports.AxisType = exports.ChartType = void 0;
const runtime_1 = require("@protobuf-ts/runtime");
const runtime_2 = require("@protobuf-ts/runtime");
const runtime_3 = require("@protobuf-ts/runtime");
const runtime_4 = require("@protobuf-ts/runtime");
const runtime_5 = require("@protobuf-ts/runtime");
const TSSArchives_1 = require("./TSSArchives");
const TSCH3DArchives_1 = require("./TSCH3DArchives");
const TSCH3DArchives_2 = require("./TSCH3DArchives");
const TSDArchives_1 = require("./TSDArchives");
const TSPMessages_1 = require("./TSPMessages");
const TSPMessages_2 = require("./TSPMessages");
/**
 * @generated from protobuf enum TSCH.ChartType
 */
var ChartType;
(function (ChartType) {
    /**
     * @generated from protobuf enum value: undefinedChartType = 0;
     */
    ChartType[ChartType["undefinedChartType"] = 0] = "undefinedChartType";
    /**
     * @generated from protobuf enum value: columnChartType2D = 1;
     */
    ChartType[ChartType["columnChartType2D"] = 1] = "columnChartType2D";
    /**
     * @generated from protobuf enum value: barChartType2D = 2;
     */
    ChartType[ChartType["barChartType2D"] = 2] = "barChartType2D";
    /**
     * @generated from protobuf enum value: lineChartType2D = 3;
     */
    ChartType[ChartType["lineChartType2D"] = 3] = "lineChartType2D";
    /**
     * @generated from protobuf enum value: areaChartType2D = 4;
     */
    ChartType[ChartType["areaChartType2D"] = 4] = "areaChartType2D";
    /**
     * @generated from protobuf enum value: pieChartType2D = 5;
     */
    ChartType[ChartType["pieChartType2D"] = 5] = "pieChartType2D";
    /**
     * @generated from protobuf enum value: stackedColumnChartType2D = 6;
     */
    ChartType[ChartType["stackedColumnChartType2D"] = 6] = "stackedColumnChartType2D";
    /**
     * @generated from protobuf enum value: stackedBarChartType2D = 7;
     */
    ChartType[ChartType["stackedBarChartType2D"] = 7] = "stackedBarChartType2D";
    /**
     * @generated from protobuf enum value: stackedAreaChartType2D = 8;
     */
    ChartType[ChartType["stackedAreaChartType2D"] = 8] = "stackedAreaChartType2D";
    /**
     * @generated from protobuf enum value: scatterChartType2D = 9;
     */
    ChartType[ChartType["scatterChartType2D"] = 9] = "scatterChartType2D";
    /**
     * @generated from protobuf enum value: mixedChartType2D = 10;
     */
    ChartType[ChartType["mixedChartType2D"] = 10] = "mixedChartType2D";
    /**
     * @generated from protobuf enum value: twoAxisChartType2D = 11;
     */
    ChartType[ChartType["twoAxisChartType2D"] = 11] = "twoAxisChartType2D";
    /**
     * @generated from protobuf enum value: columnChartType3D = 12;
     */
    ChartType[ChartType["columnChartType3D"] = 12] = "columnChartType3D";
    /**
     * @generated from protobuf enum value: barChartType3D = 13;
     */
    ChartType[ChartType["barChartType3D"] = 13] = "barChartType3D";
    /**
     * @generated from protobuf enum value: lineChartType3D = 14;
     */
    ChartType[ChartType["lineChartType3D"] = 14] = "lineChartType3D";
    /**
     * @generated from protobuf enum value: areaChartType3D = 15;
     */
    ChartType[ChartType["areaChartType3D"] = 15] = "areaChartType3D";
    /**
     * @generated from protobuf enum value: pieChartType3D = 16;
     */
    ChartType[ChartType["pieChartType3D"] = 16] = "pieChartType3D";
    /**
     * @generated from protobuf enum value: stackedColumnChartType3D = 17;
     */
    ChartType[ChartType["stackedColumnChartType3D"] = 17] = "stackedColumnChartType3D";
    /**
     * @generated from protobuf enum value: stackedBarChartType3D = 18;
     */
    ChartType[ChartType["stackedBarChartType3D"] = 18] = "stackedBarChartType3D";
    /**
     * @generated from protobuf enum value: stackedAreaChartType3D = 19;
     */
    ChartType[ChartType["stackedAreaChartType3D"] = 19] = "stackedAreaChartType3D";
    /**
     * @generated from protobuf enum value: multiDataColumnChartType2D = 20;
     */
    ChartType[ChartType["multiDataColumnChartType2D"] = 20] = "multiDataColumnChartType2D";
    /**
     * @generated from protobuf enum value: multiDataBarChartType2D = 21;
     */
    ChartType[ChartType["multiDataBarChartType2D"] = 21] = "multiDataBarChartType2D";
    /**
     * @generated from protobuf enum value: bubbleChartType2D = 22;
     */
    ChartType[ChartType["bubbleChartType2D"] = 22] = "bubbleChartType2D";
    /**
     * @generated from protobuf enum value: multiDataScatterChartType2D = 23;
     */
    ChartType[ChartType["multiDataScatterChartType2D"] = 23] = "multiDataScatterChartType2D";
    /**
     * @generated from protobuf enum value: multiDataBubbleChartType2D = 24;
     */
    ChartType[ChartType["multiDataBubbleChartType2D"] = 24] = "multiDataBubbleChartType2D";
    /**
     * @generated from protobuf enum value: donutChartType2D = 25;
     */
    ChartType[ChartType["donutChartType2D"] = 25] = "donutChartType2D";
    /**
     * @generated from protobuf enum value: donutChartType3D = 26;
     */
    ChartType[ChartType["donutChartType3D"] = 26] = "donutChartType3D";
    /**
     * @generated from protobuf enum value: radarChartType2D = 27;
     */
    ChartType[ChartType["radarChartType2D"] = 27] = "radarChartType2D";
})(ChartType = exports.ChartType || (exports.ChartType = {}));
/**
 * @generated from protobuf enum TSCH.AxisType
 */
var AxisType;
(function (AxisType) {
    /**
     * @generated from protobuf enum value: axis_type_unknown = 0;
     */
    AxisType[AxisType["axis_type_unknown"] = 0] = "axis_type_unknown";
    /**
     * @generated from protobuf enum value: axis_type_x = 1;
     */
    AxisType[AxisType["axis_type_x"] = 1] = "axis_type_x";
    /**
     * @generated from protobuf enum value: axis_type_y = 2;
     */
    AxisType[AxisType["axis_type_y"] = 2] = "axis_type_y";
    /**
     * @generated from protobuf enum value: axis_type_pie = 3;
     */
    AxisType[AxisType["axis_type_pie"] = 3] = "axis_type_pie";
    /**
     * @generated from protobuf enum value: axis_type_size = 4;
     */
    AxisType[AxisType["axis_type_size"] = 4] = "axis_type_size";
    /**
     * @generated from protobuf enum value: axis_type_polar_radius = 5;
     */
    AxisType[AxisType["axis_type_polar_radius"] = 5] = "axis_type_polar_radius";
    /**
     * @generated from protobuf enum value: axis_type_polar_angle = 6;
     */
    AxisType[AxisType["axis_type_polar_angle"] = 6] = "axis_type_polar_angle";
})(AxisType = exports.AxisType || (exports.AxisType = {}));
/**
 * @generated from protobuf enum TSCH.ScatterFormat
 */
var ScatterFormat;
(function (ScatterFormat) {
    /**
     * @generated from protobuf enum value: scatter_format_unknown = 0;
     */
    ScatterFormat[ScatterFormat["scatter_format_unknown"] = 0] = "scatter_format_unknown";
    /**
     * @generated from protobuf enum value: scatter_format_separate_x = 1;
     */
    ScatterFormat[ScatterFormat["scatter_format_separate_x"] = 1] = "scatter_format_separate_x";
    /**
     * @generated from protobuf enum value: scatter_format_shared_x = 2;
     */
    ScatterFormat[ScatterFormat["scatter_format_shared_x"] = 2] = "scatter_format_shared_x";
})(ScatterFormat = exports.ScatterFormat || (exports.ScatterFormat = {}));
/**
 * @generated from protobuf enum TSCH.SeriesDirection
 */
var SeriesDirection;
(function (SeriesDirection) {
    /**
     * @generated from protobuf enum value: series_direction_unknown = 0;
     */
    SeriesDirection[SeriesDirection["series_direction_unknown"] = 0] = "series_direction_unknown";
    /**
     * @generated from protobuf enum value: series_direction_by_row = 1;
     */
    SeriesDirection[SeriesDirection["series_direction_by_row"] = 1] = "series_direction_by_row";
    /**
     * @generated from protobuf enum value: series_direction_by_column = 2;
     */
    SeriesDirection[SeriesDirection["series_direction_by_column"] = 2] = "series_direction_by_column";
})(SeriesDirection = exports.SeriesDirection || (exports.SeriesDirection = {}));
/**
 * @generated from protobuf enum TSCH.NumberValueType
 */
var NumberValueType;
(function (NumberValueType) {
    /**
     * @generated from protobuf enum value: numberValueTypeDecimal = 0;
     */
    NumberValueType[NumberValueType["numberValueTypeDecimal"] = 0] = "numberValueTypeDecimal";
    /**
     * @generated from protobuf enum value: numberValueTypeCurrency = 1;
     */
    NumberValueType[NumberValueType["numberValueTypeCurrency"] = 1] = "numberValueTypeCurrency";
    /**
     * @generated from protobuf enum value: numberValueTypePercentage = 2;
     */
    NumberValueType[NumberValueType["numberValueTypePercentage"] = 2] = "numberValueTypePercentage";
    /**
     * @generated from protobuf enum value: numberValueTypeScientific = 3;
     */
    NumberValueType[NumberValueType["numberValueTypeScientific"] = 3] = "numberValueTypeScientific";
    /**
     * @generated from protobuf enum value: numberValueTypeFraction = 4;
     */
    NumberValueType[NumberValueType["numberValueTypeFraction"] = 4] = "numberValueTypeFraction";
    /**
     * @generated from protobuf enum value: numberValueTypeBase = 5;
     */
    NumberValueType[NumberValueType["numberValueTypeBase"] = 5] = "numberValueTypeBase";
    /**
     * @generated from protobuf enum value: numberValueTypeUnknown = -999;
     */
    NumberValueType[NumberValueType["numberValueTypeUnknown"] = -999] = "numberValueTypeUnknown";
})(NumberValueType = exports.NumberValueType || (exports.NumberValueType = {}));
/**
 * @generated from protobuf enum TSCH.NegativeNumberStyle
 */
var NegativeNumberStyle;
(function (NegativeNumberStyle) {
    /**
     * @generated from protobuf enum value: negativeNumberStyleMinus = 0;
     */
    NegativeNumberStyle[NegativeNumberStyle["negativeNumberStyleMinus"] = 0] = "negativeNumberStyleMinus";
    /**
     * @generated from protobuf enum value: negativeNumberStyleRed = 1;
     */
    NegativeNumberStyle[NegativeNumberStyle["negativeNumberStyleRed"] = 1] = "negativeNumberStyleRed";
    /**
     * @generated from protobuf enum value: negativeNumberStyleParentheses = 2;
     */
    NegativeNumberStyle[NegativeNumberStyle["negativeNumberStyleParentheses"] = 2] = "negativeNumberStyleParentheses";
    /**
     * @generated from protobuf enum value: negativeNumberStyleRedAndParentheses = 3;
     */
    NegativeNumberStyle[NegativeNumberStyle["negativeNumberStyleRedAndParentheses"] = 3] = "negativeNumberStyleRedAndParentheses";
    /**
     * @generated from protobuf enum value: negativeNumberStyleNone = 4;
     */
    NegativeNumberStyle[NegativeNumberStyle["negativeNumberStyleNone"] = 4] = "negativeNumberStyleNone";
})(NegativeNumberStyle = exports.NegativeNumberStyle || (exports.NegativeNumberStyle = {}));
/**
 * @generated from protobuf enum TSCH.FractionAccuracy
 */
var FractionAccuracy;
(function (FractionAccuracy) {
    /**
     * @generated from protobuf enum value: fractionAccuracyConflicting = 0;
     */
    FractionAccuracy[FractionAccuracy["fractionAccuracyConflicting"] = 0] = "fractionAccuracyConflicting";
    /**
     * @generated from protobuf enum value: fractionAccuracyUpToOneDigit = -1;
     */
    FractionAccuracy[FractionAccuracy["fractionAccuracyUpToOneDigit"] = -1] = "fractionAccuracyUpToOneDigit";
    /**
     * @generated from protobuf enum value: fractionAccuracyUpToTwoDigits = -2;
     */
    FractionAccuracy[FractionAccuracy["fractionAccuracyUpToTwoDigits"] = -2] = "fractionAccuracyUpToTwoDigits";
    /**
     * @generated from protobuf enum value: fractionAccuracyUpToThreeDigits = -3;
     */
    FractionAccuracy[FractionAccuracy["fractionAccuracyUpToThreeDigits"] = -3] = "fractionAccuracyUpToThreeDigits";
    /**
     * @generated from protobuf enum value: fractionAccuracyHalves = 2;
     */
    FractionAccuracy[FractionAccuracy["fractionAccuracyHalves"] = 2] = "fractionAccuracyHalves";
    /**
     * @generated from protobuf enum value: fractionAccuracyQuarters = 4;
     */
    FractionAccuracy[FractionAccuracy["fractionAccuracyQuarters"] = 4] = "fractionAccuracyQuarters";
    /**
     * @generated from protobuf enum value: fractionAccuracyEighths = 8;
     */
    FractionAccuracy[FractionAccuracy["fractionAccuracyEighths"] = 8] = "fractionAccuracyEighths";
    /**
     * @generated from protobuf enum value: fractionAccuracySixteenths = 16;
     */
    FractionAccuracy[FractionAccuracy["fractionAccuracySixteenths"] = 16] = "fractionAccuracySixteenths";
    /**
     * @generated from protobuf enum value: fractionAccuracyTenths = 10;
     */
    FractionAccuracy[FractionAccuracy["fractionAccuracyTenths"] = 10] = "fractionAccuracyTenths";
    /**
     * @generated from protobuf enum value: fractionAccuracyHundredths = 100;
     */
    FractionAccuracy[FractionAccuracy["fractionAccuracyHundredths"] = 100] = "fractionAccuracyHundredths";
})(FractionAccuracy = exports.FractionAccuracy || (exports.FractionAccuracy = {}));
// @generated message type with reflection information, may provide speed optimized methods
class RectArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCH.RectArchive", [
            { no: 1, name: "origin", kind: "message", T: () => TSPMessages_2.Point },
            { no: 2, name: "size", kind: "message", T: () => TSPMessages_1.Size }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.Point origin */ 1:
                    message.origin = TSPMessages_2.Point.internalBinaryRead(reader, reader.uint32(), options, message.origin);
                    break;
                case /* TSP.Size size */ 2:
                    message.size = TSPMessages_1.Size.internalBinaryRead(reader, reader.uint32(), options, message.size);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.Point origin = 1; */
        if (message.origin)
            TSPMessages_2.Point.internalBinaryWrite(message.origin, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Size size = 2; */
        if (message.size)
            TSPMessages_1.Size.internalBinaryWrite(message.size, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCH.RectArchive
 */
exports.RectArchive = new RectArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChartsNSNumberDoubleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCH.ChartsNSNumberDoubleArchive", [
            { no: 1, name: "number_archive", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double number_archive */ 1:
                    message.numberArchive = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional double number_archive = 1; */
        if (message.numberArchive !== undefined)
            writer.tag(1, runtime_1.WireType.Bit64).double(message.numberArchive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCH.ChartsNSNumberDoubleArchive
 */
exports.ChartsNSNumberDoubleArchive = new ChartsNSNumberDoubleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChartsNSArrayOfNSNumberDoubleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCH.ChartsNSArrayOfNSNumberDoubleArchive", [
            { no: 1, name: "numbers", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value) {
        const message = { numbers: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated double numbers */ 1:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.numbers.push(reader.double());
                    else
                        message.numbers.push(reader.double());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated double numbers = 1; */
        for (let i = 0; i < message.numbers.length; i++)
            writer.tag(1, runtime_1.WireType.Bit64).double(message.numbers[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCH.ChartsNSArrayOfNSNumberDoubleArchive
 */
exports.ChartsNSArrayOfNSNumberDoubleArchive = new ChartsNSArrayOfNSNumberDoubleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DEPRECATEDChart3DFillArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCH.DEPRECATEDChart3DFillArchive", [
            { no: 1, name: "fill", kind: "message", T: () => TSDArchives_1.FillArchive },
            { no: 2, name: "lightingmodel", kind: "message", T: () => TSCH3DArchives_2.Chart3DLightingModelArchive },
            { no: 3, name: "textureset_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "fill_type", kind: "enum", opt: true, T: () => ["TSCH.FillPropertyType", TSCH3DArchives_1.FillPropertyType] },
            { no: 5, name: "series_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSD.FillArchive fill */ 1:
                    message.fill = TSDArchives_1.FillArchive.internalBinaryRead(reader, reader.uint32(), options, message.fill);
                    break;
                case /* optional TSCH.Chart3DLightingModelArchive lightingmodel */ 2:
                    message.lightingmodel = TSCH3DArchives_2.Chart3DLightingModelArchive.internalBinaryRead(reader, reader.uint32(), options, message.lightingmodel);
                    break;
                case /* optional string textureset_id */ 3:
                    message.texturesetId = reader.string();
                    break;
                case /* optional TSCH.FillPropertyType fill_type */ 4:
                    message.fillType = reader.int32();
                    break;
                case /* optional uint32 series_index */ 5:
                    message.seriesIndex = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSD.FillArchive fill = 1; */
        if (message.fill)
            TSDArchives_1.FillArchive.internalBinaryWrite(message.fill, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCH.Chart3DLightingModelArchive lightingmodel = 2; */
        if (message.lightingmodel)
            TSCH3DArchives_2.Chart3DLightingModelArchive.internalBinaryWrite(message.lightingmodel, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string textureset_id = 3; */
        if (message.texturesetId !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.texturesetId);
        /* optional TSCH.FillPropertyType fill_type = 4; */
        if (message.fillType !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).int32(message.fillType);
        /* optional uint32 series_index = 5; */
        if (message.seriesIndex !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.seriesIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCH.DEPRECATEDChart3DFillArchive
 */
exports.DEPRECATEDChart3DFillArchive = new DEPRECATEDChart3DFillArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChartStyleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCH.ChartStyleArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSSArchives_1.StyleArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSS.StyleArchive super */ 1:
                    message.super = TSSArchives_1.StyleArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSS.StyleArchive super = 1; */
        if (message.super)
            TSSArchives_1.StyleArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCH.ChartStyleArchive
 */
exports.ChartStyleArchive = new ChartStyleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChartNonStyleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCH.ChartNonStyleArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSSArchives_1.StyleArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSS.StyleArchive super */ 1:
                    message.super = TSSArchives_1.StyleArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSS.StyleArchive super = 1; */
        if (message.super)
            TSSArchives_1.StyleArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCH.ChartNonStyleArchive
 */
exports.ChartNonStyleArchive = new ChartNonStyleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LegendStyleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCH.LegendStyleArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSSArchives_1.StyleArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSS.StyleArchive super */ 1:
                    message.super = TSSArchives_1.StyleArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSS.StyleArchive super = 1; */
        if (message.super)
            TSSArchives_1.StyleArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCH.LegendStyleArchive
 */
exports.LegendStyleArchive = new LegendStyleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LegendNonStyleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCH.LegendNonStyleArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSSArchives_1.StyleArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSS.StyleArchive super */ 1:
                    message.super = TSSArchives_1.StyleArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSS.StyleArchive super = 1; */
        if (message.super)
            TSSArchives_1.StyleArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCH.LegendNonStyleArchive
 */
exports.LegendNonStyleArchive = new LegendNonStyleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChartAxisStyleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCH.ChartAxisStyleArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSSArchives_1.StyleArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSS.StyleArchive super */ 1:
                    message.super = TSSArchives_1.StyleArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSS.StyleArchive super = 1; */
        if (message.super)
            TSSArchives_1.StyleArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCH.ChartAxisStyleArchive
 */
exports.ChartAxisStyleArchive = new ChartAxisStyleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChartAxisNonStyleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCH.ChartAxisNonStyleArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSSArchives_1.StyleArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSS.StyleArchive super */ 1:
                    message.super = TSSArchives_1.StyleArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSS.StyleArchive super = 1; */
        if (message.super)
            TSSArchives_1.StyleArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCH.ChartAxisNonStyleArchive
 */
exports.ChartAxisNonStyleArchive = new ChartAxisNonStyleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChartSeriesStyleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCH.ChartSeriesStyleArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSSArchives_1.StyleArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSS.StyleArchive super */ 1:
                    message.super = TSSArchives_1.StyleArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSS.StyleArchive super = 1; */
        if (message.super)
            TSSArchives_1.StyleArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCH.ChartSeriesStyleArchive
 */
exports.ChartSeriesStyleArchive = new ChartSeriesStyleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChartSeriesNonStyleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCH.ChartSeriesNonStyleArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSSArchives_1.StyleArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSS.StyleArchive super */ 1:
                    message.super = TSSArchives_1.StyleArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSS.StyleArchive super = 1; */
        if (message.super)
            TSSArchives_1.StyleArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCH.ChartSeriesNonStyleArchive
 */
exports.ChartSeriesNonStyleArchive = new ChartSeriesNonStyleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GridValue$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCH.GridValue", [
            { no: 1, name: "numeric_value", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "date_value_1_0", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "duration_value", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "date_value", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double numeric_value */ 1:
                    message.numericValue = reader.double();
                    break;
                case /* optional double date_value_1_0 */ 2:
                    message.dateValue10 = reader.double();
                    break;
                case /* optional double duration_value */ 3:
                    message.durationValue = reader.double();
                    break;
                case /* optional double date_value */ 4:
                    message.dateValue = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional double numeric_value = 1; */
        if (message.numericValue !== undefined)
            writer.tag(1, runtime_1.WireType.Bit64).double(message.numericValue);
        /* optional double date_value_1_0 = 2; */
        if (message.dateValue10 !== undefined)
            writer.tag(2, runtime_1.WireType.Bit64).double(message.dateValue10);
        /* optional double duration_value = 3; */
        if (message.durationValue !== undefined)
            writer.tag(3, runtime_1.WireType.Bit64).double(message.durationValue);
        /* optional double date_value = 4; */
        if (message.dateValue !== undefined)
            writer.tag(4, runtime_1.WireType.Bit64).double(message.dateValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCH.GridValue
 */
exports.GridValue = new GridValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GridRow$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCH.GridRow", [
            { no: 1, name: "value", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.GridValue }
        ]);
    }
    create(value) {
        const message = { value: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSCH.GridValue value */ 1:
                    message.value.push(exports.GridValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSCH.GridValue value = 1; */
        for (let i = 0; i < message.value.length; i++)
            exports.GridValue.internalBinaryWrite(message.value[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCH.GridRow
 */
exports.GridRow = new GridRow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReferenceLineStyleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCH.ReferenceLineStyleArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSSArchives_1.StyleArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSS.StyleArchive super */ 1:
                    message.super = TSSArchives_1.StyleArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSS.StyleArchive super = 1; */
        if (message.super)
            TSSArchives_1.StyleArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCH.ReferenceLineStyleArchive
 */
exports.ReferenceLineStyleArchive = new ReferenceLineStyleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReferenceLineNonStyleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSCH.ReferenceLineNonStyleArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSSArchives_1.StyleArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSS.StyleArchive super */ 1:
                    message.super = TSSArchives_1.StyleArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSS.StyleArchive super = 1; */
        if (message.super)
            TSSArchives_1.StyleArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSCH.ReferenceLineNonStyleArchive
 */
exports.ReferenceLineNonStyleArchive = new ReferenceLineNonStyleArchive$Type();
//# sourceMappingURL=TSCHArchives_Common.js.map