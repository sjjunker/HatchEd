"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DrawableArchive = exports.ThemeReplaceFillPresetCommandArchive = exports.ThemePresetsArchive = exports.MediaStyleArchive = exports.MediaStylePropertiesArchive = exports.ShapeStyleArchive = exports.ShapeStylePropertiesArchive = exports.ImageAdjustmentsArchive = exports.ReflectionArchive = exports.CurvedShadowArchive = exports.ContactShadowArchive = exports.DropShadowArchive = exports.ShadowArchive = exports.LineEndArchive = exports.PatternedStrokeArchive = exports.FrameArchive = exports.SmartStrokeArchive = exports.StrokeArchive = exports.StrokePatternArchive = exports.FillArchive = exports.ImageFillArchive = exports.GradientArchive_GradientStop = exports.GradientArchive = exports.TransformGradientArchive = exports.AngleGradientArchive = exports.PathSourceArchive = exports.EditableBezierPathSourceArchive_Subpath = exports.EditableBezierPathSourceArchive_Node = exports.EditableBezierPathSourceArchive = exports.ConnectionLinePathSourceArchive = exports.CalloutPathSourceArchive = exports.BezierPathSourceArchive = exports.ScalarPathSourceArchive = exports.PointPathSourceArchive = exports.GeometryArchive = exports.EdgeInsetsArchive = exports.LineJoin = exports.UserDefinedGuideArchive_GuideType = exports.GuideArchive_GuideType = exports.FreehandDrawingToolkitUIState_FreehandDrawingToolType = exports.MovieArchive_MovieLoopOption = exports.ShadowArchive_ShadowType = exports.StrokeArchive_LineCap = exports.StrokePatternArchive_StrokePatternType = exports.ImageFillArchive_ImageFillTechnique = exports.GradientArchive_GradientType = exports.EditableBezierPathSourceArchive_NodeType = exports.ConnectionLinePathSourceArchive_ConnectionLinePathSourceType = exports.ScalarPathSourceArchive_ScalarPathSourceType = exports.PointPathSourceArchive_PointPathSourceType = void 0;
exports.MovieFingerprintTrack = exports.MovieFingerprint = exports.Attribution = exports.SpecStrokeSetWidthArchive = exports.SpecStrokeSetPatternArchive = exports.SpecStrokeSetColorArchive = exports.SpecShadowSetRadiusArchive = exports.SpecShadowSetOpacityArchive = exports.SpecShadowSetOffsetArchive = exports.SpecShadowSetColorArchive = exports.SpecShadowSetAngleArchive = exports.SpecReflectionSetOpacityArchive = exports.SpecImageFillSetTechniqueArchive = exports.SpecGradientFillSetAngleArchive = exports.SpecFrameSetAssetScaleArchive = exports.SpecColorFillSetColorArchive = exports.PencilAnnotationStorageArchive = exports.PencilAnnotationSelectionArchive = exports.PencilAnnotationArchive = exports.ReplaceAnnotationAuthorCommandArchive = exports.CommentStorageArchive = exports.InfoHyperlinkSelectionArchive = exports.PathSelectionArchive = exports.GroupSelectionArchive = exports.DrawableSelectionArchive = exports.CanvasSelectionArchive = exports.GuideStorageArchive = exports.UserDefinedGuideArchive = exports.GuideArchive = exports.StandinCaptionArchive = exports.FreehandDrawingToolkitUIState = exports.FreehandDrawingContentDescription = exports.DrawableContentDescription = exports.ExteriorTextWrapArchive = exports.MovieArchive = exports.ImageDataAttributes = exports.MaskArchive = exports.ImageArchive = exports.ConnectionLineArchive = exports.ShapeArchive = exports.FreehandDrawingArchive = exports.FreehandDrawingAnimationArchive = exports.GroupArchive = exports.ContainerArchive = void 0;
const runtime_1 = require("@protobuf-ts/runtime");
const runtime_2 = require("@protobuf-ts/runtime");
const runtime_3 = require("@protobuf-ts/runtime");
const runtime_4 = require("@protobuf-ts/runtime");
const runtime_5 = require("@protobuf-ts/runtime");
const TSPMessages_1 = require("./TSPMessages");
const TSPMessages_2 = require("./TSPMessages");
const TSKArchives_1 = require("./TSKArchives");
const TSSArchives_1 = require("./TSSArchives");
const TSPMessages_3 = require("./TSPMessages");
const TSPMessages_4 = require("./TSPMessages");
const TSPMessages_5 = require("./TSPMessages");
const TSPMessages_6 = require("./TSPMessages");
const TSPMessages_7 = require("./TSPMessages");
const TSPMessages_8 = require("./TSPMessages");
const TSPMessages_9 = require("./TSPMessages");
/**
 * @generated from protobuf enum TSD.PointPathSourceArchive.PointPathSourceType
 */
var PointPathSourceArchive_PointPathSourceType;
(function (PointPathSourceArchive_PointPathSourceType) {
    /**
     * @generated from protobuf enum value: kTSDLeftSingleArrow = 0;
     */
    PointPathSourceArchive_PointPathSourceType[PointPathSourceArchive_PointPathSourceType["kTSDLeftSingleArrow"] = 0] = "kTSDLeftSingleArrow";
    /**
     * @generated from protobuf enum value: kTSDRightSingleArrow = 1;
     */
    PointPathSourceArchive_PointPathSourceType[PointPathSourceArchive_PointPathSourceType["kTSDRightSingleArrow"] = 1] = "kTSDRightSingleArrow";
    /**
     * @generated from protobuf enum value: kTSDDoubleArrow = 10;
     */
    PointPathSourceArchive_PointPathSourceType[PointPathSourceArchive_PointPathSourceType["kTSDDoubleArrow"] = 10] = "kTSDDoubleArrow";
    /**
     * @generated from protobuf enum value: kTSDStar = 100;
     */
    PointPathSourceArchive_PointPathSourceType[PointPathSourceArchive_PointPathSourceType["kTSDStar"] = 100] = "kTSDStar";
    /**
     * @generated from protobuf enum value: kTSDPlus = 200;
     */
    PointPathSourceArchive_PointPathSourceType[PointPathSourceArchive_PointPathSourceType["kTSDPlus"] = 200] = "kTSDPlus";
})(PointPathSourceArchive_PointPathSourceType = exports.PointPathSourceArchive_PointPathSourceType || (exports.PointPathSourceArchive_PointPathSourceType = {}));
/**
 * @generated from protobuf enum TSD.ScalarPathSourceArchive.ScalarPathSourceType
 */
var ScalarPathSourceArchive_ScalarPathSourceType;
(function (ScalarPathSourceArchive_ScalarPathSourceType) {
    /**
     * @generated from protobuf enum value: kTSDRoundedRectangle = 0;
     */
    ScalarPathSourceArchive_ScalarPathSourceType[ScalarPathSourceArchive_ScalarPathSourceType["kTSDRoundedRectangle"] = 0] = "kTSDRoundedRectangle";
    /**
     * @generated from protobuf enum value: kTSDRegularPolygon = 1;
     */
    ScalarPathSourceArchive_ScalarPathSourceType[ScalarPathSourceArchive_ScalarPathSourceType["kTSDRegularPolygon"] = 1] = "kTSDRegularPolygon";
    /**
     * @generated from protobuf enum value: kTSDChevron = 2;
     */
    ScalarPathSourceArchive_ScalarPathSourceType[ScalarPathSourceArchive_ScalarPathSourceType["kTSDChevron"] = 2] = "kTSDChevron";
})(ScalarPathSourceArchive_ScalarPathSourceType = exports.ScalarPathSourceArchive_ScalarPathSourceType || (exports.ScalarPathSourceArchive_ScalarPathSourceType = {}));
/**
 * @generated from protobuf enum TSD.ConnectionLinePathSourceArchive.ConnectionLinePathSourceType
 */
var ConnectionLinePathSourceArchive_ConnectionLinePathSourceType;
(function (ConnectionLinePathSourceArchive_ConnectionLinePathSourceType) {
    /**
     * @generated from protobuf enum value: kTSDConnectionLineTypeQuadratic = 0;
     */
    ConnectionLinePathSourceArchive_ConnectionLinePathSourceType[ConnectionLinePathSourceArchive_ConnectionLinePathSourceType["kTSDConnectionLineTypeQuadratic"] = 0] = "kTSDConnectionLineTypeQuadratic";
    /**
     * @generated from protobuf enum value: kTSDConnectionLineTypeOrthogonal = 1;
     */
    ConnectionLinePathSourceArchive_ConnectionLinePathSourceType[ConnectionLinePathSourceArchive_ConnectionLinePathSourceType["kTSDConnectionLineTypeOrthogonal"] = 1] = "kTSDConnectionLineTypeOrthogonal";
})(ConnectionLinePathSourceArchive_ConnectionLinePathSourceType = exports.ConnectionLinePathSourceArchive_ConnectionLinePathSourceType || (exports.ConnectionLinePathSourceArchive_ConnectionLinePathSourceType = {}));
/**
 * @generated from protobuf enum TSD.EditableBezierPathSourceArchive.NodeType
 */
var EditableBezierPathSourceArchive_NodeType;
(function (EditableBezierPathSourceArchive_NodeType) {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    EditableBezierPathSourceArchive_NodeType[EditableBezierPathSourceArchive_NodeType["UNSPECIFIED$"] = 0] = "UNSPECIFIED$";
    /**
     * @generated from protobuf enum value: sharp = 1;
     */
    EditableBezierPathSourceArchive_NodeType[EditableBezierPathSourceArchive_NodeType["sharp"] = 1] = "sharp";
    /**
     * @generated from protobuf enum value: bezier = 2;
     */
    EditableBezierPathSourceArchive_NodeType[EditableBezierPathSourceArchive_NodeType["bezier"] = 2] = "bezier";
    /**
     * @generated from protobuf enum value: smooth = 3;
     */
    EditableBezierPathSourceArchive_NodeType[EditableBezierPathSourceArchive_NodeType["smooth"] = 3] = "smooth";
})(EditableBezierPathSourceArchive_NodeType = exports.EditableBezierPathSourceArchive_NodeType || (exports.EditableBezierPathSourceArchive_NodeType = {}));
/**
 * @generated from protobuf enum TSD.GradientArchive.GradientType
 */
var GradientArchive_GradientType;
(function (GradientArchive_GradientType) {
    /**
     * @generated from protobuf enum value: Linear = 0;
     */
    GradientArchive_GradientType[GradientArchive_GradientType["Linear"] = 0] = "Linear";
    /**
     * @generated from protobuf enum value: Radial = 1;
     */
    GradientArchive_GradientType[GradientArchive_GradientType["Radial"] = 1] = "Radial";
})(GradientArchive_GradientType = exports.GradientArchive_GradientType || (exports.GradientArchive_GradientType = {}));
/**
 * @generated from protobuf enum TSD.ImageFillArchive.ImageFillTechnique
 */
var ImageFillArchive_ImageFillTechnique;
(function (ImageFillArchive_ImageFillTechnique) {
    /**
     * @generated from protobuf enum value: NaturalSize = 0;
     */
    ImageFillArchive_ImageFillTechnique[ImageFillArchive_ImageFillTechnique["NaturalSize"] = 0] = "NaturalSize";
    /**
     * @generated from protobuf enum value: Stretch = 1;
     */
    ImageFillArchive_ImageFillTechnique[ImageFillArchive_ImageFillTechnique["Stretch"] = 1] = "Stretch";
    /**
     * @generated from protobuf enum value: Tile = 2;
     */
    ImageFillArchive_ImageFillTechnique[ImageFillArchive_ImageFillTechnique["Tile"] = 2] = "Tile";
    /**
     * @generated from protobuf enum value: ScaleToFill = 3;
     */
    ImageFillArchive_ImageFillTechnique[ImageFillArchive_ImageFillTechnique["ScaleToFill"] = 3] = "ScaleToFill";
    /**
     * @generated from protobuf enum value: ScaleToFit = 4;
     */
    ImageFillArchive_ImageFillTechnique[ImageFillArchive_ImageFillTechnique["ScaleToFit"] = 4] = "ScaleToFit";
})(ImageFillArchive_ImageFillTechnique = exports.ImageFillArchive_ImageFillTechnique || (exports.ImageFillArchive_ImageFillTechnique = {}));
/**
 * @generated from protobuf enum TSD.StrokePatternArchive.StrokePatternType
 */
var StrokePatternArchive_StrokePatternType;
(function (StrokePatternArchive_StrokePatternType) {
    /**
     * @generated from protobuf enum value: TSDPattern = 0;
     */
    StrokePatternArchive_StrokePatternType[StrokePatternArchive_StrokePatternType["TSDPattern"] = 0] = "TSDPattern";
    /**
     * @generated from protobuf enum value: TSDSolidPattern = 1;
     */
    StrokePatternArchive_StrokePatternType[StrokePatternArchive_StrokePatternType["TSDSolidPattern"] = 1] = "TSDSolidPattern";
    /**
     * @generated from protobuf enum value: TSDEmptyPattern = 2;
     */
    StrokePatternArchive_StrokePatternType[StrokePatternArchive_StrokePatternType["TSDEmptyPattern"] = 2] = "TSDEmptyPattern";
})(StrokePatternArchive_StrokePatternType = exports.StrokePatternArchive_StrokePatternType || (exports.StrokePatternArchive_StrokePatternType = {}));
/**
 * @generated from protobuf enum TSD.StrokeArchive.LineCap
 */
var StrokeArchive_LineCap;
(function (StrokeArchive_LineCap) {
    /**
     * @generated from protobuf enum value: ButtCap = 0;
     */
    StrokeArchive_LineCap[StrokeArchive_LineCap["ButtCap"] = 0] = "ButtCap";
    /**
     * @generated from protobuf enum value: RoundCap = 1;
     */
    StrokeArchive_LineCap[StrokeArchive_LineCap["RoundCap"] = 1] = "RoundCap";
    /**
     * @generated from protobuf enum value: SquareCap = 2;
     */
    StrokeArchive_LineCap[StrokeArchive_LineCap["SquareCap"] = 2] = "SquareCap";
})(StrokeArchive_LineCap = exports.StrokeArchive_LineCap || (exports.StrokeArchive_LineCap = {}));
/**
 * @generated from protobuf enum TSD.ShadowArchive.ShadowType
 */
var ShadowArchive_ShadowType;
(function (ShadowArchive_ShadowType) {
    /**
     * @generated from protobuf enum value: TSDDropShadow = 0;
     */
    ShadowArchive_ShadowType[ShadowArchive_ShadowType["TSDDropShadow"] = 0] = "TSDDropShadow";
    /**
     * @generated from protobuf enum value: TSDContactShadow = 1;
     */
    ShadowArchive_ShadowType[ShadowArchive_ShadowType["TSDContactShadow"] = 1] = "TSDContactShadow";
    /**
     * @generated from protobuf enum value: TSDCurvedShadow = 2;
     */
    ShadowArchive_ShadowType[ShadowArchive_ShadowType["TSDCurvedShadow"] = 2] = "TSDCurvedShadow";
})(ShadowArchive_ShadowType = exports.ShadowArchive_ShadowType || (exports.ShadowArchive_ShadowType = {}));
/**
 * @generated from protobuf enum TSD.MovieArchive.MovieLoopOption
 */
var MovieArchive_MovieLoopOption;
(function (MovieArchive_MovieLoopOption) {
    /**
     * @generated from protobuf enum value: None = 0;
     */
    MovieArchive_MovieLoopOption[MovieArchive_MovieLoopOption["None"] = 0] = "None";
    /**
     * @generated from protobuf enum value: Repeat = 1;
     */
    MovieArchive_MovieLoopOption[MovieArchive_MovieLoopOption["Repeat"] = 1] = "Repeat";
    /**
     * @generated from protobuf enum value: BackAndForth = 2;
     */
    MovieArchive_MovieLoopOption[MovieArchive_MovieLoopOption["BackAndForth"] = 2] = "BackAndForth";
})(MovieArchive_MovieLoopOption = exports.MovieArchive_MovieLoopOption || (exports.MovieArchive_MovieLoopOption = {}));
/**
 * @generated from protobuf enum TSD.FreehandDrawingToolkitUIState.FreehandDrawingToolType
 */
var FreehandDrawingToolkitUIState_FreehandDrawingToolType;
(function (FreehandDrawingToolkitUIState_FreehandDrawingToolType) {
    /**
     * @generated from protobuf enum value: Pen = 0;
     */
    FreehandDrawingToolkitUIState_FreehandDrawingToolType[FreehandDrawingToolkitUIState_FreehandDrawingToolType["Pen"] = 0] = "Pen";
    /**
     * @generated from protobuf enum value: Pencil = 1;
     */
    FreehandDrawingToolkitUIState_FreehandDrawingToolType[FreehandDrawingToolkitUIState_FreehandDrawingToolType["Pencil"] = 1] = "Pencil";
    /**
     * @generated from protobuf enum value: Crayon = 2;
     */
    FreehandDrawingToolkitUIState_FreehandDrawingToolType[FreehandDrawingToolkitUIState_FreehandDrawingToolType["Crayon"] = 2] = "Crayon";
    /**
     * @generated from protobuf enum value: Fill = 3;
     */
    FreehandDrawingToolkitUIState_FreehandDrawingToolType[FreehandDrawingToolkitUIState_FreehandDrawingToolType["Fill"] = 3] = "Fill";
    /**
     * @generated from protobuf enum value: Eraser = 4;
     */
    FreehandDrawingToolkitUIState_FreehandDrawingToolType[FreehandDrawingToolkitUIState_FreehandDrawingToolType["Eraser"] = 4] = "Eraser";
    /**
     * @generated from protobuf enum value: MarqueeSelect = 5;
     */
    FreehandDrawingToolkitUIState_FreehandDrawingToolType[FreehandDrawingToolkitUIState_FreehandDrawingToolType["MarqueeSelect"] = 5] = "MarqueeSelect";
})(FreehandDrawingToolkitUIState_FreehandDrawingToolType = exports.FreehandDrawingToolkitUIState_FreehandDrawingToolType || (exports.FreehandDrawingToolkitUIState_FreehandDrawingToolType = {}));
/**
 * @generated from protobuf enum TSD.GuideArchive.GuideType
 */
var GuideArchive_GuideType;
(function (GuideArchive_GuideType) {
    /**
     * @generated from protobuf enum value: Horizontal = 0;
     */
    GuideArchive_GuideType[GuideArchive_GuideType["Horizontal"] = 0] = "Horizontal";
    /**
     * @generated from protobuf enum value: Vertical = 1;
     */
    GuideArchive_GuideType[GuideArchive_GuideType["Vertical"] = 1] = "Vertical";
})(GuideArchive_GuideType = exports.GuideArchive_GuideType || (exports.GuideArchive_GuideType = {}));
/**
 * @generated from protobuf enum TSD.UserDefinedGuideArchive.GuideType
 */
var UserDefinedGuideArchive_GuideType;
(function (UserDefinedGuideArchive_GuideType) {
    /**
     * @generated from protobuf enum value: Horizontal = 0;
     */
    UserDefinedGuideArchive_GuideType[UserDefinedGuideArchive_GuideType["Horizontal"] = 0] = "Horizontal";
    /**
     * @generated from protobuf enum value: Vertical = 1;
     */
    UserDefinedGuideArchive_GuideType[UserDefinedGuideArchive_GuideType["Vertical"] = 1] = "Vertical";
})(UserDefinedGuideArchive_GuideType = exports.UserDefinedGuideArchive_GuideType || (exports.UserDefinedGuideArchive_GuideType = {}));
/**
 * @generated from protobuf enum TSD.LineJoin
 */
var LineJoin;
(function (LineJoin) {
    /**
     * @generated from protobuf enum value: MiterJoin = 0;
     */
    LineJoin[LineJoin["MiterJoin"] = 0] = "MiterJoin";
    /**
     * @generated from protobuf enum value: RoundJoin = 1;
     */
    LineJoin[LineJoin["RoundJoin"] = 1] = "RoundJoin";
    /**
     * @generated from protobuf enum value: BevelJoin = 2;
     */
    LineJoin[LineJoin["BevelJoin"] = 2] = "BevelJoin";
})(LineJoin = exports.LineJoin || (exports.LineJoin = {}));
// @generated message type with reflection information, may provide speed optimized methods
class EdgeInsetsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.EdgeInsetsArchive", [
            { no: 1, name: "top", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "left", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "bottom", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "right", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value) {
        const message = { top: 0, left: 0, bottom: 0, right: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float top */ 1:
                    message.top = reader.float();
                    break;
                case /* float left */ 2:
                    message.left = reader.float();
                    break;
                case /* float bottom */ 3:
                    message.bottom = reader.float();
                    break;
                case /* float right */ 4:
                    message.right = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* float top = 1; */
        if (message.top !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).float(message.top);
        /* float left = 2; */
        if (message.left !== 0)
            writer.tag(2, runtime_1.WireType.Bit32).float(message.left);
        /* float bottom = 3; */
        if (message.bottom !== 0)
            writer.tag(3, runtime_1.WireType.Bit32).float(message.bottom);
        /* float right = 4; */
        if (message.right !== 0)
            writer.tag(4, runtime_1.WireType.Bit32).float(message.right);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.EdgeInsetsArchive
 */
exports.EdgeInsetsArchive = new EdgeInsetsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GeometryArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.GeometryArchive", [
            { no: 1, name: "position", kind: "message", T: () => TSPMessages_9.Point },
            { no: 2, name: "size", kind: "message", T: () => TSPMessages_8.Size },
            { no: 3, name: "flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "angle", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Point position */ 1:
                    message.position = TSPMessages_9.Point.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* optional TSP.Size size */ 2:
                    message.size = TSPMessages_8.Size.internalBinaryRead(reader, reader.uint32(), options, message.size);
                    break;
                case /* optional uint32 flags */ 3:
                    message.flags = reader.uint32();
                    break;
                case /* optional float angle */ 4:
                    message.angle = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Point position = 1; */
        if (message.position)
            TSPMessages_9.Point.internalBinaryWrite(message.position, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Size size = 2; */
        if (message.size)
            TSPMessages_8.Size.internalBinaryWrite(message.size, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 flags = 3; */
        if (message.flags !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.flags);
        /* optional float angle = 4; */
        if (message.angle !== undefined)
            writer.tag(4, runtime_1.WireType.Bit32).float(message.angle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.GeometryArchive
 */
exports.GeometryArchive = new GeometryArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointPathSourceArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.PointPathSourceArchive", [
            { no: 1, name: "type", kind: "enum", opt: true, T: () => ["TSD.PointPathSourceArchive.PointPathSourceType", PointPathSourceArchive_PointPathSourceType] },
            { no: 2, name: "point", kind: "message", T: () => TSPMessages_9.Point },
            { no: 3, name: "naturalSize", kind: "message", T: () => TSPMessages_8.Size }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSD.PointPathSourceArchive.PointPathSourceType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional TSP.Point point */ 2:
                    message.point = TSPMessages_9.Point.internalBinaryRead(reader, reader.uint32(), options, message.point);
                    break;
                case /* optional TSP.Size naturalSize */ 3:
                    message.naturalSize = TSPMessages_8.Size.internalBinaryRead(reader, reader.uint32(), options, message.naturalSize);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSD.PointPathSourceArchive.PointPathSourceType type = 1; */
        if (message.type !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.type);
        /* optional TSP.Point point = 2; */
        if (message.point)
            TSPMessages_9.Point.internalBinaryWrite(message.point, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Size naturalSize = 3; */
        if (message.naturalSize)
            TSPMessages_8.Size.internalBinaryWrite(message.naturalSize, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.PointPathSourceArchive
 */
exports.PointPathSourceArchive = new PointPathSourceArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScalarPathSourceArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ScalarPathSourceArchive", [
            { no: 1, name: "type", kind: "enum", opt: true, T: () => ["TSD.ScalarPathSourceArchive.ScalarPathSourceType", ScalarPathSourceArchive_ScalarPathSourceType] },
            { no: 2, name: "scalar", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "naturalSize", kind: "message", T: () => TSPMessages_8.Size },
            { no: 4, name: "is_curve_continuous", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSD.ScalarPathSourceArchive.ScalarPathSourceType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional float scalar */ 2:
                    message.scalar = reader.float();
                    break;
                case /* optional TSP.Size naturalSize */ 3:
                    message.naturalSize = TSPMessages_8.Size.internalBinaryRead(reader, reader.uint32(), options, message.naturalSize);
                    break;
                case /* optional bool is_curve_continuous */ 4:
                    message.isCurveContinuous = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSD.ScalarPathSourceArchive.ScalarPathSourceType type = 1; */
        if (message.type !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.type);
        /* optional float scalar = 2; */
        if (message.scalar !== undefined)
            writer.tag(2, runtime_1.WireType.Bit32).float(message.scalar);
        /* optional TSP.Size naturalSize = 3; */
        if (message.naturalSize)
            TSPMessages_8.Size.internalBinaryWrite(message.naturalSize, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_curve_continuous = 4; */
        if (message.isCurveContinuous !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.isCurveContinuous);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ScalarPathSourceArchive
 */
exports.ScalarPathSourceArchive = new ScalarPathSourceArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BezierPathSourceArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.BezierPathSourceArchive", [
            { no: 1, name: "path_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "naturalSize", kind: "message", T: () => TSPMessages_8.Size },
            { no: 3, name: "path", kind: "message", T: () => TSPMessages_7.Path }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string path_string = 1 [deprecated = true];*/ 1:
                    message.pathString = reader.string();
                    break;
                case /* optional TSP.Size naturalSize */ 2:
                    message.naturalSize = TSPMessages_8.Size.internalBinaryRead(reader, reader.uint32(), options, message.naturalSize);
                    break;
                case /* optional TSP.Path path */ 3:
                    message.path = TSPMessages_7.Path.internalBinaryRead(reader, reader.uint32(), options, message.path);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string path_string = 1 [deprecated = true]; */
        if (message.pathString !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.pathString);
        /* optional TSP.Size naturalSize = 2; */
        if (message.naturalSize)
            TSPMessages_8.Size.internalBinaryWrite(message.naturalSize, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Path path = 3; */
        if (message.path)
            TSPMessages_7.Path.internalBinaryWrite(message.path, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.BezierPathSourceArchive
 */
exports.BezierPathSourceArchive = new BezierPathSourceArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CalloutPathSourceArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.CalloutPathSourceArchive", [
            { no: 1, name: "natural_size", kind: "message", T: () => TSPMessages_8.Size },
            { no: 2, name: "tail_position", kind: "message", T: () => TSPMessages_9.Point },
            { no: 3, name: "tail_size", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "corner_radius", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "center_tail", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Size natural_size */ 1:
                    message.naturalSize = TSPMessages_8.Size.internalBinaryRead(reader, reader.uint32(), options, message.naturalSize);
                    break;
                case /* optional TSP.Point tail_position */ 2:
                    message.tailPosition = TSPMessages_9.Point.internalBinaryRead(reader, reader.uint32(), options, message.tailPosition);
                    break;
                case /* optional float tail_size */ 3:
                    message.tailSize = reader.float();
                    break;
                case /* optional float corner_radius */ 4:
                    message.cornerRadius = reader.float();
                    break;
                case /* optional bool center_tail */ 5:
                    message.centerTail = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Size natural_size = 1; */
        if (message.naturalSize)
            TSPMessages_8.Size.internalBinaryWrite(message.naturalSize, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Point tail_position = 2; */
        if (message.tailPosition)
            TSPMessages_9.Point.internalBinaryWrite(message.tailPosition, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional float tail_size = 3; */
        if (message.tailSize !== undefined)
            writer.tag(3, runtime_1.WireType.Bit32).float(message.tailSize);
        /* optional float corner_radius = 4; */
        if (message.cornerRadius !== undefined)
            writer.tag(4, runtime_1.WireType.Bit32).float(message.cornerRadius);
        /* optional bool center_tail = 5; */
        if (message.centerTail !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.centerTail);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.CalloutPathSourceArchive
 */
exports.CalloutPathSourceArchive = new CalloutPathSourceArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectionLinePathSourceArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ConnectionLinePathSourceArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.BezierPathSourceArchive },
            { no: 2, name: "type", kind: "enum", opt: true, T: () => ["TSD.ConnectionLinePathSourceArchive.ConnectionLinePathSourceType", ConnectionLinePathSourceArchive_ConnectionLinePathSourceType] },
            { no: 3, name: "outset_from", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "outset_to", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.BezierPathSourceArchive super */ 1:
                    message.super = exports.BezierPathSourceArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSD.ConnectionLinePathSourceArchive.ConnectionLinePathSourceType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* optional float outset_from */ 3:
                    message.outsetFrom = reader.float();
                    break;
                case /* optional float outset_to */ 4:
                    message.outsetTo = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.BezierPathSourceArchive super = 1; */
        if (message.super)
            exports.BezierPathSourceArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.ConnectionLinePathSourceArchive.ConnectionLinePathSourceType type = 2; */
        if (message.type !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.type);
        /* optional float outset_from = 3; */
        if (message.outsetFrom !== undefined)
            writer.tag(3, runtime_1.WireType.Bit32).float(message.outsetFrom);
        /* optional float outset_to = 4; */
        if (message.outsetTo !== undefined)
            writer.tag(4, runtime_1.WireType.Bit32).float(message.outsetTo);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ConnectionLinePathSourceArchive
 */
exports.ConnectionLinePathSourceArchive = new ConnectionLinePathSourceArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EditableBezierPathSourceArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.EditableBezierPathSourceArchive", [
            { no: 1, name: "subpaths", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.EditableBezierPathSourceArchive_Subpath },
            { no: 2, name: "naturalSize", kind: "message", T: () => TSPMessages_8.Size }
        ]);
    }
    create(value) {
        const message = { subpaths: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSD.EditableBezierPathSourceArchive.Subpath subpaths */ 1:
                    message.subpaths.push(exports.EditableBezierPathSourceArchive_Subpath.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Size naturalSize */ 2:
                    message.naturalSize = TSPMessages_8.Size.internalBinaryRead(reader, reader.uint32(), options, message.naturalSize);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSD.EditableBezierPathSourceArchive.Subpath subpaths = 1; */
        for (let i = 0; i < message.subpaths.length; i++)
            exports.EditableBezierPathSourceArchive_Subpath.internalBinaryWrite(message.subpaths[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Size naturalSize = 2; */
        if (message.naturalSize)
            TSPMessages_8.Size.internalBinaryWrite(message.naturalSize, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.EditableBezierPathSourceArchive
 */
exports.EditableBezierPathSourceArchive = new EditableBezierPathSourceArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EditableBezierPathSourceArchive_Node$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.EditableBezierPathSourceArchive.Node", [
            { no: 1, name: "inControlPoint", kind: "message", T: () => TSPMessages_9.Point },
            { no: 2, name: "nodePoint", kind: "message", T: () => TSPMessages_9.Point },
            { no: 3, name: "outControlPoint", kind: "message", T: () => TSPMessages_9.Point },
            { no: 4, name: "type", kind: "enum", T: () => ["TSD.EditableBezierPathSourceArchive.NodeType", EditableBezierPathSourceArchive_NodeType] }
        ]);
    }
    create(value) {
        const message = { type: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.Point inControlPoint */ 1:
                    message.inControlPoint = TSPMessages_9.Point.internalBinaryRead(reader, reader.uint32(), options, message.inControlPoint);
                    break;
                case /* TSP.Point nodePoint */ 2:
                    message.nodePoint = TSPMessages_9.Point.internalBinaryRead(reader, reader.uint32(), options, message.nodePoint);
                    break;
                case /* TSP.Point outControlPoint */ 3:
                    message.outControlPoint = TSPMessages_9.Point.internalBinaryRead(reader, reader.uint32(), options, message.outControlPoint);
                    break;
                case /* TSD.EditableBezierPathSourceArchive.NodeType type */ 4:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.Point inControlPoint = 1; */
        if (message.inControlPoint)
            TSPMessages_9.Point.internalBinaryWrite(message.inControlPoint, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Point nodePoint = 2; */
        if (message.nodePoint)
            TSPMessages_9.Point.internalBinaryWrite(message.nodePoint, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Point outControlPoint = 3; */
        if (message.outControlPoint)
            TSPMessages_9.Point.internalBinaryWrite(message.outControlPoint, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSD.EditableBezierPathSourceArchive.NodeType type = 4; */
        if (message.type !== 0)
            writer.tag(4, runtime_1.WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.EditableBezierPathSourceArchive.Node
 */
exports.EditableBezierPathSourceArchive_Node = new EditableBezierPathSourceArchive_Node$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EditableBezierPathSourceArchive_Subpath$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.EditableBezierPathSourceArchive.Subpath", [
            { no: 1, name: "nodes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.EditableBezierPathSourceArchive_Node },
            { no: 2, name: "closed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { nodes: [], closed: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSD.EditableBezierPathSourceArchive.Node nodes */ 1:
                    message.nodes.push(exports.EditableBezierPathSourceArchive_Node.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool closed */ 2:
                    message.closed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSD.EditableBezierPathSourceArchive.Node nodes = 1; */
        for (let i = 0; i < message.nodes.length; i++)
            exports.EditableBezierPathSourceArchive_Node.internalBinaryWrite(message.nodes[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool closed = 2; */
        if (message.closed !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.closed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.EditableBezierPathSourceArchive.Subpath
 */
exports.EditableBezierPathSourceArchive_Subpath = new EditableBezierPathSourceArchive_Subpath$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PathSourceArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.PathSourceArchive", [
            { no: 1, name: "horizontalFlip", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "verticalFlip", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "point_path_source", kind: "message", T: () => exports.PointPathSourceArchive },
            { no: 4, name: "scalar_path_source", kind: "message", T: () => exports.ScalarPathSourceArchive },
            { no: 5, name: "bezier_path_source", kind: "message", T: () => exports.BezierPathSourceArchive },
            { no: 6, name: "callout_path_source", kind: "message", T: () => exports.CalloutPathSourceArchive },
            { no: 7, name: "connection_line_path_source", kind: "message", T: () => exports.ConnectionLinePathSourceArchive },
            { no: 8, name: "editable_bezier_path_source", kind: "message", T: () => exports.EditableBezierPathSourceArchive },
            { no: 9, name: "localizationKey", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "userDefinedName", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool horizontalFlip */ 1:
                    message.horizontalFlip = reader.bool();
                    break;
                case /* optional bool verticalFlip */ 2:
                    message.verticalFlip = reader.bool();
                    break;
                case /* optional TSD.PointPathSourceArchive point_path_source */ 3:
                    message.pointPathSource = exports.PointPathSourceArchive.internalBinaryRead(reader, reader.uint32(), options, message.pointPathSource);
                    break;
                case /* optional TSD.ScalarPathSourceArchive scalar_path_source */ 4:
                    message.scalarPathSource = exports.ScalarPathSourceArchive.internalBinaryRead(reader, reader.uint32(), options, message.scalarPathSource);
                    break;
                case /* optional TSD.BezierPathSourceArchive bezier_path_source */ 5:
                    message.bezierPathSource = exports.BezierPathSourceArchive.internalBinaryRead(reader, reader.uint32(), options, message.bezierPathSource);
                    break;
                case /* optional TSD.CalloutPathSourceArchive callout_path_source */ 6:
                    message.calloutPathSource = exports.CalloutPathSourceArchive.internalBinaryRead(reader, reader.uint32(), options, message.calloutPathSource);
                    break;
                case /* optional TSD.ConnectionLinePathSourceArchive connection_line_path_source */ 7:
                    message.connectionLinePathSource = exports.ConnectionLinePathSourceArchive.internalBinaryRead(reader, reader.uint32(), options, message.connectionLinePathSource);
                    break;
                case /* optional TSD.EditableBezierPathSourceArchive editable_bezier_path_source */ 8:
                    message.editableBezierPathSource = exports.EditableBezierPathSourceArchive.internalBinaryRead(reader, reader.uint32(), options, message.editableBezierPathSource);
                    break;
                case /* optional string localizationKey */ 9:
                    message.localizationKey = reader.string();
                    break;
                case /* optional string userDefinedName */ 10:
                    message.userDefinedName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional bool horizontalFlip = 1; */
        if (message.horizontalFlip !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.horizontalFlip);
        /* optional bool verticalFlip = 2; */
        if (message.verticalFlip !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.verticalFlip);
        /* optional TSD.PointPathSourceArchive point_path_source = 3; */
        if (message.pointPathSource)
            exports.PointPathSourceArchive.internalBinaryWrite(message.pointPathSource, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.ScalarPathSourceArchive scalar_path_source = 4; */
        if (message.scalarPathSource)
            exports.ScalarPathSourceArchive.internalBinaryWrite(message.scalarPathSource, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.BezierPathSourceArchive bezier_path_source = 5; */
        if (message.bezierPathSource)
            exports.BezierPathSourceArchive.internalBinaryWrite(message.bezierPathSource, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.CalloutPathSourceArchive callout_path_source = 6; */
        if (message.calloutPathSource)
            exports.CalloutPathSourceArchive.internalBinaryWrite(message.calloutPathSource, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.ConnectionLinePathSourceArchive connection_line_path_source = 7; */
        if (message.connectionLinePathSource)
            exports.ConnectionLinePathSourceArchive.internalBinaryWrite(message.connectionLinePathSource, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.EditableBezierPathSourceArchive editable_bezier_path_source = 8; */
        if (message.editableBezierPathSource)
            exports.EditableBezierPathSourceArchive.internalBinaryWrite(message.editableBezierPathSource, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string localizationKey = 9; */
        if (message.localizationKey !== undefined)
            writer.tag(9, runtime_1.WireType.LengthDelimited).string(message.localizationKey);
        /* optional string userDefinedName = 10; */
        if (message.userDefinedName !== undefined)
            writer.tag(10, runtime_1.WireType.LengthDelimited).string(message.userDefinedName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.PathSourceArchive
 */
exports.PathSourceArchive = new PathSourceArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AngleGradientArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.AngleGradientArchive", [
            { no: 2, name: "gradientangle", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float gradientangle */ 2:
                    message.gradientangle = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional float gradientangle = 2; */
        if (message.gradientangle !== undefined)
            writer.tag(2, runtime_1.WireType.Bit32).float(message.gradientangle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.AngleGradientArchive
 */
exports.AngleGradientArchive = new AngleGradientArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransformGradientArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.TransformGradientArchive", [
            { no: 1, name: "start", kind: "message", T: () => TSPMessages_9.Point },
            { no: 2, name: "end", kind: "message", T: () => TSPMessages_9.Point },
            { no: 3, name: "baseNaturalSize", kind: "message", T: () => TSPMessages_8.Size }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Point start */ 1:
                    message.start = TSPMessages_9.Point.internalBinaryRead(reader, reader.uint32(), options, message.start);
                    break;
                case /* optional TSP.Point end */ 2:
                    message.end = TSPMessages_9.Point.internalBinaryRead(reader, reader.uint32(), options, message.end);
                    break;
                case /* optional TSP.Size baseNaturalSize */ 3:
                    message.baseNaturalSize = TSPMessages_8.Size.internalBinaryRead(reader, reader.uint32(), options, message.baseNaturalSize);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Point start = 1; */
        if (message.start)
            TSPMessages_9.Point.internalBinaryWrite(message.start, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Point end = 2; */
        if (message.end)
            TSPMessages_9.Point.internalBinaryWrite(message.end, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Size baseNaturalSize = 3; */
        if (message.baseNaturalSize)
            TSPMessages_8.Size.internalBinaryWrite(message.baseNaturalSize, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.TransformGradientArchive
 */
exports.TransformGradientArchive = new TransformGradientArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GradientArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.GradientArchive", [
            { no: 1, name: "type", kind: "enum", opt: true, T: () => ["TSD.GradientArchive.GradientType", GradientArchive_GradientType] },
            { no: 2, name: "stops", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.GradientArchive_GradientStop },
            { no: 3, name: "opacity", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "advancedGradient", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "anglegradient", kind: "message", T: () => exports.AngleGradientArchive },
            { no: 6, name: "transformgradient", kind: "message", T: () => exports.TransformGradientArchive }
        ]);
    }
    create(value) {
        const message = { stops: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSD.GradientArchive.GradientType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* repeated TSD.GradientArchive.GradientStop stops */ 2:
                    message.stops.push(exports.GradientArchive_GradientStop.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional float opacity */ 3:
                    message.opacity = reader.float();
                    break;
                case /* optional bool advancedGradient */ 4:
                    message.advancedGradient = reader.bool();
                    break;
                case /* optional TSD.AngleGradientArchive anglegradient */ 5:
                    message.anglegradient = exports.AngleGradientArchive.internalBinaryRead(reader, reader.uint32(), options, message.anglegradient);
                    break;
                case /* optional TSD.TransformGradientArchive transformgradient */ 6:
                    message.transformgradient = exports.TransformGradientArchive.internalBinaryRead(reader, reader.uint32(), options, message.transformgradient);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSD.GradientArchive.GradientType type = 1; */
        if (message.type !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.type);
        /* repeated TSD.GradientArchive.GradientStop stops = 2; */
        for (let i = 0; i < message.stops.length; i++)
            exports.GradientArchive_GradientStop.internalBinaryWrite(message.stops[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional float opacity = 3; */
        if (message.opacity !== undefined)
            writer.tag(3, runtime_1.WireType.Bit32).float(message.opacity);
        /* optional bool advancedGradient = 4; */
        if (message.advancedGradient !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.advancedGradient);
        /* optional TSD.AngleGradientArchive anglegradient = 5; */
        if (message.anglegradient)
            exports.AngleGradientArchive.internalBinaryWrite(message.anglegradient, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.TransformGradientArchive transformgradient = 6; */
        if (message.transformgradient)
            exports.TransformGradientArchive.internalBinaryWrite(message.transformgradient, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.GradientArchive
 */
exports.GradientArchive = new GradientArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GradientArchive_GradientStop$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.GradientArchive.GradientStop", [
            { no: 1, name: "color", kind: "message", T: () => TSPMessages_6.Color },
            { no: 2, name: "fraction", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "inflection", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Color color */ 1:
                    message.color = TSPMessages_6.Color.internalBinaryRead(reader, reader.uint32(), options, message.color);
                    break;
                case /* optional float fraction */ 2:
                    message.fraction = reader.float();
                    break;
                case /* optional float inflection */ 3:
                    message.inflection = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Color color = 1; */
        if (message.color)
            TSPMessages_6.Color.internalBinaryWrite(message.color, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional float fraction = 2; */
        if (message.fraction !== undefined)
            writer.tag(2, runtime_1.WireType.Bit32).float(message.fraction);
        /* optional float inflection = 3; */
        if (message.inflection !== undefined)
            writer.tag(3, runtime_1.WireType.Bit32).float(message.inflection);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.GradientArchive.GradientStop
 */
exports.GradientArchive_GradientStop = new GradientArchive_GradientStop$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImageFillArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ImageFillArchive", [
            { no: 6, name: "imagedata", kind: "message", T: () => TSPMessages_5.DataReference },
            { no: 2, name: "technique", kind: "enum", opt: true, T: () => ["TSD.ImageFillArchive.ImageFillTechnique", ImageFillArchive_ImageFillTechnique] },
            { no: 3, name: "tint", kind: "message", T: () => TSPMessages_6.Color },
            { no: 4, name: "fillsize", kind: "message", T: () => TSPMessages_8.Size },
            { no: 7, name: "originalimagedata", kind: "message", T: () => TSPMessages_5.DataReference },
            { no: 8, name: "interpretsUntaggedImageDataAsGeneric", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "referencecolor", kind: "message", T: () => TSPMessages_6.Color },
            { no: 1, name: "database_imagedata", kind: "message", T: () => TSPMessages_4.Reference },
            { no: 5, name: "database_originalimagedata", kind: "message", T: () => TSPMessages_4.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.DataReference imagedata */ 6:
                    message.imagedata = TSPMessages_5.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.imagedata);
                    break;
                case /* optional TSD.ImageFillArchive.ImageFillTechnique technique */ 2:
                    message.technique = reader.int32();
                    break;
                case /* optional TSP.Color tint */ 3:
                    message.tint = TSPMessages_6.Color.internalBinaryRead(reader, reader.uint32(), options, message.tint);
                    break;
                case /* optional TSP.Size fillsize */ 4:
                    message.fillsize = TSPMessages_8.Size.internalBinaryRead(reader, reader.uint32(), options, message.fillsize);
                    break;
                case /* optional TSP.DataReference originalimagedata = 7 [deprecated = true];*/ 7:
                    message.originalimagedata = TSPMessages_5.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.originalimagedata);
                    break;
                case /* optional bool interpretsUntaggedImageDataAsGeneric */ 8:
                    message.interpretsUntaggedImageDataAsGeneric = reader.bool();
                    break;
                case /* optional TSP.Color referencecolor */ 9:
                    message.referencecolor = TSPMessages_6.Color.internalBinaryRead(reader, reader.uint32(), options, message.referencecolor);
                    break;
                case /* optional TSP.Reference database_imagedata */ 1:
                    message.databaseImagedata = TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options, message.databaseImagedata);
                    break;
                case /* optional TSP.Reference database_originalimagedata */ 5:
                    message.databaseOriginalimagedata = TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options, message.databaseOriginalimagedata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.DataReference imagedata = 6; */
        if (message.imagedata)
            TSPMessages_5.DataReference.internalBinaryWrite(message.imagedata, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.ImageFillArchive.ImageFillTechnique technique = 2; */
        if (message.technique !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.technique);
        /* optional TSP.Color tint = 3; */
        if (message.tint)
            TSPMessages_6.Color.internalBinaryWrite(message.tint, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Size fillsize = 4; */
        if (message.fillsize)
            TSPMessages_8.Size.internalBinaryWrite(message.fillsize, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference originalimagedata = 7 [deprecated = true]; */
        if (message.originalimagedata)
            TSPMessages_5.DataReference.internalBinaryWrite(message.originalimagedata, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool interpretsUntaggedImageDataAsGeneric = 8; */
        if (message.interpretsUntaggedImageDataAsGeneric !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.interpretsUntaggedImageDataAsGeneric);
        /* optional TSP.Color referencecolor = 9; */
        if (message.referencecolor)
            TSPMessages_6.Color.internalBinaryWrite(message.referencecolor, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference database_imagedata = 1; */
        if (message.databaseImagedata)
            TSPMessages_4.Reference.internalBinaryWrite(message.databaseImagedata, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference database_originalimagedata = 5; */
        if (message.databaseOriginalimagedata)
            TSPMessages_4.Reference.internalBinaryWrite(message.databaseOriginalimagedata, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ImageFillArchive
 */
exports.ImageFillArchive = new ImageFillArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FillArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.FillArchive", [
            { no: 1, name: "color", kind: "message", T: () => TSPMessages_6.Color },
            { no: 2, name: "gradient", kind: "message", T: () => exports.GradientArchive },
            { no: 3, name: "image", kind: "message", T: () => exports.ImageFillArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Color color */ 1:
                    message.color = TSPMessages_6.Color.internalBinaryRead(reader, reader.uint32(), options, message.color);
                    break;
                case /* optional TSD.GradientArchive gradient */ 2:
                    message.gradient = exports.GradientArchive.internalBinaryRead(reader, reader.uint32(), options, message.gradient);
                    break;
                case /* optional TSD.ImageFillArchive image */ 3:
                    message.image = exports.ImageFillArchive.internalBinaryRead(reader, reader.uint32(), options, message.image);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Color color = 1; */
        if (message.color)
            TSPMessages_6.Color.internalBinaryWrite(message.color, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.GradientArchive gradient = 2; */
        if (message.gradient)
            exports.GradientArchive.internalBinaryWrite(message.gradient, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.ImageFillArchive image = 3; */
        if (message.image)
            exports.ImageFillArchive.internalBinaryWrite(message.image, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.FillArchive
 */
exports.FillArchive = new FillArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StrokePatternArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.StrokePatternArchive", [
            { no: 1, name: "type", kind: "enum", opt: true, T: () => ["TSD.StrokePatternArchive.StrokePatternType", StrokePatternArchive_StrokePatternType] },
            { no: 2, name: "phase", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "pattern", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value) {
        const message = { pattern: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSD.StrokePatternArchive.StrokePatternType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional float phase */ 2:
                    message.phase = reader.float();
                    break;
                case /* optional uint32 count */ 3:
                    message.count = reader.uint32();
                    break;
                case /* repeated float pattern */ 4:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.pattern.push(reader.float());
                    else
                        message.pattern.push(reader.float());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSD.StrokePatternArchive.StrokePatternType type = 1; */
        if (message.type !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.type);
        /* optional float phase = 2; */
        if (message.phase !== undefined)
            writer.tag(2, runtime_1.WireType.Bit32).float(message.phase);
        /* optional uint32 count = 3; */
        if (message.count !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.count);
        /* repeated float pattern = 4; */
        for (let i = 0; i < message.pattern.length; i++)
            writer.tag(4, runtime_1.WireType.Bit32).float(message.pattern[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.StrokePatternArchive
 */
exports.StrokePatternArchive = new StrokePatternArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StrokeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.StrokeArchive", [
            { no: 1, name: "color", kind: "message", T: () => TSPMessages_6.Color },
            { no: 2, name: "width", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "cap", kind: "enum", opt: true, T: () => ["TSD.StrokeArchive.LineCap", StrokeArchive_LineCap] },
            { no: 4, name: "join", kind: "enum", opt: true, T: () => ["TSD.LineJoin", LineJoin] },
            { no: 5, name: "miter_limit", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "pattern", kind: "message", T: () => exports.StrokePatternArchive },
            { no: 7, name: "smart_stroke", kind: "message", T: () => exports.SmartStrokeArchive },
            { no: 8, name: "frame", kind: "message", T: () => exports.FrameArchive },
            { no: 9, name: "patterned_stroke", kind: "message", T: () => exports.PatternedStrokeArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Color color */ 1:
                    message.color = TSPMessages_6.Color.internalBinaryRead(reader, reader.uint32(), options, message.color);
                    break;
                case /* optional float width */ 2:
                    message.width = reader.float();
                    break;
                case /* optional TSD.StrokeArchive.LineCap cap */ 3:
                    message.cap = reader.int32();
                    break;
                case /* optional TSD.LineJoin join */ 4:
                    message.join = reader.int32();
                    break;
                case /* optional float miter_limit */ 5:
                    message.miterLimit = reader.float();
                    break;
                case /* optional TSD.StrokePatternArchive pattern */ 6:
                    message.pattern = exports.StrokePatternArchive.internalBinaryRead(reader, reader.uint32(), options, message.pattern);
                    break;
                case /* optional TSD.SmartStrokeArchive smart_stroke */ 7:
                    message.smartStroke = exports.SmartStrokeArchive.internalBinaryRead(reader, reader.uint32(), options, message.smartStroke);
                    break;
                case /* optional TSD.FrameArchive frame */ 8:
                    message.frame = exports.FrameArchive.internalBinaryRead(reader, reader.uint32(), options, message.frame);
                    break;
                case /* optional TSD.PatternedStrokeArchive patterned_stroke */ 9:
                    message.patternedStroke = exports.PatternedStrokeArchive.internalBinaryRead(reader, reader.uint32(), options, message.patternedStroke);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Color color = 1; */
        if (message.color)
            TSPMessages_6.Color.internalBinaryWrite(message.color, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional float width = 2; */
        if (message.width !== undefined)
            writer.tag(2, runtime_1.WireType.Bit32).float(message.width);
        /* optional TSD.StrokeArchive.LineCap cap = 3; */
        if (message.cap !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.cap);
        /* optional TSD.LineJoin join = 4; */
        if (message.join !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).int32(message.join);
        /* optional float miter_limit = 5; */
        if (message.miterLimit !== undefined)
            writer.tag(5, runtime_1.WireType.Bit32).float(message.miterLimit);
        /* optional TSD.StrokePatternArchive pattern = 6; */
        if (message.pattern)
            exports.StrokePatternArchive.internalBinaryWrite(message.pattern, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.SmartStrokeArchive smart_stroke = 7; */
        if (message.smartStroke)
            exports.SmartStrokeArchive.internalBinaryWrite(message.smartStroke, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.FrameArchive frame = 8; */
        if (message.frame)
            exports.FrameArchive.internalBinaryWrite(message.frame, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.PatternedStrokeArchive patterned_stroke = 9; */
        if (message.patternedStroke)
            exports.PatternedStrokeArchive.internalBinaryWrite(message.patternedStroke, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.StrokeArchive
 */
exports.StrokeArchive = new StrokeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SmartStrokeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.SmartStrokeArchive", [
            { no: 2, name: "stroke_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "random_seed", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "parameterValues", kind: "message", T: () => TSPMessages_3.ReferenceDictionary },
            { no: 5, name: "pattern_offset_distance", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string stroke_name */ 2:
                    message.strokeName = reader.string();
                    break;
                case /* optional uint32 random_seed */ 3:
                    message.randomSeed = reader.uint32();
                    break;
                case /* optional TSP.ReferenceDictionary parameterValues */ 4:
                    message.parameterValues = TSPMessages_3.ReferenceDictionary.internalBinaryRead(reader, reader.uint32(), options, message.parameterValues);
                    break;
                case /* optional double pattern_offset_distance */ 5:
                    message.patternOffsetDistance = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string stroke_name = 2; */
        if (message.strokeName !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.strokeName);
        /* optional uint32 random_seed = 3; */
        if (message.randomSeed !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.randomSeed);
        /* optional TSP.ReferenceDictionary parameterValues = 4; */
        if (message.parameterValues)
            TSPMessages_3.ReferenceDictionary.internalBinaryWrite(message.parameterValues, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional double pattern_offset_distance = 5; */
        if (message.patternOffsetDistance !== undefined)
            writer.tag(5, runtime_1.WireType.Bit64).double(message.patternOffsetDistance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.SmartStrokeArchive
 */
exports.SmartStrokeArchive = new SmartStrokeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FrameArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.FrameArchive", [
            { no: 2, name: "frameName", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "assetScale", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string frameName */ 2:
                    message.frameName = reader.string();
                    break;
                case /* optional float assetScale */ 3:
                    message.assetScale = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string frameName = 2; */
        if (message.frameName !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.frameName);
        /* optional float assetScale = 3; */
        if (message.assetScale !== undefined)
            writer.tag(3, runtime_1.WireType.Bit32).float(message.assetScale);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.FrameArchive
 */
exports.FrameArchive = new FrameArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PatternedStrokeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.PatternedStrokeArchive", [
            { no: 2, name: "pattern_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string pattern_name */ 2:
                    message.patternName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string pattern_name = 2; */
        if (message.patternName !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.patternName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.PatternedStrokeArchive
 */
exports.PatternedStrokeArchive = new PatternedStrokeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LineEndArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.LineEndArchive", [
            { no: 1, name: "path", kind: "message", T: () => TSPMessages_7.Path },
            { no: 2, name: "line_join", kind: "enum", opt: true, T: () => ["TSD.LineJoin", LineJoin] },
            { no: 3, name: "end_point", kind: "message", T: () => TSPMessages_9.Point },
            { no: 4, name: "is_filled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "identifier", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Path path */ 1:
                    message.path = TSPMessages_7.Path.internalBinaryRead(reader, reader.uint32(), options, message.path);
                    break;
                case /* optional TSD.LineJoin line_join */ 2:
                    message.lineJoin = reader.int32();
                    break;
                case /* optional TSP.Point end_point */ 3:
                    message.endPoint = TSPMessages_9.Point.internalBinaryRead(reader, reader.uint32(), options, message.endPoint);
                    break;
                case /* optional bool is_filled */ 4:
                    message.isFilled = reader.bool();
                    break;
                case /* optional string identifier */ 5:
                    message.identifier = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Path path = 1; */
        if (message.path)
            TSPMessages_7.Path.internalBinaryWrite(message.path, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.LineJoin line_join = 2; */
        if (message.lineJoin !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.lineJoin);
        /* optional TSP.Point end_point = 3; */
        if (message.endPoint)
            TSPMessages_9.Point.internalBinaryWrite(message.endPoint, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_filled = 4; */
        if (message.isFilled !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.isFilled);
        /* optional string identifier = 5; */
        if (message.identifier !== undefined)
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.identifier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.LineEndArchive
 */
exports.LineEndArchive = new LineEndArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShadowArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ShadowArchive", [
            { no: 1, name: "color", kind: "message", T: () => TSPMessages_6.Color },
            { no: 2, name: "angle", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "offset", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "radius", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "opacity", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "is_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "type", kind: "enum", opt: true, T: () => ["TSD.ShadowArchive.ShadowType", ShadowArchive_ShadowType] },
            { no: 8, name: "dropShadow", kind: "message", T: () => exports.DropShadowArchive },
            { no: 9, name: "contactShadow", kind: "message", T: () => exports.ContactShadowArchive },
            { no: 10, name: "curvedShadow", kind: "message", T: () => exports.CurvedShadowArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Color color */ 1:
                    message.color = TSPMessages_6.Color.internalBinaryRead(reader, reader.uint32(), options, message.color);
                    break;
                case /* optional float angle */ 2:
                    message.angle = reader.float();
                    break;
                case /* optional float offset */ 3:
                    message.offset = reader.float();
                    break;
                case /* optional int32 radius */ 4:
                    message.radius = reader.int32();
                    break;
                case /* optional float opacity */ 5:
                    message.opacity = reader.float();
                    break;
                case /* optional bool is_enabled */ 6:
                    message.isEnabled = reader.bool();
                    break;
                case /* optional TSD.ShadowArchive.ShadowType type */ 7:
                    message.type = reader.int32();
                    break;
                case /* optional TSD.DropShadowArchive dropShadow */ 8:
                    message.dropShadow = exports.DropShadowArchive.internalBinaryRead(reader, reader.uint32(), options, message.dropShadow);
                    break;
                case /* optional TSD.ContactShadowArchive contactShadow */ 9:
                    message.contactShadow = exports.ContactShadowArchive.internalBinaryRead(reader, reader.uint32(), options, message.contactShadow);
                    break;
                case /* optional TSD.CurvedShadowArchive curvedShadow */ 10:
                    message.curvedShadow = exports.CurvedShadowArchive.internalBinaryRead(reader, reader.uint32(), options, message.curvedShadow);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Color color = 1; */
        if (message.color)
            TSPMessages_6.Color.internalBinaryWrite(message.color, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional float angle = 2; */
        if (message.angle !== undefined)
            writer.tag(2, runtime_1.WireType.Bit32).float(message.angle);
        /* optional float offset = 3; */
        if (message.offset !== undefined)
            writer.tag(3, runtime_1.WireType.Bit32).float(message.offset);
        /* optional int32 radius = 4; */
        if (message.radius !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).int32(message.radius);
        /* optional float opacity = 5; */
        if (message.opacity !== undefined)
            writer.tag(5, runtime_1.WireType.Bit32).float(message.opacity);
        /* optional bool is_enabled = 6; */
        if (message.isEnabled !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.isEnabled);
        /* optional TSD.ShadowArchive.ShadowType type = 7; */
        if (message.type !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).int32(message.type);
        /* optional TSD.DropShadowArchive dropShadow = 8; */
        if (message.dropShadow)
            exports.DropShadowArchive.internalBinaryWrite(message.dropShadow, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.ContactShadowArchive contactShadow = 9; */
        if (message.contactShadow)
            exports.ContactShadowArchive.internalBinaryWrite(message.contactShadow, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.CurvedShadowArchive curvedShadow = 10; */
        if (message.curvedShadow)
            exports.CurvedShadowArchive.internalBinaryWrite(message.curvedShadow, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ShadowArchive
 */
exports.ShadowArchive = new ShadowArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DropShadowArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.DropShadowArchive", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.DropShadowArchive
 */
exports.DropShadowArchive = new DropShadowArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ContactShadowArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ContactShadowArchive", [
            { no: 2, name: "height", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "offset", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float height */ 2:
                    message.height = reader.float();
                    break;
                case /* optional float offset */ 4:
                    message.offset = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional float height = 2; */
        if (message.height !== undefined)
            writer.tag(2, runtime_1.WireType.Bit32).float(message.height);
        /* optional float offset = 4; */
        if (message.offset !== undefined)
            writer.tag(4, runtime_1.WireType.Bit32).float(message.offset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ContactShadowArchive
 */
exports.ContactShadowArchive = new ContactShadowArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CurvedShadowArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.CurvedShadowArchive", [
            { no: 1, name: "curve", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float curve */ 1:
                    message.curve = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional float curve = 1; */
        if (message.curve !== undefined)
            writer.tag(1, runtime_1.WireType.Bit32).float(message.curve);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.CurvedShadowArchive
 */
exports.CurvedShadowArchive = new CurvedShadowArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReflectionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ReflectionArchive", [
            { no: 1, name: "opacity", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float opacity */ 1:
                    message.opacity = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional float opacity = 1; */
        if (message.opacity !== undefined)
            writer.tag(1, runtime_1.WireType.Bit32).float(message.opacity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ReflectionArchive
 */
exports.ReflectionArchive = new ReflectionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImageAdjustmentsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ImageAdjustmentsArchive", [
            { no: 1, name: "exposure", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "saturation", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "contrast", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "highlights", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "shadows", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "sharpness", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "denoise", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "temperature", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "tint", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "bottom_level", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "top_level", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "gamma", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 13, name: "enhance", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "represents_sage_adjustments", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float exposure */ 1:
                    message.exposure = reader.float();
                    break;
                case /* optional float saturation */ 2:
                    message.saturation = reader.float();
                    break;
                case /* optional float contrast */ 3:
                    message.contrast = reader.float();
                    break;
                case /* optional float highlights */ 4:
                    message.highlights = reader.float();
                    break;
                case /* optional float shadows */ 5:
                    message.shadows = reader.float();
                    break;
                case /* optional float sharpness */ 6:
                    message.sharpness = reader.float();
                    break;
                case /* optional float denoise */ 7:
                    message.denoise = reader.float();
                    break;
                case /* optional float temperature */ 8:
                    message.temperature = reader.float();
                    break;
                case /* optional float tint */ 9:
                    message.tint = reader.float();
                    break;
                case /* optional float bottom_level */ 10:
                    message.bottomLevel = reader.float();
                    break;
                case /* optional float top_level */ 11:
                    message.topLevel = reader.float();
                    break;
                case /* optional float gamma */ 12:
                    message.gamma = reader.float();
                    break;
                case /* optional bool enhance */ 13:
                    message.enhance = reader.bool();
                    break;
                case /* optional bool represents_sage_adjustments */ 14:
                    message.representsSageAdjustments = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional float exposure = 1; */
        if (message.exposure !== undefined)
            writer.tag(1, runtime_1.WireType.Bit32).float(message.exposure);
        /* optional float saturation = 2; */
        if (message.saturation !== undefined)
            writer.tag(2, runtime_1.WireType.Bit32).float(message.saturation);
        /* optional float contrast = 3; */
        if (message.contrast !== undefined)
            writer.tag(3, runtime_1.WireType.Bit32).float(message.contrast);
        /* optional float highlights = 4; */
        if (message.highlights !== undefined)
            writer.tag(4, runtime_1.WireType.Bit32).float(message.highlights);
        /* optional float shadows = 5; */
        if (message.shadows !== undefined)
            writer.tag(5, runtime_1.WireType.Bit32).float(message.shadows);
        /* optional float sharpness = 6; */
        if (message.sharpness !== undefined)
            writer.tag(6, runtime_1.WireType.Bit32).float(message.sharpness);
        /* optional float denoise = 7; */
        if (message.denoise !== undefined)
            writer.tag(7, runtime_1.WireType.Bit32).float(message.denoise);
        /* optional float temperature = 8; */
        if (message.temperature !== undefined)
            writer.tag(8, runtime_1.WireType.Bit32).float(message.temperature);
        /* optional float tint = 9; */
        if (message.tint !== undefined)
            writer.tag(9, runtime_1.WireType.Bit32).float(message.tint);
        /* optional float bottom_level = 10; */
        if (message.bottomLevel !== undefined)
            writer.tag(10, runtime_1.WireType.Bit32).float(message.bottomLevel);
        /* optional float top_level = 11; */
        if (message.topLevel !== undefined)
            writer.tag(11, runtime_1.WireType.Bit32).float(message.topLevel);
        /* optional float gamma = 12; */
        if (message.gamma !== undefined)
            writer.tag(12, runtime_1.WireType.Bit32).float(message.gamma);
        /* optional bool enhance = 13; */
        if (message.enhance !== undefined)
            writer.tag(13, runtime_1.WireType.Varint).bool(message.enhance);
        /* optional bool represents_sage_adjustments = 14; */
        if (message.representsSageAdjustments !== undefined)
            writer.tag(14, runtime_1.WireType.Varint).bool(message.representsSageAdjustments);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ImageAdjustmentsArchive
 */
exports.ImageAdjustmentsArchive = new ImageAdjustmentsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShapeStylePropertiesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ShapeStylePropertiesArchive", [
            { no: 1, name: "fill", kind: "message", T: () => exports.FillArchive },
            { no: 2, name: "stroke", kind: "message", T: () => exports.StrokeArchive },
            { no: 3, name: "opacity", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "shadow", kind: "message", T: () => exports.ShadowArchive },
            { no: 5, name: "reflection", kind: "message", T: () => exports.ReflectionArchive },
            { no: 6, name: "head_line_end", kind: "message", T: () => exports.LineEndArchive },
            { no: 7, name: "tail_line_end", kind: "message", T: () => exports.LineEndArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSD.FillArchive fill */ 1:
                    message.fill = exports.FillArchive.internalBinaryRead(reader, reader.uint32(), options, message.fill);
                    break;
                case /* optional TSD.StrokeArchive stroke */ 2:
                    message.stroke = exports.StrokeArchive.internalBinaryRead(reader, reader.uint32(), options, message.stroke);
                    break;
                case /* optional float opacity */ 3:
                    message.opacity = reader.float();
                    break;
                case /* optional TSD.ShadowArchive shadow */ 4:
                    message.shadow = exports.ShadowArchive.internalBinaryRead(reader, reader.uint32(), options, message.shadow);
                    break;
                case /* optional TSD.ReflectionArchive reflection */ 5:
                    message.reflection = exports.ReflectionArchive.internalBinaryRead(reader, reader.uint32(), options, message.reflection);
                    break;
                case /* optional TSD.LineEndArchive head_line_end */ 6:
                    message.headLineEnd = exports.LineEndArchive.internalBinaryRead(reader, reader.uint32(), options, message.headLineEnd);
                    break;
                case /* optional TSD.LineEndArchive tail_line_end */ 7:
                    message.tailLineEnd = exports.LineEndArchive.internalBinaryRead(reader, reader.uint32(), options, message.tailLineEnd);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSD.FillArchive fill = 1; */
        if (message.fill)
            exports.FillArchive.internalBinaryWrite(message.fill, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.StrokeArchive stroke = 2; */
        if (message.stroke)
            exports.StrokeArchive.internalBinaryWrite(message.stroke, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional float opacity = 3; */
        if (message.opacity !== undefined)
            writer.tag(3, runtime_1.WireType.Bit32).float(message.opacity);
        /* optional TSD.ShadowArchive shadow = 4; */
        if (message.shadow)
            exports.ShadowArchive.internalBinaryWrite(message.shadow, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.ReflectionArchive reflection = 5; */
        if (message.reflection)
            exports.ReflectionArchive.internalBinaryWrite(message.reflection, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.LineEndArchive head_line_end = 6; */
        if (message.headLineEnd)
            exports.LineEndArchive.internalBinaryWrite(message.headLineEnd, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.LineEndArchive tail_line_end = 7; */
        if (message.tailLineEnd)
            exports.LineEndArchive.internalBinaryWrite(message.tailLineEnd, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ShapeStylePropertiesArchive
 */
exports.ShapeStylePropertiesArchive = new ShapeStylePropertiesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShapeStyleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ShapeStyleArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSSArchives_1.StyleArchive },
            { no: 10, name: "override_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "shape_properties", kind: "message", T: () => exports.ShapeStylePropertiesArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSS.StyleArchive super */ 1:
                    message.super = TSSArchives_1.StyleArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional uint32 override_count */ 10:
                    message.overrideCount = reader.uint32();
                    break;
                case /* optional TSD.ShapeStylePropertiesArchive shape_properties */ 11:
                    message.shapeProperties = exports.ShapeStylePropertiesArchive.internalBinaryRead(reader, reader.uint32(), options, message.shapeProperties);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSS.StyleArchive super = 1; */
        if (message.super)
            TSSArchives_1.StyleArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 override_count = 10; */
        if (message.overrideCount !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).uint32(message.overrideCount);
        /* optional TSD.ShapeStylePropertiesArchive shape_properties = 11; */
        if (message.shapeProperties)
            exports.ShapeStylePropertiesArchive.internalBinaryWrite(message.shapeProperties, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ShapeStyleArchive
 */
exports.ShapeStyleArchive = new ShapeStyleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MediaStylePropertiesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.MediaStylePropertiesArchive", [
            { no: 1, name: "stroke", kind: "message", T: () => exports.StrokeArchive },
            { no: 2, name: "opacity", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "shadow", kind: "message", T: () => exports.ShadowArchive },
            { no: 4, name: "reflection", kind: "message", T: () => exports.ReflectionArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSD.StrokeArchive stroke */ 1:
                    message.stroke = exports.StrokeArchive.internalBinaryRead(reader, reader.uint32(), options, message.stroke);
                    break;
                case /* optional float opacity */ 2:
                    message.opacity = reader.float();
                    break;
                case /* optional TSD.ShadowArchive shadow */ 3:
                    message.shadow = exports.ShadowArchive.internalBinaryRead(reader, reader.uint32(), options, message.shadow);
                    break;
                case /* optional TSD.ReflectionArchive reflection */ 4:
                    message.reflection = exports.ReflectionArchive.internalBinaryRead(reader, reader.uint32(), options, message.reflection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSD.StrokeArchive stroke = 1; */
        if (message.stroke)
            exports.StrokeArchive.internalBinaryWrite(message.stroke, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional float opacity = 2; */
        if (message.opacity !== undefined)
            writer.tag(2, runtime_1.WireType.Bit32).float(message.opacity);
        /* optional TSD.ShadowArchive shadow = 3; */
        if (message.shadow)
            exports.ShadowArchive.internalBinaryWrite(message.shadow, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.ReflectionArchive reflection = 4; */
        if (message.reflection)
            exports.ReflectionArchive.internalBinaryWrite(message.reflection, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.MediaStylePropertiesArchive
 */
exports.MediaStylePropertiesArchive = new MediaStylePropertiesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MediaStyleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.MediaStyleArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSSArchives_1.StyleArchive },
            { no: 10, name: "override_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "media_properties", kind: "message", T: () => exports.MediaStylePropertiesArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSS.StyleArchive super */ 1:
                    message.super = TSSArchives_1.StyleArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional uint32 override_count */ 10:
                    message.overrideCount = reader.uint32();
                    break;
                case /* optional TSD.MediaStylePropertiesArchive media_properties */ 11:
                    message.mediaProperties = exports.MediaStylePropertiesArchive.internalBinaryRead(reader, reader.uint32(), options, message.mediaProperties);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSS.StyleArchive super = 1; */
        if (message.super)
            TSSArchives_1.StyleArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 override_count = 10; */
        if (message.overrideCount !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).uint32(message.overrideCount);
        /* optional TSD.MediaStylePropertiesArchive media_properties = 11; */
        if (message.mediaProperties)
            exports.MediaStylePropertiesArchive.internalBinaryWrite(message.mediaProperties, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.MediaStyleArchive
 */
exports.MediaStyleArchive = new MediaStyleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ThemePresetsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ThemePresetsArchive", [
            { no: 1, name: "gradient_fill_presets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.FillArchive },
            { no: 2, name: "image_fill_presets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.FillArchive },
            { no: 3, name: "shadow_presets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ShadowArchive },
            { no: 4, name: "line_style_presets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.Reference },
            { no: 5, name: "shape_style_presets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.Reference },
            { no: 6, name: "textbox_style_presets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.Reference },
            { no: 7, name: "image_style_presets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.Reference },
            { no: 8, name: "movie_style_presets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.Reference },
            { no: 9, name: "drawing_line_style_presets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.Reference }
        ]);
    }
    create(value) {
        const message = { gradientFillPresets: [], imageFillPresets: [], shadowPresets: [], lineStylePresets: [], shapeStylePresets: [], textboxStylePresets: [], imageStylePresets: [], movieStylePresets: [], drawingLineStylePresets: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSD.FillArchive gradient_fill_presets */ 1:
                    message.gradientFillPresets.push(exports.FillArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSD.FillArchive image_fill_presets */ 2:
                    message.imageFillPresets.push(exports.FillArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSD.ShadowArchive shadow_presets */ 3:
                    message.shadowPresets.push(exports.ShadowArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference line_style_presets */ 4:
                    message.lineStylePresets.push(TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference shape_style_presets */ 5:
                    message.shapeStylePresets.push(TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference textbox_style_presets */ 6:
                    message.textboxStylePresets.push(TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference image_style_presets */ 7:
                    message.imageStylePresets.push(TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference movie_style_presets */ 8:
                    message.movieStylePresets.push(TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference drawing_line_style_presets */ 9:
                    message.drawingLineStylePresets.push(TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSD.FillArchive gradient_fill_presets = 1; */
        for (let i = 0; i < message.gradientFillPresets.length; i++)
            exports.FillArchive.internalBinaryWrite(message.gradientFillPresets[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSD.FillArchive image_fill_presets = 2; */
        for (let i = 0; i < message.imageFillPresets.length; i++)
            exports.FillArchive.internalBinaryWrite(message.imageFillPresets[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSD.ShadowArchive shadow_presets = 3; */
        for (let i = 0; i < message.shadowPresets.length; i++)
            exports.ShadowArchive.internalBinaryWrite(message.shadowPresets[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference line_style_presets = 4; */
        for (let i = 0; i < message.lineStylePresets.length; i++)
            TSPMessages_4.Reference.internalBinaryWrite(message.lineStylePresets[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference shape_style_presets = 5; */
        for (let i = 0; i < message.shapeStylePresets.length; i++)
            TSPMessages_4.Reference.internalBinaryWrite(message.shapeStylePresets[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference textbox_style_presets = 6; */
        for (let i = 0; i < message.textboxStylePresets.length; i++)
            TSPMessages_4.Reference.internalBinaryWrite(message.textboxStylePresets[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference image_style_presets = 7; */
        for (let i = 0; i < message.imageStylePresets.length; i++)
            TSPMessages_4.Reference.internalBinaryWrite(message.imageStylePresets[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference movie_style_presets = 8; */
        for (let i = 0; i < message.movieStylePresets.length; i++)
            TSPMessages_4.Reference.internalBinaryWrite(message.movieStylePresets[i], writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference drawing_line_style_presets = 9; */
        for (let i = 0; i < message.drawingLineStylePresets.length; i++)
            TSPMessages_4.Reference.internalBinaryWrite(message.drawingLineStylePresets[i], writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ThemePresetsArchive
 */
exports.ThemePresetsArchive = new ThemePresetsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ThemeReplaceFillPresetCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ThemeReplaceFillPresetCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_1.CommandArchive },
            { no: 2, name: "theme", kind: "message", T: () => TSPMessages_4.Reference },
            { no: 3, name: "fill", kind: "message", T: () => exports.FillArchive },
            { no: 4, name: "old_fill", kind: "message", T: () => exports.FillArchive },
            { no: 5, name: "index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { index: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_1.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Reference theme */ 2:
                    message.theme = TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options, message.theme);
                    break;
                case /* TSD.FillArchive fill */ 3:
                    message.fill = exports.FillArchive.internalBinaryRead(reader, reader.uint32(), options, message.fill);
                    break;
                case /* TSD.FillArchive old_fill */ 4:
                    message.oldFill = exports.FillArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldFill);
                    break;
                case /* uint32 index */ 5:
                    message.index = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_1.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference theme = 2; */
        if (message.theme)
            TSPMessages_4.Reference.internalBinaryWrite(message.theme, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSD.FillArchive fill = 3; */
        if (message.fill)
            exports.FillArchive.internalBinaryWrite(message.fill, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSD.FillArchive old_fill = 4; */
        if (message.oldFill)
            exports.FillArchive.internalBinaryWrite(message.oldFill, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 index = 5; */
        if (message.index !== 0)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.index);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ThemeReplaceFillPresetCommandArchive
 */
exports.ThemeReplaceFillPresetCommandArchive = new ThemeReplaceFillPresetCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DrawableArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.DrawableArchive", [
            { no: 1, name: "geometry", kind: "message", T: () => exports.GeometryArchive },
            { no: 2, name: "parent", kind: "message", T: () => TSPMessages_4.Reference },
            { no: 3, name: "exterior_text_wrap", kind: "message", T: () => exports.ExteriorTextWrapArchive },
            { no: 4, name: "hyperlink_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "locked", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "comment", kind: "message", T: () => TSPMessages_4.Reference },
            { no: 7, name: "aspect_ratio_locked", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "accessibility_description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "pencil_annotations", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.Reference },
            { no: 10, name: "title", kind: "message", T: () => TSPMessages_4.Reference },
            { no: 11, name: "caption", kind: "message", T: () => TSPMessages_4.Reference },
            { no: 12, name: "title_hidden", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "caption_hidden", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { pencilAnnotations: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSD.GeometryArchive geometry */ 1:
                    message.geometry = exports.GeometryArchive.internalBinaryRead(reader, reader.uint32(), options, message.geometry);
                    break;
                case /* optional TSP.Reference parent */ 2:
                    message.parent = TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options, message.parent);
                    break;
                case /* optional TSD.ExteriorTextWrapArchive exterior_text_wrap */ 3:
                    message.exteriorTextWrap = exports.ExteriorTextWrapArchive.internalBinaryRead(reader, reader.uint32(), options, message.exteriorTextWrap);
                    break;
                case /* optional string hyperlink_url */ 4:
                    message.hyperlinkUrl = reader.string();
                    break;
                case /* optional bool locked */ 5:
                    message.locked = reader.bool();
                    break;
                case /* optional TSP.Reference comment */ 6:
                    message.comment = TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options, message.comment);
                    break;
                case /* optional bool aspect_ratio_locked */ 7:
                    message.aspectRatioLocked = reader.bool();
                    break;
                case /* optional string accessibility_description */ 8:
                    message.accessibilityDescription = reader.string();
                    break;
                case /* repeated TSP.Reference pencil_annotations */ 9:
                    message.pencilAnnotations.push(TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Reference title */ 10:
                    message.title = TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options, message.title);
                    break;
                case /* optional TSP.Reference caption */ 11:
                    message.caption = TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options, message.caption);
                    break;
                case /* optional bool title_hidden */ 12:
                    message.titleHidden = reader.bool();
                    break;
                case /* optional bool caption_hidden */ 13:
                    message.captionHidden = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSD.GeometryArchive geometry = 1; */
        if (message.geometry)
            exports.GeometryArchive.internalBinaryWrite(message.geometry, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference parent = 2; */
        if (message.parent)
            TSPMessages_4.Reference.internalBinaryWrite(message.parent, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.ExteriorTextWrapArchive exterior_text_wrap = 3; */
        if (message.exteriorTextWrap)
            exports.ExteriorTextWrapArchive.internalBinaryWrite(message.exteriorTextWrap, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string hyperlink_url = 4; */
        if (message.hyperlinkUrl !== undefined)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.hyperlinkUrl);
        /* optional bool locked = 5; */
        if (message.locked !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.locked);
        /* optional TSP.Reference comment = 6; */
        if (message.comment)
            TSPMessages_4.Reference.internalBinaryWrite(message.comment, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool aspect_ratio_locked = 7; */
        if (message.aspectRatioLocked !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.aspectRatioLocked);
        /* optional string accessibility_description = 8; */
        if (message.accessibilityDescription !== undefined)
            writer.tag(8, runtime_1.WireType.LengthDelimited).string(message.accessibilityDescription);
        /* repeated TSP.Reference pencil_annotations = 9; */
        for (let i = 0; i < message.pencilAnnotations.length; i++)
            TSPMessages_4.Reference.internalBinaryWrite(message.pencilAnnotations[i], writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference title = 10; */
        if (message.title)
            TSPMessages_4.Reference.internalBinaryWrite(message.title, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference caption = 11; */
        if (message.caption)
            TSPMessages_4.Reference.internalBinaryWrite(message.caption, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool title_hidden = 12; */
        if (message.titleHidden !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).bool(message.titleHidden);
        /* optional bool caption_hidden = 13; */
        if (message.captionHidden !== undefined)
            writer.tag(13, runtime_1.WireType.Varint).bool(message.captionHidden);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.DrawableArchive
 */
exports.DrawableArchive = new DrawableArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ContainerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ContainerArchive", [
            { no: 1, name: "geometry", kind: "message", T: () => exports.GeometryArchive },
            { no: 2, name: "parent", kind: "message", T: () => TSPMessages_4.Reference },
            { no: 3, name: "children", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.Reference }
        ]);
    }
    create(value) {
        const message = { children: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSD.GeometryArchive geometry */ 1:
                    message.geometry = exports.GeometryArchive.internalBinaryRead(reader, reader.uint32(), options, message.geometry);
                    break;
                case /* optional TSP.Reference parent */ 2:
                    message.parent = TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options, message.parent);
                    break;
                case /* repeated TSP.Reference children */ 3:
                    message.children.push(TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSD.GeometryArchive geometry = 1; */
        if (message.geometry)
            exports.GeometryArchive.internalBinaryWrite(message.geometry, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference parent = 2; */
        if (message.parent)
            TSPMessages_4.Reference.internalBinaryWrite(message.parent, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference children = 3; */
        for (let i = 0; i < message.children.length; i++)
            TSPMessages_4.Reference.internalBinaryWrite(message.children[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ContainerArchive
 */
exports.ContainerArchive = new ContainerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.GroupArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.DrawableArchive },
            { no: 2, name: "children", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.Reference },
            { no: 3, name: "fake_shape_for_empty_group", kind: "message", T: () => TSPMessages_4.Reference }
        ]);
    }
    create(value) {
        const message = { children: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.DrawableArchive super */ 1:
                    message.super = exports.DrawableArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSP.Reference children */ 2:
                    message.children.push(TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Reference fake_shape_for_empty_group */ 3:
                    message.fakeShapeForEmptyGroup = TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options, message.fakeShapeForEmptyGroup);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.DrawableArchive super = 1; */
        if (message.super)
            exports.DrawableArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference children = 2; */
        for (let i = 0; i < message.children.length; i++)
            TSPMessages_4.Reference.internalBinaryWrite(message.children[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference fake_shape_for_empty_group = 3; */
        if (message.fakeShapeForEmptyGroup)
            TSPMessages_4.Reference.internalBinaryWrite(message.fakeShapeForEmptyGroup, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.GroupArchive
 */
exports.GroupArchive = new GroupArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FreehandDrawingAnimationArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.FreehandDrawingAnimationArchive", [
            { no: 1, name: "duration", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "should_loop", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double duration */ 1:
                    message.duration = reader.double();
                    break;
                case /* optional bool should_loop */ 2:
                    message.shouldLoop = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional double duration = 1; */
        if (message.duration !== undefined)
            writer.tag(1, runtime_1.WireType.Bit64).double(message.duration);
        /* optional bool should_loop = 2; */
        if (message.shouldLoop !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.shouldLoop);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.FreehandDrawingAnimationArchive
 */
exports.FreehandDrawingAnimationArchive = new FreehandDrawingAnimationArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FreehandDrawingArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.FreehandDrawingArchive", [
            { no: 1, name: "spacer_shape", kind: "message", T: () => TSPMessages_4.Reference },
            { no: 2, name: "opacity", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "animation", kind: "message", T: () => exports.FreehandDrawingAnimationArchive },
            { no: 4, name: "last_clamped_scale", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference spacer_shape */ 1:
                    message.spacerShape = TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options, message.spacerShape);
                    break;
                case /* optional double opacity */ 2:
                    message.opacity = reader.double();
                    break;
                case /* optional TSD.FreehandDrawingAnimationArchive animation */ 3:
                    message.animation = exports.FreehandDrawingAnimationArchive.internalBinaryRead(reader, reader.uint32(), options, message.animation);
                    break;
                case /* optional double last_clamped_scale */ 4:
                    message.lastClampedScale = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference spacer_shape = 1; */
        if (message.spacerShape)
            TSPMessages_4.Reference.internalBinaryWrite(message.spacerShape, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional double opacity = 2; */
        if (message.opacity !== undefined)
            writer.tag(2, runtime_1.WireType.Bit64).double(message.opacity);
        /* optional TSD.FreehandDrawingAnimationArchive animation = 3; */
        if (message.animation)
            exports.FreehandDrawingAnimationArchive.internalBinaryWrite(message.animation, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional double last_clamped_scale = 4; */
        if (message.lastClampedScale !== undefined)
            writer.tag(4, runtime_1.WireType.Bit64).double(message.lastClampedScale);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.FreehandDrawingArchive
 */
exports.FreehandDrawingArchive = new FreehandDrawingArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShapeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ShapeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.DrawableArchive },
            { no: 2, name: "style", kind: "message", T: () => TSPMessages_4.Reference },
            { no: 3, name: "pathsource", kind: "message", T: () => exports.PathSourceArchive },
            { no: 4, name: "head_line_end", kind: "message", T: () => exports.LineEndArchive },
            { no: 5, name: "tail_line_end", kind: "message", T: () => exports.LineEndArchive },
            { no: 6, name: "strokePatternOffsetDistance", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.DrawableArchive super */ 1:
                    message.super = exports.DrawableArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference style */ 2:
                    message.style = TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options, message.style);
                    break;
                case /* optional TSD.PathSourceArchive pathsource */ 3:
                    message.pathsource = exports.PathSourceArchive.internalBinaryRead(reader, reader.uint32(), options, message.pathsource);
                    break;
                case /* optional TSD.LineEndArchive head_line_end = 4 [deprecated = true];*/ 4:
                    message.headLineEnd = exports.LineEndArchive.internalBinaryRead(reader, reader.uint32(), options, message.headLineEnd);
                    break;
                case /* optional TSD.LineEndArchive tail_line_end = 5 [deprecated = true];*/ 5:
                    message.tailLineEnd = exports.LineEndArchive.internalBinaryRead(reader, reader.uint32(), options, message.tailLineEnd);
                    break;
                case /* optional float strokePatternOffsetDistance */ 6:
                    message.strokePatternOffsetDistance = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.DrawableArchive super = 1; */
        if (message.super)
            exports.DrawableArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference style = 2; */
        if (message.style)
            TSPMessages_4.Reference.internalBinaryWrite(message.style, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.PathSourceArchive pathsource = 3; */
        if (message.pathsource)
            exports.PathSourceArchive.internalBinaryWrite(message.pathsource, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.LineEndArchive head_line_end = 4 [deprecated = true]; */
        if (message.headLineEnd)
            exports.LineEndArchive.internalBinaryWrite(message.headLineEnd, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.LineEndArchive tail_line_end = 5 [deprecated = true]; */
        if (message.tailLineEnd)
            exports.LineEndArchive.internalBinaryWrite(message.tailLineEnd, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional float strokePatternOffsetDistance = 6; */
        if (message.strokePatternOffsetDistance !== undefined)
            writer.tag(6, runtime_1.WireType.Bit32).float(message.strokePatternOffsetDistance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ShapeArchive
 */
exports.ShapeArchive = new ShapeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectionLineArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ConnectionLineArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.ShapeArchive },
            { no: 2, name: "connected_from", kind: "message", T: () => TSPMessages_4.Reference },
            { no: 3, name: "connected_to", kind: "message", T: () => TSPMessages_4.Reference },
            { no: 4, name: "connected_to_uuid", kind: "message", T: () => TSPMessages_2.UUID },
            { no: 5, name: "connected_from_uuid", kind: "message", T: () => TSPMessages_2.UUID }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.ShapeArchive super */ 1:
                    message.super = exports.ShapeArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference connected_from */ 2:
                    message.connectedFrom = TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options, message.connectedFrom);
                    break;
                case /* optional TSP.Reference connected_to */ 3:
                    message.connectedTo = TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options, message.connectedTo);
                    break;
                case /* optional TSP.UUID connected_to_uuid */ 4:
                    message.connectedToUuid = TSPMessages_2.UUID.internalBinaryRead(reader, reader.uint32(), options, message.connectedToUuid);
                    break;
                case /* optional TSP.UUID connected_from_uuid */ 5:
                    message.connectedFromUuid = TSPMessages_2.UUID.internalBinaryRead(reader, reader.uint32(), options, message.connectedFromUuid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.ShapeArchive super = 1; */
        if (message.super)
            exports.ShapeArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference connected_from = 2; */
        if (message.connectedFrom)
            TSPMessages_4.Reference.internalBinaryWrite(message.connectedFrom, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference connected_to = 3; */
        if (message.connectedTo)
            TSPMessages_4.Reference.internalBinaryWrite(message.connectedTo, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID connected_to_uuid = 4; */
        if (message.connectedToUuid)
            TSPMessages_2.UUID.internalBinaryWrite(message.connectedToUuid, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID connected_from_uuid = 5; */
        if (message.connectedFromUuid)
            TSPMessages_2.UUID.internalBinaryWrite(message.connectedFromUuid, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ConnectionLineArchive
 */
exports.ConnectionLineArchive = new ConnectionLineArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImageArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ImageArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.DrawableArchive },
            { no: 11, name: "data", kind: "message", T: () => TSPMessages_5.DataReference },
            { no: 3, name: "style", kind: "message", T: () => TSPMessages_4.Reference },
            { no: 4, name: "originalSize", kind: "message", T: () => TSPMessages_8.Size },
            { no: 5, name: "mask", kind: "message", T: () => TSPMessages_4.Reference },
            { no: 12, name: "thumbnailData", kind: "message", T: () => TSPMessages_5.DataReference },
            { no: 7, name: "flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "originalData", kind: "message", T: () => TSPMessages_5.DataReference },
            { no: 9, name: "naturalSize", kind: "message", T: () => TSPMessages_8.Size },
            { no: 10, name: "instantAlphaPath", kind: "message", T: () => TSPMessages_7.Path },
            { no: 14, name: "imageAdjustments", kind: "message", T: () => exports.ImageAdjustmentsArchive },
            { no: 17, name: "enhancedImageData", kind: "message", T: () => TSPMessages_5.DataReference },
            { no: 15, name: "adjustedImageData", kind: "message", T: () => TSPMessages_5.DataReference },
            { no: 16, name: "thumbnailAdjustedImageData", kind: "message", T: () => TSPMessages_5.DataReference },
            { no: 18, name: "interpretsUntaggedImageDataAsGeneric", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "database_data", kind: "message", T: () => TSPMessages_4.Reference },
            { no: 6, name: "database_thumbnailData", kind: "message", T: () => TSPMessages_4.Reference },
            { no: 8, name: "database_originalData", kind: "message", T: () => TSPMessages_4.Reference },
            { no: 19, name: "traced_path", kind: "message", T: () => TSPMessages_7.Path },
            { no: 20, name: "attribution", kind: "message", T: () => exports.Attribution },
            { no: 21, name: "should_trace_pdf_content", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 22, name: "background_removed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.DrawableArchive super */ 1:
                    message.super = exports.DrawableArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.DataReference data */ 11:
                    message.data = TSPMessages_5.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                case /* optional TSP.Reference style */ 3:
                    message.style = TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options, message.style);
                    break;
                case /* optional TSP.Size originalSize */ 4:
                    message.originalSize = TSPMessages_8.Size.internalBinaryRead(reader, reader.uint32(), options, message.originalSize);
                    break;
                case /* optional TSP.Reference mask */ 5:
                    message.mask = TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options, message.mask);
                    break;
                case /* optional TSP.DataReference thumbnailData */ 12:
                    message.thumbnailData = TSPMessages_5.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.thumbnailData);
                    break;
                case /* optional uint32 flags */ 7:
                    message.flags = reader.uint32();
                    break;
                case /* optional TSP.DataReference originalData */ 13:
                    message.originalData = TSPMessages_5.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.originalData);
                    break;
                case /* optional TSP.Size naturalSize */ 9:
                    message.naturalSize = TSPMessages_8.Size.internalBinaryRead(reader, reader.uint32(), options, message.naturalSize);
                    break;
                case /* optional TSP.Path instantAlphaPath */ 10:
                    message.instantAlphaPath = TSPMessages_7.Path.internalBinaryRead(reader, reader.uint32(), options, message.instantAlphaPath);
                    break;
                case /* optional TSD.ImageAdjustmentsArchive imageAdjustments */ 14:
                    message.imageAdjustments = exports.ImageAdjustmentsArchive.internalBinaryRead(reader, reader.uint32(), options, message.imageAdjustments);
                    break;
                case /* optional TSP.DataReference enhancedImageData */ 17:
                    message.enhancedImageData = TSPMessages_5.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.enhancedImageData);
                    break;
                case /* optional TSP.DataReference adjustedImageData */ 15:
                    message.adjustedImageData = TSPMessages_5.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.adjustedImageData);
                    break;
                case /* optional TSP.DataReference thumbnailAdjustedImageData */ 16:
                    message.thumbnailAdjustedImageData = TSPMessages_5.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.thumbnailAdjustedImageData);
                    break;
                case /* optional bool interpretsUntaggedImageDataAsGeneric */ 18:
                    message.interpretsUntaggedImageDataAsGeneric = reader.bool();
                    break;
                case /* optional TSP.Reference database_data */ 2:
                    message.databaseData = TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options, message.databaseData);
                    break;
                case /* optional TSP.Reference database_thumbnailData */ 6:
                    message.databaseThumbnailData = TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options, message.databaseThumbnailData);
                    break;
                case /* optional TSP.Reference database_originalData */ 8:
                    message.databaseOriginalData = TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options, message.databaseOriginalData);
                    break;
                case /* optional TSP.Path traced_path */ 19:
                    message.tracedPath = TSPMessages_7.Path.internalBinaryRead(reader, reader.uint32(), options, message.tracedPath);
                    break;
                case /* optional TSD.Attribution attribution */ 20:
                    message.attribution = exports.Attribution.internalBinaryRead(reader, reader.uint32(), options, message.attribution);
                    break;
                case /* optional bool should_trace_pdf_content */ 21:
                    message.shouldTracePdfContent = reader.bool();
                    break;
                case /* optional bool background_removed */ 22:
                    message.backgroundRemoved = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.DrawableArchive super = 1; */
        if (message.super)
            exports.DrawableArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference data = 11; */
        if (message.data)
            TSPMessages_5.DataReference.internalBinaryWrite(message.data, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference style = 3; */
        if (message.style)
            TSPMessages_4.Reference.internalBinaryWrite(message.style, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Size originalSize = 4; */
        if (message.originalSize)
            TSPMessages_8.Size.internalBinaryWrite(message.originalSize, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference mask = 5; */
        if (message.mask)
            TSPMessages_4.Reference.internalBinaryWrite(message.mask, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference thumbnailData = 12; */
        if (message.thumbnailData)
            TSPMessages_5.DataReference.internalBinaryWrite(message.thumbnailData, writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 flags = 7; */
        if (message.flags !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).uint32(message.flags);
        /* optional TSP.DataReference originalData = 13; */
        if (message.originalData)
            TSPMessages_5.DataReference.internalBinaryWrite(message.originalData, writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Size naturalSize = 9; */
        if (message.naturalSize)
            TSPMessages_8.Size.internalBinaryWrite(message.naturalSize, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Path instantAlphaPath = 10; */
        if (message.instantAlphaPath)
            TSPMessages_7.Path.internalBinaryWrite(message.instantAlphaPath, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.ImageAdjustmentsArchive imageAdjustments = 14; */
        if (message.imageAdjustments)
            exports.ImageAdjustmentsArchive.internalBinaryWrite(message.imageAdjustments, writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference enhancedImageData = 17; */
        if (message.enhancedImageData)
            TSPMessages_5.DataReference.internalBinaryWrite(message.enhancedImageData, writer.tag(17, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference adjustedImageData = 15; */
        if (message.adjustedImageData)
            TSPMessages_5.DataReference.internalBinaryWrite(message.adjustedImageData, writer.tag(15, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference thumbnailAdjustedImageData = 16; */
        if (message.thumbnailAdjustedImageData)
            TSPMessages_5.DataReference.internalBinaryWrite(message.thumbnailAdjustedImageData, writer.tag(16, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool interpretsUntaggedImageDataAsGeneric = 18; */
        if (message.interpretsUntaggedImageDataAsGeneric !== undefined)
            writer.tag(18, runtime_1.WireType.Varint).bool(message.interpretsUntaggedImageDataAsGeneric);
        /* optional TSP.Reference database_data = 2; */
        if (message.databaseData)
            TSPMessages_4.Reference.internalBinaryWrite(message.databaseData, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference database_thumbnailData = 6; */
        if (message.databaseThumbnailData)
            TSPMessages_4.Reference.internalBinaryWrite(message.databaseThumbnailData, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference database_originalData = 8; */
        if (message.databaseOriginalData)
            TSPMessages_4.Reference.internalBinaryWrite(message.databaseOriginalData, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Path traced_path = 19; */
        if (message.tracedPath)
            TSPMessages_7.Path.internalBinaryWrite(message.tracedPath, writer.tag(19, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.Attribution attribution = 20; */
        if (message.attribution)
            exports.Attribution.internalBinaryWrite(message.attribution, writer.tag(20, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool should_trace_pdf_content = 21; */
        if (message.shouldTracePdfContent !== undefined)
            writer.tag(21, runtime_1.WireType.Varint).bool(message.shouldTracePdfContent);
        /* optional bool background_removed = 22; */
        if (message.backgroundRemoved !== undefined)
            writer.tag(22, runtime_1.WireType.Varint).bool(message.backgroundRemoved);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ImageArchive
 */
exports.ImageArchive = new ImageArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MaskArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.MaskArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.DrawableArchive },
            { no: 2, name: "pathsource", kind: "message", T: () => exports.PathSourceArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.DrawableArchive super */ 1:
                    message.super = exports.DrawableArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSD.PathSourceArchive pathsource */ 2:
                    message.pathsource = exports.PathSourceArchive.internalBinaryRead(reader, reader.uint32(), options, message.pathsource);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.DrawableArchive super = 1; */
        if (message.super)
            exports.DrawableArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.PathSourceArchive pathsource = 2; */
        if (message.pathsource)
            exports.PathSourceArchive.internalBinaryWrite(message.pathsource, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.MaskArchive
 */
exports.MaskArchive = new MaskArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImageDataAttributes$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ImageDataAttributes", [
            { no: 1, name: "pixel_size", kind: "message", T: () => TSPMessages_8.Size },
            { no: 2, name: "image_is_srgb", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "should_be_interpreted_as_generic_if_untagged", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Size pixel_size */ 1:
                    message.pixelSize = TSPMessages_8.Size.internalBinaryRead(reader, reader.uint32(), options, message.pixelSize);
                    break;
                case /* optional bool image_is_srgb */ 2:
                    message.imageIsSrgb = reader.bool();
                    break;
                case /* optional bool should_be_interpreted_as_generic_if_untagged */ 3:
                    message.shouldBeInterpretedAsGenericIfUntagged = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Size pixel_size = 1; */
        if (message.pixelSize)
            TSPMessages_8.Size.internalBinaryWrite(message.pixelSize, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool image_is_srgb = 2; */
        if (message.imageIsSrgb !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.imageIsSrgb);
        /* optional bool should_be_interpreted_as_generic_if_untagged = 3; */
        if (message.shouldBeInterpretedAsGenericIfUntagged !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.shouldBeInterpretedAsGenericIfUntagged);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ImageDataAttributes
 */
exports.ImageDataAttributes = new ImageDataAttributes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MovieArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.MovieArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.DrawableArchive },
            { no: 14, name: "movieData", kind: "message", T: () => TSPMessages_5.DataReference },
            { no: 22, name: "importedAuxiliaryMovieData", kind: "message", T: () => TSPMessages_5.DataReference },
            { no: 25, name: "imported_auxiliary_movie_data_original_filename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "movieRemoteURL", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "startTime", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "endTime", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "posterTime", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "loopOptionAsInteger", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 24, name: "loop_option", kind: "enum", opt: true, T: () => ["TSD.MovieArchive.MovieLoopOption", MovieArchive_MovieLoopOption] },
            { no: 7, name: "volume", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "autoPlay", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "audioOnly", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "streaming", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 27, name: "nativeAudioRecording", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 28, name: "playsAcrossSlides", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "posterImageData", kind: "message", T: () => TSPMessages_5.DataReference },
            { no: 16, name: "audioOnlyImageData", kind: "message", T: () => TSPMessages_5.DataReference },
            { no: 23, name: "poster_image_generated_with_alpha_support", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "playableState", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "database_movieData", kind: "message", T: () => TSPMessages_4.Reference },
            { no: 10, name: "database_posterImageData", kind: "message", T: () => TSPMessages_4.Reference },
            { no: 11, name: "database_audioOnlyImageData", kind: "message", T: () => TSPMessages_4.Reference },
            { no: 19, name: "style", kind: "message", T: () => TSPMessages_4.Reference },
            { no: 20, name: "originalSize", kind: "message", T: () => TSPMessages_8.Size },
            { no: 21, name: "naturalSize", kind: "message", T: () => TSPMessages_8.Size },
            { no: 26, name: "attribution", kind: "message", T: () => exports.Attribution },
            { no: 29, name: "fingerprint", kind: "message", T: () => exports.MovieFingerprint },
            { no: 30, name: "is_live_video", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.DrawableArchive super */ 1:
                    message.super = exports.DrawableArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.DataReference movieData */ 14:
                    message.movieData = TSPMessages_5.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.movieData);
                    break;
                case /* optional TSP.DataReference importedAuxiliaryMovieData */ 22:
                    message.importedAuxiliaryMovieData = TSPMessages_5.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.importedAuxiliaryMovieData);
                    break;
                case /* optional string imported_auxiliary_movie_data_original_filename */ 25:
                    message.importedAuxiliaryMovieDataOriginalFilename = reader.string();
                    break;
                case /* optional string movieRemoteURL */ 17:
                    message.movieRemoteURL = reader.string();
                    break;
                case /* optional float startTime */ 3:
                    message.startTime = reader.float();
                    break;
                case /* optional float endTime */ 4:
                    message.endTime = reader.float();
                    break;
                case /* optional float posterTime */ 5:
                    message.posterTime = reader.float();
                    break;
                case /* optional uint32 loopOptionAsInteger = 6 [deprecated = true];*/ 6:
                    message.loopOptionAsInteger = reader.uint32();
                    break;
                case /* optional TSD.MovieArchive.MovieLoopOption loop_option */ 24:
                    message.loopOption = reader.int32();
                    break;
                case /* optional float volume */ 7:
                    message.volume = reader.float();
                    break;
                case /* optional bool autoPlay = 8 [deprecated = true];*/ 8:
                    message.autoPlay = reader.bool();
                    break;
                case /* optional bool audioOnly */ 9:
                    message.audioOnly = reader.bool();
                    break;
                case /* optional bool streaming */ 18:
                    message.streaming = reader.bool();
                    break;
                case /* optional bool nativeAudioRecording */ 27:
                    message.nativeAudioRecording = reader.bool();
                    break;
                case /* optional bool playsAcrossSlides */ 28:
                    message.playsAcrossSlides = reader.bool();
                    break;
                case /* optional TSP.DataReference posterImageData */ 15:
                    message.posterImageData = TSPMessages_5.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.posterImageData);
                    break;
                case /* optional TSP.DataReference audioOnlyImageData */ 16:
                    message.audioOnlyImageData = TSPMessages_5.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.audioOnlyImageData);
                    break;
                case /* optional bool poster_image_generated_with_alpha_support */ 23:
                    message.posterImageGeneratedWithAlphaSupport = reader.bool();
                    break;
                case /* optional uint32 playableState */ 12:
                    message.playableState = reader.uint32();
                    break;
                case /* optional uint32 flags */ 13:
                    message.flags = reader.uint32();
                    break;
                case /* optional TSP.Reference database_movieData */ 2:
                    message.databaseMovieData = TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options, message.databaseMovieData);
                    break;
                case /* optional TSP.Reference database_posterImageData */ 10:
                    message.databasePosterImageData = TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options, message.databasePosterImageData);
                    break;
                case /* optional TSP.Reference database_audioOnlyImageData */ 11:
                    message.databaseAudioOnlyImageData = TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options, message.databaseAudioOnlyImageData);
                    break;
                case /* optional TSP.Reference style */ 19:
                    message.style = TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options, message.style);
                    break;
                case /* optional TSP.Size originalSize */ 20:
                    message.originalSize = TSPMessages_8.Size.internalBinaryRead(reader, reader.uint32(), options, message.originalSize);
                    break;
                case /* optional TSP.Size naturalSize */ 21:
                    message.naturalSize = TSPMessages_8.Size.internalBinaryRead(reader, reader.uint32(), options, message.naturalSize);
                    break;
                case /* optional TSD.Attribution attribution */ 26:
                    message.attribution = exports.Attribution.internalBinaryRead(reader, reader.uint32(), options, message.attribution);
                    break;
                case /* optional TSD.MovieFingerprint fingerprint */ 29:
                    message.fingerprint = exports.MovieFingerprint.internalBinaryRead(reader, reader.uint32(), options, message.fingerprint);
                    break;
                case /* optional bool is_live_video */ 30:
                    message.isLiveVideo = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.DrawableArchive super = 1; */
        if (message.super)
            exports.DrawableArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference movieData = 14; */
        if (message.movieData)
            TSPMessages_5.DataReference.internalBinaryWrite(message.movieData, writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference importedAuxiliaryMovieData = 22; */
        if (message.importedAuxiliaryMovieData)
            TSPMessages_5.DataReference.internalBinaryWrite(message.importedAuxiliaryMovieData, writer.tag(22, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string imported_auxiliary_movie_data_original_filename = 25; */
        if (message.importedAuxiliaryMovieDataOriginalFilename !== undefined)
            writer.tag(25, runtime_1.WireType.LengthDelimited).string(message.importedAuxiliaryMovieDataOriginalFilename);
        /* optional string movieRemoteURL = 17; */
        if (message.movieRemoteURL !== undefined)
            writer.tag(17, runtime_1.WireType.LengthDelimited).string(message.movieRemoteURL);
        /* optional float startTime = 3; */
        if (message.startTime !== undefined)
            writer.tag(3, runtime_1.WireType.Bit32).float(message.startTime);
        /* optional float endTime = 4; */
        if (message.endTime !== undefined)
            writer.tag(4, runtime_1.WireType.Bit32).float(message.endTime);
        /* optional float posterTime = 5; */
        if (message.posterTime !== undefined)
            writer.tag(5, runtime_1.WireType.Bit32).float(message.posterTime);
        /* optional uint32 loopOptionAsInteger = 6 [deprecated = true]; */
        if (message.loopOptionAsInteger !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).uint32(message.loopOptionAsInteger);
        /* optional TSD.MovieArchive.MovieLoopOption loop_option = 24; */
        if (message.loopOption !== undefined)
            writer.tag(24, runtime_1.WireType.Varint).int32(message.loopOption);
        /* optional float volume = 7; */
        if (message.volume !== undefined)
            writer.tag(7, runtime_1.WireType.Bit32).float(message.volume);
        /* optional bool autoPlay = 8 [deprecated = true]; */
        if (message.autoPlay !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.autoPlay);
        /* optional bool audioOnly = 9; */
        if (message.audioOnly !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).bool(message.audioOnly);
        /* optional bool streaming = 18; */
        if (message.streaming !== undefined)
            writer.tag(18, runtime_1.WireType.Varint).bool(message.streaming);
        /* optional bool nativeAudioRecording = 27; */
        if (message.nativeAudioRecording !== undefined)
            writer.tag(27, runtime_1.WireType.Varint).bool(message.nativeAudioRecording);
        /* optional bool playsAcrossSlides = 28; */
        if (message.playsAcrossSlides !== undefined)
            writer.tag(28, runtime_1.WireType.Varint).bool(message.playsAcrossSlides);
        /* optional TSP.DataReference posterImageData = 15; */
        if (message.posterImageData)
            TSPMessages_5.DataReference.internalBinaryWrite(message.posterImageData, writer.tag(15, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference audioOnlyImageData = 16; */
        if (message.audioOnlyImageData)
            TSPMessages_5.DataReference.internalBinaryWrite(message.audioOnlyImageData, writer.tag(16, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool poster_image_generated_with_alpha_support = 23; */
        if (message.posterImageGeneratedWithAlphaSupport !== undefined)
            writer.tag(23, runtime_1.WireType.Varint).bool(message.posterImageGeneratedWithAlphaSupport);
        /* optional uint32 playableState = 12; */
        if (message.playableState !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).uint32(message.playableState);
        /* optional uint32 flags = 13; */
        if (message.flags !== undefined)
            writer.tag(13, runtime_1.WireType.Varint).uint32(message.flags);
        /* optional TSP.Reference database_movieData = 2; */
        if (message.databaseMovieData)
            TSPMessages_4.Reference.internalBinaryWrite(message.databaseMovieData, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference database_posterImageData = 10; */
        if (message.databasePosterImageData)
            TSPMessages_4.Reference.internalBinaryWrite(message.databasePosterImageData, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference database_audioOnlyImageData = 11; */
        if (message.databaseAudioOnlyImageData)
            TSPMessages_4.Reference.internalBinaryWrite(message.databaseAudioOnlyImageData, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference style = 19; */
        if (message.style)
            TSPMessages_4.Reference.internalBinaryWrite(message.style, writer.tag(19, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Size originalSize = 20; */
        if (message.originalSize)
            TSPMessages_8.Size.internalBinaryWrite(message.originalSize, writer.tag(20, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Size naturalSize = 21; */
        if (message.naturalSize)
            TSPMessages_8.Size.internalBinaryWrite(message.naturalSize, writer.tag(21, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.Attribution attribution = 26; */
        if (message.attribution)
            exports.Attribution.internalBinaryWrite(message.attribution, writer.tag(26, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.MovieFingerprint fingerprint = 29; */
        if (message.fingerprint)
            exports.MovieFingerprint.internalBinaryWrite(message.fingerprint, writer.tag(29, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_live_video = 30; */
        if (message.isLiveVideo !== undefined)
            writer.tag(30, runtime_1.WireType.Varint).bool(message.isLiveVideo);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.MovieArchive
 */
exports.MovieArchive = new MovieArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExteriorTextWrapArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ExteriorTextWrapArchive", [
            { no: 1, name: "type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "direction", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "fit_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "margin", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "alpha_threshold", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "is_html_wrap", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 type */ 1:
                    message.type = reader.uint32();
                    break;
                case /* optional uint32 direction */ 2:
                    message.direction = reader.uint32();
                    break;
                case /* optional uint32 fit_type */ 3:
                    message.fitType = reader.uint32();
                    break;
                case /* optional float margin */ 4:
                    message.margin = reader.float();
                    break;
                case /* optional float alpha_threshold */ 5:
                    message.alphaThreshold = reader.float();
                    break;
                case /* optional bool is_html_wrap */ 6:
                    message.isHtmlWrap = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional uint32 type = 1; */
        if (message.type !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.type);
        /* optional uint32 direction = 2; */
        if (message.direction !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.direction);
        /* optional uint32 fit_type = 3; */
        if (message.fitType !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.fitType);
        /* optional float margin = 4; */
        if (message.margin !== undefined)
            writer.tag(4, runtime_1.WireType.Bit32).float(message.margin);
        /* optional float alpha_threshold = 5; */
        if (message.alphaThreshold !== undefined)
            writer.tag(5, runtime_1.WireType.Bit32).float(message.alphaThreshold);
        /* optional bool is_html_wrap = 6; */
        if (message.isHtmlWrap !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.isHtmlWrap);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ExteriorTextWrapArchive
 */
exports.ExteriorTextWrapArchive = new ExteriorTextWrapArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DrawableContentDescription$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.DrawableContentDescription", [
            { no: 1, name: "element_kind", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "is_anchored_to_text", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "is_floating_above_text", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "is_inline_with_text", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 element_kind */ 1:
                    message.elementKind = reader.uint32();
                    break;
                case /* optional bool is_anchored_to_text */ 2:
                    message.isAnchoredToText = reader.bool();
                    break;
                case /* optional bool is_floating_above_text */ 3:
                    message.isFloatingAboveText = reader.bool();
                    break;
                case /* optional bool is_inline_with_text */ 4:
                    message.isInlineWithText = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional uint32 element_kind = 1; */
        if (message.elementKind !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.elementKind);
        /* optional bool is_anchored_to_text = 2; */
        if (message.isAnchoredToText !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.isAnchoredToText);
        /* optional bool is_floating_above_text = 3; */
        if (message.isFloatingAboveText !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.isFloatingAboveText);
        /* optional bool is_inline_with_text = 4; */
        if (message.isInlineWithText !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.isInlineWithText);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.DrawableContentDescription
 */
exports.DrawableContentDescription = new DrawableContentDescription$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FreehandDrawingContentDescription$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.FreehandDrawingContentDescription", [
            { no: 1, name: "super", kind: "message", T: () => exports.DrawableContentDescription },
            { no: 2, name: "source_doc_wanted_spacer_shape", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.DrawableContentDescription super */ 1:
                    message.super = exports.DrawableContentDescription.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional bool source_doc_wanted_spacer_shape */ 2:
                    message.sourceDocWantedSpacerShape = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.DrawableContentDescription super = 1; */
        if (message.super)
            exports.DrawableContentDescription.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool source_doc_wanted_spacer_shape = 2; */
        if (message.sourceDocWantedSpacerShape !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.sourceDocWantedSpacerShape);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.FreehandDrawingContentDescription
 */
exports.FreehandDrawingContentDescription = new FreehandDrawingContentDescription$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FreehandDrawingToolkitUIState$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.FreehandDrawingToolkitUIState", [
            { no: 1, name: "current_color", kind: "message", T: () => TSPMessages_6.Color },
            { no: 2, name: "most_recent_restorable_tool_type", kind: "enum", opt: true, T: () => ["TSD.FreehandDrawingToolkitUIState.FreehandDrawingToolType", FreehandDrawingToolkitUIState_FreehandDrawingToolType] },
            { no: 3, name: "pen_tool_opacity", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "pen_tool_unscaled_width", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "pencil_tool_opacity", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "pencil_tool_unscaled_width", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "crayon_tool_opacity", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "crayon_tool_unscaled_width", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "fill_tool_opacity", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "eraser_tool_scaled_width", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "eraser_tool_erases_whole_objects", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "pen_tool_color", kind: "message", T: () => TSPMessages_6.Color },
            { no: 13, name: "pencil_tool_color", kind: "message", T: () => TSPMessages_6.Color },
            { no: 14, name: "crayon_tool_color", kind: "message", T: () => TSPMessages_6.Color },
            { no: 15, name: "fill_tool_color", kind: "message", T: () => TSPMessages_6.Color }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Color current_color = 1 [deprecated = true];*/ 1:
                    message.currentColor = TSPMessages_6.Color.internalBinaryRead(reader, reader.uint32(), options, message.currentColor);
                    break;
                case /* optional TSD.FreehandDrawingToolkitUIState.FreehandDrawingToolType most_recent_restorable_tool_type */ 2:
                    message.mostRecentRestorableToolType = reader.int32();
                    break;
                case /* optional float pen_tool_opacity */ 3:
                    message.penToolOpacity = reader.float();
                    break;
                case /* optional float pen_tool_unscaled_width */ 4:
                    message.penToolUnscaledWidth = reader.float();
                    break;
                case /* optional float pencil_tool_opacity */ 5:
                    message.pencilToolOpacity = reader.float();
                    break;
                case /* optional float pencil_tool_unscaled_width */ 6:
                    message.pencilToolUnscaledWidth = reader.float();
                    break;
                case /* optional float crayon_tool_opacity */ 7:
                    message.crayonToolOpacity = reader.float();
                    break;
                case /* optional float crayon_tool_unscaled_width */ 8:
                    message.crayonToolUnscaledWidth = reader.float();
                    break;
                case /* optional float fill_tool_opacity */ 9:
                    message.fillToolOpacity = reader.float();
                    break;
                case /* optional float eraser_tool_scaled_width */ 10:
                    message.eraserToolScaledWidth = reader.float();
                    break;
                case /* optional bool eraser_tool_erases_whole_objects */ 11:
                    message.eraserToolErasesWholeObjects = reader.bool();
                    break;
                case /* optional TSP.Color pen_tool_color */ 12:
                    message.penToolColor = TSPMessages_6.Color.internalBinaryRead(reader, reader.uint32(), options, message.penToolColor);
                    break;
                case /* optional TSP.Color pencil_tool_color */ 13:
                    message.pencilToolColor = TSPMessages_6.Color.internalBinaryRead(reader, reader.uint32(), options, message.pencilToolColor);
                    break;
                case /* optional TSP.Color crayon_tool_color */ 14:
                    message.crayonToolColor = TSPMessages_6.Color.internalBinaryRead(reader, reader.uint32(), options, message.crayonToolColor);
                    break;
                case /* optional TSP.Color fill_tool_color */ 15:
                    message.fillToolColor = TSPMessages_6.Color.internalBinaryRead(reader, reader.uint32(), options, message.fillToolColor);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Color current_color = 1 [deprecated = true]; */
        if (message.currentColor)
            TSPMessages_6.Color.internalBinaryWrite(message.currentColor, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.FreehandDrawingToolkitUIState.FreehandDrawingToolType most_recent_restorable_tool_type = 2; */
        if (message.mostRecentRestorableToolType !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.mostRecentRestorableToolType);
        /* optional float pen_tool_opacity = 3; */
        if (message.penToolOpacity !== undefined)
            writer.tag(3, runtime_1.WireType.Bit32).float(message.penToolOpacity);
        /* optional float pen_tool_unscaled_width = 4; */
        if (message.penToolUnscaledWidth !== undefined)
            writer.tag(4, runtime_1.WireType.Bit32).float(message.penToolUnscaledWidth);
        /* optional float pencil_tool_opacity = 5; */
        if (message.pencilToolOpacity !== undefined)
            writer.tag(5, runtime_1.WireType.Bit32).float(message.pencilToolOpacity);
        /* optional float pencil_tool_unscaled_width = 6; */
        if (message.pencilToolUnscaledWidth !== undefined)
            writer.tag(6, runtime_1.WireType.Bit32).float(message.pencilToolUnscaledWidth);
        /* optional float crayon_tool_opacity = 7; */
        if (message.crayonToolOpacity !== undefined)
            writer.tag(7, runtime_1.WireType.Bit32).float(message.crayonToolOpacity);
        /* optional float crayon_tool_unscaled_width = 8; */
        if (message.crayonToolUnscaledWidth !== undefined)
            writer.tag(8, runtime_1.WireType.Bit32).float(message.crayonToolUnscaledWidth);
        /* optional float fill_tool_opacity = 9; */
        if (message.fillToolOpacity !== undefined)
            writer.tag(9, runtime_1.WireType.Bit32).float(message.fillToolOpacity);
        /* optional float eraser_tool_scaled_width = 10; */
        if (message.eraserToolScaledWidth !== undefined)
            writer.tag(10, runtime_1.WireType.Bit32).float(message.eraserToolScaledWidth);
        /* optional bool eraser_tool_erases_whole_objects = 11; */
        if (message.eraserToolErasesWholeObjects !== undefined)
            writer.tag(11, runtime_1.WireType.Varint).bool(message.eraserToolErasesWholeObjects);
        /* optional TSP.Color pen_tool_color = 12; */
        if (message.penToolColor)
            TSPMessages_6.Color.internalBinaryWrite(message.penToolColor, writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Color pencil_tool_color = 13; */
        if (message.pencilToolColor)
            TSPMessages_6.Color.internalBinaryWrite(message.pencilToolColor, writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Color crayon_tool_color = 14; */
        if (message.crayonToolColor)
            TSPMessages_6.Color.internalBinaryWrite(message.crayonToolColor, writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Color fill_tool_color = 15; */
        if (message.fillToolColor)
            TSPMessages_6.Color.internalBinaryWrite(message.fillToolColor, writer.tag(15, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.FreehandDrawingToolkitUIState
 */
exports.FreehandDrawingToolkitUIState = new FreehandDrawingToolkitUIState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StandinCaptionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.StandinCaptionArchive", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.StandinCaptionArchive
 */
exports.StandinCaptionArchive = new StandinCaptionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GuideArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.GuideArchive", [
            { no: 1, name: "type", kind: "enum", opt: true, T: () => ["TSD.GuideArchive.GuideType", GuideArchive_GuideType] },
            { no: 2, name: "offset", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "start", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "end", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "dynamic", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "infinite", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSD.GuideArchive.GuideType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional float offset */ 2:
                    message.offset = reader.float();
                    break;
                case /* optional float start */ 3:
                    message.start = reader.float();
                    break;
                case /* optional float end */ 4:
                    message.end = reader.float();
                    break;
                case /* optional bool dynamic */ 5:
                    message.dynamic = reader.bool();
                    break;
                case /* optional bool infinite */ 6:
                    message.infinite = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSD.GuideArchive.GuideType type = 1; */
        if (message.type !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.type);
        /* optional float offset = 2; */
        if (message.offset !== undefined)
            writer.tag(2, runtime_1.WireType.Bit32).float(message.offset);
        /* optional float start = 3; */
        if (message.start !== undefined)
            writer.tag(3, runtime_1.WireType.Bit32).float(message.start);
        /* optional float end = 4; */
        if (message.end !== undefined)
            writer.tag(4, runtime_1.WireType.Bit32).float(message.end);
        /* optional bool dynamic = 5; */
        if (message.dynamic !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.dynamic);
        /* optional bool infinite = 6; */
        if (message.infinite !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.infinite);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.GuideArchive
 */
exports.GuideArchive = new GuideArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserDefinedGuideArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.UserDefinedGuideArchive", [
            { no: 1, name: "type", kind: "enum", opt: true, T: () => ["TSD.UserDefinedGuideArchive.GuideType", UserDefinedGuideArchive_GuideType] },
            { no: 2, name: "position", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSD.UserDefinedGuideArchive.GuideType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional float position */ 2:
                    message.position = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSD.UserDefinedGuideArchive.GuideType type = 1; */
        if (message.type !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.type);
        /* optional float position = 2; */
        if (message.position !== undefined)
            writer.tag(2, runtime_1.WireType.Bit32).float(message.position);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.UserDefinedGuideArchive
 */
exports.UserDefinedGuideArchive = new UserDefinedGuideArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GuideStorageArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.GuideStorageArchive", [
            { no: 1, name: "userDefinedGuides", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.UserDefinedGuideArchive }
        ]);
    }
    create(value) {
        const message = { userDefinedGuides: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSD.UserDefinedGuideArchive userDefinedGuides */ 1:
                    message.userDefinedGuides.push(exports.UserDefinedGuideArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSD.UserDefinedGuideArchive userDefinedGuides = 1; */
        for (let i = 0; i < message.userDefinedGuides.length; i++)
            exports.UserDefinedGuideArchive.internalBinaryWrite(message.userDefinedGuides[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.GuideStorageArchive
 */
exports.GuideStorageArchive = new GuideStorageArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CanvasSelectionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.CanvasSelectionArchive", [
            { no: 1, name: "infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.Reference },
            { no: 3, name: "non_interactive_infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.Reference },
            { no: 2, name: "container", kind: "message", T: () => TSPMessages_4.Reference }
        ]);
    }
    create(value) {
        const message = { infos: [], nonInteractiveInfos: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.Reference infos */ 1:
                    message.infos.push(TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference non_interactive_infos */ 3:
                    message.nonInteractiveInfos.push(TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Reference container = 2 [deprecated = true];*/ 2:
                    message.container = TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options, message.container);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.Reference infos = 1; */
        for (let i = 0; i < message.infos.length; i++)
            TSPMessages_4.Reference.internalBinaryWrite(message.infos[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference non_interactive_infos = 3; */
        for (let i = 0; i < message.nonInteractiveInfos.length; i++)
            TSPMessages_4.Reference.internalBinaryWrite(message.nonInteractiveInfos[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference container = 2 [deprecated = true]; */
        if (message.container)
            TSPMessages_4.Reference.internalBinaryWrite(message.container, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.CanvasSelectionArchive
 */
exports.CanvasSelectionArchive = new CanvasSelectionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DrawableSelectionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.DrawableSelectionArchive", [
            { no: 2, name: "infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.Reference },
            { no: 3, name: "non_interactive_infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.Reference }
        ]);
    }
    create(value) {
        const message = { infos: [], nonInteractiveInfos: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.Reference infos */ 2:
                    message.infos.push(TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference non_interactive_infos */ 3:
                    message.nonInteractiveInfos.push(TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.Reference infos = 2; */
        for (let i = 0; i < message.infos.length; i++)
            TSPMessages_4.Reference.internalBinaryWrite(message.infos[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference non_interactive_infos = 3; */
        for (let i = 0; i < message.nonInteractiveInfos.length; i++)
            TSPMessages_4.Reference.internalBinaryWrite(message.nonInteractiveInfos[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.DrawableSelectionArchive
 */
exports.DrawableSelectionArchive = new DrawableSelectionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupSelectionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.GroupSelectionArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.DrawableSelectionArchive },
            { no: 2, name: "has_selected_infos_in_non_group_container", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.DrawableSelectionArchive super */ 1:
                    message.super = exports.DrawableSelectionArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional bool has_selected_infos_in_non_group_container */ 2:
                    message.hasSelectedInfosInNonGroupContainer = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.DrawableSelectionArchive super = 1; */
        if (message.super)
            exports.DrawableSelectionArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool has_selected_infos_in_non_group_container = 2; */
        if (message.hasSelectedInfosInNonGroupContainer !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.hasSelectedInfosInNonGroupContainer);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.GroupSelectionArchive
 */
exports.GroupSelectionArchive = new GroupSelectionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PathSelectionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.PathSelectionArchive", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.PathSelectionArchive
 */
exports.PathSelectionArchive = new PathSelectionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InfoHyperlinkSelectionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.InfoHyperlinkSelectionArchive", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.InfoHyperlinkSelectionArchive
 */
exports.InfoHyperlinkSelectionArchive = new InfoHyperlinkSelectionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommentStorageArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.CommentStorageArchive", [
            { no: 1, name: "text", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "creation_date", kind: "message", T: () => TSPMessages_1.Date },
            { no: 3, name: "author", kind: "message", T: () => TSPMessages_4.Reference },
            { no: 4, name: "replies", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.Reference },
            { no: 5, name: "storage_uuid", kind: "message", T: () => TSPMessages_2.UUID }
        ]);
    }
    create(value) {
        const message = { replies: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string text */ 1:
                    message.text = reader.string();
                    break;
                case /* optional TSP.Date creation_date */ 2:
                    message.creationDate = TSPMessages_1.Date.internalBinaryRead(reader, reader.uint32(), options, message.creationDate);
                    break;
                case /* optional TSP.Reference author */ 3:
                    message.author = TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options, message.author);
                    break;
                case /* repeated TSP.Reference replies */ 4:
                    message.replies.push(TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.UUID storage_uuid */ 5:
                    message.storageUuid = TSPMessages_2.UUID.internalBinaryRead(reader, reader.uint32(), options, message.storageUuid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string text = 1; */
        if (message.text !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.text);
        /* optional TSP.Date creation_date = 2; */
        if (message.creationDate)
            TSPMessages_1.Date.internalBinaryWrite(message.creationDate, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference author = 3; */
        if (message.author)
            TSPMessages_4.Reference.internalBinaryWrite(message.author, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference replies = 4; */
        for (let i = 0; i < message.replies.length; i++)
            TSPMessages_4.Reference.internalBinaryWrite(message.replies[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID storage_uuid = 5; */
        if (message.storageUuid)
            TSPMessages_2.UUID.internalBinaryWrite(message.storageUuid, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.CommentStorageArchive
 */
exports.CommentStorageArchive = new CommentStorageArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReplaceAnnotationAuthorCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ReplaceAnnotationAuthorCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_1.CommandArchive },
            { no: 2, name: "old_annotation_author", kind: "message", T: () => TSPMessages_4.Reference },
            { no: 3, name: "new_annotation_author", kind: "message", T: () => TSPMessages_4.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_1.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference old_annotation_author */ 2:
                    message.oldAnnotationAuthor = TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options, message.oldAnnotationAuthor);
                    break;
                case /* optional TSP.Reference new_annotation_author */ 3:
                    message.newAnnotationAuthor = TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options, message.newAnnotationAuthor);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_1.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference old_annotation_author = 2; */
        if (message.oldAnnotationAuthor)
            TSPMessages_4.Reference.internalBinaryWrite(message.oldAnnotationAuthor, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference new_annotation_author = 3; */
        if (message.newAnnotationAuthor)
            TSPMessages_4.Reference.internalBinaryWrite(message.newAnnotationAuthor, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ReplaceAnnotationAuthorCommandArchive
 */
exports.ReplaceAnnotationAuthorCommandArchive = new ReplaceAnnotationAuthorCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PencilAnnotationArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.PencilAnnotationArchive", [
            { no: 1, name: "pencil_annotation_storage", kind: "message", T: () => TSPMessages_4.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference pencil_annotation_storage */ 1:
                    message.pencilAnnotationStorage = TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options, message.pencilAnnotationStorage);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference pencil_annotation_storage = 1; */
        if (message.pencilAnnotationStorage)
            TSPMessages_4.Reference.internalBinaryWrite(message.pencilAnnotationStorage, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.PencilAnnotationArchive
 */
exports.PencilAnnotationArchive = new PencilAnnotationArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PencilAnnotationSelectionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.PencilAnnotationSelectionArchive", [
            { no: 1, name: "pencil_annotation", kind: "message", T: () => TSPMessages_4.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference pencil_annotation */ 1:
                    message.pencilAnnotation = TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options, message.pencilAnnotation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference pencil_annotation = 1; */
        if (message.pencilAnnotation)
            TSPMessages_4.Reference.internalBinaryWrite(message.pencilAnnotation, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.PencilAnnotationSelectionArchive
 */
exports.PencilAnnotationSelectionArchive = new PencilAnnotationSelectionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PencilAnnotationStorageArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.PencilAnnotationStorageArchive", [
            { no: 1, name: "attached_location", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "markup_offset", kind: "message", T: () => TSPMessages_9.Point },
            { no: 3, name: "rasterized_image", kind: "message", T: () => TSPMessages_5.DataReference },
            { no: 4, name: "legacy_encoded_drawing", kind: "message", T: () => TSPMessages_5.DataReference },
            { no: 5, name: "drawing_path", kind: "message", T: () => TSPMessages_7.Path },
            { no: 6, name: "strokes_bounding_box_origin", kind: "message", T: () => TSPMessages_9.Point },
            { no: 7, name: "strokes_bounding_box_size", kind: "message", T: () => TSPMessages_8.Size },
            { no: 8, name: "attached_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "original_attached_size", kind: "message", T: () => TSPMessages_8.Size },
            { no: 10, name: "percent_of_pa_contained_in_parent_rep", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 11, name: "text_baselines_touched_count", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "visible_strokes_count", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "pen_color", kind: "message", T: () => TSPMessages_6.Color },
            { no: 14, name: "tool_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "callout_sub_storages", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.Reference },
            { no: 16, name: "creation_date", kind: "message", T: () => TSPMessages_1.Date },
            { no: 17, name: "pencil_annotation_drawing_scale", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 18, name: "compound_annotation_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 19, name: "sub_storages", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.Reference },
            { no: 20, name: "encoded_drawing", kind: "message", T: () => TSPMessages_5.DataReference },
            { no: 21, name: "stroke_points_frame_origin", kind: "message", T: () => TSPMessages_9.Point },
            { no: 22, name: "stroke_points_frame_size", kind: "message", T: () => TSPMessages_8.Size },
            { no: 23, name: "rendered_frame_origin", kind: "message", T: () => TSPMessages_9.Point },
            { no: 24, name: "rendered_frame_size", kind: "message", T: () => TSPMessages_8.Size }
        ]);
    }
    create(value) {
        const message = { calloutSubStorages: [], subStorages: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 attached_location */ 1:
                    message.attachedLocation = reader.int32();
                    break;
                case /* optional TSP.Point markup_offset */ 2:
                    message.markupOffset = TSPMessages_9.Point.internalBinaryRead(reader, reader.uint32(), options, message.markupOffset);
                    break;
                case /* optional TSP.DataReference rasterized_image */ 3:
                    message.rasterizedImage = TSPMessages_5.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.rasterizedImage);
                    break;
                case /* optional TSP.DataReference legacy_encoded_drawing */ 4:
                    message.legacyEncodedDrawing = TSPMessages_5.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.legacyEncodedDrawing);
                    break;
                case /* optional TSP.Path drawing_path */ 5:
                    message.drawingPath = TSPMessages_7.Path.internalBinaryRead(reader, reader.uint32(), options, message.drawingPath);
                    break;
                case /* optional TSP.Point strokes_bounding_box_origin */ 6:
                    message.strokesBoundingBoxOrigin = TSPMessages_9.Point.internalBinaryRead(reader, reader.uint32(), options, message.strokesBoundingBoxOrigin);
                    break;
                case /* optional TSP.Size strokes_bounding_box_size */ 7:
                    message.strokesBoundingBoxSize = TSPMessages_8.Size.internalBinaryRead(reader, reader.uint32(), options, message.strokesBoundingBoxSize);
                    break;
                case /* optional int32 attached_type */ 8:
                    message.attachedType = reader.int32();
                    break;
                case /* optional TSP.Size original_attached_size */ 9:
                    message.originalAttachedSize = TSPMessages_8.Size.internalBinaryRead(reader, reader.uint32(), options, message.originalAttachedSize);
                    break;
                case /* optional double percent_of_pa_contained_in_parent_rep */ 10:
                    message.percentOfPaContainedInParentRep = reader.double();
                    break;
                case /* optional uint64 text_baselines_touched_count */ 11:
                    message.textBaselinesTouchedCount = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 visible_strokes_count */ 12:
                    message.visibleStrokesCount = reader.uint64().toBigInt();
                    break;
                case /* optional TSP.Color pen_color */ 13:
                    message.penColor = TSPMessages_6.Color.internalBinaryRead(reader, reader.uint32(), options, message.penColor);
                    break;
                case /* optional int32 tool_type */ 14:
                    message.toolType = reader.int32();
                    break;
                case /* repeated TSP.Reference callout_sub_storages */ 15:
                    message.calloutSubStorages.push(TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Date creation_date */ 16:
                    message.creationDate = TSPMessages_1.Date.internalBinaryRead(reader, reader.uint32(), options, message.creationDate);
                    break;
                case /* optional double pencil_annotation_drawing_scale */ 17:
                    message.pencilAnnotationDrawingScale = reader.double();
                    break;
                case /* optional int32 compound_annotation_type */ 18:
                    message.compoundAnnotationType = reader.int32();
                    break;
                case /* repeated TSP.Reference sub_storages */ 19:
                    message.subStorages.push(TSPMessages_4.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.DataReference encoded_drawing */ 20:
                    message.encodedDrawing = TSPMessages_5.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.encodedDrawing);
                    break;
                case /* optional TSP.Point stroke_points_frame_origin */ 21:
                    message.strokePointsFrameOrigin = TSPMessages_9.Point.internalBinaryRead(reader, reader.uint32(), options, message.strokePointsFrameOrigin);
                    break;
                case /* optional TSP.Size stroke_points_frame_size */ 22:
                    message.strokePointsFrameSize = TSPMessages_8.Size.internalBinaryRead(reader, reader.uint32(), options, message.strokePointsFrameSize);
                    break;
                case /* optional TSP.Point rendered_frame_origin */ 23:
                    message.renderedFrameOrigin = TSPMessages_9.Point.internalBinaryRead(reader, reader.uint32(), options, message.renderedFrameOrigin);
                    break;
                case /* optional TSP.Size rendered_frame_size */ 24:
                    message.renderedFrameSize = TSPMessages_8.Size.internalBinaryRead(reader, reader.uint32(), options, message.renderedFrameSize);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional int32 attached_location = 1; */
        if (message.attachedLocation !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.attachedLocation);
        /* optional TSP.Point markup_offset = 2; */
        if (message.markupOffset)
            TSPMessages_9.Point.internalBinaryWrite(message.markupOffset, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference rasterized_image = 3; */
        if (message.rasterizedImage)
            TSPMessages_5.DataReference.internalBinaryWrite(message.rasterizedImage, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference legacy_encoded_drawing = 4; */
        if (message.legacyEncodedDrawing)
            TSPMessages_5.DataReference.internalBinaryWrite(message.legacyEncodedDrawing, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Path drawing_path = 5; */
        if (message.drawingPath)
            TSPMessages_7.Path.internalBinaryWrite(message.drawingPath, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Point strokes_bounding_box_origin = 6; */
        if (message.strokesBoundingBoxOrigin)
            TSPMessages_9.Point.internalBinaryWrite(message.strokesBoundingBoxOrigin, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Size strokes_bounding_box_size = 7; */
        if (message.strokesBoundingBoxSize)
            TSPMessages_8.Size.internalBinaryWrite(message.strokesBoundingBoxSize, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional int32 attached_type = 8; */
        if (message.attachedType !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).int32(message.attachedType);
        /* optional TSP.Size original_attached_size = 9; */
        if (message.originalAttachedSize)
            TSPMessages_8.Size.internalBinaryWrite(message.originalAttachedSize, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional double percent_of_pa_contained_in_parent_rep = 10; */
        if (message.percentOfPaContainedInParentRep !== undefined)
            writer.tag(10, runtime_1.WireType.Bit64).double(message.percentOfPaContainedInParentRep);
        /* optional uint64 text_baselines_touched_count = 11; */
        if (message.textBaselinesTouchedCount !== undefined)
            writer.tag(11, runtime_1.WireType.Varint).uint64(message.textBaselinesTouchedCount);
        /* optional uint64 visible_strokes_count = 12; */
        if (message.visibleStrokesCount !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).uint64(message.visibleStrokesCount);
        /* optional TSP.Color pen_color = 13; */
        if (message.penColor)
            TSPMessages_6.Color.internalBinaryWrite(message.penColor, writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional int32 tool_type = 14; */
        if (message.toolType !== undefined)
            writer.tag(14, runtime_1.WireType.Varint).int32(message.toolType);
        /* repeated TSP.Reference callout_sub_storages = 15; */
        for (let i = 0; i < message.calloutSubStorages.length; i++)
            TSPMessages_4.Reference.internalBinaryWrite(message.calloutSubStorages[i], writer.tag(15, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Date creation_date = 16; */
        if (message.creationDate)
            TSPMessages_1.Date.internalBinaryWrite(message.creationDate, writer.tag(16, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional double pencil_annotation_drawing_scale = 17; */
        if (message.pencilAnnotationDrawingScale !== undefined)
            writer.tag(17, runtime_1.WireType.Bit64).double(message.pencilAnnotationDrawingScale);
        /* optional int32 compound_annotation_type = 18; */
        if (message.compoundAnnotationType !== undefined)
            writer.tag(18, runtime_1.WireType.Varint).int32(message.compoundAnnotationType);
        /* repeated TSP.Reference sub_storages = 19; */
        for (let i = 0; i < message.subStorages.length; i++)
            TSPMessages_4.Reference.internalBinaryWrite(message.subStorages[i], writer.tag(19, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference encoded_drawing = 20; */
        if (message.encodedDrawing)
            TSPMessages_5.DataReference.internalBinaryWrite(message.encodedDrawing, writer.tag(20, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Point stroke_points_frame_origin = 21; */
        if (message.strokePointsFrameOrigin)
            TSPMessages_9.Point.internalBinaryWrite(message.strokePointsFrameOrigin, writer.tag(21, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Size stroke_points_frame_size = 22; */
        if (message.strokePointsFrameSize)
            TSPMessages_8.Size.internalBinaryWrite(message.strokePointsFrameSize, writer.tag(22, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Point rendered_frame_origin = 23; */
        if (message.renderedFrameOrigin)
            TSPMessages_9.Point.internalBinaryWrite(message.renderedFrameOrigin, writer.tag(23, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Size rendered_frame_size = 24; */
        if (message.renderedFrameSize)
            TSPMessages_8.Size.internalBinaryWrite(message.renderedFrameSize, writer.tag(24, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.PencilAnnotationStorageArchive
 */
exports.PencilAnnotationStorageArchive = new PencilAnnotationStorageArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpecColorFillSetColorArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.SpecColorFillSetColorArchive", [
            { no: 1, name: "color", kind: "message", T: () => TSPMessages_6.Color }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.Color color */ 1:
                    message.color = TSPMessages_6.Color.internalBinaryRead(reader, reader.uint32(), options, message.color);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.Color color = 1; */
        if (message.color)
            TSPMessages_6.Color.internalBinaryWrite(message.color, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.SpecColorFillSetColorArchive
 */
exports.SpecColorFillSetColorArchive = new SpecColorFillSetColorArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpecFrameSetAssetScaleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.SpecFrameSetAssetScaleArchive", [
            { no: 1, name: "asset_scale", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value) {
        const message = { assetScale: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double asset_scale */ 1:
                    message.assetScale = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* double asset_scale = 1; */
        if (message.assetScale !== 0)
            writer.tag(1, runtime_1.WireType.Bit64).double(message.assetScale);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.SpecFrameSetAssetScaleArchive
 */
exports.SpecFrameSetAssetScaleArchive = new SpecFrameSetAssetScaleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpecGradientFillSetAngleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.SpecGradientFillSetAngleArchive", [
            { no: 1, name: "angle", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value) {
        const message = { angle: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double angle */ 1:
                    message.angle = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* double angle = 1; */
        if (message.angle !== 0)
            writer.tag(1, runtime_1.WireType.Bit64).double(message.angle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.SpecGradientFillSetAngleArchive
 */
exports.SpecGradientFillSetAngleArchive = new SpecGradientFillSetAngleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpecImageFillSetTechniqueArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.SpecImageFillSetTechniqueArchive", [
            { no: 1, name: "technique", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = { technique: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 technique */ 1:
                    message.technique = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int32 technique = 1; */
        if (message.technique !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.technique);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.SpecImageFillSetTechniqueArchive
 */
exports.SpecImageFillSetTechniqueArchive = new SpecImageFillSetTechniqueArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpecReflectionSetOpacityArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.SpecReflectionSetOpacityArchive", [
            { no: 1, name: "opacity", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value) {
        const message = { opacity: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double opacity */ 1:
                    message.opacity = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* double opacity = 1; */
        if (message.opacity !== 0)
            writer.tag(1, runtime_1.WireType.Bit64).double(message.opacity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.SpecReflectionSetOpacityArchive
 */
exports.SpecReflectionSetOpacityArchive = new SpecReflectionSetOpacityArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpecShadowSetAngleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.SpecShadowSetAngleArchive", [
            { no: 1, name: "angle", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value) {
        const message = { angle: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double angle */ 1:
                    message.angle = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* double angle = 1; */
        if (message.angle !== 0)
            writer.tag(1, runtime_1.WireType.Bit64).double(message.angle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.SpecShadowSetAngleArchive
 */
exports.SpecShadowSetAngleArchive = new SpecShadowSetAngleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpecShadowSetColorArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.SpecShadowSetColorArchive", [
            { no: 1, name: "color", kind: "message", T: () => TSPMessages_6.Color }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.Color color */ 1:
                    message.color = TSPMessages_6.Color.internalBinaryRead(reader, reader.uint32(), options, message.color);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.Color color = 1; */
        if (message.color)
            TSPMessages_6.Color.internalBinaryWrite(message.color, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.SpecShadowSetColorArchive
 */
exports.SpecShadowSetColorArchive = new SpecShadowSetColorArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpecShadowSetOffsetArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.SpecShadowSetOffsetArchive", [
            { no: 1, name: "offset", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value) {
        const message = { offset: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double offset */ 1:
                    message.offset = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* double offset = 1; */
        if (message.offset !== 0)
            writer.tag(1, runtime_1.WireType.Bit64).double(message.offset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.SpecShadowSetOffsetArchive
 */
exports.SpecShadowSetOffsetArchive = new SpecShadowSetOffsetArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpecShadowSetOpacityArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.SpecShadowSetOpacityArchive", [
            { no: 1, name: "opacity", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value) {
        const message = { opacity: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double opacity */ 1:
                    message.opacity = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* double opacity = 1; */
        if (message.opacity !== 0)
            writer.tag(1, runtime_1.WireType.Bit64).double(message.opacity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.SpecShadowSetOpacityArchive
 */
exports.SpecShadowSetOpacityArchive = new SpecShadowSetOpacityArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpecShadowSetRadiusArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.SpecShadowSetRadiusArchive", [
            { no: 1, name: "radius", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = { radius: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 radius */ 1:
                    message.radius = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int32 radius = 1; */
        if (message.radius !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.radius);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.SpecShadowSetRadiusArchive
 */
exports.SpecShadowSetRadiusArchive = new SpecShadowSetRadiusArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpecStrokeSetColorArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.SpecStrokeSetColorArchive", [
            { no: 1, name: "color", kind: "message", T: () => TSPMessages_6.Color }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.Color color */ 1:
                    message.color = TSPMessages_6.Color.internalBinaryRead(reader, reader.uint32(), options, message.color);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.Color color = 1; */
        if (message.color)
            TSPMessages_6.Color.internalBinaryWrite(message.color, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.SpecStrokeSetColorArchive
 */
exports.SpecStrokeSetColorArchive = new SpecStrokeSetColorArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpecStrokeSetPatternArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.SpecStrokeSetPatternArchive", [
            { no: 1, name: "line_cap", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "line_join", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "miter_limit", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "width", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "color", kind: "message", T: () => TSPMessages_6.Color },
            { no: 6, name: "pattern", kind: "message", T: () => exports.StrokePatternArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 line_cap */ 1:
                    message.lineCap = reader.int32();
                    break;
                case /* optional int32 line_join */ 2:
                    message.lineJoin = reader.int32();
                    break;
                case /* optional double miter_limit */ 3:
                    message.miterLimit = reader.double();
                    break;
                case /* optional double width */ 4:
                    message.width = reader.double();
                    break;
                case /* optional TSP.Color color */ 5:
                    message.color = TSPMessages_6.Color.internalBinaryRead(reader, reader.uint32(), options, message.color);
                    break;
                case /* TSD.StrokePatternArchive pattern */ 6:
                    message.pattern = exports.StrokePatternArchive.internalBinaryRead(reader, reader.uint32(), options, message.pattern);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional int32 line_cap = 1; */
        if (message.lineCap !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.lineCap);
        /* optional int32 line_join = 2; */
        if (message.lineJoin !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.lineJoin);
        /* optional double miter_limit = 3; */
        if (message.miterLimit !== undefined)
            writer.tag(3, runtime_1.WireType.Bit64).double(message.miterLimit);
        /* optional double width = 4; */
        if (message.width !== undefined)
            writer.tag(4, runtime_1.WireType.Bit64).double(message.width);
        /* optional TSP.Color color = 5; */
        if (message.color)
            TSPMessages_6.Color.internalBinaryWrite(message.color, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSD.StrokePatternArchive pattern = 6; */
        if (message.pattern)
            exports.StrokePatternArchive.internalBinaryWrite(message.pattern, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.SpecStrokeSetPatternArchive
 */
exports.SpecStrokeSetPatternArchive = new SpecStrokeSetPatternArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpecStrokeSetWidthArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.SpecStrokeSetWidthArchive", [
            { no: 1, name: "width", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value) {
        const message = { width: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double width */ 1:
                    message.width = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* double width = 1; */
        if (message.width !== 0)
            writer.tag(1, runtime_1.WireType.Bit64).double(message.width);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.SpecStrokeSetWidthArchive
 */
exports.SpecStrokeSetWidthArchive = new SpecStrokeSetWidthArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Attribution$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.Attribution", [
            { no: 1, name: "title", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description_text", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "external_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "author_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "author_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string title */ 1:
                    message.title = reader.string();
                    break;
                case /* optional string description_text */ 2:
                    message.descriptionText = reader.string();
                    break;
                case /* optional string external_url */ 3:
                    message.externalUrl = reader.string();
                    break;
                case /* optional string author_name */ 4:
                    message.authorName = reader.string();
                    break;
                case /* optional string author_url */ 5:
                    message.authorUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string title = 1; */
        if (message.title !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.title);
        /* optional string description_text = 2; */
        if (message.descriptionText !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.descriptionText);
        /* optional string external_url = 3; */
        if (message.externalUrl !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.externalUrl);
        /* optional string author_name = 4; */
        if (message.authorName !== undefined)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.authorName);
        /* optional string author_url = 5; */
        if (message.authorUrl !== undefined)
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.authorUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.Attribution
 */
exports.Attribution = new Attribution$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MovieFingerprint$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.MovieFingerprint", [
            { no: 1, name: "tracks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.MovieFingerprintTrack },
            { no: 2, name: "version", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { tracks: [], version: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSD.MovieFingerprintTrack tracks */ 1:
                    message.tracks.push(exports.MovieFingerprintTrack.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 version = 2 [packed = true];*/ 2:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.version.push(reader.uint32());
                    else
                        message.version.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSD.MovieFingerprintTrack tracks = 1; */
        for (let i = 0; i < message.tracks.length; i++)
            exports.MovieFingerprintTrack.internalBinaryWrite(message.tracks[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 version = 2 [packed = true]; */
        if (message.version.length) {
            writer.tag(2, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.version.length; i++)
                writer.uint32(message.version[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.MovieFingerprint
 */
exports.MovieFingerprint = new MovieFingerprint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MovieFingerprintTrack$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.MovieFingerprintTrack", [
            { no: 1, name: "media_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "total_sample_data_length", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "sample_data_digest_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "time_range_start_value", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "time_range_start_timescale", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "time_range_start_is_valid", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "time_range_duration_value", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "time_range_duration_timescale", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "time_range_duration_is_valid", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "natural_size", kind: "message", T: () => TSPMessages_8.Size },
            { no: 12, name: "preferred_transform_a", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 13, name: "preferred_transform_b", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 14, name: "preferred_transform_c", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 15, name: "preferred_transform_d", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 16, name: "preferred_transform_tx", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 17, name: "preferred_transform_ty", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 18, name: "preferred_volume", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 19, name: "language_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "extended_language_tag", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string media_type */ 1:
                    message.mediaType = reader.string();
                    break;
                case /* optional bool enabled */ 2:
                    message.enabled = reader.bool();
                    break;
                case /* optional int64 total_sample_data_length */ 3:
                    message.totalSampleDataLength = reader.int64().toBigInt();
                    break;
                case /* optional string sample_data_digest_string */ 4:
                    message.sampleDataDigestString = reader.string();
                    break;
                case /* optional int64 time_range_start_value */ 5:
                    message.timeRangeStartValue = reader.int64().toBigInt();
                    break;
                case /* optional int32 time_range_start_timescale */ 6:
                    message.timeRangeStartTimescale = reader.int32();
                    break;
                case /* optional bool time_range_start_is_valid */ 7:
                    message.timeRangeStartIsValid = reader.bool();
                    break;
                case /* optional int64 time_range_duration_value */ 8:
                    message.timeRangeDurationValue = reader.int64().toBigInt();
                    break;
                case /* optional int32 time_range_duration_timescale */ 9:
                    message.timeRangeDurationTimescale = reader.int32();
                    break;
                case /* optional bool time_range_duration_is_valid */ 10:
                    message.timeRangeDurationIsValid = reader.bool();
                    break;
                case /* optional TSP.Size natural_size */ 11:
                    message.naturalSize = TSPMessages_8.Size.internalBinaryRead(reader, reader.uint32(), options, message.naturalSize);
                    break;
                case /* optional double preferred_transform_a */ 12:
                    message.preferredTransformA = reader.double();
                    break;
                case /* optional double preferred_transform_b */ 13:
                    message.preferredTransformB = reader.double();
                    break;
                case /* optional double preferred_transform_c */ 14:
                    message.preferredTransformC = reader.double();
                    break;
                case /* optional double preferred_transform_d */ 15:
                    message.preferredTransformD = reader.double();
                    break;
                case /* optional double preferred_transform_tx */ 16:
                    message.preferredTransformTx = reader.double();
                    break;
                case /* optional double preferred_transform_ty */ 17:
                    message.preferredTransformTy = reader.double();
                    break;
                case /* optional double preferred_volume */ 18:
                    message.preferredVolume = reader.double();
                    break;
                case /* optional string language_code */ 19:
                    message.languageCode = reader.string();
                    break;
                case /* optional string extended_language_tag */ 20:
                    message.extendedLanguageTag = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string media_type = 1; */
        if (message.mediaType !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.mediaType);
        /* optional bool enabled = 2; */
        if (message.enabled !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.enabled);
        /* optional int64 total_sample_data_length = 3; */
        if (message.totalSampleDataLength !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).int64(message.totalSampleDataLength);
        /* optional string sample_data_digest_string = 4; */
        if (message.sampleDataDigestString !== undefined)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.sampleDataDigestString);
        /* optional int64 time_range_start_value = 5; */
        if (message.timeRangeStartValue !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).int64(message.timeRangeStartValue);
        /* optional int32 time_range_start_timescale = 6; */
        if (message.timeRangeStartTimescale !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).int32(message.timeRangeStartTimescale);
        /* optional bool time_range_start_is_valid = 7; */
        if (message.timeRangeStartIsValid !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.timeRangeStartIsValid);
        /* optional int64 time_range_duration_value = 8; */
        if (message.timeRangeDurationValue !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).int64(message.timeRangeDurationValue);
        /* optional int32 time_range_duration_timescale = 9; */
        if (message.timeRangeDurationTimescale !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).int32(message.timeRangeDurationTimescale);
        /* optional bool time_range_duration_is_valid = 10; */
        if (message.timeRangeDurationIsValid !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).bool(message.timeRangeDurationIsValid);
        /* optional TSP.Size natural_size = 11; */
        if (message.naturalSize)
            TSPMessages_8.Size.internalBinaryWrite(message.naturalSize, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional double preferred_transform_a = 12; */
        if (message.preferredTransformA !== undefined)
            writer.tag(12, runtime_1.WireType.Bit64).double(message.preferredTransformA);
        /* optional double preferred_transform_b = 13; */
        if (message.preferredTransformB !== undefined)
            writer.tag(13, runtime_1.WireType.Bit64).double(message.preferredTransformB);
        /* optional double preferred_transform_c = 14; */
        if (message.preferredTransformC !== undefined)
            writer.tag(14, runtime_1.WireType.Bit64).double(message.preferredTransformC);
        /* optional double preferred_transform_d = 15; */
        if (message.preferredTransformD !== undefined)
            writer.tag(15, runtime_1.WireType.Bit64).double(message.preferredTransformD);
        /* optional double preferred_transform_tx = 16; */
        if (message.preferredTransformTx !== undefined)
            writer.tag(16, runtime_1.WireType.Bit64).double(message.preferredTransformTx);
        /* optional double preferred_transform_ty = 17; */
        if (message.preferredTransformTy !== undefined)
            writer.tag(17, runtime_1.WireType.Bit64).double(message.preferredTransformTy);
        /* optional double preferred_volume = 18; */
        if (message.preferredVolume !== undefined)
            writer.tag(18, runtime_1.WireType.Bit64).double(message.preferredVolume);
        /* optional string language_code = 19; */
        if (message.languageCode !== undefined)
            writer.tag(19, runtime_1.WireType.LengthDelimited).string(message.languageCode);
        /* optional string extended_language_tag = 20; */
        if (message.extendedLanguageTag !== undefined)
            writer.tag(20, runtime_1.WireType.LengthDelimited).string(message.extendedLanguageTag);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.MovieFingerprintTrack
 */
exports.MovieFingerprintTrack = new MovieFingerprintTrack$Type();
//# sourceMappingURL=TSDArchives.js.map