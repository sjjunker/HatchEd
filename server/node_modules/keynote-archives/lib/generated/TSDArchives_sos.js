"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediaStylePropertyChangeSetArchive = exports.BaseShapeStylePropertyChangeSetArchive = exports.SpecStrokeArchive = exports.SpecShadowArchive = exports.SpecReflectionArchive = exports.SpecLineEndArchive = exports.SpecFillArchive = exports.SpecSetStrokeArchive = exports.SpecSetShadowArchive = exports.SpecSetReflectionArchive = exports.SpecSetLineEndArchive = exports.SpecSetFillArchive = void 0;
const runtime_1 = require("@protobuf-ts/runtime");
const runtime_2 = require("@protobuf-ts/runtime");
const runtime_3 = require("@protobuf-ts/runtime");
const runtime_4 = require("@protobuf-ts/runtime");
const runtime_5 = require("@protobuf-ts/runtime");
const TSSArchives_sos_1 = require("./TSSArchives_sos");
const TSDArchives_1 = require("./TSDArchives");
const TSDArchives_2 = require("./TSDArchives");
const TSDArchives_3 = require("./TSDArchives");
const TSDArchives_4 = require("./TSDArchives");
const TSDArchives_5 = require("./TSDArchives");
const TSDArchives_6 = require("./TSDArchives");
const TSDArchives_7 = require("./TSDArchives");
const TSDArchives_8 = require("./TSDArchives");
const TSDArchives_9 = require("./TSDArchives");
const TSDArchives_10 = require("./TSDArchives");
const TSDArchives_11 = require("./TSDArchives");
const TSDArchives_12 = require("./TSDArchives");
const TSDArchives_13 = require("./TSDArchives");
const TSDArchives_14 = require("./TSDArchives");
const TSDArchives_15 = require("./TSDArchives");
const TSDArchives_16 = require("./TSDArchives");
const TSDArchives_17 = require("./TSDArchives");
const TSDArchives_18 = require("./TSDArchives");
// @generated message type with reflection information, may provide speed optimized methods
class SpecSetFillArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSDSOS.SpecSetFillArchive", [
            { no: 1, name: "fill", kind: "message", T: () => TSDArchives_18.FillArchive },
            { no: 2, name: "unset", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { unset: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSD.FillArchive fill */ 1:
                    message.fill = TSDArchives_18.FillArchive.internalBinaryRead(reader, reader.uint32(), options, message.fill);
                    break;
                case /* bool unset */ 2:
                    message.unset = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSD.FillArchive fill = 1; */
        if (message.fill)
            TSDArchives_18.FillArchive.internalBinaryWrite(message.fill, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool unset = 2; */
        if (message.unset !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.unset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSDSOS.SpecSetFillArchive
 */
exports.SpecSetFillArchive = new SpecSetFillArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpecSetLineEndArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSDSOS.SpecSetLineEndArchive", [
            { no: 1, name: "line_end", kind: "message", T: () => TSDArchives_17.LineEndArchive },
            { no: 2, name: "unset", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { unset: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSD.LineEndArchive line_end */ 1:
                    message.lineEnd = TSDArchives_17.LineEndArchive.internalBinaryRead(reader, reader.uint32(), options, message.lineEnd);
                    break;
                case /* bool unset */ 2:
                    message.unset = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSD.LineEndArchive line_end = 1; */
        if (message.lineEnd)
            TSDArchives_17.LineEndArchive.internalBinaryWrite(message.lineEnd, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool unset = 2; */
        if (message.unset !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.unset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSDSOS.SpecSetLineEndArchive
 */
exports.SpecSetLineEndArchive = new SpecSetLineEndArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpecSetReflectionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSDSOS.SpecSetReflectionArchive", [
            { no: 1, name: "reflection", kind: "message", T: () => TSDArchives_16.ReflectionArchive },
            { no: 2, name: "unset", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { unset: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSD.ReflectionArchive reflection */ 1:
                    message.reflection = TSDArchives_16.ReflectionArchive.internalBinaryRead(reader, reader.uint32(), options, message.reflection);
                    break;
                case /* bool unset */ 2:
                    message.unset = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSD.ReflectionArchive reflection = 1; */
        if (message.reflection)
            TSDArchives_16.ReflectionArchive.internalBinaryWrite(message.reflection, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool unset = 2; */
        if (message.unset !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.unset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSDSOS.SpecSetReflectionArchive
 */
exports.SpecSetReflectionArchive = new SpecSetReflectionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpecSetShadowArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSDSOS.SpecSetShadowArchive", [
            { no: 1, name: "shadow", kind: "message", T: () => TSDArchives_15.ShadowArchive },
            { no: 2, name: "unset", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { unset: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSD.ShadowArchive shadow */ 1:
                    message.shadow = TSDArchives_15.ShadowArchive.internalBinaryRead(reader, reader.uint32(), options, message.shadow);
                    break;
                case /* bool unset */ 2:
                    message.unset = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSD.ShadowArchive shadow = 1; */
        if (message.shadow)
            TSDArchives_15.ShadowArchive.internalBinaryWrite(message.shadow, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool unset = 2; */
        if (message.unset !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.unset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSDSOS.SpecSetShadowArchive
 */
exports.SpecSetShadowArchive = new SpecSetShadowArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpecSetStrokeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSDSOS.SpecSetStrokeArchive", [
            { no: 1, name: "stroke", kind: "message", T: () => TSDArchives_14.StrokeArchive },
            { no: 2, name: "unset", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { unset: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSD.StrokeArchive stroke */ 1:
                    message.stroke = TSDArchives_14.StrokeArchive.internalBinaryRead(reader, reader.uint32(), options, message.stroke);
                    break;
                case /* bool unset */ 2:
                    message.unset = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSD.StrokeArchive stroke = 1; */
        if (message.stroke)
            TSDArchives_14.StrokeArchive.internalBinaryWrite(message.stroke, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool unset = 2; */
        if (message.unset !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.unset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSDSOS.SpecSetStrokeArchive
 */
exports.SpecSetStrokeArchive = new SpecSetStrokeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpecFillArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSDSOS.SpecFillArchive", [
            { no: 1, name: "spec_color_fill_set_color", kind: "message", T: () => TSDArchives_13.SpecColorFillSetColorArchive },
            { no: 2, name: "spec_gradient_fill_set_angle", kind: "message", T: () => TSDArchives_12.SpecGradientFillSetAngleArchive },
            { no: 3, name: "spec_image_fill_set_technique", kind: "message", T: () => TSDArchives_11.SpecImageFillSetTechniqueArchive },
            { no: 4, name: "spec_set_fill", kind: "message", T: () => exports.SpecSetFillArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSD.SpecColorFillSetColorArchive spec_color_fill_set_color */ 1:
                    message.specColorFillSetColor = TSDArchives_13.SpecColorFillSetColorArchive.internalBinaryRead(reader, reader.uint32(), options, message.specColorFillSetColor);
                    break;
                case /* optional TSD.SpecGradientFillSetAngleArchive spec_gradient_fill_set_angle */ 2:
                    message.specGradientFillSetAngle = TSDArchives_12.SpecGradientFillSetAngleArchive.internalBinaryRead(reader, reader.uint32(), options, message.specGradientFillSetAngle);
                    break;
                case /* optional TSD.SpecImageFillSetTechniqueArchive spec_image_fill_set_technique */ 3:
                    message.specImageFillSetTechnique = TSDArchives_11.SpecImageFillSetTechniqueArchive.internalBinaryRead(reader, reader.uint32(), options, message.specImageFillSetTechnique);
                    break;
                case /* optional TSDSOS.SpecSetFillArchive spec_set_fill */ 4:
                    message.specSetFill = exports.SpecSetFillArchive.internalBinaryRead(reader, reader.uint32(), options, message.specSetFill);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSD.SpecColorFillSetColorArchive spec_color_fill_set_color = 1; */
        if (message.specColorFillSetColor)
            TSDArchives_13.SpecColorFillSetColorArchive.internalBinaryWrite(message.specColorFillSetColor, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.SpecGradientFillSetAngleArchive spec_gradient_fill_set_angle = 2; */
        if (message.specGradientFillSetAngle)
            TSDArchives_12.SpecGradientFillSetAngleArchive.internalBinaryWrite(message.specGradientFillSetAngle, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.SpecImageFillSetTechniqueArchive spec_image_fill_set_technique = 3; */
        if (message.specImageFillSetTechnique)
            TSDArchives_11.SpecImageFillSetTechniqueArchive.internalBinaryWrite(message.specImageFillSetTechnique, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSDSOS.SpecSetFillArchive spec_set_fill = 4; */
        if (message.specSetFill)
            exports.SpecSetFillArchive.internalBinaryWrite(message.specSetFill, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSDSOS.SpecFillArchive
 */
exports.SpecFillArchive = new SpecFillArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpecLineEndArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSDSOS.SpecLineEndArchive", [
            { no: 1, name: "spec_set_line_end", kind: "message", T: () => exports.SpecSetLineEndArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSDSOS.SpecSetLineEndArchive spec_set_line_end */ 1:
                    message.specSetLineEnd = exports.SpecSetLineEndArchive.internalBinaryRead(reader, reader.uint32(), options, message.specSetLineEnd);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSDSOS.SpecSetLineEndArchive spec_set_line_end = 1; */
        if (message.specSetLineEnd)
            exports.SpecSetLineEndArchive.internalBinaryWrite(message.specSetLineEnd, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSDSOS.SpecLineEndArchive
 */
exports.SpecLineEndArchive = new SpecLineEndArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpecReflectionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSDSOS.SpecReflectionArchive", [
            { no: 1, name: "spec_reflection_set_opacity", kind: "message", T: () => TSDArchives_10.SpecReflectionSetOpacityArchive },
            { no: 2, name: "spec_set_reflection", kind: "message", T: () => exports.SpecSetReflectionArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSD.SpecReflectionSetOpacityArchive spec_reflection_set_opacity */ 1:
                    message.specReflectionSetOpacity = TSDArchives_10.SpecReflectionSetOpacityArchive.internalBinaryRead(reader, reader.uint32(), options, message.specReflectionSetOpacity);
                    break;
                case /* optional TSDSOS.SpecSetReflectionArchive spec_set_reflection */ 2:
                    message.specSetReflection = exports.SpecSetReflectionArchive.internalBinaryRead(reader, reader.uint32(), options, message.specSetReflection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSD.SpecReflectionSetOpacityArchive spec_reflection_set_opacity = 1; */
        if (message.specReflectionSetOpacity)
            TSDArchives_10.SpecReflectionSetOpacityArchive.internalBinaryWrite(message.specReflectionSetOpacity, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSDSOS.SpecSetReflectionArchive spec_set_reflection = 2; */
        if (message.specSetReflection)
            exports.SpecSetReflectionArchive.internalBinaryWrite(message.specSetReflection, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSDSOS.SpecReflectionArchive
 */
exports.SpecReflectionArchive = new SpecReflectionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpecShadowArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSDSOS.SpecShadowArchive", [
            { no: 1, name: "spec_set_shadow", kind: "message", T: () => exports.SpecSetShadowArchive },
            { no: 2, name: "spec_shadow_set_angle", kind: "message", T: () => TSDArchives_9.SpecShadowSetAngleArchive },
            { no: 3, name: "spec_shadow_set_color", kind: "message", T: () => TSDArchives_8.SpecShadowSetColorArchive },
            { no: 4, name: "spec_shadow_set_offset", kind: "message", T: () => TSDArchives_7.SpecShadowSetOffsetArchive },
            { no: 5, name: "spec_shadow_set_opacity", kind: "message", T: () => TSDArchives_6.SpecShadowSetOpacityArchive },
            { no: 6, name: "spec_shadow_set_radius", kind: "message", T: () => TSDArchives_5.SpecShadowSetRadiusArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSDSOS.SpecSetShadowArchive spec_set_shadow */ 1:
                    message.specSetShadow = exports.SpecSetShadowArchive.internalBinaryRead(reader, reader.uint32(), options, message.specSetShadow);
                    break;
                case /* optional TSD.SpecShadowSetAngleArchive spec_shadow_set_angle */ 2:
                    message.specShadowSetAngle = TSDArchives_9.SpecShadowSetAngleArchive.internalBinaryRead(reader, reader.uint32(), options, message.specShadowSetAngle);
                    break;
                case /* optional TSD.SpecShadowSetColorArchive spec_shadow_set_color */ 3:
                    message.specShadowSetColor = TSDArchives_8.SpecShadowSetColorArchive.internalBinaryRead(reader, reader.uint32(), options, message.specShadowSetColor);
                    break;
                case /* optional TSD.SpecShadowSetOffsetArchive spec_shadow_set_offset */ 4:
                    message.specShadowSetOffset = TSDArchives_7.SpecShadowSetOffsetArchive.internalBinaryRead(reader, reader.uint32(), options, message.specShadowSetOffset);
                    break;
                case /* optional TSD.SpecShadowSetOpacityArchive spec_shadow_set_opacity */ 5:
                    message.specShadowSetOpacity = TSDArchives_6.SpecShadowSetOpacityArchive.internalBinaryRead(reader, reader.uint32(), options, message.specShadowSetOpacity);
                    break;
                case /* optional TSD.SpecShadowSetRadiusArchive spec_shadow_set_radius */ 6:
                    message.specShadowSetRadius = TSDArchives_5.SpecShadowSetRadiusArchive.internalBinaryRead(reader, reader.uint32(), options, message.specShadowSetRadius);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSDSOS.SpecSetShadowArchive spec_set_shadow = 1; */
        if (message.specSetShadow)
            exports.SpecSetShadowArchive.internalBinaryWrite(message.specSetShadow, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.SpecShadowSetAngleArchive spec_shadow_set_angle = 2; */
        if (message.specShadowSetAngle)
            TSDArchives_9.SpecShadowSetAngleArchive.internalBinaryWrite(message.specShadowSetAngle, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.SpecShadowSetColorArchive spec_shadow_set_color = 3; */
        if (message.specShadowSetColor)
            TSDArchives_8.SpecShadowSetColorArchive.internalBinaryWrite(message.specShadowSetColor, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.SpecShadowSetOffsetArchive spec_shadow_set_offset = 4; */
        if (message.specShadowSetOffset)
            TSDArchives_7.SpecShadowSetOffsetArchive.internalBinaryWrite(message.specShadowSetOffset, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.SpecShadowSetOpacityArchive spec_shadow_set_opacity = 5; */
        if (message.specShadowSetOpacity)
            TSDArchives_6.SpecShadowSetOpacityArchive.internalBinaryWrite(message.specShadowSetOpacity, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.SpecShadowSetRadiusArchive spec_shadow_set_radius = 6; */
        if (message.specShadowSetRadius)
            TSDArchives_5.SpecShadowSetRadiusArchive.internalBinaryWrite(message.specShadowSetRadius, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSDSOS.SpecShadowArchive
 */
exports.SpecShadowArchive = new SpecShadowArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpecStrokeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSDSOS.SpecStrokeArchive", [
            { no: 1, name: "spec_frame_set_asset_scale", kind: "message", T: () => TSDArchives_4.SpecFrameSetAssetScaleArchive },
            { no: 2, name: "spec_set_stroke", kind: "message", T: () => exports.SpecSetStrokeArchive },
            { no: 3, name: "spec_stroke_set_color", kind: "message", T: () => TSDArchives_3.SpecStrokeSetColorArchive },
            { no: 4, name: "spec_stroke_set_pattern", kind: "message", T: () => TSDArchives_2.SpecStrokeSetPatternArchive },
            { no: 5, name: "spec_stroke_set_width", kind: "message", T: () => TSDArchives_1.SpecStrokeSetWidthArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSD.SpecFrameSetAssetScaleArchive spec_frame_set_asset_scale */ 1:
                    message.specFrameSetAssetScale = TSDArchives_4.SpecFrameSetAssetScaleArchive.internalBinaryRead(reader, reader.uint32(), options, message.specFrameSetAssetScale);
                    break;
                case /* optional TSDSOS.SpecSetStrokeArchive spec_set_stroke */ 2:
                    message.specSetStroke = exports.SpecSetStrokeArchive.internalBinaryRead(reader, reader.uint32(), options, message.specSetStroke);
                    break;
                case /* optional TSD.SpecStrokeSetColorArchive spec_stroke_set_color */ 3:
                    message.specStrokeSetColor = TSDArchives_3.SpecStrokeSetColorArchive.internalBinaryRead(reader, reader.uint32(), options, message.specStrokeSetColor);
                    break;
                case /* optional TSD.SpecStrokeSetPatternArchive spec_stroke_set_pattern */ 4:
                    message.specStrokeSetPattern = TSDArchives_2.SpecStrokeSetPatternArchive.internalBinaryRead(reader, reader.uint32(), options, message.specStrokeSetPattern);
                    break;
                case /* optional TSD.SpecStrokeSetWidthArchive spec_stroke_set_width */ 5:
                    message.specStrokeSetWidth = TSDArchives_1.SpecStrokeSetWidthArchive.internalBinaryRead(reader, reader.uint32(), options, message.specStrokeSetWidth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSD.SpecFrameSetAssetScaleArchive spec_frame_set_asset_scale = 1; */
        if (message.specFrameSetAssetScale)
            TSDArchives_4.SpecFrameSetAssetScaleArchive.internalBinaryWrite(message.specFrameSetAssetScale, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSDSOS.SpecSetStrokeArchive spec_set_stroke = 2; */
        if (message.specSetStroke)
            exports.SpecSetStrokeArchive.internalBinaryWrite(message.specSetStroke, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.SpecStrokeSetColorArchive spec_stroke_set_color = 3; */
        if (message.specStrokeSetColor)
            TSDArchives_3.SpecStrokeSetColorArchive.internalBinaryWrite(message.specStrokeSetColor, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.SpecStrokeSetPatternArchive spec_stroke_set_pattern = 4; */
        if (message.specStrokeSetPattern)
            TSDArchives_2.SpecStrokeSetPatternArchive.internalBinaryWrite(message.specStrokeSetPattern, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.SpecStrokeSetWidthArchive spec_stroke_set_width = 5; */
        if (message.specStrokeSetWidth)
            TSDArchives_1.SpecStrokeSetWidthArchive.internalBinaryWrite(message.specStrokeSetWidth, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSDSOS.SpecStrokeArchive
 */
exports.SpecStrokeArchive = new SpecStrokeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BaseShapeStylePropertyChangeSetArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSDSOS.BaseShapeStylePropertyChangeSetArchive", [
            { no: 1, name: "fill", kind: "message", T: () => exports.SpecFillArchive },
            { no: 2, name: "fill_undefined", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "stroke", kind: "message", T: () => exports.SpecStrokeArchive },
            { no: 4, name: "stroke_undefined", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "opacity", kind: "message", T: () => TSSArchives_sos_1.SpecDoubleArchive },
            { no: 6, name: "opacity_undefined", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "shadow", kind: "message", T: () => exports.SpecShadowArchive },
            { no: 8, name: "shadow_undefined", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "reflection", kind: "message", T: () => exports.SpecReflectionArchive },
            { no: 10, name: "reflection_undefined", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "head_line_end", kind: "message", T: () => exports.SpecLineEndArchive },
            { no: 12, name: "head_line_end_undefined", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "tail_line_end", kind: "message", T: () => exports.SpecLineEndArchive },
            { no: 14, name: "tail_line_end_undefined", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSDSOS.SpecFillArchive fill */ 1:
                    message.fill = exports.SpecFillArchive.internalBinaryRead(reader, reader.uint32(), options, message.fill);
                    break;
                case /* optional bool fill_undefined */ 2:
                    message.fillUndefined = reader.bool();
                    break;
                case /* optional TSDSOS.SpecStrokeArchive stroke */ 3:
                    message.stroke = exports.SpecStrokeArchive.internalBinaryRead(reader, reader.uint32(), options, message.stroke);
                    break;
                case /* optional bool stroke_undefined */ 4:
                    message.strokeUndefined = reader.bool();
                    break;
                case /* optional TSSSOS.SpecDoubleArchive opacity */ 5:
                    message.opacity = TSSArchives_sos_1.SpecDoubleArchive.internalBinaryRead(reader, reader.uint32(), options, message.opacity);
                    break;
                case /* optional bool opacity_undefined */ 6:
                    message.opacityUndefined = reader.bool();
                    break;
                case /* optional TSDSOS.SpecShadowArchive shadow */ 7:
                    message.shadow = exports.SpecShadowArchive.internalBinaryRead(reader, reader.uint32(), options, message.shadow);
                    break;
                case /* optional bool shadow_undefined */ 8:
                    message.shadowUndefined = reader.bool();
                    break;
                case /* optional TSDSOS.SpecReflectionArchive reflection */ 9:
                    message.reflection = exports.SpecReflectionArchive.internalBinaryRead(reader, reader.uint32(), options, message.reflection);
                    break;
                case /* optional bool reflection_undefined */ 10:
                    message.reflectionUndefined = reader.bool();
                    break;
                case /* optional TSDSOS.SpecLineEndArchive head_line_end */ 11:
                    message.headLineEnd = exports.SpecLineEndArchive.internalBinaryRead(reader, reader.uint32(), options, message.headLineEnd);
                    break;
                case /* optional bool head_line_end_undefined */ 12:
                    message.headLineEndUndefined = reader.bool();
                    break;
                case /* optional TSDSOS.SpecLineEndArchive tail_line_end */ 13:
                    message.tailLineEnd = exports.SpecLineEndArchive.internalBinaryRead(reader, reader.uint32(), options, message.tailLineEnd);
                    break;
                case /* optional bool tail_line_end_undefined */ 14:
                    message.tailLineEndUndefined = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSDSOS.SpecFillArchive fill = 1; */
        if (message.fill)
            exports.SpecFillArchive.internalBinaryWrite(message.fill, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool fill_undefined = 2; */
        if (message.fillUndefined !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.fillUndefined);
        /* optional TSDSOS.SpecStrokeArchive stroke = 3; */
        if (message.stroke)
            exports.SpecStrokeArchive.internalBinaryWrite(message.stroke, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool stroke_undefined = 4; */
        if (message.strokeUndefined !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.strokeUndefined);
        /* optional TSSSOS.SpecDoubleArchive opacity = 5; */
        if (message.opacity)
            TSSArchives_sos_1.SpecDoubleArchive.internalBinaryWrite(message.opacity, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool opacity_undefined = 6; */
        if (message.opacityUndefined !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.opacityUndefined);
        /* optional TSDSOS.SpecShadowArchive shadow = 7; */
        if (message.shadow)
            exports.SpecShadowArchive.internalBinaryWrite(message.shadow, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool shadow_undefined = 8; */
        if (message.shadowUndefined !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.shadowUndefined);
        /* optional TSDSOS.SpecReflectionArchive reflection = 9; */
        if (message.reflection)
            exports.SpecReflectionArchive.internalBinaryWrite(message.reflection, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool reflection_undefined = 10; */
        if (message.reflectionUndefined !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).bool(message.reflectionUndefined);
        /* optional TSDSOS.SpecLineEndArchive head_line_end = 11; */
        if (message.headLineEnd)
            exports.SpecLineEndArchive.internalBinaryWrite(message.headLineEnd, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool head_line_end_undefined = 12; */
        if (message.headLineEndUndefined !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).bool(message.headLineEndUndefined);
        /* optional TSDSOS.SpecLineEndArchive tail_line_end = 13; */
        if (message.tailLineEnd)
            exports.SpecLineEndArchive.internalBinaryWrite(message.tailLineEnd, writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool tail_line_end_undefined = 14; */
        if (message.tailLineEndUndefined !== undefined)
            writer.tag(14, runtime_1.WireType.Varint).bool(message.tailLineEndUndefined);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSDSOS.BaseShapeStylePropertyChangeSetArchive
 */
exports.BaseShapeStylePropertyChangeSetArchive = new BaseShapeStylePropertyChangeSetArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MediaStylePropertyChangeSetArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSDSOS.MediaStylePropertyChangeSetArchive", [
            { no: 1, name: "stroke", kind: "message", T: () => exports.SpecStrokeArchive },
            { no: 2, name: "stroke_undefined", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "opacity", kind: "message", T: () => TSSArchives_sos_1.SpecDoubleArchive },
            { no: 4, name: "opacity_undefined", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "shadow", kind: "message", T: () => exports.SpecShadowArchive },
            { no: 6, name: "shadow_undefined", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "reflection", kind: "message", T: () => exports.SpecReflectionArchive },
            { no: 8, name: "reflection_undefined", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSDSOS.SpecStrokeArchive stroke */ 1:
                    message.stroke = exports.SpecStrokeArchive.internalBinaryRead(reader, reader.uint32(), options, message.stroke);
                    break;
                case /* optional bool stroke_undefined */ 2:
                    message.strokeUndefined = reader.bool();
                    break;
                case /* optional TSSSOS.SpecDoubleArchive opacity */ 3:
                    message.opacity = TSSArchives_sos_1.SpecDoubleArchive.internalBinaryRead(reader, reader.uint32(), options, message.opacity);
                    break;
                case /* optional bool opacity_undefined */ 4:
                    message.opacityUndefined = reader.bool();
                    break;
                case /* optional TSDSOS.SpecShadowArchive shadow */ 5:
                    message.shadow = exports.SpecShadowArchive.internalBinaryRead(reader, reader.uint32(), options, message.shadow);
                    break;
                case /* optional bool shadow_undefined */ 6:
                    message.shadowUndefined = reader.bool();
                    break;
                case /* optional TSDSOS.SpecReflectionArchive reflection */ 7:
                    message.reflection = exports.SpecReflectionArchive.internalBinaryRead(reader, reader.uint32(), options, message.reflection);
                    break;
                case /* optional bool reflection_undefined */ 8:
                    message.reflectionUndefined = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSDSOS.SpecStrokeArchive stroke = 1; */
        if (message.stroke)
            exports.SpecStrokeArchive.internalBinaryWrite(message.stroke, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool stroke_undefined = 2; */
        if (message.strokeUndefined !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.strokeUndefined);
        /* optional TSSSOS.SpecDoubleArchive opacity = 3; */
        if (message.opacity)
            TSSArchives_sos_1.SpecDoubleArchive.internalBinaryWrite(message.opacity, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool opacity_undefined = 4; */
        if (message.opacityUndefined !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.opacityUndefined);
        /* optional TSDSOS.SpecShadowArchive shadow = 5; */
        if (message.shadow)
            exports.SpecShadowArchive.internalBinaryWrite(message.shadow, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool shadow_undefined = 6; */
        if (message.shadowUndefined !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.shadowUndefined);
        /* optional TSDSOS.SpecReflectionArchive reflection = 7; */
        if (message.reflection)
            exports.SpecReflectionArchive.internalBinaryWrite(message.reflection, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool reflection_undefined = 8; */
        if (message.reflectionUndefined !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.reflectionUndefined);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSDSOS.MediaStylePropertyChangeSetArchive
 */
exports.MediaStylePropertyChangeSetArchive = new MediaStylePropertyChangeSetArchive$Type();
//# sourceMappingURL=TSDArchives_sos.js.map