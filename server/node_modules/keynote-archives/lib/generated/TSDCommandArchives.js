"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PasteStyleCommandArchive = exports.DrawableAccessibilityDescriptionCommandArchive = exports.DrawableAspectRatioLockedCommandArchive = exports.GuideCommandArchive = exports.AbstractGuideCommandArchive = exports.DrawablePencilAnnotationCommandArchive = exports.DrawableInfoCommentCommandArchive = exports.DrawableLockCommandArchive = exports.ImageReplaceCommandArchive = exports.CommentInvalidatingCommandSelectionBehaviorArchive = exports.DrawableHyperlinkCommandArchive = exports.ExteriorTextWrapCommandArchive = exports.DrawablesCommandGroupArchive = exports.MediaFlagsCommandArchive = exports.ImageAdjustmentsCommandArchive = exports.ImageMaskCommandArchive = exports.ImageNaturalSizeCommandArchive = exports.MediaInfoGeometryCommandArchive = exports.MediaOriginalSizeCommandArchive = exports.ImageMediaCommandArchive = exports.MediaStyleSetValueCommandArchive = exports.MovieSetValueCommandArchive_PropertyValue = exports.MovieSetValueCommandArchive = exports.BaseStyleSetValueCommandArchive = exports.ShapeStyleSetValueCommandArchive = exports.MediaApplyPresetCommandArchive = exports.ShapeApplyPresetCommandArchive = exports.BaseApplyPresetCommandArchive = exports.StyledInfoSetStyleCommandArchive = exports.AbstractStyleCommandArchive = exports.DrawableApplyThemeCommandArchive = exports.InstantAlphaCommandArchive = exports.DrawablePathSourceCommandArchive = exports.InfoGeometryCommandArchive = exports.ConnectionLineConnectCommandArchive = exports.InfoCommandArchive = exports.GroupUngroupInformativeCommandArchive = exports.ContainerReorderChildrenCommandArchive = exports.ContainerInsertDrawablesCommandArchive = exports.ContainerInsertChildrenCommandArchive = exports.ContainerRemoveDrawablesCommandArchive = exports.ContainerRemoveChildrenCommandArchive = exports.UngroupGroupCommandArchive = exports.GroupDrawablesCommandArchive = exports.UndoObjectArchive = exports.CaptionOrTitleKind = exports.CommentCommandVariant = exports.DrawablesCommandGroupArchive_DrawablesCommandGroupType = exports.MovieSetValueCommandArchive_LoopOption = exports.GroupUngroupInformativeCommandArchive_CommandType = void 0;
exports.SetCaptionOrTitleVisibilityCommandArchive = exports.RemoveCaptionOrTitleCommandArchive = exports.InsertCaptionOrTitleCommandArchive = exports.FreehandDrawingAnimationCommandArchive = exports.FreehandDrawingOpacityCommandArchive = exports.PencilAnnotationSelectionTransformerArchive = exports.GroupSelectionTransformerArchive = exports.ShapeSelectionTransformerArchive = exports.PathSelectionTransformerArchive = exports.CanvasSelectionTransformerArchive = exports.InfoHyperlinkSelectionTransformerArchive = exports.DrawableSelectionTransformerArchive = exports.InfoCollectionSelectionTransformerHelperArchive = exports.ImageInfoMaskGeometryCommandArchive = exports.ImageInfoGeometryCommandArchive = exports.ImageInfoAbstractGeometryCommandArchive = void 0;
const runtime_1 = require("@protobuf-ts/runtime");
const runtime_2 = require("@protobuf-ts/runtime");
const runtime_3 = require("@protobuf-ts/runtime");
const runtime_4 = require("@protobuf-ts/runtime");
const runtime_5 = require("@protobuf-ts/runtime");
const TSDArchives_1 = require("./TSDArchives");
const TSDArchives_2 = require("./TSDArchives");
const TSKArchives_1 = require("./TSKArchives");
const TSDArchives_3 = require("./TSDArchives");
const TSDArchives_4 = require("./TSDArchives");
const TSKArchives_2 = require("./TSKArchives");
const TSDArchives_5 = require("./TSDArchives");
const TSPMessages_1 = require("./TSPMessages");
const TSDArchives_sos_1 = require("./TSDArchives_sos");
const TSPMessages_2 = require("./TSPMessages");
const TSDArchives_sos_2 = require("./TSDArchives_sos");
const TSSArchives_1 = require("./TSSArchives");
const TSPMessages_3 = require("./TSPMessages");
const TSDArchives_6 = require("./TSDArchives");
const TSDArchives_7 = require("./TSDArchives");
const TSKArchives_3 = require("./TSKArchives");
const TSPMessages_4 = require("./TSPMessages");
const TSKArchives_4 = require("./TSKArchives");
const TSKArchives_5 = require("./TSKArchives");
const TSPMessages_5 = require("./TSPMessages");
const TSKArchives_6 = require("./TSKArchives");
const TSPMessages_6 = require("./TSPMessages");
/**
 * @generated from protobuf enum TSD.GroupUngroupInformativeCommandArchive.CommandType
 */
var GroupUngroupInformativeCommandArchive_CommandType;
(function (GroupUngroupInformativeCommandArchive_CommandType) {
    /**
     * @generated from protobuf enum value: Group = 0;
     */
    GroupUngroupInformativeCommandArchive_CommandType[GroupUngroupInformativeCommandArchive_CommandType["Group"] = 0] = "Group";
    /**
     * @generated from protobuf enum value: Ungroup = 1;
     */
    GroupUngroupInformativeCommandArchive_CommandType[GroupUngroupInformativeCommandArchive_CommandType["Ungroup"] = 1] = "Ungroup";
})(GroupUngroupInformativeCommandArchive_CommandType = exports.GroupUngroupInformativeCommandArchive_CommandType || (exports.GroupUngroupInformativeCommandArchive_CommandType = {}));
/**
 * @generated from protobuf enum TSD.MovieSetValueCommandArchive.LoopOption
 */
var MovieSetValueCommandArchive_LoopOption;
(function (MovieSetValueCommandArchive_LoopOption) {
    /**
     * @generated from protobuf enum value: None = 0;
     */
    MovieSetValueCommandArchive_LoopOption[MovieSetValueCommandArchive_LoopOption["None"] = 0] = "None";
    /**
     * @generated from protobuf enum value: Repeat = 1;
     */
    MovieSetValueCommandArchive_LoopOption[MovieSetValueCommandArchive_LoopOption["Repeat"] = 1] = "Repeat";
    /**
     * @generated from protobuf enum value: BackAndForth = 2;
     */
    MovieSetValueCommandArchive_LoopOption[MovieSetValueCommandArchive_LoopOption["BackAndForth"] = 2] = "BackAndForth";
})(MovieSetValueCommandArchive_LoopOption = exports.MovieSetValueCommandArchive_LoopOption || (exports.MovieSetValueCommandArchive_LoopOption = {}));
/**
 * @generated from protobuf enum TSD.DrawablesCommandGroupArchive.DrawablesCommandGroupType
 */
var DrawablesCommandGroupArchive_DrawablesCommandGroupType;
(function (DrawablesCommandGroupArchive_DrawablesCommandGroupType) {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    DrawablesCommandGroupArchive_DrawablesCommandGroupType[DrawablesCommandGroupArchive_DrawablesCommandGroupType["UNSPECIFIED$"] = 0] = "UNSPECIFIED$";
    /**
     * @generated from protobuf enum value: Constructive = 1;
     */
    DrawablesCommandGroupArchive_DrawablesCommandGroupType[DrawablesCommandGroupArchive_DrawablesCommandGroupType["Constructive"] = 1] = "Constructive";
    /**
     * @generated from protobuf enum value: Destructive = 2;
     */
    DrawablesCommandGroupArchive_DrawablesCommandGroupType[DrawablesCommandGroupArchive_DrawablesCommandGroupType["Destructive"] = 2] = "Destructive";
    /**
     * @generated from protobuf enum value: InPlace = 3;
     */
    DrawablesCommandGroupArchive_DrawablesCommandGroupType[DrawablesCommandGroupArchive_DrawablesCommandGroupType["InPlace"] = 3] = "InPlace";
})(DrawablesCommandGroupArchive_DrawablesCommandGroupType = exports.DrawablesCommandGroupArchive_DrawablesCommandGroupType || (exports.DrawablesCommandGroupArchive_DrawablesCommandGroupType = {}));
/**
 * @generated from protobuf enum TSD.CommentCommandVariant
 */
var CommentCommandVariant;
(function (CommentCommandVariant) {
    /**
     * @generated from protobuf enum value: BaseComment = 0;
     */
    CommentCommandVariant[CommentCommandVariant["BaseComment"] = 0] = "BaseComment";
    /**
     * @generated from protobuf enum value: AddReply = 1;
     */
    CommentCommandVariant[CommentCommandVariant["AddReply"] = 1] = "AddReply";
    /**
     * @generated from protobuf enum value: EditReply = 2;
     */
    CommentCommandVariant[CommentCommandVariant["EditReply"] = 2] = "EditReply";
    /**
     * @generated from protobuf enum value: DeleteReply = 3;
     */
    CommentCommandVariant[CommentCommandVariant["DeleteReply"] = 3] = "DeleteReply";
})(CommentCommandVariant = exports.CommentCommandVariant || (exports.CommentCommandVariant = {}));
/**
 * @generated from protobuf enum TSD.CaptionOrTitleKind
 */
var CaptionOrTitleKind;
(function (CaptionOrTitleKind) {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    CaptionOrTitleKind[CaptionOrTitleKind["UNSPECIFIED$"] = 0] = "UNSPECIFIED$";
    /**
     * @generated from protobuf enum value: Caption = 1;
     */
    CaptionOrTitleKind[CaptionOrTitleKind["Caption"] = 1] = "Caption";
    /**
     * @generated from protobuf enum value: Title = 2;
     */
    CaptionOrTitleKind[CaptionOrTitleKind["Title"] = 2] = "Title";
})(CaptionOrTitleKind = exports.CaptionOrTitleKind || (exports.CaptionOrTitleKind = {}));
// @generated message type with reflection information, may provide speed optimized methods
class UndoObjectArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.UndoObjectArchive", [
            { no: 2, name: "stylesheet", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 1, name: "objects", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_6.Reference },
            { no: 3, name: "keys", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "counts", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { objects: [], keys: [], counts: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference stylesheet */ 2:
                    message.stylesheet = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.stylesheet);
                    break;
                case /* repeated TSP.Reference objects */ 1:
                    message.objects.push(TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string keys */ 3:
                    message.keys.push(reader.string());
                    break;
                case /* repeated uint32 counts */ 4:
                    if (wireType === runtime_2.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.counts.push(reader.uint32());
                    else
                        message.counts.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference stylesheet = 2; */
        if (message.stylesheet)
            TSPMessages_6.Reference.internalBinaryWrite(message.stylesheet, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference objects = 1; */
        for (let i = 0; i < message.objects.length; i++)
            TSPMessages_6.Reference.internalBinaryWrite(message.objects[i], writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* repeated string keys = 3; */
        for (let i = 0; i < message.keys.length; i++)
            writer.tag(3, runtime_2.WireType.LengthDelimited).string(message.keys[i]);
        /* repeated uint32 counts = 4; */
        for (let i = 0; i < message.counts.length; i++)
            writer.tag(4, runtime_2.WireType.Varint).uint32(message.counts[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.UndoObjectArchive
 */
exports.UndoObjectArchive = new UndoObjectArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupDrawablesCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.GroupDrawablesCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "drawables", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_6.Reference },
            { no: 3, name: "group", kind: "message", T: () => TSPMessages_6.Reference }
        ]);
    }
    create(value) {
        const message = { drawables: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSP.Reference drawables */ 2:
                    message.drawables.push(TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Reference group */ 3:
                    message.group = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.group);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference drawables = 2; */
        for (let i = 0; i < message.drawables.length; i++)
            TSPMessages_6.Reference.internalBinaryWrite(message.drawables[i], writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference group = 3; */
        if (message.group)
            TSPMessages_6.Reference.internalBinaryWrite(message.group, writer.tag(3, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.GroupDrawablesCommandArchive
 */
exports.GroupDrawablesCommandArchive = new GroupDrawablesCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UngroupGroupCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.UngroupGroupCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "drawables", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_6.Reference },
            { no: 3, name: "group", kind: "message", T: () => TSPMessages_6.Reference }
        ]);
    }
    create(value) {
        const message = { drawables: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSP.Reference drawables */ 2:
                    message.drawables.push(TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Reference group */ 3:
                    message.group = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.group);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference drawables = 2; */
        for (let i = 0; i < message.drawables.length; i++)
            TSPMessages_6.Reference.internalBinaryWrite(message.drawables[i], writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference group = 3; */
        if (message.group)
            TSPMessages_6.Reference.internalBinaryWrite(message.group, writer.tag(3, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.UngroupGroupCommandArchive
 */
exports.UngroupGroupCommandArchive = new UngroupGroupCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ContainerRemoveChildrenCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ContainerRemoveChildrenCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "container_id_path", kind: "message", T: () => TSPMessages_5.UUIDPath },
            { no: 3, name: "args_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSKArchives_5.RemoveIdOperationArgs },
            { no: 4, name: "children", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_6.Reference }
        ]);
    }
    create(value) {
        const message = { argsList: [], children: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.UUIDPath container_id_path */ 2:
                    message.containerIdPath = TSPMessages_5.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.containerIdPath);
                    break;
                case /* repeated TSK.RemoveIdOperationArgs args_list */ 3:
                    message.argsList.push(TSKArchives_5.RemoveIdOperationArgs.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference children */ 4:
                    message.children.push(TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDPath container_id_path = 2; */
        if (message.containerIdPath)
            TSPMessages_5.UUIDPath.internalBinaryWrite(message.containerIdPath, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSK.RemoveIdOperationArgs args_list = 3; */
        for (let i = 0; i < message.argsList.length; i++)
            TSKArchives_5.RemoveIdOperationArgs.internalBinaryWrite(message.argsList[i], writer.tag(3, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference children = 4; */
        for (let i = 0; i < message.children.length; i++)
            TSPMessages_6.Reference.internalBinaryWrite(message.children[i], writer.tag(4, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ContainerRemoveChildrenCommandArchive
 */
exports.ContainerRemoveChildrenCommandArchive = new ContainerRemoveChildrenCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ContainerRemoveDrawablesCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ContainerRemoveDrawablesCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.ContainerRemoveChildrenCommandArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.ContainerRemoveChildrenCommandArchive super */ 1:
                    message.super = exports.ContainerRemoveChildrenCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.ContainerRemoveChildrenCommandArchive super = 1; */
        if (message.super)
            exports.ContainerRemoveChildrenCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ContainerRemoveDrawablesCommandArchive
 */
exports.ContainerRemoveDrawablesCommandArchive = new ContainerRemoveDrawablesCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ContainerInsertChildrenCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ContainerInsertChildrenCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "container_id_path", kind: "message", T: () => TSPMessages_5.UUIDPath },
            { no: 3, name: "children", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_6.Reference },
            { no: 4, name: "args_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSKArchives_4.AddIdOperationArgs },
            { no: 5, name: "custom_format_keys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 6, name: "undo_object", kind: "message", T: () => TSPMessages_6.Reference }
        ]);
    }
    create(value) {
        const message = { children: [], argsList: [], customFormatKeys: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.UUIDPath container_id_path */ 2:
                    message.containerIdPath = TSPMessages_5.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.containerIdPath);
                    break;
                case /* repeated TSP.Reference children */ 3:
                    message.children.push(TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSK.AddIdOperationArgs args_list */ 4:
                    message.argsList.push(TSKArchives_4.AddIdOperationArgs.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID custom_format_keys */ 5:
                    message.customFormatKeys.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Reference undo_object */ 6:
                    message.undoObject = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoObject);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDPath container_id_path = 2; */
        if (message.containerIdPath)
            TSPMessages_5.UUIDPath.internalBinaryWrite(message.containerIdPath, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference children = 3; */
        for (let i = 0; i < message.children.length; i++)
            TSPMessages_6.Reference.internalBinaryWrite(message.children[i], writer.tag(3, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSK.AddIdOperationArgs args_list = 4; */
        for (let i = 0; i < message.argsList.length; i++)
            TSKArchives_4.AddIdOperationArgs.internalBinaryWrite(message.argsList[i], writer.tag(4, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID custom_format_keys = 5; */
        for (let i = 0; i < message.customFormatKeys.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.customFormatKeys[i], writer.tag(5, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_object = 6; */
        if (message.undoObject)
            TSPMessages_6.Reference.internalBinaryWrite(message.undoObject, writer.tag(6, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ContainerInsertChildrenCommandArchive
 */
exports.ContainerInsertChildrenCommandArchive = new ContainerInsertChildrenCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ContainerInsertDrawablesCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ContainerInsertDrawablesCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.ContainerInsertChildrenCommandArchive },
            { no: 2, name: "drawables", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_6.Reference }
        ]);
    }
    create(value) {
        const message = { drawables: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.ContainerInsertChildrenCommandArchive super */ 1:
                    message.super = exports.ContainerInsertChildrenCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSP.Reference drawables */ 2:
                    message.drawables.push(TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.ContainerInsertChildrenCommandArchive super = 1; */
        if (message.super)
            exports.ContainerInsertChildrenCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference drawables = 2; */
        for (let i = 0; i < message.drawables.length; i++)
            TSPMessages_6.Reference.internalBinaryWrite(message.drawables[i], writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ContainerInsertDrawablesCommandArchive
 */
exports.ContainerInsertDrawablesCommandArchive = new ContainerInsertDrawablesCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ContainerReorderChildrenCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ContainerReorderChildrenCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "container_id_path", kind: "message", T: () => TSPMessages_5.UUIDPath },
            { no: 3, name: "args_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSKArchives_3.RearrangeIdOperationArgs }
        ]);
    }
    create(value) {
        const message = { argsList: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.UUIDPath container_id_path */ 2:
                    message.containerIdPath = TSPMessages_5.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.containerIdPath);
                    break;
                case /* repeated TSK.RearrangeIdOperationArgs args_list */ 3:
                    message.argsList.push(TSKArchives_3.RearrangeIdOperationArgs.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDPath container_id_path = 2; */
        if (message.containerIdPath)
            TSPMessages_5.UUIDPath.internalBinaryWrite(message.containerIdPath, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSK.RearrangeIdOperationArgs args_list = 3; */
        for (let i = 0; i < message.argsList.length; i++)
            TSKArchives_3.RearrangeIdOperationArgs.internalBinaryWrite(message.argsList[i], writer.tag(3, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ContainerReorderChildrenCommandArchive
 */
exports.ContainerReorderChildrenCommandArchive = new ContainerReorderChildrenCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupUngroupInformativeCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.GroupUngroupInformativeCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "removed_infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_6.Reference },
            { no: 3, name: "inserted_infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_6.Reference },
            { no: 4, name: "command_type", kind: "enum", opt: true, T: () => ["TSD.GroupUngroupInformativeCommandArchive.CommandType", GroupUngroupInformativeCommandArchive_CommandType] }
        ]);
    }
    create(value) {
        const message = { removedInfos: [], insertedInfos: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSP.Reference removed_infos */ 2:
                    message.removedInfos.push(TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference inserted_infos */ 3:
                    message.insertedInfos.push(TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSD.GroupUngroupInformativeCommandArchive.CommandType command_type */ 4:
                    message.commandType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference removed_infos = 2; */
        for (let i = 0; i < message.removedInfos.length; i++)
            TSPMessages_6.Reference.internalBinaryWrite(message.removedInfos[i], writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference inserted_infos = 3; */
        for (let i = 0; i < message.insertedInfos.length; i++)
            TSPMessages_6.Reference.internalBinaryWrite(message.insertedInfos[i], writer.tag(3, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.GroupUngroupInformativeCommandArchive.CommandType command_type = 4; */
        if (message.commandType !== undefined)
            writer.tag(4, runtime_2.WireType.Varint).int32(message.commandType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.GroupUngroupInformativeCommandArchive
 */
exports.GroupUngroupInformativeCommandArchive = new GroupUngroupInformativeCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InfoCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.InfoCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "info_id_path", kind: "message", T: () => TSPMessages_5.UUIDPath }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.UUIDPath info_id_path */ 2:
                    message.infoIdPath = TSPMessages_5.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.infoIdPath);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDPath info_id_path = 2; */
        if (message.infoIdPath)
            TSPMessages_5.UUIDPath.internalBinaryWrite(message.infoIdPath, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.InfoCommandArchive
 */
exports.InfoCommandArchive = new InfoCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectionLineConnectCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ConnectionLineConnectCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.InfoCommandArchive },
            { no: 4, name: "connected_from_id", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 5, name: "connected_to_id", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 6, name: "old_connected_to_id", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 7, name: "old_connected_from_id", kind: "message", T: () => TSPMessages_4.UUID }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoCommandArchive super */ 1:
                    message.super = exports.InfoCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.UUID connected_from_id */ 4:
                    message.connectedFromId = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.connectedFromId);
                    break;
                case /* optional TSP.UUID connected_to_id */ 5:
                    message.connectedToId = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.connectedToId);
                    break;
                case /* optional TSP.UUID old_connected_to_id */ 6:
                    message.oldConnectedToId = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.oldConnectedToId);
                    break;
                case /* optional TSP.UUID old_connected_from_id */ 7:
                    message.oldConnectedFromId = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.oldConnectedFromId);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoCommandArchive super = 1; */
        if (message.super)
            exports.InfoCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID connected_from_id = 4; */
        if (message.connectedFromId)
            TSPMessages_4.UUID.internalBinaryWrite(message.connectedFromId, writer.tag(4, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID connected_to_id = 5; */
        if (message.connectedToId)
            TSPMessages_4.UUID.internalBinaryWrite(message.connectedToId, writer.tag(5, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID old_connected_to_id = 6; */
        if (message.oldConnectedToId)
            TSPMessages_4.UUID.internalBinaryWrite(message.oldConnectedToId, writer.tag(6, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID old_connected_from_id = 7; */
        if (message.oldConnectedFromId)
            TSPMessages_4.UUID.internalBinaryWrite(message.oldConnectedFromId, writer.tag(7, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ConnectionLineConnectCommandArchive
 */
exports.ConnectionLineConnectCommandArchive = new ConnectionLineConnectCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InfoGeometryCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.InfoGeometryCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.InfoCommandArchive },
            { no: 2, name: "newGeometry", kind: "message", T: () => TSDArchives_7.GeometryArchive },
            { no: 3, name: "oldGeometry", kind: "message", T: () => TSDArchives_7.GeometryArchive },
            { no: 4, name: "matchObjectPlaceholderGeometry", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "oldMatchObjectPlaceholderGeometry", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "shouldTriggerRtuAnimation", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "initiatedOnWeb", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoCommandArchive super */ 1:
                    message.super = exports.InfoCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSD.GeometryArchive newGeometry */ 2:
                    message.newGeometry = TSDArchives_7.GeometryArchive.internalBinaryRead(reader, reader.uint32(), options, message.newGeometry);
                    break;
                case /* optional TSD.GeometryArchive oldGeometry */ 3:
                    message.oldGeometry = TSDArchives_7.GeometryArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldGeometry);
                    break;
                case /* optional bool matchObjectPlaceholderGeometry */ 4:
                    message.matchObjectPlaceholderGeometry = reader.bool();
                    break;
                case /* optional bool oldMatchObjectPlaceholderGeometry */ 5:
                    message.oldMatchObjectPlaceholderGeometry = reader.bool();
                    break;
                case /* optional bool shouldTriggerRtuAnimation */ 6:
                    message.shouldTriggerRtuAnimation = reader.bool();
                    break;
                case /* optional bool initiatedOnWeb */ 7:
                    message.initiatedOnWeb = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoCommandArchive super = 1; */
        if (message.super)
            exports.InfoCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.GeometryArchive newGeometry = 2; */
        if (message.newGeometry)
            TSDArchives_7.GeometryArchive.internalBinaryWrite(message.newGeometry, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.GeometryArchive oldGeometry = 3; */
        if (message.oldGeometry)
            TSDArchives_7.GeometryArchive.internalBinaryWrite(message.oldGeometry, writer.tag(3, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional bool matchObjectPlaceholderGeometry = 4; */
        if (message.matchObjectPlaceholderGeometry !== undefined)
            writer.tag(4, runtime_2.WireType.Varint).bool(message.matchObjectPlaceholderGeometry);
        /* optional bool oldMatchObjectPlaceholderGeometry = 5; */
        if (message.oldMatchObjectPlaceholderGeometry !== undefined)
            writer.tag(5, runtime_2.WireType.Varint).bool(message.oldMatchObjectPlaceholderGeometry);
        /* optional bool shouldTriggerRtuAnimation = 6; */
        if (message.shouldTriggerRtuAnimation !== undefined)
            writer.tag(6, runtime_2.WireType.Varint).bool(message.shouldTriggerRtuAnimation);
        /* optional bool initiatedOnWeb = 7; */
        if (message.initiatedOnWeb !== undefined)
            writer.tag(7, runtime_2.WireType.Varint).bool(message.initiatedOnWeb);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.InfoGeometryCommandArchive
 */
exports.InfoGeometryCommandArchive = new InfoGeometryCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DrawablePathSourceCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.DrawablePathSourceCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.InfoCommandArchive },
            { no: 2, name: "old_path_source", kind: "message", T: () => TSDArchives_6.PathSourceArchive },
            { no: 3, name: "new_path_source", kind: "message", T: () => TSDArchives_6.PathSourceArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoCommandArchive super */ 1:
                    message.super = exports.InfoCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSD.PathSourceArchive old_path_source */ 2:
                    message.oldPathSource = TSDArchives_6.PathSourceArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldPathSource);
                    break;
                case /* optional TSD.PathSourceArchive new_path_source */ 3:
                    message.newPathSource = TSDArchives_6.PathSourceArchive.internalBinaryRead(reader, reader.uint32(), options, message.newPathSource);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoCommandArchive super = 1; */
        if (message.super)
            exports.InfoCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.PathSourceArchive old_path_source = 2; */
        if (message.oldPathSource)
            TSDArchives_6.PathSourceArchive.internalBinaryWrite(message.oldPathSource, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.PathSourceArchive new_path_source = 3; */
        if (message.newPathSource)
            TSDArchives_6.PathSourceArchive.internalBinaryWrite(message.newPathSource, writer.tag(3, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.DrawablePathSourceCommandArchive
 */
exports.DrawablePathSourceCommandArchive = new DrawablePathSourceCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstantAlphaCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.InstantAlphaCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.InfoCommandArchive },
            { no: 2, name: "oldpath", kind: "message", T: () => TSPMessages_3.Path },
            { no: 3, name: "newpath", kind: "message", T: () => TSPMessages_3.Path }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoCommandArchive super */ 1:
                    message.super = exports.InfoCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Path oldpath */ 2:
                    message.oldpath = TSPMessages_3.Path.internalBinaryRead(reader, reader.uint32(), options, message.oldpath);
                    break;
                case /* optional TSP.Path newpath */ 3:
                    message.newpath = TSPMessages_3.Path.internalBinaryRead(reader, reader.uint32(), options, message.newpath);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoCommandArchive super = 1; */
        if (message.super)
            exports.InfoCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Path oldpath = 2; */
        if (message.oldpath)
            TSPMessages_3.Path.internalBinaryWrite(message.oldpath, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Path newpath = 3; */
        if (message.newpath)
            TSPMessages_3.Path.internalBinaryWrite(message.newpath, writer.tag(3, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.InstantAlphaCommandArchive
 */
exports.InstantAlphaCommandArchive = new InstantAlphaCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DrawableApplyThemeCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.DrawableApplyThemeCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSSArchives_1.ApplyThemeChildCommandArchive },
            { no: 2, name: "info", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 3, name: "style", kind: "message", T: () => TSPMessages_6.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSS.ApplyThemeChildCommandArchive super */ 1:
                    message.super = TSSArchives_1.ApplyThemeChildCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference info */ 2:
                    message.info = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                case /* optional TSP.Reference style */ 3:
                    message.style = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.style);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSS.ApplyThemeChildCommandArchive super = 1; */
        if (message.super)
            TSSArchives_1.ApplyThemeChildCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference info = 2; */
        if (message.info)
            TSPMessages_6.Reference.internalBinaryWrite(message.info, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference style = 3; */
        if (message.style)
            TSPMessages_6.Reference.internalBinaryWrite(message.style, writer.tag(3, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.DrawableApplyThemeCommandArchive
 */
exports.DrawableApplyThemeCommandArchive = new DrawableApplyThemeCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbstractStyleCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.AbstractStyleCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.InfoCommandArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoCommandArchive super */ 1:
                    message.super = exports.InfoCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoCommandArchive super = 1; */
        if (message.super)
            exports.InfoCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.AbstractStyleCommandArchive
 */
exports.AbstractStyleCommandArchive = new AbstractStyleCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StyledInfoSetStyleCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.StyledInfoSetStyleCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.AbstractStyleCommandArchive },
            { no: 2, name: "new_style", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 4, name: "rollback_style", kind: "message", T: () => TSPMessages_6.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.AbstractStyleCommandArchive super */ 1:
                    message.super = exports.AbstractStyleCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference new_style */ 2:
                    message.newStyle = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.newStyle);
                    break;
                case /* optional TSP.Reference rollback_style */ 4:
                    message.rollbackStyle = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.rollbackStyle);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.AbstractStyleCommandArchive super = 1; */
        if (message.super)
            exports.AbstractStyleCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference new_style = 2; */
        if (message.newStyle)
            TSPMessages_6.Reference.internalBinaryWrite(message.newStyle, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference rollback_style = 4; */
        if (message.rollbackStyle)
            TSPMessages_6.Reference.internalBinaryWrite(message.rollbackStyle, writer.tag(4, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.StyledInfoSetStyleCommandArchive
 */
exports.StyledInfoSetStyleCommandArchive = new StyledInfoSetStyleCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BaseApplyPresetCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.BaseApplyPresetCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.AbstractStyleCommandArchive },
            { no: 2, name: "preset_style", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 4, name: "rollback_style", kind: "message", T: () => TSPMessages_6.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.AbstractStyleCommandArchive super */ 1:
                    message.super = exports.AbstractStyleCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference preset_style */ 2:
                    message.presetStyle = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.presetStyle);
                    break;
                case /* optional TSP.Reference rollback_style */ 4:
                    message.rollbackStyle = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.rollbackStyle);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.AbstractStyleCommandArchive super = 1; */
        if (message.super)
            exports.AbstractStyleCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference preset_style = 2; */
        if (message.presetStyle)
            TSPMessages_6.Reference.internalBinaryWrite(message.presetStyle, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference rollback_style = 4; */
        if (message.rollbackStyle)
            TSPMessages_6.Reference.internalBinaryWrite(message.rollbackStyle, writer.tag(4, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.BaseApplyPresetCommandArchive
 */
exports.BaseApplyPresetCommandArchive = new BaseApplyPresetCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShapeApplyPresetCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ShapeApplyPresetCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.BaseApplyPresetCommandArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.BaseApplyPresetCommandArchive super */ 1:
                    message.super = exports.BaseApplyPresetCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.BaseApplyPresetCommandArchive super = 1; */
        if (message.super)
            exports.BaseApplyPresetCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ShapeApplyPresetCommandArchive
 */
exports.ShapeApplyPresetCommandArchive = new ShapeApplyPresetCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MediaApplyPresetCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.MediaApplyPresetCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.BaseApplyPresetCommandArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.BaseApplyPresetCommandArchive super */ 1:
                    message.super = exports.BaseApplyPresetCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.BaseApplyPresetCommandArchive super = 1; */
        if (message.super)
            exports.BaseApplyPresetCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.MediaApplyPresetCommandArchive
 */
exports.MediaApplyPresetCommandArchive = new MediaApplyPresetCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShapeStyleSetValueCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ShapeStyleSetValueCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.BaseStyleSetValueCommandArchive },
            { no: 4, name: "change", kind: "message", T: () => TSDArchives_sos_2.BaseShapeStylePropertyChangeSetArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.BaseStyleSetValueCommandArchive super */ 1:
                    message.super = exports.BaseStyleSetValueCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSDSOS.BaseShapeStylePropertyChangeSetArchive change */ 4:
                    message.change = TSDArchives_sos_2.BaseShapeStylePropertyChangeSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.change);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.BaseStyleSetValueCommandArchive super = 1; */
        if (message.super)
            exports.BaseStyleSetValueCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSDSOS.BaseShapeStylePropertyChangeSetArchive change = 4; */
        if (message.change)
            TSDArchives_sos_2.BaseShapeStylePropertyChangeSetArchive.internalBinaryWrite(message.change, writer.tag(4, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ShapeStyleSetValueCommandArchive
 */
exports.ShapeStyleSetValueCommandArchive = new ShapeStyleSetValueCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BaseStyleSetValueCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.BaseStyleSetValueCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.AbstractStyleCommandArchive },
            { no: 4, name: "old_style", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 5, name: "is_border_change", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { isBorderChange: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.AbstractStyleCommandArchive super */ 1:
                    message.super = exports.AbstractStyleCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference old_style */ 4:
                    message.oldStyle = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.oldStyle);
                    break;
                case /* bool is_border_change */ 5:
                    message.isBorderChange = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.AbstractStyleCommandArchive super = 1; */
        if (message.super)
            exports.AbstractStyleCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference old_style = 4; */
        if (message.oldStyle)
            TSPMessages_6.Reference.internalBinaryWrite(message.oldStyle, writer.tag(4, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* bool is_border_change = 5; */
        if (message.isBorderChange !== false)
            writer.tag(5, runtime_2.WireType.Varint).bool(message.isBorderChange);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.BaseStyleSetValueCommandArchive
 */
exports.BaseStyleSetValueCommandArchive = new BaseStyleSetValueCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MovieSetValueCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.MovieSetValueCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.InfoCommandArchive },
            { no: 2, name: "property", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "value", kind: "message", T: () => exports.MovieSetValueCommandArchive_PropertyValue },
            { no: 4, name: "oldValue", kind: "message", T: () => exports.MovieSetValueCommandArchive_PropertyValue },
            { no: 5, name: "importedauxiliarymedia", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 6, name: "oldimportedauxiliarymedia", kind: "message", T: () => TSPMessages_2.DataReference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoCommandArchive super */ 1:
                    message.super = exports.InfoCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional int32 property */ 2:
                    message.property = reader.int32();
                    break;
                case /* optional TSD.MovieSetValueCommandArchive.PropertyValue value */ 3:
                    message.value = exports.MovieSetValueCommandArchive_PropertyValue.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                case /* optional TSD.MovieSetValueCommandArchive.PropertyValue oldValue */ 4:
                    message.oldValue = exports.MovieSetValueCommandArchive_PropertyValue.internalBinaryRead(reader, reader.uint32(), options, message.oldValue);
                    break;
                case /* optional TSP.DataReference importedauxiliarymedia */ 5:
                    message.importedauxiliarymedia = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.importedauxiliarymedia);
                    break;
                case /* optional TSP.DataReference oldimportedauxiliarymedia */ 6:
                    message.oldimportedauxiliarymedia = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.oldimportedauxiliarymedia);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoCommandArchive super = 1; */
        if (message.super)
            exports.InfoCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional int32 property = 2; */
        if (message.property !== undefined)
            writer.tag(2, runtime_2.WireType.Varint).int32(message.property);
        /* optional TSD.MovieSetValueCommandArchive.PropertyValue value = 3; */
        if (message.value)
            exports.MovieSetValueCommandArchive_PropertyValue.internalBinaryWrite(message.value, writer.tag(3, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.MovieSetValueCommandArchive.PropertyValue oldValue = 4; */
        if (message.oldValue)
            exports.MovieSetValueCommandArchive_PropertyValue.internalBinaryWrite(message.oldValue, writer.tag(4, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference importedauxiliarymedia = 5; */
        if (message.importedauxiliarymedia)
            TSPMessages_2.DataReference.internalBinaryWrite(message.importedauxiliarymedia, writer.tag(5, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference oldimportedauxiliarymedia = 6; */
        if (message.oldimportedauxiliarymedia)
            TSPMessages_2.DataReference.internalBinaryWrite(message.oldimportedauxiliarymedia, writer.tag(6, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.MovieSetValueCommandArchive
 */
exports.MovieSetValueCommandArchive = new MovieSetValueCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MovieSetValueCommandArchive_PropertyValue$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.MovieSetValueCommandArchive.PropertyValue", [
            { no: 1, name: "starttime", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "endtime", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "postertime", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "posterimagedata", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 5, name: "autoplay", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "loopOption", kind: "enum", opt: true, T: () => ["TSD.MovieSetValueCommandArchive.LoopOption", MovieSetValueCommandArchive_LoopOption] },
            { no: 7, name: "volume", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "media", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 9, name: "playsAcrossSlides", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double starttime */ 1:
                    message.starttime = reader.double();
                    break;
                case /* optional double endtime */ 2:
                    message.endtime = reader.double();
                    break;
                case /* optional double postertime */ 3:
                    message.postertime = reader.double();
                    break;
                case /* optional TSP.DataReference posterimagedata */ 4:
                    message.posterimagedata = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.posterimagedata);
                    break;
                case /* optional bool autoplay */ 5:
                    message.autoplay = reader.bool();
                    break;
                case /* optional TSD.MovieSetValueCommandArchive.LoopOption loopOption */ 6:
                    message.loopOption = reader.int32();
                    break;
                case /* optional float volume */ 7:
                    message.volume = reader.float();
                    break;
                case /* optional TSP.DataReference media */ 8:
                    message.media = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.media);
                    break;
                case /* optional bool playsAcrossSlides */ 9:
                    message.playsAcrossSlides = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional double starttime = 1; */
        if (message.starttime !== undefined)
            writer.tag(1, runtime_2.WireType.Bit64).double(message.starttime);
        /* optional double endtime = 2; */
        if (message.endtime !== undefined)
            writer.tag(2, runtime_2.WireType.Bit64).double(message.endtime);
        /* optional double postertime = 3; */
        if (message.postertime !== undefined)
            writer.tag(3, runtime_2.WireType.Bit64).double(message.postertime);
        /* optional TSP.DataReference posterimagedata = 4; */
        if (message.posterimagedata)
            TSPMessages_2.DataReference.internalBinaryWrite(message.posterimagedata, writer.tag(4, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional bool autoplay = 5; */
        if (message.autoplay !== undefined)
            writer.tag(5, runtime_2.WireType.Varint).bool(message.autoplay);
        /* optional TSD.MovieSetValueCommandArchive.LoopOption loopOption = 6; */
        if (message.loopOption !== undefined)
            writer.tag(6, runtime_2.WireType.Varint).int32(message.loopOption);
        /* optional float volume = 7; */
        if (message.volume !== undefined)
            writer.tag(7, runtime_2.WireType.Bit32).float(message.volume);
        /* optional TSP.DataReference media = 8; */
        if (message.media)
            TSPMessages_2.DataReference.internalBinaryWrite(message.media, writer.tag(8, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional bool playsAcrossSlides = 9; */
        if (message.playsAcrossSlides !== undefined)
            writer.tag(9, runtime_2.WireType.Varint).bool(message.playsAcrossSlides);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.MovieSetValueCommandArchive.PropertyValue
 */
exports.MovieSetValueCommandArchive_PropertyValue = new MovieSetValueCommandArchive_PropertyValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MediaStyleSetValueCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.MediaStyleSetValueCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.BaseStyleSetValueCommandArchive },
            { no: 4, name: "change", kind: "message", T: () => TSDArchives_sos_1.MediaStylePropertyChangeSetArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.BaseStyleSetValueCommandArchive super */ 1:
                    message.super = exports.BaseStyleSetValueCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSDSOS.MediaStylePropertyChangeSetArchive change */ 4:
                    message.change = TSDArchives_sos_1.MediaStylePropertyChangeSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.change);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.BaseStyleSetValueCommandArchive super = 1; */
        if (message.super)
            exports.BaseStyleSetValueCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSDSOS.MediaStylePropertyChangeSetArchive change = 4; */
        if (message.change)
            TSDArchives_sos_1.MediaStylePropertyChangeSetArchive.internalBinaryWrite(message.change, writer.tag(4, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.MediaStyleSetValueCommandArchive
 */
exports.MediaStyleSetValueCommandArchive = new MediaStyleSetValueCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImageMediaCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ImageMediaCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.InfoCommandArchive },
            { no: 8, name: "newImageData", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 9, name: "oldImageData", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 10, name: "oldOriginalImageData", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 6, name: "oldNaturalSize", kind: "message", T: () => TSPMessages_1.Size },
            { no: 11, name: "newOriginalImageData", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 12, name: "oldImageAdjustments", kind: "message", T: () => TSDArchives_5.ImageAdjustmentsArchive },
            { no: 13, name: "oldAdjustedImageData", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 14, name: "oldEnhancedImageData", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 15, name: "imageAdjustments", kind: "message", T: () => TSDArchives_5.ImageAdjustmentsArchive },
            { no: 16, name: "adjustedImageData", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 17, name: "enhancedImageData", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 18, name: "newThumbnailImageData", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 19, name: "oldThumbnailImageData", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 20, name: "thumbnailAdjustedImageData", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 21, name: "oldThumbnailAdjustedImageData", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 3, name: "database_newImageData", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 4, name: "database_oldImageData", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 5, name: "database_oldOriginalImageData", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 7, name: "database_newOriginalImageData", kind: "message", T: () => TSPMessages_6.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoCommandArchive super */ 1:
                    message.super = exports.InfoCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.DataReference newImageData */ 8:
                    message.newImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.newImageData);
                    break;
                case /* optional TSP.DataReference oldImageData */ 9:
                    message.oldImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.oldImageData);
                    break;
                case /* optional TSP.DataReference oldOriginalImageData */ 10:
                    message.oldOriginalImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.oldOriginalImageData);
                    break;
                case /* optional TSP.Size oldNaturalSize */ 6:
                    message.oldNaturalSize = TSPMessages_1.Size.internalBinaryRead(reader, reader.uint32(), options, message.oldNaturalSize);
                    break;
                case /* optional TSP.DataReference newOriginalImageData */ 11:
                    message.newOriginalImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.newOriginalImageData);
                    break;
                case /* optional TSD.ImageAdjustmentsArchive oldImageAdjustments */ 12:
                    message.oldImageAdjustments = TSDArchives_5.ImageAdjustmentsArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldImageAdjustments);
                    break;
                case /* optional TSP.DataReference oldAdjustedImageData */ 13:
                    message.oldAdjustedImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.oldAdjustedImageData);
                    break;
                case /* optional TSP.DataReference oldEnhancedImageData */ 14:
                    message.oldEnhancedImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.oldEnhancedImageData);
                    break;
                case /* optional TSD.ImageAdjustmentsArchive imageAdjustments */ 15:
                    message.imageAdjustments = TSDArchives_5.ImageAdjustmentsArchive.internalBinaryRead(reader, reader.uint32(), options, message.imageAdjustments);
                    break;
                case /* optional TSP.DataReference adjustedImageData */ 16:
                    message.adjustedImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.adjustedImageData);
                    break;
                case /* optional TSP.DataReference enhancedImageData */ 17:
                    message.enhancedImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.enhancedImageData);
                    break;
                case /* optional TSP.DataReference newThumbnailImageData */ 18:
                    message.newThumbnailImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.newThumbnailImageData);
                    break;
                case /* optional TSP.DataReference oldThumbnailImageData */ 19:
                    message.oldThumbnailImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.oldThumbnailImageData);
                    break;
                case /* optional TSP.DataReference thumbnailAdjustedImageData */ 20:
                    message.thumbnailAdjustedImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.thumbnailAdjustedImageData);
                    break;
                case /* optional TSP.DataReference oldThumbnailAdjustedImageData */ 21:
                    message.oldThumbnailAdjustedImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.oldThumbnailAdjustedImageData);
                    break;
                case /* optional TSP.Reference database_newImageData */ 3:
                    message.databaseNewImageData = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.databaseNewImageData);
                    break;
                case /* optional TSP.Reference database_oldImageData */ 4:
                    message.databaseOldImageData = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.databaseOldImageData);
                    break;
                case /* optional TSP.Reference database_oldOriginalImageData */ 5:
                    message.databaseOldOriginalImageData = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.databaseOldOriginalImageData);
                    break;
                case /* optional TSP.Reference database_newOriginalImageData */ 7:
                    message.databaseNewOriginalImageData = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.databaseNewOriginalImageData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoCommandArchive super = 1; */
        if (message.super)
            exports.InfoCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference newImageData = 8; */
        if (message.newImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.newImageData, writer.tag(8, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference oldImageData = 9; */
        if (message.oldImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.oldImageData, writer.tag(9, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference oldOriginalImageData = 10; */
        if (message.oldOriginalImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.oldOriginalImageData, writer.tag(10, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Size oldNaturalSize = 6; */
        if (message.oldNaturalSize)
            TSPMessages_1.Size.internalBinaryWrite(message.oldNaturalSize, writer.tag(6, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference newOriginalImageData = 11; */
        if (message.newOriginalImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.newOriginalImageData, writer.tag(11, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.ImageAdjustmentsArchive oldImageAdjustments = 12; */
        if (message.oldImageAdjustments)
            TSDArchives_5.ImageAdjustmentsArchive.internalBinaryWrite(message.oldImageAdjustments, writer.tag(12, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference oldAdjustedImageData = 13; */
        if (message.oldAdjustedImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.oldAdjustedImageData, writer.tag(13, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference oldEnhancedImageData = 14; */
        if (message.oldEnhancedImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.oldEnhancedImageData, writer.tag(14, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.ImageAdjustmentsArchive imageAdjustments = 15; */
        if (message.imageAdjustments)
            TSDArchives_5.ImageAdjustmentsArchive.internalBinaryWrite(message.imageAdjustments, writer.tag(15, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference adjustedImageData = 16; */
        if (message.adjustedImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.adjustedImageData, writer.tag(16, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference enhancedImageData = 17; */
        if (message.enhancedImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.enhancedImageData, writer.tag(17, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference newThumbnailImageData = 18; */
        if (message.newThumbnailImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.newThumbnailImageData, writer.tag(18, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference oldThumbnailImageData = 19; */
        if (message.oldThumbnailImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.oldThumbnailImageData, writer.tag(19, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference thumbnailAdjustedImageData = 20; */
        if (message.thumbnailAdjustedImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.thumbnailAdjustedImageData, writer.tag(20, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference oldThumbnailAdjustedImageData = 21; */
        if (message.oldThumbnailAdjustedImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.oldThumbnailAdjustedImageData, writer.tag(21, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference database_newImageData = 3; */
        if (message.databaseNewImageData)
            TSPMessages_6.Reference.internalBinaryWrite(message.databaseNewImageData, writer.tag(3, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference database_oldImageData = 4; */
        if (message.databaseOldImageData)
            TSPMessages_6.Reference.internalBinaryWrite(message.databaseOldImageData, writer.tag(4, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference database_oldOriginalImageData = 5; */
        if (message.databaseOldOriginalImageData)
            TSPMessages_6.Reference.internalBinaryWrite(message.databaseOldOriginalImageData, writer.tag(5, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference database_newOriginalImageData = 7; */
        if (message.databaseNewOriginalImageData)
            TSPMessages_6.Reference.internalBinaryWrite(message.databaseNewOriginalImageData, writer.tag(7, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ImageMediaCommandArchive
 */
exports.ImageMediaCommandArchive = new ImageMediaCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MediaOriginalSizeCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.MediaOriginalSizeCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.InfoCommandArchive },
            { no: 2, name: "newOriginalSize", kind: "message", T: () => TSPMessages_1.Size },
            { no: 3, name: "oldOriginalSize", kind: "message", T: () => TSPMessages_1.Size },
            { no: 4, name: "propertyName", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { propertyName: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoCommandArchive super */ 1:
                    message.super = exports.InfoCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Size newOriginalSize */ 2:
                    message.newOriginalSize = TSPMessages_1.Size.internalBinaryRead(reader, reader.uint32(), options, message.newOriginalSize);
                    break;
                case /* optional TSP.Size oldOriginalSize */ 3:
                    message.oldOriginalSize = TSPMessages_1.Size.internalBinaryRead(reader, reader.uint32(), options, message.oldOriginalSize);
                    break;
                case /* string propertyName */ 4:
                    message.propertyName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoCommandArchive super = 1; */
        if (message.super)
            exports.InfoCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Size newOriginalSize = 2; */
        if (message.newOriginalSize)
            TSPMessages_1.Size.internalBinaryWrite(message.newOriginalSize, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Size oldOriginalSize = 3; */
        if (message.oldOriginalSize)
            TSPMessages_1.Size.internalBinaryWrite(message.oldOriginalSize, writer.tag(3, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* string propertyName = 4; */
        if (message.propertyName !== "")
            writer.tag(4, runtime_2.WireType.LengthDelimited).string(message.propertyName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.MediaOriginalSizeCommandArchive
 */
exports.MediaOriginalSizeCommandArchive = new MediaOriginalSizeCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MediaInfoGeometryCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.MediaInfoGeometryCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.InfoGeometryCommandArchive },
            { no: 2, name: "newOriginalSize", kind: "message", T: () => TSPMessages_1.Size },
            { no: 3, name: "oldOriginalSize", kind: "message", T: () => TSPMessages_1.Size }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoGeometryCommandArchive super */ 1:
                    message.super = exports.InfoGeometryCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Size newOriginalSize */ 2:
                    message.newOriginalSize = TSPMessages_1.Size.internalBinaryRead(reader, reader.uint32(), options, message.newOriginalSize);
                    break;
                case /* TSP.Size oldOriginalSize */ 3:
                    message.oldOriginalSize = TSPMessages_1.Size.internalBinaryRead(reader, reader.uint32(), options, message.oldOriginalSize);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoGeometryCommandArchive super = 1; */
        if (message.super)
            exports.InfoGeometryCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Size newOriginalSize = 2; */
        if (message.newOriginalSize)
            TSPMessages_1.Size.internalBinaryWrite(message.newOriginalSize, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Size oldOriginalSize = 3; */
        if (message.oldOriginalSize)
            TSPMessages_1.Size.internalBinaryWrite(message.oldOriginalSize, writer.tag(3, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.MediaInfoGeometryCommandArchive
 */
exports.MediaInfoGeometryCommandArchive = new MediaInfoGeometryCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImageNaturalSizeCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ImageNaturalSizeCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.InfoCommandArchive },
            { no: 2, name: "new_natural_size", kind: "message", T: () => TSPMessages_1.Size },
            { no: 3, name: "old_natural_size", kind: "message", T: () => TSPMessages_1.Size }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoCommandArchive super */ 1:
                    message.super = exports.InfoCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Size new_natural_size */ 2:
                    message.newNaturalSize = TSPMessages_1.Size.internalBinaryRead(reader, reader.uint32(), options, message.newNaturalSize);
                    break;
                case /* optional TSP.Size old_natural_size */ 3:
                    message.oldNaturalSize = TSPMessages_1.Size.internalBinaryRead(reader, reader.uint32(), options, message.oldNaturalSize);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoCommandArchive super = 1; */
        if (message.super)
            exports.InfoCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Size new_natural_size = 2; */
        if (message.newNaturalSize)
            TSPMessages_1.Size.internalBinaryWrite(message.newNaturalSize, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Size old_natural_size = 3; */
        if (message.oldNaturalSize)
            TSPMessages_1.Size.internalBinaryWrite(message.oldNaturalSize, writer.tag(3, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ImageNaturalSizeCommandArchive
 */
exports.ImageNaturalSizeCommandArchive = new ImageNaturalSizeCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImageMaskCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ImageMaskCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.InfoCommandArchive },
            { no: 2, name: "newMaskInfo", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 3, name: "oldMaskInfo", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 4, name: "background_removed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "old_background_removed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoCommandArchive super */ 1:
                    message.super = exports.InfoCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference newMaskInfo */ 2:
                    message.newMaskInfo = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.newMaskInfo);
                    break;
                case /* optional TSP.Reference oldMaskInfo */ 3:
                    message.oldMaskInfo = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.oldMaskInfo);
                    break;
                case /* optional bool background_removed */ 4:
                    message.backgroundRemoved = reader.bool();
                    break;
                case /* optional bool old_background_removed */ 5:
                    message.oldBackgroundRemoved = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoCommandArchive super = 1; */
        if (message.super)
            exports.InfoCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference newMaskInfo = 2; */
        if (message.newMaskInfo)
            TSPMessages_6.Reference.internalBinaryWrite(message.newMaskInfo, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference oldMaskInfo = 3; */
        if (message.oldMaskInfo)
            TSPMessages_6.Reference.internalBinaryWrite(message.oldMaskInfo, writer.tag(3, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional bool background_removed = 4; */
        if (message.backgroundRemoved !== undefined)
            writer.tag(4, runtime_2.WireType.Varint).bool(message.backgroundRemoved);
        /* optional bool old_background_removed = 5; */
        if (message.oldBackgroundRemoved !== undefined)
            writer.tag(5, runtime_2.WireType.Varint).bool(message.oldBackgroundRemoved);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ImageMaskCommandArchive
 */
exports.ImageMaskCommandArchive = new ImageMaskCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImageAdjustmentsCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ImageAdjustmentsCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.InfoCommandArchive },
            { no: 2, name: "old_image_adjustments", kind: "message", T: () => TSDArchives_5.ImageAdjustmentsArchive },
            { no: 3, name: "new_image_adjustments", kind: "message", T: () => TSDArchives_5.ImageAdjustmentsArchive },
            { no: 4, name: "adjustedImageData", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 5, name: "replacedAdjustedImageData", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 6, name: "enhancedImageData", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 7, name: "replacedEnhancedImageData", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 8, name: "thumbnailAdjustedImageData", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 9, name: "replacedThumbnailAdjustedImageData", kind: "message", T: () => TSPMessages_2.DataReference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoCommandArchive super */ 1:
                    message.super = exports.InfoCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSD.ImageAdjustmentsArchive old_image_adjustments */ 2:
                    message.oldImageAdjustments = TSDArchives_5.ImageAdjustmentsArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldImageAdjustments);
                    break;
                case /* optional TSD.ImageAdjustmentsArchive new_image_adjustments */ 3:
                    message.newImageAdjustments = TSDArchives_5.ImageAdjustmentsArchive.internalBinaryRead(reader, reader.uint32(), options, message.newImageAdjustments);
                    break;
                case /* optional TSP.DataReference adjustedImageData */ 4:
                    message.adjustedImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.adjustedImageData);
                    break;
                case /* optional TSP.DataReference replacedAdjustedImageData */ 5:
                    message.replacedAdjustedImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.replacedAdjustedImageData);
                    break;
                case /* optional TSP.DataReference enhancedImageData */ 6:
                    message.enhancedImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.enhancedImageData);
                    break;
                case /* optional TSP.DataReference replacedEnhancedImageData */ 7:
                    message.replacedEnhancedImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.replacedEnhancedImageData);
                    break;
                case /* optional TSP.DataReference thumbnailAdjustedImageData */ 8:
                    message.thumbnailAdjustedImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.thumbnailAdjustedImageData);
                    break;
                case /* optional TSP.DataReference replacedThumbnailAdjustedImageData */ 9:
                    message.replacedThumbnailAdjustedImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.replacedThumbnailAdjustedImageData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoCommandArchive super = 1; */
        if (message.super)
            exports.InfoCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.ImageAdjustmentsArchive old_image_adjustments = 2; */
        if (message.oldImageAdjustments)
            TSDArchives_5.ImageAdjustmentsArchive.internalBinaryWrite(message.oldImageAdjustments, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.ImageAdjustmentsArchive new_image_adjustments = 3; */
        if (message.newImageAdjustments)
            TSDArchives_5.ImageAdjustmentsArchive.internalBinaryWrite(message.newImageAdjustments, writer.tag(3, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference adjustedImageData = 4; */
        if (message.adjustedImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.adjustedImageData, writer.tag(4, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference replacedAdjustedImageData = 5; */
        if (message.replacedAdjustedImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.replacedAdjustedImageData, writer.tag(5, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference enhancedImageData = 6; */
        if (message.enhancedImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.enhancedImageData, writer.tag(6, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference replacedEnhancedImageData = 7; */
        if (message.replacedEnhancedImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.replacedEnhancedImageData, writer.tag(7, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference thumbnailAdjustedImageData = 8; */
        if (message.thumbnailAdjustedImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.thumbnailAdjustedImageData, writer.tag(8, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference replacedThumbnailAdjustedImageData = 9; */
        if (message.replacedThumbnailAdjustedImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.replacedThumbnailAdjustedImageData, writer.tag(9, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ImageAdjustmentsCommandArchive
 */
exports.ImageAdjustmentsCommandArchive = new ImageAdjustmentsCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MediaFlagsCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.MediaFlagsCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.InfoCommandArchive },
            { no: 5, name: "was_media_replaced", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "is_placeholder", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "old_was_media_replaced", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "old_is_placeholder", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "property_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { propertyName: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoCommandArchive super */ 1:
                    message.super = exports.InfoCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional bool was_media_replaced */ 5:
                    message.wasMediaReplaced = reader.bool();
                    break;
                case /* optional bool is_placeholder */ 6:
                    message.isPlaceholder = reader.bool();
                    break;
                case /* optional bool old_was_media_replaced */ 7:
                    message.oldWasMediaReplaced = reader.bool();
                    break;
                case /* optional bool old_is_placeholder */ 8:
                    message.oldIsPlaceholder = reader.bool();
                    break;
                case /* string property_name */ 4:
                    message.propertyName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoCommandArchive super = 1; */
        if (message.super)
            exports.InfoCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional bool was_media_replaced = 5; */
        if (message.wasMediaReplaced !== undefined)
            writer.tag(5, runtime_2.WireType.Varint).bool(message.wasMediaReplaced);
        /* optional bool is_placeholder = 6; */
        if (message.isPlaceholder !== undefined)
            writer.tag(6, runtime_2.WireType.Varint).bool(message.isPlaceholder);
        /* optional bool old_was_media_replaced = 7; */
        if (message.oldWasMediaReplaced !== undefined)
            writer.tag(7, runtime_2.WireType.Varint).bool(message.oldWasMediaReplaced);
        /* optional bool old_is_placeholder = 8; */
        if (message.oldIsPlaceholder !== undefined)
            writer.tag(8, runtime_2.WireType.Varint).bool(message.oldIsPlaceholder);
        /* string property_name = 4; */
        if (message.propertyName !== "")
            writer.tag(4, runtime_2.WireType.LengthDelimited).string(message.propertyName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.MediaFlagsCommandArchive
 */
exports.MediaFlagsCommandArchive = new MediaFlagsCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DrawablesCommandGroupArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.DrawablesCommandGroupArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_2.CommandGroupArchive },
            { no: 2, name: "obsolete_selection", kind: "message", T: () => TSDArchives_4.CanvasSelectionArchive },
            { no: 3, name: "modelforselection", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 4, name: "type", kind: "enum", opt: true, T: () => ["TSD.DrawablesCommandGroupArchive.DrawablesCommandGroupType", DrawablesCommandGroupArchive_DrawablesCommandGroupType] },
            { no: 5, name: "forDrag", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "archivedselection", kind: "message", T: () => TSPMessages_6.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandGroupArchive super */ 1:
                    message.super = TSKArchives_2.CommandGroupArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSD.CanvasSelectionArchive obsolete_selection */ 2:
                    message.obsoleteSelection = TSDArchives_4.CanvasSelectionArchive.internalBinaryRead(reader, reader.uint32(), options, message.obsoleteSelection);
                    break;
                case /* optional TSP.Reference modelforselection */ 3:
                    message.modelforselection = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.modelforselection);
                    break;
                case /* optional TSD.DrawablesCommandGroupArchive.DrawablesCommandGroupType type */ 4:
                    message.type = reader.int32();
                    break;
                case /* optional bool forDrag */ 5:
                    message.forDrag = reader.bool();
                    break;
                case /* optional TSP.Reference archivedselection */ 6:
                    message.archivedselection = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.archivedselection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandGroupArchive super = 1; */
        if (message.super)
            TSKArchives_2.CommandGroupArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.CanvasSelectionArchive obsolete_selection = 2; */
        if (message.obsoleteSelection)
            TSDArchives_4.CanvasSelectionArchive.internalBinaryWrite(message.obsoleteSelection, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference modelforselection = 3; */
        if (message.modelforselection)
            TSPMessages_6.Reference.internalBinaryWrite(message.modelforselection, writer.tag(3, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.DrawablesCommandGroupArchive.DrawablesCommandGroupType type = 4; */
        if (message.type !== undefined)
            writer.tag(4, runtime_2.WireType.Varint).int32(message.type);
        /* optional bool forDrag = 5; */
        if (message.forDrag !== undefined)
            writer.tag(5, runtime_2.WireType.Varint).bool(message.forDrag);
        /* optional TSP.Reference archivedselection = 6; */
        if (message.archivedselection)
            TSPMessages_6.Reference.internalBinaryWrite(message.archivedselection, writer.tag(6, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.DrawablesCommandGroupArchive
 */
exports.DrawablesCommandGroupArchive = new DrawablesCommandGroupArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExteriorTextWrapCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ExteriorTextWrapCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.InfoCommandArchive },
            { no: 3, name: "old_exterior_text_wrap", kind: "message", T: () => TSDArchives_3.ExteriorTextWrapArchive },
            { no: 4, name: "type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "direction", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "fit_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "margin", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "alpha_threshold", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "is_html_wrap", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoCommandArchive super */ 1:
                    message.super = exports.InfoCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSD.ExteriorTextWrapArchive old_exterior_text_wrap */ 3:
                    message.oldExteriorTextWrap = TSDArchives_3.ExteriorTextWrapArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldExteriorTextWrap);
                    break;
                case /* optional uint32 type */ 4:
                    message.type = reader.uint32();
                    break;
                case /* optional uint32 direction */ 5:
                    message.direction = reader.uint32();
                    break;
                case /* optional uint32 fit_type */ 6:
                    message.fitType = reader.uint32();
                    break;
                case /* optional float margin */ 7:
                    message.margin = reader.float();
                    break;
                case /* optional float alpha_threshold */ 8:
                    message.alphaThreshold = reader.float();
                    break;
                case /* optional bool is_html_wrap */ 9:
                    message.isHtmlWrap = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoCommandArchive super = 1; */
        if (message.super)
            exports.InfoCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.ExteriorTextWrapArchive old_exterior_text_wrap = 3; */
        if (message.oldExteriorTextWrap)
            TSDArchives_3.ExteriorTextWrapArchive.internalBinaryWrite(message.oldExteriorTextWrap, writer.tag(3, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 type = 4; */
        if (message.type !== undefined)
            writer.tag(4, runtime_2.WireType.Varint).uint32(message.type);
        /* optional uint32 direction = 5; */
        if (message.direction !== undefined)
            writer.tag(5, runtime_2.WireType.Varint).uint32(message.direction);
        /* optional uint32 fit_type = 6; */
        if (message.fitType !== undefined)
            writer.tag(6, runtime_2.WireType.Varint).uint32(message.fitType);
        /* optional float margin = 7; */
        if (message.margin !== undefined)
            writer.tag(7, runtime_2.WireType.Bit32).float(message.margin);
        /* optional float alpha_threshold = 8; */
        if (message.alphaThreshold !== undefined)
            writer.tag(8, runtime_2.WireType.Bit32).float(message.alphaThreshold);
        /* optional bool is_html_wrap = 9; */
        if (message.isHtmlWrap !== undefined)
            writer.tag(9, runtime_2.WireType.Varint).bool(message.isHtmlWrap);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ExteriorTextWrapCommandArchive
 */
exports.ExteriorTextWrapCommandArchive = new ExteriorTextWrapCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DrawableHyperlinkCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.DrawableHyperlinkCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.InfoCommandArchive },
            { no: 2, name: "oldhyperlink_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "newhyperlink_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoCommandArchive super */ 1:
                    message.super = exports.InfoCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional string oldhyperlink_url */ 2:
                    message.oldhyperlinkUrl = reader.string();
                    break;
                case /* optional string newhyperlink_url */ 3:
                    message.newhyperlinkUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoCommandArchive super = 1; */
        if (message.super)
            exports.InfoCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional string oldhyperlink_url = 2; */
        if (message.oldhyperlinkUrl !== undefined)
            writer.tag(2, runtime_2.WireType.LengthDelimited).string(message.oldhyperlinkUrl);
        /* optional string newhyperlink_url = 3; */
        if (message.newhyperlinkUrl !== undefined)
            writer.tag(3, runtime_2.WireType.LengthDelimited).string(message.newhyperlinkUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.DrawableHyperlinkCommandArchive
 */
exports.DrawableHyperlinkCommandArchive = new DrawableHyperlinkCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommentInvalidatingCommandSelectionBehaviorArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.CommentInvalidatingCommandSelectionBehaviorArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_1.CommandSelectionBehaviorArchive },
            { no: 2, name: "annotation_displaying_command", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 3, name: "begin_editing_on_undo", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "begin_editing_on_redo", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "should_invalidate_on_undo", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "should_invalidate_on_redo", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandSelectionBehaviorArchive super */ 1:
                    message.super = TSKArchives_1.CommandSelectionBehaviorArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference annotation_displaying_command */ 2:
                    message.annotationDisplayingCommand = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.annotationDisplayingCommand);
                    break;
                case /* optional bool begin_editing_on_undo */ 3:
                    message.beginEditingOnUndo = reader.bool();
                    break;
                case /* optional bool begin_editing_on_redo */ 4:
                    message.beginEditingOnRedo = reader.bool();
                    break;
                case /* optional bool should_invalidate_on_undo */ 5:
                    message.shouldInvalidateOnUndo = reader.bool();
                    break;
                case /* optional bool should_invalidate_on_redo */ 6:
                    message.shouldInvalidateOnRedo = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandSelectionBehaviorArchive super = 1; */
        if (message.super)
            TSKArchives_1.CommandSelectionBehaviorArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference annotation_displaying_command = 2; */
        if (message.annotationDisplayingCommand)
            TSPMessages_6.Reference.internalBinaryWrite(message.annotationDisplayingCommand, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional bool begin_editing_on_undo = 3; */
        if (message.beginEditingOnUndo !== undefined)
            writer.tag(3, runtime_2.WireType.Varint).bool(message.beginEditingOnUndo);
        /* optional bool begin_editing_on_redo = 4; */
        if (message.beginEditingOnRedo !== undefined)
            writer.tag(4, runtime_2.WireType.Varint).bool(message.beginEditingOnRedo);
        /* optional bool should_invalidate_on_undo = 5; */
        if (message.shouldInvalidateOnUndo !== undefined)
            writer.tag(5, runtime_2.WireType.Varint).bool(message.shouldInvalidateOnUndo);
        /* optional bool should_invalidate_on_redo = 6; */
        if (message.shouldInvalidateOnRedo !== undefined)
            writer.tag(6, runtime_2.WireType.Varint).bool(message.shouldInvalidateOnRedo);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.CommentInvalidatingCommandSelectionBehaviorArchive
 */
exports.CommentInvalidatingCommandSelectionBehaviorArchive = new CommentInvalidatingCommandSelectionBehaviorArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImageReplaceCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ImageReplaceCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.InfoCommandArchive },
            { no: 2, name: "new_image_data", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 3, name: "new_original_image_data", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 4, name: "old_image_data", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 5, name: "old_original_image_data", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 6, name: "instant_alpha_path", kind: "message", T: () => TSPMessages_3.Path },
            { no: 7, name: "old_instant_alpha_path", kind: "message", T: () => TSPMessages_3.Path },
            { no: 8, name: "natural_size_for_IAPath", kind: "message", T: () => TSPMessages_1.Size },
            { no: 9, name: "old_natural_size_for_IAPath", kind: "message", T: () => TSPMessages_1.Size },
            { no: 10, name: "target_image_geometry", kind: "message", T: () => TSDArchives_7.GeometryArchive },
            { no: 12, name: "old_target_image_geometry", kind: "message", T: () => TSDArchives_7.GeometryArchive },
            { no: 13, name: "target_mask_geometry", kind: "message", T: () => TSDArchives_7.GeometryArchive },
            { no: 14, name: "old_target_mask_geometry", kind: "message", T: () => TSDArchives_7.GeometryArchive },
            { no: 15, name: "image_adjustments", kind: "message", T: () => TSDArchives_5.ImageAdjustmentsArchive },
            { no: 16, name: "adjusted_image_data", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 17, name: "enhanced_image_data", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 18, name: "old_image_adjustments", kind: "message", T: () => TSDArchives_5.ImageAdjustmentsArchive },
            { no: 19, name: "old_adjusted_image_data", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 20, name: "old_enhanced_image_data", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 21, name: "thumbnail_image_data", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 22, name: "old_thumbnail_image_data", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 23, name: "thumbnail_adjusted_image_data", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 24, name: "old_thumbnail_adjusted_image_data", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 25, name: "natural_size", kind: "message", T: () => TSPMessages_1.Size },
            { no: 26, name: "old_natural_size", kind: "message", T: () => TSPMessages_1.Size }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoCommandArchive super */ 1:
                    message.super = exports.InfoCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.DataReference new_image_data */ 2:
                    message.newImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.newImageData);
                    break;
                case /* optional TSP.DataReference new_original_image_data */ 3:
                    message.newOriginalImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.newOriginalImageData);
                    break;
                case /* optional TSP.DataReference old_image_data */ 4:
                    message.oldImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.oldImageData);
                    break;
                case /* optional TSP.DataReference old_original_image_data */ 5:
                    message.oldOriginalImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.oldOriginalImageData);
                    break;
                case /* optional TSP.Path instant_alpha_path */ 6:
                    message.instantAlphaPath = TSPMessages_3.Path.internalBinaryRead(reader, reader.uint32(), options, message.instantAlphaPath);
                    break;
                case /* optional TSP.Path old_instant_alpha_path */ 7:
                    message.oldInstantAlphaPath = TSPMessages_3.Path.internalBinaryRead(reader, reader.uint32(), options, message.oldInstantAlphaPath);
                    break;
                case /* optional TSP.Size natural_size_for_IAPath */ 8:
                    message.naturalSizeForIAPath = TSPMessages_1.Size.internalBinaryRead(reader, reader.uint32(), options, message.naturalSizeForIAPath);
                    break;
                case /* optional TSP.Size old_natural_size_for_IAPath */ 9:
                    message.oldNaturalSizeForIAPath = TSPMessages_1.Size.internalBinaryRead(reader, reader.uint32(), options, message.oldNaturalSizeForIAPath);
                    break;
                case /* optional TSD.GeometryArchive target_image_geometry */ 10:
                    message.targetImageGeometry = TSDArchives_7.GeometryArchive.internalBinaryRead(reader, reader.uint32(), options, message.targetImageGeometry);
                    break;
                case /* optional TSD.GeometryArchive old_target_image_geometry */ 12:
                    message.oldTargetImageGeometry = TSDArchives_7.GeometryArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldTargetImageGeometry);
                    break;
                case /* optional TSD.GeometryArchive target_mask_geometry */ 13:
                    message.targetMaskGeometry = TSDArchives_7.GeometryArchive.internalBinaryRead(reader, reader.uint32(), options, message.targetMaskGeometry);
                    break;
                case /* optional TSD.GeometryArchive old_target_mask_geometry */ 14:
                    message.oldTargetMaskGeometry = TSDArchives_7.GeometryArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldTargetMaskGeometry);
                    break;
                case /* optional TSD.ImageAdjustmentsArchive image_adjustments */ 15:
                    message.imageAdjustments = TSDArchives_5.ImageAdjustmentsArchive.internalBinaryRead(reader, reader.uint32(), options, message.imageAdjustments);
                    break;
                case /* optional TSP.DataReference adjusted_image_data */ 16:
                    message.adjustedImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.adjustedImageData);
                    break;
                case /* optional TSP.DataReference enhanced_image_data */ 17:
                    message.enhancedImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.enhancedImageData);
                    break;
                case /* optional TSD.ImageAdjustmentsArchive old_image_adjustments */ 18:
                    message.oldImageAdjustments = TSDArchives_5.ImageAdjustmentsArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldImageAdjustments);
                    break;
                case /* optional TSP.DataReference old_adjusted_image_data */ 19:
                    message.oldAdjustedImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.oldAdjustedImageData);
                    break;
                case /* optional TSP.DataReference old_enhanced_image_data */ 20:
                    message.oldEnhancedImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.oldEnhancedImageData);
                    break;
                case /* optional TSP.DataReference thumbnail_image_data */ 21:
                    message.thumbnailImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.thumbnailImageData);
                    break;
                case /* optional TSP.DataReference old_thumbnail_image_data */ 22:
                    message.oldThumbnailImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.oldThumbnailImageData);
                    break;
                case /* optional TSP.DataReference thumbnail_adjusted_image_data */ 23:
                    message.thumbnailAdjustedImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.thumbnailAdjustedImageData);
                    break;
                case /* optional TSP.DataReference old_thumbnail_adjusted_image_data */ 24:
                    message.oldThumbnailAdjustedImageData = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.oldThumbnailAdjustedImageData);
                    break;
                case /* optional TSP.Size natural_size */ 25:
                    message.naturalSize = TSPMessages_1.Size.internalBinaryRead(reader, reader.uint32(), options, message.naturalSize);
                    break;
                case /* optional TSP.Size old_natural_size */ 26:
                    message.oldNaturalSize = TSPMessages_1.Size.internalBinaryRead(reader, reader.uint32(), options, message.oldNaturalSize);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoCommandArchive super = 1; */
        if (message.super)
            exports.InfoCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference new_image_data = 2; */
        if (message.newImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.newImageData, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference new_original_image_data = 3; */
        if (message.newOriginalImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.newOriginalImageData, writer.tag(3, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference old_image_data = 4; */
        if (message.oldImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.oldImageData, writer.tag(4, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference old_original_image_data = 5; */
        if (message.oldOriginalImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.oldOriginalImageData, writer.tag(5, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Path instant_alpha_path = 6; */
        if (message.instantAlphaPath)
            TSPMessages_3.Path.internalBinaryWrite(message.instantAlphaPath, writer.tag(6, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Path old_instant_alpha_path = 7; */
        if (message.oldInstantAlphaPath)
            TSPMessages_3.Path.internalBinaryWrite(message.oldInstantAlphaPath, writer.tag(7, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Size natural_size_for_IAPath = 8; */
        if (message.naturalSizeForIAPath)
            TSPMessages_1.Size.internalBinaryWrite(message.naturalSizeForIAPath, writer.tag(8, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Size old_natural_size_for_IAPath = 9; */
        if (message.oldNaturalSizeForIAPath)
            TSPMessages_1.Size.internalBinaryWrite(message.oldNaturalSizeForIAPath, writer.tag(9, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.GeometryArchive target_image_geometry = 10; */
        if (message.targetImageGeometry)
            TSDArchives_7.GeometryArchive.internalBinaryWrite(message.targetImageGeometry, writer.tag(10, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.GeometryArchive old_target_image_geometry = 12; */
        if (message.oldTargetImageGeometry)
            TSDArchives_7.GeometryArchive.internalBinaryWrite(message.oldTargetImageGeometry, writer.tag(12, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.GeometryArchive target_mask_geometry = 13; */
        if (message.targetMaskGeometry)
            TSDArchives_7.GeometryArchive.internalBinaryWrite(message.targetMaskGeometry, writer.tag(13, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.GeometryArchive old_target_mask_geometry = 14; */
        if (message.oldTargetMaskGeometry)
            TSDArchives_7.GeometryArchive.internalBinaryWrite(message.oldTargetMaskGeometry, writer.tag(14, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.ImageAdjustmentsArchive image_adjustments = 15; */
        if (message.imageAdjustments)
            TSDArchives_5.ImageAdjustmentsArchive.internalBinaryWrite(message.imageAdjustments, writer.tag(15, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference adjusted_image_data = 16; */
        if (message.adjustedImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.adjustedImageData, writer.tag(16, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference enhanced_image_data = 17; */
        if (message.enhancedImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.enhancedImageData, writer.tag(17, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.ImageAdjustmentsArchive old_image_adjustments = 18; */
        if (message.oldImageAdjustments)
            TSDArchives_5.ImageAdjustmentsArchive.internalBinaryWrite(message.oldImageAdjustments, writer.tag(18, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference old_adjusted_image_data = 19; */
        if (message.oldAdjustedImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.oldAdjustedImageData, writer.tag(19, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference old_enhanced_image_data = 20; */
        if (message.oldEnhancedImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.oldEnhancedImageData, writer.tag(20, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference thumbnail_image_data = 21; */
        if (message.thumbnailImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.thumbnailImageData, writer.tag(21, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference old_thumbnail_image_data = 22; */
        if (message.oldThumbnailImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.oldThumbnailImageData, writer.tag(22, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference thumbnail_adjusted_image_data = 23; */
        if (message.thumbnailAdjustedImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.thumbnailAdjustedImageData, writer.tag(23, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.DataReference old_thumbnail_adjusted_image_data = 24; */
        if (message.oldThumbnailAdjustedImageData)
            TSPMessages_2.DataReference.internalBinaryWrite(message.oldThumbnailAdjustedImageData, writer.tag(24, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Size natural_size = 25; */
        if (message.naturalSize)
            TSPMessages_1.Size.internalBinaryWrite(message.naturalSize, writer.tag(25, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Size old_natural_size = 26; */
        if (message.oldNaturalSize)
            TSPMessages_1.Size.internalBinaryWrite(message.oldNaturalSize, writer.tag(26, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ImageReplaceCommandArchive
 */
exports.ImageReplaceCommandArchive = new ImageReplaceCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DrawableLockCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.DrawableLockCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.InfoCommandArchive },
            { no: 2, name: "locked", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "was_locked", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoCommandArchive super */ 1:
                    message.super = exports.InfoCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional bool locked */ 2:
                    message.locked = reader.bool();
                    break;
                case /* optional bool was_locked */ 3:
                    message.wasLocked = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoCommandArchive super = 1; */
        if (message.super)
            exports.InfoCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional bool locked = 2; */
        if (message.locked !== undefined)
            writer.tag(2, runtime_2.WireType.Varint).bool(message.locked);
        /* optional bool was_locked = 3; */
        if (message.wasLocked !== undefined)
            writer.tag(3, runtime_2.WireType.Varint).bool(message.wasLocked);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.DrawableLockCommandArchive
 */
exports.DrawableLockCommandArchive = new DrawableLockCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DrawableInfoCommentCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.DrawableInfoCommentCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.InfoCommandArchive },
            { no: 2, name: "old_comment", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 3, name: "new_comment", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 4, name: "forward_variant", kind: "enum", opt: true, T: () => ["TSD.CommentCommandVariant", CommentCommandVariant] },
            { no: 5, name: "inverse_variant", kind: "enum", opt: true, T: () => ["TSD.CommentCommandVariant", CommentCommandVariant] }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoCommandArchive super */ 1:
                    message.super = exports.InfoCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference old_comment */ 2:
                    message.oldComment = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.oldComment);
                    break;
                case /* optional TSP.Reference new_comment */ 3:
                    message.newComment = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.newComment);
                    break;
                case /* optional TSD.CommentCommandVariant forward_variant */ 4:
                    message.forwardVariant = reader.int32();
                    break;
                case /* optional TSD.CommentCommandVariant inverse_variant */ 5:
                    message.inverseVariant = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoCommandArchive super = 1; */
        if (message.super)
            exports.InfoCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference old_comment = 2; */
        if (message.oldComment)
            TSPMessages_6.Reference.internalBinaryWrite(message.oldComment, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference new_comment = 3; */
        if (message.newComment)
            TSPMessages_6.Reference.internalBinaryWrite(message.newComment, writer.tag(3, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.CommentCommandVariant forward_variant = 4; */
        if (message.forwardVariant !== undefined)
            writer.tag(4, runtime_2.WireType.Varint).int32(message.forwardVariant);
        /* optional TSD.CommentCommandVariant inverse_variant = 5; */
        if (message.inverseVariant !== undefined)
            writer.tag(5, runtime_2.WireType.Varint).int32(message.inverseVariant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.DrawableInfoCommentCommandArchive
 */
exports.DrawableInfoCommentCommandArchive = new DrawableInfoCommentCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DrawablePencilAnnotationCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.DrawablePencilAnnotationCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.InfoCommandArchive },
            { no: 2, name: "pencil_annotation_to_add", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 3, name: "pencil_annotation_to_remove", kind: "message", T: () => TSPMessages_6.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoCommandArchive super */ 1:
                    message.super = exports.InfoCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference pencil_annotation_to_add */ 2:
                    message.pencilAnnotationToAdd = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.pencilAnnotationToAdd);
                    break;
                case /* optional TSP.Reference pencil_annotation_to_remove */ 3:
                    message.pencilAnnotationToRemove = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.pencilAnnotationToRemove);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoCommandArchive super = 1; */
        if (message.super)
            exports.InfoCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference pencil_annotation_to_add = 2; */
        if (message.pencilAnnotationToAdd)
            TSPMessages_6.Reference.internalBinaryWrite(message.pencilAnnotationToAdd, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference pencil_annotation_to_remove = 3; */
        if (message.pencilAnnotationToRemove)
            TSPMessages_6.Reference.internalBinaryWrite(message.pencilAnnotationToRemove, writer.tag(3, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.DrawablePencilAnnotationCommandArchive
 */
exports.DrawablePencilAnnotationCommandArchive = new DrawablePencilAnnotationCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AbstractGuideCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.AbstractGuideCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 7, name: "old_guides", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSDArchives_2.UserDefinedGuideArchive },
            { no: 8, name: "new_guides", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSDArchives_2.UserDefinedGuideArchive }
        ]);
    }
    create(value) {
        const message = { oldGuides: [], newGuides: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSD.UserDefinedGuideArchive old_guides */ 7:
                    message.oldGuides.push(TSDArchives_2.UserDefinedGuideArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSD.UserDefinedGuideArchive new_guides */ 8:
                    message.newGuides.push(TSDArchives_2.UserDefinedGuideArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSD.UserDefinedGuideArchive old_guides = 7; */
        for (let i = 0; i < message.oldGuides.length; i++)
            TSDArchives_2.UserDefinedGuideArchive.internalBinaryWrite(message.oldGuides[i], writer.tag(7, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSD.UserDefinedGuideArchive new_guides = 8; */
        for (let i = 0; i < message.newGuides.length; i++)
            TSDArchives_2.UserDefinedGuideArchive.internalBinaryWrite(message.newGuides[i], writer.tag(8, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.AbstractGuideCommandArchive
 */
exports.AbstractGuideCommandArchive = new AbstractGuideCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GuideCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.GuideCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.AbstractGuideCommandArchive },
            { no: 2, name: "storage_id_path", kind: "message", T: () => TSPMessages_5.UUIDPath }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.AbstractGuideCommandArchive super */ 1:
                    message.super = exports.AbstractGuideCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUIDPath storage_id_path */ 2:
                    message.storageIdPath = TSPMessages_5.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.storageIdPath);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.AbstractGuideCommandArchive super = 1; */
        if (message.super)
            exports.AbstractGuideCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUIDPath storage_id_path = 2; */
        if (message.storageIdPath)
            TSPMessages_5.UUIDPath.internalBinaryWrite(message.storageIdPath, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.GuideCommandArchive
 */
exports.GuideCommandArchive = new GuideCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DrawableAspectRatioLockedCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.DrawableAspectRatioLockedCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.InfoCommandArchive },
            { no: 2, name: "aspect_ratio_locked", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "was_aspect_ratio_locked", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoCommandArchive super */ 1:
                    message.super = exports.InfoCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional bool aspect_ratio_locked */ 2:
                    message.aspectRatioLocked = reader.bool();
                    break;
                case /* optional bool was_aspect_ratio_locked */ 3:
                    message.wasAspectRatioLocked = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoCommandArchive super = 1; */
        if (message.super)
            exports.InfoCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional bool aspect_ratio_locked = 2; */
        if (message.aspectRatioLocked !== undefined)
            writer.tag(2, runtime_2.WireType.Varint).bool(message.aspectRatioLocked);
        /* optional bool was_aspect_ratio_locked = 3; */
        if (message.wasAspectRatioLocked !== undefined)
            writer.tag(3, runtime_2.WireType.Varint).bool(message.wasAspectRatioLocked);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.DrawableAspectRatioLockedCommandArchive
 */
exports.DrawableAspectRatioLockedCommandArchive = new DrawableAspectRatioLockedCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DrawableAccessibilityDescriptionCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.DrawableAccessibilityDescriptionCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.InfoCommandArchive },
            { no: 2, name: "accessibility_description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "old_accessibility_description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoCommandArchive super */ 1:
                    message.super = exports.InfoCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional string accessibility_description */ 2:
                    message.accessibilityDescription = reader.string();
                    break;
                case /* optional string old_accessibility_description */ 3:
                    message.oldAccessibilityDescription = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoCommandArchive super = 1; */
        if (message.super)
            exports.InfoCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional string accessibility_description = 2; */
        if (message.accessibilityDescription !== undefined)
            writer.tag(2, runtime_2.WireType.LengthDelimited).string(message.accessibilityDescription);
        /* optional string old_accessibility_description = 3; */
        if (message.oldAccessibilityDescription !== undefined)
            writer.tag(3, runtime_2.WireType.LengthDelimited).string(message.oldAccessibilityDescription);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.DrawableAccessibilityDescriptionCommandArchive
 */
exports.DrawableAccessibilityDescriptionCommandArchive = new DrawableAccessibilityDescriptionCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PasteStyleCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.PasteStyleCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.AbstractStyleCommandArchive },
            { no: 2, name: "new_style", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 5, name: "rollback_style", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 4, name: "tail_end_on_left", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.AbstractStyleCommandArchive super */ 1:
                    message.super = exports.AbstractStyleCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference new_style */ 2:
                    message.newStyle = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.newStyle);
                    break;
                case /* optional TSP.Reference rollback_style */ 5:
                    message.rollbackStyle = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.rollbackStyle);
                    break;
                case /* optional bool tail_end_on_left */ 4:
                    message.tailEndOnLeft = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.AbstractStyleCommandArchive super = 1; */
        if (message.super)
            exports.AbstractStyleCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference new_style = 2; */
        if (message.newStyle)
            TSPMessages_6.Reference.internalBinaryWrite(message.newStyle, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference rollback_style = 5; */
        if (message.rollbackStyle)
            TSPMessages_6.Reference.internalBinaryWrite(message.rollbackStyle, writer.tag(5, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional bool tail_end_on_left = 4; */
        if (message.tailEndOnLeft !== undefined)
            writer.tag(4, runtime_2.WireType.Varint).bool(message.tailEndOnLeft);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.PasteStyleCommandArchive
 */
exports.PasteStyleCommandArchive = new PasteStyleCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImageInfoAbstractGeometryCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ImageInfoAbstractGeometryCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.InfoCommandArchive },
            { no: 2, name: "new_image_geometry", kind: "message", T: () => TSDArchives_7.GeometryArchive },
            { no: 3, name: "old_image_geometry", kind: "message", T: () => TSDArchives_7.GeometryArchive },
            { no: 4, name: "new_mask_geometry", kind: "message", T: () => TSDArchives_7.GeometryArchive },
            { no: 5, name: "old_mask_geometry", kind: "message", T: () => TSDArchives_7.GeometryArchive },
            { no: 6, name: "new_mask_path_source", kind: "message", T: () => TSDArchives_6.PathSourceArchive },
            { no: 7, name: "old_mask_path_source", kind: "message", T: () => TSDArchives_6.PathSourceArchive },
            { no: 8, name: "new_image_original_size", kind: "message", T: () => TSPMessages_1.Size },
            { no: 9, name: "old_image_original_size", kind: "message", T: () => TSPMessages_1.Size },
            { no: 10, name: "background_removed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "old_background_removed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoCommandArchive super */ 1:
                    message.super = exports.InfoCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSD.GeometryArchive new_image_geometry */ 2:
                    message.newImageGeometry = TSDArchives_7.GeometryArchive.internalBinaryRead(reader, reader.uint32(), options, message.newImageGeometry);
                    break;
                case /* optional TSD.GeometryArchive old_image_geometry */ 3:
                    message.oldImageGeometry = TSDArchives_7.GeometryArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldImageGeometry);
                    break;
                case /* optional TSD.GeometryArchive new_mask_geometry */ 4:
                    message.newMaskGeometry = TSDArchives_7.GeometryArchive.internalBinaryRead(reader, reader.uint32(), options, message.newMaskGeometry);
                    break;
                case /* optional TSD.GeometryArchive old_mask_geometry */ 5:
                    message.oldMaskGeometry = TSDArchives_7.GeometryArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldMaskGeometry);
                    break;
                case /* optional TSD.PathSourceArchive new_mask_path_source */ 6:
                    message.newMaskPathSource = TSDArchives_6.PathSourceArchive.internalBinaryRead(reader, reader.uint32(), options, message.newMaskPathSource);
                    break;
                case /* optional TSD.PathSourceArchive old_mask_path_source */ 7:
                    message.oldMaskPathSource = TSDArchives_6.PathSourceArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldMaskPathSource);
                    break;
                case /* optional TSP.Size new_image_original_size */ 8:
                    message.newImageOriginalSize = TSPMessages_1.Size.internalBinaryRead(reader, reader.uint32(), options, message.newImageOriginalSize);
                    break;
                case /* optional TSP.Size old_image_original_size */ 9:
                    message.oldImageOriginalSize = TSPMessages_1.Size.internalBinaryRead(reader, reader.uint32(), options, message.oldImageOriginalSize);
                    break;
                case /* optional bool background_removed */ 10:
                    message.backgroundRemoved = reader.bool();
                    break;
                case /* optional bool old_background_removed */ 11:
                    message.oldBackgroundRemoved = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoCommandArchive super = 1; */
        if (message.super)
            exports.InfoCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.GeometryArchive new_image_geometry = 2; */
        if (message.newImageGeometry)
            TSDArchives_7.GeometryArchive.internalBinaryWrite(message.newImageGeometry, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.GeometryArchive old_image_geometry = 3; */
        if (message.oldImageGeometry)
            TSDArchives_7.GeometryArchive.internalBinaryWrite(message.oldImageGeometry, writer.tag(3, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.GeometryArchive new_mask_geometry = 4; */
        if (message.newMaskGeometry)
            TSDArchives_7.GeometryArchive.internalBinaryWrite(message.newMaskGeometry, writer.tag(4, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.GeometryArchive old_mask_geometry = 5; */
        if (message.oldMaskGeometry)
            TSDArchives_7.GeometryArchive.internalBinaryWrite(message.oldMaskGeometry, writer.tag(5, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.PathSourceArchive new_mask_path_source = 6; */
        if (message.newMaskPathSource)
            TSDArchives_6.PathSourceArchive.internalBinaryWrite(message.newMaskPathSource, writer.tag(6, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.PathSourceArchive old_mask_path_source = 7; */
        if (message.oldMaskPathSource)
            TSDArchives_6.PathSourceArchive.internalBinaryWrite(message.oldMaskPathSource, writer.tag(7, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Size new_image_original_size = 8; */
        if (message.newImageOriginalSize)
            TSPMessages_1.Size.internalBinaryWrite(message.newImageOriginalSize, writer.tag(8, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Size old_image_original_size = 9; */
        if (message.oldImageOriginalSize)
            TSPMessages_1.Size.internalBinaryWrite(message.oldImageOriginalSize, writer.tag(9, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional bool background_removed = 10; */
        if (message.backgroundRemoved !== undefined)
            writer.tag(10, runtime_2.WireType.Varint).bool(message.backgroundRemoved);
        /* optional bool old_background_removed = 11; */
        if (message.oldBackgroundRemoved !== undefined)
            writer.tag(11, runtime_2.WireType.Varint).bool(message.oldBackgroundRemoved);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ImageInfoAbstractGeometryCommandArchive
 */
exports.ImageInfoAbstractGeometryCommandArchive = new ImageInfoAbstractGeometryCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImageInfoGeometryCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ImageInfoGeometryCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.ImageInfoAbstractGeometryCommandArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.ImageInfoAbstractGeometryCommandArchive super */ 1:
                    message.super = exports.ImageInfoAbstractGeometryCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.ImageInfoAbstractGeometryCommandArchive super = 1; */
        if (message.super)
            exports.ImageInfoAbstractGeometryCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ImageInfoGeometryCommandArchive
 */
exports.ImageInfoGeometryCommandArchive = new ImageInfoGeometryCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImageInfoMaskGeometryCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ImageInfoMaskGeometryCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.ImageInfoAbstractGeometryCommandArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.ImageInfoAbstractGeometryCommandArchive super */ 1:
                    message.super = exports.ImageInfoAbstractGeometryCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.ImageInfoAbstractGeometryCommandArchive super = 1; */
        if (message.super)
            exports.ImageInfoAbstractGeometryCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ImageInfoMaskGeometryCommandArchive
 */
exports.ImageInfoMaskGeometryCommandArchive = new ImageInfoMaskGeometryCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InfoCollectionSelectionTransformerHelperArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.InfoCollectionSelectionTransformerHelperArchive", [
            { no: 1, name: "info_uuid_path_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.UUIDPath }
        ]);
    }
    create(value) {
        const message = { infoUuidPathList: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.UUIDPath info_uuid_path_list */ 1:
                    message.infoUuidPathList.push(TSPMessages_5.UUIDPath.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.UUIDPath info_uuid_path_list = 1; */
        for (let i = 0; i < message.infoUuidPathList.length; i++)
            TSPMessages_5.UUIDPath.internalBinaryWrite(message.infoUuidPathList[i], writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.InfoCollectionSelectionTransformerHelperArchive
 */
exports.InfoCollectionSelectionTransformerHelperArchive = new InfoCollectionSelectionTransformerHelperArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DrawableSelectionTransformerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.DrawableSelectionTransformerArchive", [
            { no: 1, name: "transformer_helper", kind: "message", T: () => exports.InfoCollectionSelectionTransformerHelperArchive },
            { no: 2, name: "untransformed_drawable_selection", kind: "message", T: () => TSPMessages_6.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoCollectionSelectionTransformerHelperArchive transformer_helper */ 1:
                    message.transformerHelper = exports.InfoCollectionSelectionTransformerHelperArchive.internalBinaryRead(reader, reader.uint32(), options, message.transformerHelper);
                    break;
                case /* TSP.Reference untransformed_drawable_selection */ 2:
                    message.untransformedDrawableSelection = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.untransformedDrawableSelection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoCollectionSelectionTransformerHelperArchive transformer_helper = 1; */
        if (message.transformerHelper)
            exports.InfoCollectionSelectionTransformerHelperArchive.internalBinaryWrite(message.transformerHelper, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference untransformed_drawable_selection = 2; */
        if (message.untransformedDrawableSelection)
            TSPMessages_6.Reference.internalBinaryWrite(message.untransformedDrawableSelection, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.DrawableSelectionTransformerArchive
 */
exports.DrawableSelectionTransformerArchive = new DrawableSelectionTransformerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InfoHyperlinkSelectionTransformerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.InfoHyperlinkSelectionTransformerArchive", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.InfoHyperlinkSelectionTransformerArchive
 */
exports.InfoHyperlinkSelectionTransformerArchive = new InfoHyperlinkSelectionTransformerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CanvasSelectionTransformerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.CanvasSelectionTransformerArchive", [
            { no: 1, name: "transformer_helper", kind: "message", T: () => exports.InfoCollectionSelectionTransformerHelperArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoCollectionSelectionTransformerHelperArchive transformer_helper */ 1:
                    message.transformerHelper = exports.InfoCollectionSelectionTransformerHelperArchive.internalBinaryRead(reader, reader.uint32(), options, message.transformerHelper);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoCollectionSelectionTransformerHelperArchive transformer_helper = 1; */
        if (message.transformerHelper)
            exports.InfoCollectionSelectionTransformerHelperArchive.internalBinaryWrite(message.transformerHelper, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.CanvasSelectionTransformerArchive
 */
exports.CanvasSelectionTransformerArchive = new CanvasSelectionTransformerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PathSelectionTransformerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.PathSelectionTransformerArchive", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.PathSelectionTransformerArchive
 */
exports.PathSelectionTransformerArchive = new PathSelectionTransformerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShapeSelectionTransformerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.ShapeSelectionTransformerArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.DrawableSelectionTransformerArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.DrawableSelectionTransformerArchive super */ 1:
                    message.super = exports.DrawableSelectionTransformerArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.DrawableSelectionTransformerArchive super = 1; */
        if (message.super)
            exports.DrawableSelectionTransformerArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.ShapeSelectionTransformerArchive
 */
exports.ShapeSelectionTransformerArchive = new ShapeSelectionTransformerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupSelectionTransformerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.GroupSelectionTransformerArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.DrawableSelectionTransformerArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.DrawableSelectionTransformerArchive super */ 1:
                    message.super = exports.DrawableSelectionTransformerArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.DrawableSelectionTransformerArchive super = 1; */
        if (message.super)
            exports.DrawableSelectionTransformerArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.GroupSelectionTransformerArchive
 */
exports.GroupSelectionTransformerArchive = new GroupSelectionTransformerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PencilAnnotationSelectionTransformerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.PencilAnnotationSelectionTransformerArchive", [
            { no: 1, name: "pencil_annotation_uuid", kind: "message", T: () => TSPMessages_4.UUID }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID pencil_annotation_uuid */ 1:
                    message.pencilAnnotationUuid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.pencilAnnotationUuid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID pencil_annotation_uuid = 1; */
        if (message.pencilAnnotationUuid)
            TSPMessages_4.UUID.internalBinaryWrite(message.pencilAnnotationUuid, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.PencilAnnotationSelectionTransformerArchive
 */
exports.PencilAnnotationSelectionTransformerArchive = new PencilAnnotationSelectionTransformerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FreehandDrawingOpacityCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.FreehandDrawingOpacityCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.InfoCommandArchive },
            { no: 2, name: "opacity", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "old_opacity", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoCommandArchive super */ 1:
                    message.super = exports.InfoCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional double opacity */ 2:
                    message.opacity = reader.double();
                    break;
                case /* optional double old_opacity */ 3:
                    message.oldOpacity = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoCommandArchive super = 1; */
        if (message.super)
            exports.InfoCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional double opacity = 2; */
        if (message.opacity !== undefined)
            writer.tag(2, runtime_2.WireType.Bit64).double(message.opacity);
        /* optional double old_opacity = 3; */
        if (message.oldOpacity !== undefined)
            writer.tag(3, runtime_2.WireType.Bit64).double(message.oldOpacity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.FreehandDrawingOpacityCommandArchive
 */
exports.FreehandDrawingOpacityCommandArchive = new FreehandDrawingOpacityCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FreehandDrawingAnimationCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.FreehandDrawingAnimationCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.InfoCommandArchive },
            { no: 2, name: "animation", kind: "message", T: () => TSDArchives_1.FreehandDrawingAnimationArchive },
            { no: 3, name: "old_animation", kind: "message", T: () => TSDArchives_1.FreehandDrawingAnimationArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoCommandArchive super */ 1:
                    message.super = exports.InfoCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSD.FreehandDrawingAnimationArchive animation */ 2:
                    message.animation = TSDArchives_1.FreehandDrawingAnimationArchive.internalBinaryRead(reader, reader.uint32(), options, message.animation);
                    break;
                case /* optional TSD.FreehandDrawingAnimationArchive old_animation */ 3:
                    message.oldAnimation = TSDArchives_1.FreehandDrawingAnimationArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldAnimation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoCommandArchive super = 1; */
        if (message.super)
            exports.InfoCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.FreehandDrawingAnimationArchive animation = 2; */
        if (message.animation)
            TSDArchives_1.FreehandDrawingAnimationArchive.internalBinaryWrite(message.animation, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.FreehandDrawingAnimationArchive old_animation = 3; */
        if (message.oldAnimation)
            TSDArchives_1.FreehandDrawingAnimationArchive.internalBinaryWrite(message.oldAnimation, writer.tag(3, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.FreehandDrawingAnimationCommandArchive
 */
exports.FreehandDrawingAnimationCommandArchive = new FreehandDrawingAnimationCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InsertCaptionOrTitleCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.InsertCaptionOrTitleCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "drawable_info_id_path", kind: "message", T: () => TSPMessages_5.UUIDPath },
            { no: 3, name: "caption_or_title_info", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 4, name: "added_caption_or_title_uuid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 5, name: "caption_or_title_kind", kind: "enum", opt: true, T: () => ["TSD.CaptionOrTitleKind", CaptionOrTitleKind] },
            { no: 6, name: "undo_object", kind: "message", T: () => TSPMessages_6.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.UUIDPath drawable_info_id_path */ 2:
                    message.drawableInfoIdPath = TSPMessages_5.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.drawableInfoIdPath);
                    break;
                case /* optional TSP.Reference caption_or_title_info */ 3:
                    message.captionOrTitleInfo = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.captionOrTitleInfo);
                    break;
                case /* optional TSP.UUID added_caption_or_title_uuid */ 4:
                    message.addedCaptionOrTitleUuid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.addedCaptionOrTitleUuid);
                    break;
                case /* optional TSD.CaptionOrTitleKind caption_or_title_kind */ 5:
                    message.captionOrTitleKind = reader.int32();
                    break;
                case /* optional TSP.Reference undo_object */ 6:
                    message.undoObject = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoObject);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDPath drawable_info_id_path = 2; */
        if (message.drawableInfoIdPath)
            TSPMessages_5.UUIDPath.internalBinaryWrite(message.drawableInfoIdPath, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference caption_or_title_info = 3; */
        if (message.captionOrTitleInfo)
            TSPMessages_6.Reference.internalBinaryWrite(message.captionOrTitleInfo, writer.tag(3, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID added_caption_or_title_uuid = 4; */
        if (message.addedCaptionOrTitleUuid)
            TSPMessages_4.UUID.internalBinaryWrite(message.addedCaptionOrTitleUuid, writer.tag(4, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.CaptionOrTitleKind caption_or_title_kind = 5; */
        if (message.captionOrTitleKind !== undefined)
            writer.tag(5, runtime_2.WireType.Varint).int32(message.captionOrTitleKind);
        /* optional TSP.Reference undo_object = 6; */
        if (message.undoObject)
            TSPMessages_6.Reference.internalBinaryWrite(message.undoObject, writer.tag(6, runtime_2.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.InsertCaptionOrTitleCommandArchive
 */
exports.InsertCaptionOrTitleCommandArchive = new InsertCaptionOrTitleCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveCaptionOrTitleCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.RemoveCaptionOrTitleCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_6.CommandArchive },
            { no: 2, name: "drawable_info_id_path", kind: "message", T: () => TSPMessages_5.UUIDPath },
            { no: 3, name: "removed_caption_or_title_info", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 4, name: "removed_caption_or_title_uuid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 5, name: "caption_or_title_kind", kind: "enum", opt: true, T: () => ["TSD.CaptionOrTitleKind", CaptionOrTitleKind] }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_6.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.UUIDPath drawable_info_id_path */ 2:
                    message.drawableInfoIdPath = TSPMessages_5.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.drawableInfoIdPath);
                    break;
                case /* optional TSP.Reference removed_caption_or_title_info */ 3:
                    message.removedCaptionOrTitleInfo = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.removedCaptionOrTitleInfo);
                    break;
                case /* optional TSP.UUID removed_caption_or_title_uuid */ 4:
                    message.removedCaptionOrTitleUuid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.removedCaptionOrTitleUuid);
                    break;
                case /* optional TSD.CaptionOrTitleKind caption_or_title_kind */ 5:
                    message.captionOrTitleKind = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_6.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDPath drawable_info_id_path = 2; */
        if (message.drawableInfoIdPath)
            TSPMessages_5.UUIDPath.internalBinaryWrite(message.drawableInfoIdPath, writer.tag(2, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference removed_caption_or_title_info = 3; */
        if (message.removedCaptionOrTitleInfo)
            TSPMessages_6.Reference.internalBinaryWrite(message.removedCaptionOrTitleInfo, writer.tag(3, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID removed_caption_or_title_uuid = 4; */
        if (message.removedCaptionOrTitleUuid)
            TSPMessages_4.UUID.internalBinaryWrite(message.removedCaptionOrTitleUuid, writer.tag(4, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.CaptionOrTitleKind caption_or_title_kind = 5; */
        if (message.captionOrTitleKind !== undefined)
            writer.tag(5, runtime_2.WireType.Varint).int32(message.captionOrTitleKind);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.RemoveCaptionOrTitleCommandArchive
 */
exports.RemoveCaptionOrTitleCommandArchive = new RemoveCaptionOrTitleCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetCaptionOrTitleVisibilityCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSD.SetCaptionOrTitleVisibilityCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.InfoCommandArchive },
            { no: 2, name: "caption_or_title_kind", kind: "enum", opt: true, T: () => ["TSD.CaptionOrTitleKind", CaptionOrTitleKind] },
            { no: 3, name: "hidden", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "was_hidden", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.InfoCommandArchive super */ 1:
                    message.super = exports.InfoCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSD.CaptionOrTitleKind caption_or_title_kind */ 2:
                    message.captionOrTitleKind = reader.int32();
                    break;
                case /* optional bool hidden */ 3:
                    message.hidden = reader.bool();
                    break;
                case /* optional bool was_hidden */ 4:
                    message.wasHidden = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_1.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.InfoCommandArchive super = 1; */
        if (message.super)
            exports.InfoCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_2.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.CaptionOrTitleKind caption_or_title_kind = 2; */
        if (message.captionOrTitleKind !== undefined)
            writer.tag(2, runtime_2.WireType.Varint).int32(message.captionOrTitleKind);
        /* optional bool hidden = 3; */
        if (message.hidden !== undefined)
            writer.tag(3, runtime_2.WireType.Varint).bool(message.hidden);
        /* optional bool was_hidden = 4; */
        if (message.wasHidden !== undefined)
            writer.tag(4, runtime_2.WireType.Varint).bool(message.wasHidden);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_1.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSD.SetCaptionOrTitleVisibilityCommandArchive
 */
exports.SetCaptionOrTitleVisibilityCommandArchive = new SetCaptionOrTitleVisibilityCommandArchive$Type();
//# sourceMappingURL=TSDCommandArchives.js.map