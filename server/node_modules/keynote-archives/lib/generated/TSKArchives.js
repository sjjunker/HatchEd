"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddIdOperationArgs = exports.IdOperationArgs = exports.DocumentSelectionArchive = exports.SelectionPathArchive = exports.SelectionPathTransformerArchive = exports.CommandSelectionBehaviorArchive = exports.CommandBehaviorArchive = exports.CommandBehaviorSelectionPathStorageArchive = exports.SetActivityAuthorShareParticipantIDCommandArchive = exports.SetAnnotationAuthorColorCommandArchive = exports.AnnotationAuthorStorageArchive = exports.DeprecatedChangeAuthorArchive = exports.AnnotationAuthorArchive = exports.CustomFormatListArchive = exports.CustomFormatArchive_Condition = exports.CustomFormatArchive = exports.FormatStructArchive = exports.ProgressiveCommandGroupArchive = exports.CommandContainerArchive = exports.FinalCommandPairArchive = exports.PropagatedCommandCollectionArchive = exports.InducedCommandCollectionArchive = exports.CommandGroupArchive = exports.CommandArchive = exports.ViewStateArchive = exports.DocumentSupportArchive = exports.DocumentSupportCollaborationState = exports.FormattingSymbolsArchive_CurrencySymbol = exports.FormattingSymbolsArchive = exports.DocumentArchive = exports.CollaborationCommandHistoryOriginatingCommandAcknowledgementObserver = exports.CollaborationCommandHistoryCoalescingGroupNode = exports.CollaborationCommandHistoryCoalescingGroup = exports.CollaborationCommandHistoryItem = exports.CollaborationCommandHistory_ItemList = exports.CollaborationCommandHistory = exports.CollaborationCommandHistoryArraySegment = exports.CollaborationCommandHistoryArray = exports.LocalCommandHistory = exports.LocalCommandHistoryArraySegment = exports.LocalCommandHistoryArray = exports.LocalCommandHistoryItem = exports.TreeNode = exports.StructuredTextImportType = exports.ActivityStreamTransformationStateArchive_ActionType = exports.CommandActivityBehaviorArchive_ActionSubType = exports.CommandActivityBehaviorArchive_ActionType = exports.PencilAnnotationUIState_PencilAnnotationToolType = exports.Operation_OperationType = exports.ChangeDocumentPackageTypeCommandArchive_PackageType = void 0;
exports.ActivityAuthorCacheArchive_ShareParticipantIDCache = exports.ActivityAuthorCacheArchive = exports.CommentActivityNavigationInfoArchive = exports.ActivityNavigationInfoArchive = exports.ActivityCursorCollectionPersistenceWrapperArchive = exports.ActivityCursorCollectionArchive = exports.CommandActivityBehaviorArchive = exports.ActivityAuthorArchive = exports.ActivityArchive = exports.ActivityStreamActivityArraySegment = exports.ActivityStreamActivityArray = exports.ActivityStreamArchive = exports.CollaboratorCursorArchive = exports.PencilAnnotationUIState = exports.AssetUnmaterializedOnServerCommandArchive = exports.AssetUploadStatusCommandArchive_AssetUploadStatusInfo = exports.AssetUploadStatusCommandArchive = exports.CommandAssetChunkArchive = exports.DataReferenceRecord_ContainerUUIDToReferencedDataPair = exports.DataReferenceRecord = exports.OutgoingCommandQueueSegment = exports.OutgoingCommandQueue = exports.OperationStorage = exports.OperationStorageEntryArraySegment = exports.OperationStorageEntryArray = exports.OperationStorageEntry = exports.OperationStorageCommandOperationsEntry = exports.StructuredTextImportSettings = exports.NativeContentDescription = exports.CollaborationDocumentSessionState_AcknowledgementObserverEntry = exports.CollaborationDocumentSessionState = exports.CollaborationAppliedCommandDocumentRevisionMapping = exports.OutgoingCommandQueueItemUUIDToDataMapEntry = exports.OutgoingCommandQueueItem = exports.TransformerEntry = exports.OperationTransformer = exports.Operation = exports.RangeAddress = exports.BlockDiffsAtCurrentRevisionCommand = exports.CreateLocalStorageSnapshotCommandArchive = exports.ChangeDocumentPackageTypeCommandArchive = exports.ExecuteTestBetweenRollbackAndReapplyCommandArchive = exports.ActivityCommitCommandArchive = exports.InducedCommandCollectionCommitCommandArchive = exports.UpgradeDocPostProcessingCommandArchive = exports.GroupCommitCommandArchive = exports.NullCommandArchive = exports.IdPlacementOperationArgs = exports.RearrangeIdOperationArgs = exports.RemoveIdOperationArgs = void 0;
exports.ActivityStreamRemovedAuthorAuditorPendingStateArchive_DateToAuditAndType = exports.ActivityStreamRemovedAuthorAuditorPendingStateArchive = exports.ActivityStreamActivityCounterArchive_CursorTypeCounter = exports.ActivityStreamActivityCounterArchive_ActionTypeCounter = exports.ActivityStreamActivityCounterArchive = exports.ActivityStreamTransformationStateArchive = exports.ActivityNotificationQueueArchive = exports.ActivityNotificationParticipantCacheArchive_UniqueIdentifierAndAttempts = exports.ActivityNotificationParticipantCacheArchive = exports.ActivityNotificationItemArchive = exports.ActivityOnlyCommandArchive = exports.ActivityAuthorCacheArchive_FirstJoinCache = exports.ActivityAuthorCacheArchive_IndexCache = exports.ActivityAuthorCacheArchive_PublicIDCache = void 0;
const runtime_1 = require("@protobuf-ts/runtime");
const runtime_2 = require("@protobuf-ts/runtime");
const runtime_3 = require("@protobuf-ts/runtime");
const runtime_4 = require("@protobuf-ts/runtime");
const runtime_5 = require("@protobuf-ts/runtime");
const TSPMessages_1 = require("./TSPMessages");
const TSPMessages_2 = require("./TSPMessages");
const TSPMessages_3 = require("./TSPMessages");
const TSPMessages_4 = require("./TSPMessages");
const TSPMessages_5 = require("./TSPMessages");
const TSPMessages_6 = require("./TSPMessages");
const TSPMessages_7 = require("./TSPMessages");
const TSPMessages_8 = require("./TSPMessages");
const TSPMessages_9 = require("./TSPMessages");
const TSPMessages_10 = require("./TSPMessages");
const TSPMessages_11 = require("./TSPMessages");
const TSPMessages_12 = require("./TSPMessages");
/**
 * @generated from protobuf enum TSK.ChangeDocumentPackageTypeCommandArchive.PackageType
 */
var ChangeDocumentPackageTypeCommandArchive_PackageType;
(function (ChangeDocumentPackageTypeCommandArchive_PackageType) {
    /**
     * @generated from protobuf enum value: Default = 0;
     */
    ChangeDocumentPackageTypeCommandArchive_PackageType[ChangeDocumentPackageTypeCommandArchive_PackageType["Default"] = 0] = "Default";
    /**
     * @generated from protobuf enum value: Directory = 1;
     */
    ChangeDocumentPackageTypeCommandArchive_PackageType[ChangeDocumentPackageTypeCommandArchive_PackageType["Directory"] = 1] = "Directory";
    /**
     * @generated from protobuf enum value: SingleFile = 2;
     */
    ChangeDocumentPackageTypeCommandArchive_PackageType[ChangeDocumentPackageTypeCommandArchive_PackageType["SingleFile"] = 2] = "SingleFile";
})(ChangeDocumentPackageTypeCommandArchive_PackageType = exports.ChangeDocumentPackageTypeCommandArchive_PackageType || (exports.ChangeDocumentPackageTypeCommandArchive_PackageType = {}));
/**
 * @generated from protobuf enum TSK.Operation.OperationType
 */
var Operation_OperationType;
(function (Operation_OperationType) {
    /**
     * @generated from protobuf enum value: Add = 0;
     */
    Operation_OperationType[Operation_OperationType["Add"] = 0] = "Add";
    /**
     * @generated from protobuf enum value: Remove = 1;
     */
    Operation_OperationType[Operation_OperationType["Remove"] = 1] = "Remove";
    /**
     * @generated from protobuf enum value: Placement = 2;
     */
    Operation_OperationType[Operation_OperationType["Placement"] = 2] = "Placement";
    /**
     * @generated from protobuf enum value: Rearrange = 3;
     */
    Operation_OperationType[Operation_OperationType["Rearrange"] = 3] = "Rearrange";
    /**
     * @generated from protobuf enum value: UpdateId = 4;
     */
    Operation_OperationType[Operation_OperationType["UpdateId"] = 4] = "UpdateId";
    /**
     * @generated from protobuf enum value: UpdateRange = 5;
     */
    Operation_OperationType[Operation_OperationType["UpdateRange"] = 5] = "UpdateRange";
    /**
     * @generated from protobuf enum value: ReplaceRange = 6;
     */
    Operation_OperationType[Operation_OperationType["ReplaceRange"] = 6] = "ReplaceRange";
})(Operation_OperationType = exports.Operation_OperationType || (exports.Operation_OperationType = {}));
/**
 * @generated from protobuf enum TSK.PencilAnnotationUIState.PencilAnnotationToolType
 */
var PencilAnnotationUIState_PencilAnnotationToolType;
(function (PencilAnnotationUIState_PencilAnnotationToolType) {
    /**
     * @generated from protobuf enum value: Pen = 0;
     */
    PencilAnnotationUIState_PencilAnnotationToolType[PencilAnnotationUIState_PencilAnnotationToolType["Pen"] = 0] = "Pen";
    /**
     * @generated from protobuf enum value: Highlighter = 1;
     */
    PencilAnnotationUIState_PencilAnnotationToolType[PencilAnnotationUIState_PencilAnnotationToolType["Highlighter"] = 1] = "Highlighter";
})(PencilAnnotationUIState_PencilAnnotationToolType = exports.PencilAnnotationUIState_PencilAnnotationToolType || (exports.PencilAnnotationUIState_PencilAnnotationToolType = {}));
/**
 * @generated from protobuf enum TSK.CommandActivityBehaviorArchive.ActionType
 */
var CommandActivityBehaviorArchive_ActionType;
(function (CommandActivityBehaviorArchive_ActionType) {
    /**
     * @generated from protobuf enum value: Unknown = 0;
     */
    CommandActivityBehaviorArchive_ActionType[CommandActivityBehaviorArchive_ActionType["Unknown"] = 0] = "Unknown";
    /**
     * @generated from protobuf enum value: FirstJoin = 1;
     */
    CommandActivityBehaviorArchive_ActionType[CommandActivityBehaviorArchive_ActionType["FirstJoin"] = 1] = "FirstJoin";
    /**
     * @generated from protobuf enum value: Add = 2;
     */
    CommandActivityBehaviorArchive_ActionType[CommandActivityBehaviorArchive_ActionType["Add"] = 2] = "Add";
    /**
     * @generated from protobuf enum value: Modify = 3;
     */
    CommandActivityBehaviorArchive_ActionType[CommandActivityBehaviorArchive_ActionType["Modify"] = 3] = "Modify";
    /**
     * @generated from protobuf enum value: Comment = 4;
     */
    CommandActivityBehaviorArchive_ActionType[CommandActivityBehaviorArchive_ActionType["Comment"] = 4] = "Comment";
    /**
     * @generated from protobuf enum value: Reply = 5;
     */
    CommandActivityBehaviorArchive_ActionType[CommandActivityBehaviorArchive_ActionType["Reply"] = 5] = "Reply";
    /**
     * @generated from protobuf enum value: Paste = 6;
     */
    CommandActivityBehaviorArchive_ActionType[CommandActivityBehaviorArchive_ActionType["Paste"] = 6] = "Paste";
    /**
     * @generated from protobuf enum value: Password = 7;
     */
    CommandActivityBehaviorArchive_ActionType[CommandActivityBehaviorArchive_ActionType["Password"] = 7] = "Password";
    /**
     * @generated from protobuf enum value: Restore = 8;
     */
    CommandActivityBehaviorArchive_ActionType[CommandActivityBehaviorArchive_ActionType["Restore"] = 8] = "Restore";
    /**
     * @generated from protobuf enum value: Remove = 9;
     */
    CommandActivityBehaviorArchive_ActionType[CommandActivityBehaviorArchive_ActionType["Remove"] = 9] = "Remove";
    /**
     * @generated from protobuf enum value: EditText = 10;
     */
    CommandActivityBehaviorArchive_ActionType[CommandActivityBehaviorArchive_ActionType["EditText"] = 10] = "EditText";
    /**
     * @generated from protobuf enum value: Group = 11;
     */
    CommandActivityBehaviorArchive_ActionType[CommandActivityBehaviorArchive_ActionType["Group"] = 11] = "Group";
    /**
     * @generated from protobuf enum value: Ungroup = 12;
     */
    CommandActivityBehaviorArchive_ActionType[CommandActivityBehaviorArchive_ActionType["Ungroup"] = 12] = "Ungroup";
    /**
     * @generated from protobuf enum value: Replace = 13;
     */
    CommandActivityBehaviorArchive_ActionType[CommandActivityBehaviorArchive_ActionType["Replace"] = 13] = "Replace";
})(CommandActivityBehaviorArchive_ActionType = exports.CommandActivityBehaviorArchive_ActionType || (exports.CommandActivityBehaviorArchive_ActionType = {}));
/**
 * @generated from protobuf enum TSK.CommandActivityBehaviorArchive.ActionSubType
 */
var CommandActivityBehaviorArchive_ActionSubType;
(function (CommandActivityBehaviorArchive_ActionSubType) {
    /**
     * @generated from protobuf enum value: None = 0;
     */
    CommandActivityBehaviorArchive_ActionSubType[CommandActivityBehaviorArchive_ActionSubType["None"] = 0] = "None";
    /**
     * @generated from protobuf enum value: FilterTable = 1;
     */
    CommandActivityBehaviorArchive_ActionSubType[CommandActivityBehaviorArchive_ActionSubType["FilterTable"] = 1] = "FilterTable";
    /**
     * @generated from protobuf enum value: SortTable = 2;
     */
    CommandActivityBehaviorArchive_ActionSubType[CommandActivityBehaviorArchive_ActionSubType["SortTable"] = 2] = "SortTable";
    /**
     * @generated from protobuf enum value: CategorizeTable = 3;
     */
    CommandActivityBehaviorArchive_ActionSubType[CommandActivityBehaviorArchive_ActionSubType["CategorizeTable"] = 3] = "CategorizeTable";
    /**
     * @generated from protobuf enum value: ChangeTemplateSlide = 4;
     */
    CommandActivityBehaviorArchive_ActionSubType[CommandActivityBehaviorArchive_ActionSubType["ChangeTemplateSlide"] = 4] = "ChangeTemplateSlide";
    /**
     * @generated from protobuf enum value: ChangeChartType = 5;
     */
    CommandActivityBehaviorArchive_ActionSubType[CommandActivityBehaviorArchive_ActionSubType["ChangeChartType"] = 5] = "ChangeChartType";
    /**
     * @generated from protobuf enum value: MoveDrawable = 6;
     */
    CommandActivityBehaviorArchive_ActionSubType[CommandActivityBehaviorArchive_ActionSubType["MoveDrawable"] = 6] = "MoveDrawable";
    /**
     * @generated from protobuf enum value: ResizeDrawable = 7;
     */
    CommandActivityBehaviorArchive_ActionSubType[CommandActivityBehaviorArchive_ActionSubType["ResizeDrawable"] = 7] = "ResizeDrawable";
    /**
     * @generated from protobuf enum value: AddOrRemovePage = 8;
     */
    CommandActivityBehaviorArchive_ActionSubType[CommandActivityBehaviorArchive_ActionSubType["AddOrRemovePage"] = 8] = "AddOrRemovePage";
    /**
     * @generated from protobuf enum value: Hyperlink = 9;
     */
    CommandActivityBehaviorArchive_ActionSubType[CommandActivityBehaviorArchive_ActionSubType["Hyperlink"] = 9] = "Hyperlink";
    /**
     * @generated from protobuf enum value: SkipSlide = 10;
     */
    CommandActivityBehaviorArchive_ActionSubType[CommandActivityBehaviorArchive_ActionSubType["SkipSlide"] = 10] = "SkipSlide";
    /**
     * @generated from protobuf enum value: UnskipSlide = 11;
     */
    CommandActivityBehaviorArchive_ActionSubType[CommandActivityBehaviorArchive_ActionSubType["UnskipSlide"] = 11] = "UnskipSlide";
    /**
     * @generated from protobuf enum value: ChangeBackground = 12;
     */
    CommandActivityBehaviorArchive_ActionSubType[CommandActivityBehaviorArchive_ActionSubType["ChangeBackground"] = 12] = "ChangeBackground";
    /**
     * @generated from protobuf enum value: ChangePageTemplate = 13;
     */
    CommandActivityBehaviorArchive_ActionSubType[CommandActivityBehaviorArchive_ActionSubType["ChangePageTemplate"] = 13] = "ChangePageTemplate";
    /**
     * @generated from protobuf enum value: InsertPageNumber = 14;
     */
    CommandActivityBehaviorArchive_ActionSubType[CommandActivityBehaviorArchive_ActionSubType["InsertPageNumber"] = 14] = "InsertPageNumber";
    /**
     * @generated from protobuf enum value: RefreshPivotTable = 15;
     */
    CommandActivityBehaviorArchive_ActionSubType[CommandActivityBehaviorArchive_ActionSubType["RefreshPivotTable"] = 15] = "RefreshPivotTable";
    /**
     * @generated from protobuf enum value: AddPassword = 16;
     */
    CommandActivityBehaviorArchive_ActionSubType[CommandActivityBehaviorArchive_ActionSubType["AddPassword"] = 16] = "AddPassword";
    /**
     * @generated from protobuf enum value: ChangePassword = 17;
     */
    CommandActivityBehaviorArchive_ActionSubType[CommandActivityBehaviorArchive_ActionSubType["ChangePassword"] = 17] = "ChangePassword";
    /**
     * @generated from protobuf enum value: RemovePassword = 18;
     */
    CommandActivityBehaviorArchive_ActionSubType[CommandActivityBehaviorArchive_ActionSubType["RemovePassword"] = 18] = "RemovePassword";
    /**
     * @generated from protobuf enum value: Bookmark = 19;
     */
    CommandActivityBehaviorArchive_ActionSubType[CommandActivityBehaviorArchive_ActionSubType["Bookmark"] = 19] = "Bookmark";
    /**
     * @generated from protobuf enum value: Equation = 20;
     */
    CommandActivityBehaviorArchive_ActionSubType[CommandActivityBehaviorArchive_ActionSubType["Equation"] = 20] = "Equation";
    /**
     * @generated from protobuf enum value: SectionBreak = 21;
     */
    CommandActivityBehaviorArchive_ActionSubType[CommandActivityBehaviorArchive_ActionSubType["SectionBreak"] = 21] = "SectionBreak";
    /**
     * @generated from protobuf enum value: MoveColumn = 22;
     */
    CommandActivityBehaviorArchive_ActionSubType[CommandActivityBehaviorArchive_ActionSubType["MoveColumn"] = 22] = "MoveColumn";
})(CommandActivityBehaviorArchive_ActionSubType = exports.CommandActivityBehaviorArchive_ActionSubType || (exports.CommandActivityBehaviorArchive_ActionSubType = {}));
/**
 * @generated from protobuf enum TSK.ActivityStreamTransformationStateArchive.ActionType
 */
var ActivityStreamTransformationStateArchive_ActionType;
(function (ActivityStreamTransformationStateArchive_ActionType) {
    /**
     * @generated from protobuf enum value: Trasnform = 0;
     */
    ActivityStreamTransformationStateArchive_ActionType[ActivityStreamTransformationStateArchive_ActionType["Trasnform"] = 0] = "Trasnform";
    /**
     * @generated from protobuf enum value: Coalesce = 1;
     */
    ActivityStreamTransformationStateArchive_ActionType[ActivityStreamTransformationStateArchive_ActionType["Coalesce"] = 1] = "Coalesce";
})(ActivityStreamTransformationStateArchive_ActionType = exports.ActivityStreamTransformationStateArchive_ActionType || (exports.ActivityStreamTransformationStateArchive_ActionType = {}));
/**
 * @generated from protobuf enum TSK.StructuredTextImportType
 */
var StructuredTextImportType;
(function (StructuredTextImportType) {
    /**
     * @generated from protobuf enum value: ImportType_UNKNOWN = 0;
     */
    StructuredTextImportType[StructuredTextImportType["ImportType_UNKNOWN"] = 0] = "ImportType_UNKNOWN";
    /**
     * @generated from protobuf enum value: ImportType_DELIMITED = 1;
     */
    StructuredTextImportType[StructuredTextImportType["ImportType_DELIMITED"] = 1] = "ImportType_DELIMITED";
    /**
     * @generated from protobuf enum value: ImportType_FIXEDWIDTH = 2;
     */
    StructuredTextImportType[StructuredTextImportType["ImportType_FIXEDWIDTH"] = 2] = "ImportType_FIXEDWIDTH";
})(StructuredTextImportType = exports.StructuredTextImportType || (exports.StructuredTextImportType = {}));
// @generated message type with reflection information, may provide speed optimized methods
class TreeNode$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.TreeNode", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "children", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_12.Reference },
            { no: 3, name: "object", kind: "message", T: () => TSPMessages_12.Reference }
        ]);
    }
    create(value) {
        const message = { children: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* repeated TSP.Reference children */ 2:
                    message.children.push(TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Reference object */ 3:
                    message.object = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.object);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* repeated TSP.Reference children = 2; */
        for (let i = 0; i < message.children.length; i++)
            TSPMessages_12.Reference.internalBinaryWrite(message.children[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference object = 3; */
        if (message.object)
            TSPMessages_12.Reference.internalBinaryWrite(message.object, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.TreeNode
 */
exports.TreeNode = new TreeNode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocalCommandHistoryItem$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.LocalCommandHistoryItem", [
            { no: 1, name: "command", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 2, name: "behavior", kind: "message", T: () => TSPMessages_12.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference command */ 1:
                    message.command = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.command);
                    break;
                case /* optional TSP.Reference behavior */ 2:
                    message.behavior = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.behavior);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference command = 1; */
        if (message.command)
            TSPMessages_12.Reference.internalBinaryWrite(message.command, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference behavior = 2; */
        if (message.behavior)
            TSPMessages_12.Reference.internalBinaryWrite(message.behavior, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.LocalCommandHistoryItem
 */
exports.LocalCommandHistoryItem = new LocalCommandHistoryItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocalCommandHistoryArray$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.LocalCommandHistoryArray", [
            { no: 1, name: "large_array", kind: "message", T: () => TSPMessages_11.LargeArray }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.LargeArray large_array */ 1:
                    message.largeArray = TSPMessages_11.LargeArray.internalBinaryRead(reader, reader.uint32(), options, message.largeArray);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.LargeArray large_array = 1; */
        if (message.largeArray)
            TSPMessages_11.LargeArray.internalBinaryWrite(message.largeArray, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.LocalCommandHistoryArray
 */
exports.LocalCommandHistoryArray = new LocalCommandHistoryArray$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocalCommandHistoryArraySegment$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.LocalCommandHistoryArraySegment", [
            { no: 1, name: "large_object_array_segment", kind: "message", T: () => TSPMessages_10.LargeObjectArraySegment }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.LargeObjectArraySegment large_object_array_segment */ 1:
                    message.largeObjectArraySegment = TSPMessages_10.LargeObjectArraySegment.internalBinaryRead(reader, reader.uint32(), options, message.largeObjectArraySegment);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.LargeObjectArraySegment large_object_array_segment = 1; */
        if (message.largeObjectArraySegment)
            TSPMessages_10.LargeObjectArraySegment.internalBinaryWrite(message.largeObjectArraySegment, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.LocalCommandHistoryArraySegment
 */
exports.LocalCommandHistoryArraySegment = new LocalCommandHistoryArraySegment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocalCommandHistory$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.LocalCommandHistory", [
            { no: 1, name: "undo_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "items_array", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 10, name: "fixed_radar_13365177", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { undoCount: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 undo_count */ 1:
                    message.undoCount = reader.uint32();
                    break;
                case /* optional TSP.Reference items_array */ 2:
                    message.itemsArray = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.itemsArray);
                    break;
                case /* optional bool fixed_radar_13365177 */ 10:
                    message.fixedRadar13365177 = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 undo_count = 1; */
        if (message.undoCount !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.undoCount);
        /* optional TSP.Reference items_array = 2; */
        if (message.itemsArray)
            TSPMessages_12.Reference.internalBinaryWrite(message.itemsArray, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool fixed_radar_13365177 = 10; */
        if (message.fixedRadar13365177 !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).bool(message.fixedRadar13365177);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.LocalCommandHistory
 */
exports.LocalCommandHistory = new LocalCommandHistory$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CollaborationCommandHistoryArray$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.CollaborationCommandHistoryArray", [
            { no: 1, name: "large_array", kind: "message", T: () => TSPMessages_11.LargeArray }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.LargeArray large_array */ 1:
                    message.largeArray = TSPMessages_11.LargeArray.internalBinaryRead(reader, reader.uint32(), options, message.largeArray);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.LargeArray large_array = 1; */
        if (message.largeArray)
            TSPMessages_11.LargeArray.internalBinaryWrite(message.largeArray, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.CollaborationCommandHistoryArray
 */
exports.CollaborationCommandHistoryArray = new CollaborationCommandHistoryArray$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CollaborationCommandHistoryArraySegment$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.CollaborationCommandHistoryArraySegment", [
            { no: 1, name: "large_object_array_segment", kind: "message", T: () => TSPMessages_10.LargeObjectArraySegment }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.LargeObjectArraySegment large_object_array_segment */ 1:
                    message.largeObjectArraySegment = TSPMessages_10.LargeObjectArraySegment.internalBinaryRead(reader, reader.uint32(), options, message.largeObjectArraySegment);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.LargeObjectArraySegment large_object_array_segment = 1; */
        if (message.largeObjectArraySegment)
            TSPMessages_10.LargeObjectArraySegment.internalBinaryWrite(message.largeObjectArraySegment, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.CollaborationCommandHistoryArraySegment
 */
exports.CollaborationCommandHistoryArraySegment = new CollaborationCommandHistoryArraySegment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CollaborationCommandHistory$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.CollaborationCommandHistory", [
            { no: 1, name: "local_identifier", kind: "message", T: () => TSPMessages_9.UUID },
            { no: 2, name: "undo_items", kind: "message", T: () => exports.CollaborationCommandHistory_ItemList },
            { no: 3, name: "redo_items", kind: "message", T: () => exports.CollaborationCommandHistory_ItemList }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.UUID local_identifier */ 1:
                    message.localIdentifier = TSPMessages_9.UUID.internalBinaryRead(reader, reader.uint32(), options, message.localIdentifier);
                    break;
                case /* optional TSK.CollaborationCommandHistory.ItemList undo_items */ 2:
                    message.undoItems = exports.CollaborationCommandHistory_ItemList.internalBinaryRead(reader, reader.uint32(), options, message.undoItems);
                    break;
                case /* optional TSK.CollaborationCommandHistory.ItemList redo_items */ 3:
                    message.redoItems = exports.CollaborationCommandHistory_ItemList.internalBinaryRead(reader, reader.uint32(), options, message.redoItems);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.UUID local_identifier = 1; */
        if (message.localIdentifier)
            TSPMessages_9.UUID.internalBinaryWrite(message.localIdentifier, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.CollaborationCommandHistory.ItemList undo_items = 2; */
        if (message.undoItems)
            exports.CollaborationCommandHistory_ItemList.internalBinaryWrite(message.undoItems, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.CollaborationCommandHistory.ItemList redo_items = 3; */
        if (message.redoItems)
            exports.CollaborationCommandHistory_ItemList.internalBinaryWrite(message.redoItems, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.CollaborationCommandHistory
 */
exports.CollaborationCommandHistory = new CollaborationCommandHistory$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CollaborationCommandHistory_ItemList$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.CollaborationCommandHistory.ItemList", [
            { no: 1, name: "items_array", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 2, name: "transformer_entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_12.Reference }
        ]);
    }
    create(value) {
        const message = { transformerEntries: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference items_array */ 1:
                    message.itemsArray = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.itemsArray);
                    break;
                case /* repeated TSP.Reference transformer_entries */ 2:
                    message.transformerEntries.push(TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference items_array = 1; */
        if (message.itemsArray)
            TSPMessages_12.Reference.internalBinaryWrite(message.itemsArray, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference transformer_entries = 2; */
        for (let i = 0; i < message.transformerEntries.length; i++)
            TSPMessages_12.Reference.internalBinaryWrite(message.transformerEntries[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.CollaborationCommandHistory.ItemList
 */
exports.CollaborationCommandHistory_ItemList = new CollaborationCommandHistory_ItemList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CollaborationCommandHistoryItem$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.CollaborationCommandHistoryItem", [
            { no: 1, name: "command", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 2, name: "action_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "behavior", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 4, name: "coalescing_group", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 5, name: "revision_sequence", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference command */ 1:
                    message.command = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.command);
                    break;
                case /* optional string action_string */ 2:
                    message.actionString = reader.string();
                    break;
                case /* optional TSP.Reference behavior */ 3:
                    message.behavior = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.behavior);
                    break;
                case /* optional TSP.Reference coalescing_group */ 4:
                    message.coalescingGroup = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.coalescingGroup);
                    break;
                case /* optional uint64 revision_sequence */ 5:
                    message.revisionSequence = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference command = 1; */
        if (message.command)
            TSPMessages_12.Reference.internalBinaryWrite(message.command, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string action_string = 2; */
        if (message.actionString !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.actionString);
        /* optional TSP.Reference behavior = 3; */
        if (message.behavior)
            TSPMessages_12.Reference.internalBinaryWrite(message.behavior, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference coalescing_group = 4; */
        if (message.coalescingGroup)
            TSPMessages_12.Reference.internalBinaryWrite(message.coalescingGroup, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint64 revision_sequence = 5; */
        if (message.revisionSequence !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).uint64(message.revisionSequence);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.CollaborationCommandHistoryItem
 */
exports.CollaborationCommandHistoryItem = new CollaborationCommandHistoryItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CollaborationCommandHistoryCoalescingGroup$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.CollaborationCommandHistoryCoalescingGroup", [
            { no: 1, name: "nodes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_12.Reference },
            { no: 2, name: "did_coalesce_all_commands", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { nodes: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.Reference nodes */ 1:
                    message.nodes.push(TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool did_coalesce_all_commands */ 2:
                    message.didCoalesceAllCommands = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.Reference nodes = 1; */
        for (let i = 0; i < message.nodes.length; i++)
            TSPMessages_12.Reference.internalBinaryWrite(message.nodes[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool did_coalesce_all_commands = 2; */
        if (message.didCoalesceAllCommands !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.didCoalesceAllCommands);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.CollaborationCommandHistoryCoalescingGroup
 */
exports.CollaborationCommandHistoryCoalescingGroup = new CollaborationCommandHistoryCoalescingGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CollaborationCommandHistoryCoalescingGroupNode$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.CollaborationCommandHistoryCoalescingGroupNode", [
            { no: 1, name: "command", kind: "message", T: () => TSPMessages_12.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference command */ 1:
                    message.command = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.command);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference command = 1; */
        if (message.command)
            TSPMessages_12.Reference.internalBinaryWrite(message.command, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.CollaborationCommandHistoryCoalescingGroupNode
 */
exports.CollaborationCommandHistoryCoalescingGroupNode = new CollaborationCommandHistoryCoalescingGroupNode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CollaborationCommandHistoryOriginatingCommandAcknowledgementObserver$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.CollaborationCommandHistoryOriginatingCommandAcknowledgementObserver", [
            { no: 1, name: "coalescing_group", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 2, name: "node", kind: "message", T: () => TSPMessages_12.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference coalescing_group */ 1:
                    message.coalescingGroup = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.coalescingGroup);
                    break;
                case /* optional TSP.Reference node */ 2:
                    message.node = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.node);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference coalescing_group = 1; */
        if (message.coalescingGroup)
            TSPMessages_12.Reference.internalBinaryWrite(message.coalescingGroup, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference node = 2; */
        if (message.node)
            TSPMessages_12.Reference.internalBinaryWrite(message.node, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.CollaborationCommandHistoryOriginatingCommandAcknowledgementObserver
 */
exports.CollaborationCommandHistoryOriginatingCommandAcknowledgementObserver = new CollaborationCommandHistoryOriginatingCommandAcknowledgementObserver$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.DocumentArchive", [
            { no: 4, name: "locale_identifier", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "annotation_author_storage", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 8, name: "activity_log_entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_12.Reference },
            { no: 9, name: "creation_locale_identifier", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "prevent_image_conversion_on_open", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "has_floating_locale", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "has_user_defined_locale", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "collaboration_operation_history", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 15, name: "should_measure_negatively_tracked_text_correctly", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "use_optimized_text_vertical_alignment", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "formatting_symbols", kind: "message", T: () => exports.FormattingSymbolsArchive },
            { no: 199, name: "activity_stream", kind: "message", T: () => TSPMessages_12.Reference }
        ]);
    }
    create(value) {
        const message = { activityLogEntries: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string locale_identifier */ 4:
                    message.localeIdentifier = reader.string();
                    break;
                case /* optional TSP.Reference annotation_author_storage */ 7:
                    message.annotationAuthorStorage = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.annotationAuthorStorage);
                    break;
                case /* repeated TSP.Reference activity_log_entries */ 8:
                    message.activityLogEntries.push(TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string creation_locale_identifier */ 9:
                    message.creationLocaleIdentifier = reader.string();
                    break;
                case /* optional bool prevent_image_conversion_on_open */ 10:
                    message.preventImageConversionOnOpen = reader.bool();
                    break;
                case /* optional bool has_floating_locale */ 11:
                    message.hasFloatingLocale = reader.bool();
                    break;
                case /* optional bool has_user_defined_locale */ 12:
                    message.hasUserDefinedLocale = reader.bool();
                    break;
                case /* optional TSP.Reference collaboration_operation_history */ 14:
                    message.collaborationOperationHistory = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.collaborationOperationHistory);
                    break;
                case /* optional bool should_measure_negatively_tracked_text_correctly */ 15:
                    message.shouldMeasureNegativelyTrackedTextCorrectly = reader.bool();
                    break;
                case /* optional bool use_optimized_text_vertical_alignment */ 16:
                    message.useOptimizedTextVerticalAlignment = reader.bool();
                    break;
                case /* optional TSK.FormattingSymbolsArchive formatting_symbols */ 17:
                    message.formattingSymbols = exports.FormattingSymbolsArchive.internalBinaryRead(reader, reader.uint32(), options, message.formattingSymbols);
                    break;
                case /* optional TSP.Reference activity_stream */ 199:
                    message.activityStream = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.activityStream);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string locale_identifier = 4; */
        if (message.localeIdentifier !== undefined)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.localeIdentifier);
        /* optional TSP.Reference annotation_author_storage = 7; */
        if (message.annotationAuthorStorage)
            TSPMessages_12.Reference.internalBinaryWrite(message.annotationAuthorStorage, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference activity_log_entries = 8; */
        for (let i = 0; i < message.activityLogEntries.length; i++)
            TSPMessages_12.Reference.internalBinaryWrite(message.activityLogEntries[i], writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string creation_locale_identifier = 9; */
        if (message.creationLocaleIdentifier !== undefined)
            writer.tag(9, runtime_1.WireType.LengthDelimited).string(message.creationLocaleIdentifier);
        /* optional bool prevent_image_conversion_on_open = 10; */
        if (message.preventImageConversionOnOpen !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).bool(message.preventImageConversionOnOpen);
        /* optional bool has_floating_locale = 11; */
        if (message.hasFloatingLocale !== undefined)
            writer.tag(11, runtime_1.WireType.Varint).bool(message.hasFloatingLocale);
        /* optional bool has_user_defined_locale = 12; */
        if (message.hasUserDefinedLocale !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).bool(message.hasUserDefinedLocale);
        /* optional TSP.Reference collaboration_operation_history = 14; */
        if (message.collaborationOperationHistory)
            TSPMessages_12.Reference.internalBinaryWrite(message.collaborationOperationHistory, writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool should_measure_negatively_tracked_text_correctly = 15; */
        if (message.shouldMeasureNegativelyTrackedTextCorrectly !== undefined)
            writer.tag(15, runtime_1.WireType.Varint).bool(message.shouldMeasureNegativelyTrackedTextCorrectly);
        /* optional bool use_optimized_text_vertical_alignment = 16; */
        if (message.useOptimizedTextVerticalAlignment !== undefined)
            writer.tag(16, runtime_1.WireType.Varint).bool(message.useOptimizedTextVerticalAlignment);
        /* optional TSK.FormattingSymbolsArchive formatting_symbols = 17; */
        if (message.formattingSymbols)
            exports.FormattingSymbolsArchive.internalBinaryWrite(message.formattingSymbols, writer.tag(17, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference activity_stream = 199; */
        if (message.activityStream)
            TSPMessages_12.Reference.internalBinaryWrite(message.activityStream, writer.tag(199, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.DocumentArchive
 */
exports.DocumentArchive = new DocumentArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormattingSymbolsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.FormattingSymbolsArchive", [
            { no: 1, name: "version", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "calendar", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "numbering_system", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "months", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "standalone_months", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "short_months", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "standalone_short_months", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "weekdays", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "standalone_weekdays", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "short_weekdays", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "standalone_short_weekdays", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "am_symbol", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "pm_symbol", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "tiny_months", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "standalone_tiny_months", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "tiny_weekdays", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "standalone_tiny_weekdays", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "quarters", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "standalone_quarters", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "short_quarters", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 21, name: "standalone_short_quarters", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 22, name: "eras", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 23, name: "long_eras", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 24, name: "short_date_pattern", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 25, name: "medium_date_pattern", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 26, name: "long_date_pattern", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 27, name: "full_date_pattern", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 28, name: "short_time_pattern", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 29, name: "medium_time_pattern", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 30, name: "long_time_pattern", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 31, name: "full_time_pattern", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 32, name: "decimal_separator", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 33, name: "grouping_separator", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 34, name: "currency_decimal_separator", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 35, name: "currency_grouping_separator", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 36, name: "plus_sign", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 37, name: "minus_sign", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 38, name: "exponential_symbol", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 39, name: "percent_symbol", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 40, name: "per_mille_symbol", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 41, name: "infinity_symbol", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 42, name: "nan_symbol", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 43, name: "decimal_pattern", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 44, name: "scientific_pattern", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 45, name: "percent_pattern", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 46, name: "currency_pattern", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 47, name: "currency_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 48, name: "currency_symbols", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.FormattingSymbolsArchive_CurrencySymbol }
        ]);
    }
    create(value) {
        const message = { months: [], standaloneMonths: [], shortMonths: [], standaloneShortMonths: [], weekdays: [], standaloneWeekdays: [], shortWeekdays: [], standaloneShortWeekdays: [], tinyMonths: [], standaloneTinyMonths: [], tinyWeekdays: [], standaloneTinyWeekdays: [], quarters: [], standaloneQuarters: [], shortQuarters: [], standaloneShortQuarters: [], eras: [], longEras: [], currencySymbols: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string version */ 1:
                    message.version = reader.string();
                    break;
                case /* optional string calendar */ 2:
                    message.calendar = reader.string();
                    break;
                case /* optional string numbering_system */ 3:
                    message.numberingSystem = reader.string();
                    break;
                case /* repeated string months */ 4:
                    message.months.push(reader.string());
                    break;
                case /* repeated string standalone_months */ 5:
                    message.standaloneMonths.push(reader.string());
                    break;
                case /* repeated string short_months */ 6:
                    message.shortMonths.push(reader.string());
                    break;
                case /* repeated string standalone_short_months */ 7:
                    message.standaloneShortMonths.push(reader.string());
                    break;
                case /* repeated string weekdays */ 8:
                    message.weekdays.push(reader.string());
                    break;
                case /* repeated string standalone_weekdays */ 9:
                    message.standaloneWeekdays.push(reader.string());
                    break;
                case /* repeated string short_weekdays */ 10:
                    message.shortWeekdays.push(reader.string());
                    break;
                case /* repeated string standalone_short_weekdays */ 11:
                    message.standaloneShortWeekdays.push(reader.string());
                    break;
                case /* optional string am_symbol */ 12:
                    message.amSymbol = reader.string();
                    break;
                case /* optional string pm_symbol */ 13:
                    message.pmSymbol = reader.string();
                    break;
                case /* repeated string tiny_months */ 14:
                    message.tinyMonths.push(reader.string());
                    break;
                case /* repeated string standalone_tiny_months */ 15:
                    message.standaloneTinyMonths.push(reader.string());
                    break;
                case /* repeated string tiny_weekdays */ 16:
                    message.tinyWeekdays.push(reader.string());
                    break;
                case /* repeated string standalone_tiny_weekdays */ 17:
                    message.standaloneTinyWeekdays.push(reader.string());
                    break;
                case /* repeated string quarters */ 18:
                    message.quarters.push(reader.string());
                    break;
                case /* repeated string standalone_quarters */ 19:
                    message.standaloneQuarters.push(reader.string());
                    break;
                case /* repeated string short_quarters */ 20:
                    message.shortQuarters.push(reader.string());
                    break;
                case /* repeated string standalone_short_quarters */ 21:
                    message.standaloneShortQuarters.push(reader.string());
                    break;
                case /* repeated string eras */ 22:
                    message.eras.push(reader.string());
                    break;
                case /* repeated string long_eras */ 23:
                    message.longEras.push(reader.string());
                    break;
                case /* optional string short_date_pattern */ 24:
                    message.shortDatePattern = reader.string();
                    break;
                case /* optional string medium_date_pattern */ 25:
                    message.mediumDatePattern = reader.string();
                    break;
                case /* optional string long_date_pattern */ 26:
                    message.longDatePattern = reader.string();
                    break;
                case /* optional string full_date_pattern */ 27:
                    message.fullDatePattern = reader.string();
                    break;
                case /* optional string short_time_pattern */ 28:
                    message.shortTimePattern = reader.string();
                    break;
                case /* optional string medium_time_pattern */ 29:
                    message.mediumTimePattern = reader.string();
                    break;
                case /* optional string long_time_pattern */ 30:
                    message.longTimePattern = reader.string();
                    break;
                case /* optional string full_time_pattern */ 31:
                    message.fullTimePattern = reader.string();
                    break;
                case /* optional string decimal_separator */ 32:
                    message.decimalSeparator = reader.string();
                    break;
                case /* optional string grouping_separator */ 33:
                    message.groupingSeparator = reader.string();
                    break;
                case /* optional string currency_decimal_separator */ 34:
                    message.currencyDecimalSeparator = reader.string();
                    break;
                case /* optional string currency_grouping_separator */ 35:
                    message.currencyGroupingSeparator = reader.string();
                    break;
                case /* optional string plus_sign */ 36:
                    message.plusSign = reader.string();
                    break;
                case /* optional string minus_sign */ 37:
                    message.minusSign = reader.string();
                    break;
                case /* optional string exponential_symbol */ 38:
                    message.exponentialSymbol = reader.string();
                    break;
                case /* optional string percent_symbol */ 39:
                    message.percentSymbol = reader.string();
                    break;
                case /* optional string per_mille_symbol */ 40:
                    message.perMilleSymbol = reader.string();
                    break;
                case /* optional string infinity_symbol */ 41:
                    message.infinitySymbol = reader.string();
                    break;
                case /* optional string nan_symbol */ 42:
                    message.nanSymbol = reader.string();
                    break;
                case /* optional string decimal_pattern */ 43:
                    message.decimalPattern = reader.string();
                    break;
                case /* optional string scientific_pattern */ 44:
                    message.scientificPattern = reader.string();
                    break;
                case /* optional string percent_pattern */ 45:
                    message.percentPattern = reader.string();
                    break;
                case /* optional string currency_pattern */ 46:
                    message.currencyPattern = reader.string();
                    break;
                case /* optional string currency_code */ 47:
                    message.currencyCode = reader.string();
                    break;
                case /* repeated TSK.FormattingSymbolsArchive.CurrencySymbol currency_symbols */ 48:
                    message.currencySymbols.push(exports.FormattingSymbolsArchive_CurrencySymbol.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string version = 1; */
        if (message.version !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.version);
        /* optional string calendar = 2; */
        if (message.calendar !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.calendar);
        /* optional string numbering_system = 3; */
        if (message.numberingSystem !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.numberingSystem);
        /* repeated string months = 4; */
        for (let i = 0; i < message.months.length; i++)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.months[i]);
        /* repeated string standalone_months = 5; */
        for (let i = 0; i < message.standaloneMonths.length; i++)
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.standaloneMonths[i]);
        /* repeated string short_months = 6; */
        for (let i = 0; i < message.shortMonths.length; i++)
            writer.tag(6, runtime_1.WireType.LengthDelimited).string(message.shortMonths[i]);
        /* repeated string standalone_short_months = 7; */
        for (let i = 0; i < message.standaloneShortMonths.length; i++)
            writer.tag(7, runtime_1.WireType.LengthDelimited).string(message.standaloneShortMonths[i]);
        /* repeated string weekdays = 8; */
        for (let i = 0; i < message.weekdays.length; i++)
            writer.tag(8, runtime_1.WireType.LengthDelimited).string(message.weekdays[i]);
        /* repeated string standalone_weekdays = 9; */
        for (let i = 0; i < message.standaloneWeekdays.length; i++)
            writer.tag(9, runtime_1.WireType.LengthDelimited).string(message.standaloneWeekdays[i]);
        /* repeated string short_weekdays = 10; */
        for (let i = 0; i < message.shortWeekdays.length; i++)
            writer.tag(10, runtime_1.WireType.LengthDelimited).string(message.shortWeekdays[i]);
        /* repeated string standalone_short_weekdays = 11; */
        for (let i = 0; i < message.standaloneShortWeekdays.length; i++)
            writer.tag(11, runtime_1.WireType.LengthDelimited).string(message.standaloneShortWeekdays[i]);
        /* optional string am_symbol = 12; */
        if (message.amSymbol !== undefined)
            writer.tag(12, runtime_1.WireType.LengthDelimited).string(message.amSymbol);
        /* optional string pm_symbol = 13; */
        if (message.pmSymbol !== undefined)
            writer.tag(13, runtime_1.WireType.LengthDelimited).string(message.pmSymbol);
        /* repeated string tiny_months = 14; */
        for (let i = 0; i < message.tinyMonths.length; i++)
            writer.tag(14, runtime_1.WireType.LengthDelimited).string(message.tinyMonths[i]);
        /* repeated string standalone_tiny_months = 15; */
        for (let i = 0; i < message.standaloneTinyMonths.length; i++)
            writer.tag(15, runtime_1.WireType.LengthDelimited).string(message.standaloneTinyMonths[i]);
        /* repeated string tiny_weekdays = 16; */
        for (let i = 0; i < message.tinyWeekdays.length; i++)
            writer.tag(16, runtime_1.WireType.LengthDelimited).string(message.tinyWeekdays[i]);
        /* repeated string standalone_tiny_weekdays = 17; */
        for (let i = 0; i < message.standaloneTinyWeekdays.length; i++)
            writer.tag(17, runtime_1.WireType.LengthDelimited).string(message.standaloneTinyWeekdays[i]);
        /* repeated string quarters = 18; */
        for (let i = 0; i < message.quarters.length; i++)
            writer.tag(18, runtime_1.WireType.LengthDelimited).string(message.quarters[i]);
        /* repeated string standalone_quarters = 19; */
        for (let i = 0; i < message.standaloneQuarters.length; i++)
            writer.tag(19, runtime_1.WireType.LengthDelimited).string(message.standaloneQuarters[i]);
        /* repeated string short_quarters = 20; */
        for (let i = 0; i < message.shortQuarters.length; i++)
            writer.tag(20, runtime_1.WireType.LengthDelimited).string(message.shortQuarters[i]);
        /* repeated string standalone_short_quarters = 21; */
        for (let i = 0; i < message.standaloneShortQuarters.length; i++)
            writer.tag(21, runtime_1.WireType.LengthDelimited).string(message.standaloneShortQuarters[i]);
        /* repeated string eras = 22; */
        for (let i = 0; i < message.eras.length; i++)
            writer.tag(22, runtime_1.WireType.LengthDelimited).string(message.eras[i]);
        /* repeated string long_eras = 23; */
        for (let i = 0; i < message.longEras.length; i++)
            writer.tag(23, runtime_1.WireType.LengthDelimited).string(message.longEras[i]);
        /* optional string short_date_pattern = 24; */
        if (message.shortDatePattern !== undefined)
            writer.tag(24, runtime_1.WireType.LengthDelimited).string(message.shortDatePattern);
        /* optional string medium_date_pattern = 25; */
        if (message.mediumDatePattern !== undefined)
            writer.tag(25, runtime_1.WireType.LengthDelimited).string(message.mediumDatePattern);
        /* optional string long_date_pattern = 26; */
        if (message.longDatePattern !== undefined)
            writer.tag(26, runtime_1.WireType.LengthDelimited).string(message.longDatePattern);
        /* optional string full_date_pattern = 27; */
        if (message.fullDatePattern !== undefined)
            writer.tag(27, runtime_1.WireType.LengthDelimited).string(message.fullDatePattern);
        /* optional string short_time_pattern = 28; */
        if (message.shortTimePattern !== undefined)
            writer.tag(28, runtime_1.WireType.LengthDelimited).string(message.shortTimePattern);
        /* optional string medium_time_pattern = 29; */
        if (message.mediumTimePattern !== undefined)
            writer.tag(29, runtime_1.WireType.LengthDelimited).string(message.mediumTimePattern);
        /* optional string long_time_pattern = 30; */
        if (message.longTimePattern !== undefined)
            writer.tag(30, runtime_1.WireType.LengthDelimited).string(message.longTimePattern);
        /* optional string full_time_pattern = 31; */
        if (message.fullTimePattern !== undefined)
            writer.tag(31, runtime_1.WireType.LengthDelimited).string(message.fullTimePattern);
        /* optional string decimal_separator = 32; */
        if (message.decimalSeparator !== undefined)
            writer.tag(32, runtime_1.WireType.LengthDelimited).string(message.decimalSeparator);
        /* optional string grouping_separator = 33; */
        if (message.groupingSeparator !== undefined)
            writer.tag(33, runtime_1.WireType.LengthDelimited).string(message.groupingSeparator);
        /* optional string currency_decimal_separator = 34; */
        if (message.currencyDecimalSeparator !== undefined)
            writer.tag(34, runtime_1.WireType.LengthDelimited).string(message.currencyDecimalSeparator);
        /* optional string currency_grouping_separator = 35; */
        if (message.currencyGroupingSeparator !== undefined)
            writer.tag(35, runtime_1.WireType.LengthDelimited).string(message.currencyGroupingSeparator);
        /* optional string plus_sign = 36; */
        if (message.plusSign !== undefined)
            writer.tag(36, runtime_1.WireType.LengthDelimited).string(message.plusSign);
        /* optional string minus_sign = 37; */
        if (message.minusSign !== undefined)
            writer.tag(37, runtime_1.WireType.LengthDelimited).string(message.minusSign);
        /* optional string exponential_symbol = 38; */
        if (message.exponentialSymbol !== undefined)
            writer.tag(38, runtime_1.WireType.LengthDelimited).string(message.exponentialSymbol);
        /* optional string percent_symbol = 39; */
        if (message.percentSymbol !== undefined)
            writer.tag(39, runtime_1.WireType.LengthDelimited).string(message.percentSymbol);
        /* optional string per_mille_symbol = 40; */
        if (message.perMilleSymbol !== undefined)
            writer.tag(40, runtime_1.WireType.LengthDelimited).string(message.perMilleSymbol);
        /* optional string infinity_symbol = 41; */
        if (message.infinitySymbol !== undefined)
            writer.tag(41, runtime_1.WireType.LengthDelimited).string(message.infinitySymbol);
        /* optional string nan_symbol = 42; */
        if (message.nanSymbol !== undefined)
            writer.tag(42, runtime_1.WireType.LengthDelimited).string(message.nanSymbol);
        /* optional string decimal_pattern = 43; */
        if (message.decimalPattern !== undefined)
            writer.tag(43, runtime_1.WireType.LengthDelimited).string(message.decimalPattern);
        /* optional string scientific_pattern = 44; */
        if (message.scientificPattern !== undefined)
            writer.tag(44, runtime_1.WireType.LengthDelimited).string(message.scientificPattern);
        /* optional string percent_pattern = 45; */
        if (message.percentPattern !== undefined)
            writer.tag(45, runtime_1.WireType.LengthDelimited).string(message.percentPattern);
        /* optional string currency_pattern = 46; */
        if (message.currencyPattern !== undefined)
            writer.tag(46, runtime_1.WireType.LengthDelimited).string(message.currencyPattern);
        /* optional string currency_code = 47; */
        if (message.currencyCode !== undefined)
            writer.tag(47, runtime_1.WireType.LengthDelimited).string(message.currencyCode);
        /* repeated TSK.FormattingSymbolsArchive.CurrencySymbol currency_symbols = 48; */
        for (let i = 0; i < message.currencySymbols.length; i++)
            exports.FormattingSymbolsArchive_CurrencySymbol.internalBinaryWrite(message.currencySymbols[i], writer.tag(48, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.FormattingSymbolsArchive
 */
exports.FormattingSymbolsArchive = new FormattingSymbolsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormattingSymbolsArchive_CurrencySymbol$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.FormattingSymbolsArchive.CurrencySymbol", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { code: "", symbol: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* string symbol */ 2:
                    message.symbol = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.code);
        /* string symbol = 2; */
        if (message.symbol !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.symbol);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.FormattingSymbolsArchive.CurrencySymbol
 */
exports.FormattingSymbolsArchive_CurrencySymbol = new FormattingSymbolsArchive_CurrencySymbol$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentSupportCollaborationState$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.DocumentSupportCollaborationState", [
            { no: 1, name: "collaboration_command_history", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 2, name: "collaboration_session_state", kind: "message", T: () => TSPMessages_12.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference collaboration_command_history */ 1:
                    message.collaborationCommandHistory = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.collaborationCommandHistory);
                    break;
                case /* optional TSP.Reference collaboration_session_state */ 2:
                    message.collaborationSessionState = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.collaborationSessionState);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference collaboration_command_history = 1; */
        if (message.collaborationCommandHistory)
            TSPMessages_12.Reference.internalBinaryWrite(message.collaborationCommandHistory, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference collaboration_session_state = 2; */
        if (message.collaborationSessionState)
            TSPMessages_12.Reference.internalBinaryWrite(message.collaborationSessionState, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.DocumentSupportCollaborationState
 */
exports.DocumentSupportCollaborationState = new DocumentSupportCollaborationState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentSupportArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.DocumentSupportArchive", [
            { no: 1, name: "command_history", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 4, name: "undo_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "redo_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "undo_action_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "redo_action_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "web_state", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 9, name: "is_in_collaboration_mode", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "action_string_localization", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "collaboration_state", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 14, name: "activity_notification_map", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 15, name: "removed_author_auditor_pending_state", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 2, name: "command_selection_behavior_history", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 3, name: "view_state", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 10, name: "collaboration_command_history", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 11, name: "collaboration_session_state", kind: "message", T: () => TSPMessages_12.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference command_history */ 1:
                    message.commandHistory = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.commandHistory);
                    break;
                case /* optional uint32 undo_count */ 4:
                    message.undoCount = reader.uint32();
                    break;
                case /* optional uint32 redo_count */ 5:
                    message.redoCount = reader.uint32();
                    break;
                case /* optional string undo_action_string */ 6:
                    message.undoActionString = reader.string();
                    break;
                case /* optional string redo_action_string */ 7:
                    message.redoActionString = reader.string();
                    break;
                case /* optional TSP.Reference web_state */ 8:
                    message.webState = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.webState);
                    break;
                case /* optional bool is_in_collaboration_mode */ 9:
                    message.isInCollaborationMode = reader.bool();
                    break;
                case /* optional string action_string_localization */ 12:
                    message.actionStringLocalization = reader.string();
                    break;
                case /* optional TSP.Reference collaboration_state */ 13:
                    message.collaborationState = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.collaborationState);
                    break;
                case /* optional TSP.Reference activity_notification_map */ 14:
                    message.activityNotificationMap = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.activityNotificationMap);
                    break;
                case /* optional TSP.Reference removed_author_auditor_pending_state */ 15:
                    message.removedAuthorAuditorPendingState = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.removedAuthorAuditorPendingState);
                    break;
                case /* optional TSP.Reference command_selection_behavior_history = 2 [deprecated = true];*/ 2:
                    message.commandSelectionBehaviorHistory = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.commandSelectionBehaviorHistory);
                    break;
                case /* optional TSP.Reference view_state = 3 [deprecated = true];*/ 3:
                    message.viewState = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.viewState);
                    break;
                case /* optional TSP.Reference collaboration_command_history = 10 [deprecated = true];*/ 10:
                    message.collaborationCommandHistory = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.collaborationCommandHistory);
                    break;
                case /* optional TSP.Reference collaboration_session_state = 11 [deprecated = true];*/ 11:
                    message.collaborationSessionState = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.collaborationSessionState);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference command_history = 1; */
        if (message.commandHistory)
            TSPMessages_12.Reference.internalBinaryWrite(message.commandHistory, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 undo_count = 4; */
        if (message.undoCount !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.undoCount);
        /* optional uint32 redo_count = 5; */
        if (message.redoCount !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.redoCount);
        /* optional string undo_action_string = 6; */
        if (message.undoActionString !== undefined)
            writer.tag(6, runtime_1.WireType.LengthDelimited).string(message.undoActionString);
        /* optional string redo_action_string = 7; */
        if (message.redoActionString !== undefined)
            writer.tag(7, runtime_1.WireType.LengthDelimited).string(message.redoActionString);
        /* optional TSP.Reference web_state = 8; */
        if (message.webState)
            TSPMessages_12.Reference.internalBinaryWrite(message.webState, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_in_collaboration_mode = 9; */
        if (message.isInCollaborationMode !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).bool(message.isInCollaborationMode);
        /* optional string action_string_localization = 12; */
        if (message.actionStringLocalization !== undefined)
            writer.tag(12, runtime_1.WireType.LengthDelimited).string(message.actionStringLocalization);
        /* optional TSP.Reference collaboration_state = 13; */
        if (message.collaborationState)
            TSPMessages_12.Reference.internalBinaryWrite(message.collaborationState, writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference activity_notification_map = 14; */
        if (message.activityNotificationMap)
            TSPMessages_12.Reference.internalBinaryWrite(message.activityNotificationMap, writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference removed_author_auditor_pending_state = 15; */
        if (message.removedAuthorAuditorPendingState)
            TSPMessages_12.Reference.internalBinaryWrite(message.removedAuthorAuditorPendingState, writer.tag(15, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference command_selection_behavior_history = 2 [deprecated = true]; */
        if (message.commandSelectionBehaviorHistory)
            TSPMessages_12.Reference.internalBinaryWrite(message.commandSelectionBehaviorHistory, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference view_state = 3 [deprecated = true]; */
        if (message.viewState)
            TSPMessages_12.Reference.internalBinaryWrite(message.viewState, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference collaboration_command_history = 10 [deprecated = true]; */
        if (message.collaborationCommandHistory)
            TSPMessages_12.Reference.internalBinaryWrite(message.collaborationCommandHistory, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference collaboration_session_state = 11 [deprecated = true]; */
        if (message.collaborationSessionState)
            TSPMessages_12.Reference.internalBinaryWrite(message.collaborationSessionState, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.DocumentSupportArchive
 */
exports.DocumentSupportArchive = new DocumentSupportArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ViewStateArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.ViewStateArchive", [
            { no: 1, name: "view_state_root", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 2, name: "document_revision_sequence", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "document_revision_identifier", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.Reference view_state_root */ 1:
                    message.viewStateRoot = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.viewStateRoot);
                    break;
                case /* optional int32 document_revision_sequence */ 2:
                    message.documentRevisionSequence = reader.int32();
                    break;
                case /* optional string document_revision_identifier */ 3:
                    message.documentRevisionIdentifier = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.Reference view_state_root = 1; */
        if (message.viewStateRoot)
            TSPMessages_12.Reference.internalBinaryWrite(message.viewStateRoot, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional int32 document_revision_sequence = 2; */
        if (message.documentRevisionSequence !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.documentRevisionSequence);
        /* optional string document_revision_identifier = 3; */
        if (message.documentRevisionIdentifier !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.documentRevisionIdentifier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.ViewStateArchive
 */
exports.ViewStateArchive = new ViewStateArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.CommandArchive", [
            { no: 1, name: "undoRedoState", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 2, name: "undoCollection", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 3, name: "shadowed_by_transform", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "shadowed_by_commit", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "remote", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "should_hold_until_group_commit", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "server_originated", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference undoRedoState = 1 [deprecated = true];*/ 1:
                    message.undoRedoState = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoRedoState);
                    break;
                case /* optional TSP.Reference undoCollection */ 2:
                    message.undoCollection = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoCollection);
                    break;
                case /* optional bool shadowed_by_transform */ 3:
                    message.shadowedByTransform = reader.bool();
                    break;
                case /* optional bool shadowed_by_commit */ 4:
                    message.shadowedByCommit = reader.bool();
                    break;
                case /* optional bool remote */ 5:
                    message.remote = reader.bool();
                    break;
                case /* optional bool should_hold_until_group_commit */ 6:
                    message.shouldHoldUntilGroupCommit = reader.bool();
                    break;
                case /* optional bool server_originated */ 7:
                    message.serverOriginated = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference undoRedoState = 1 [deprecated = true]; */
        if (message.undoRedoState)
            TSPMessages_12.Reference.internalBinaryWrite(message.undoRedoState, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undoCollection = 2; */
        if (message.undoCollection)
            TSPMessages_12.Reference.internalBinaryWrite(message.undoCollection, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool shadowed_by_transform = 3; */
        if (message.shadowedByTransform !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.shadowedByTransform);
        /* optional bool shadowed_by_commit = 4; */
        if (message.shadowedByCommit !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.shadowedByCommit);
        /* optional bool remote = 5; */
        if (message.remote !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.remote);
        /* optional bool should_hold_until_group_commit = 6; */
        if (message.shouldHoldUntilGroupCommit !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.shouldHoldUntilGroupCommit);
        /* optional bool server_originated = 7; */
        if (message.serverOriginated !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.serverOriginated);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.CommandArchive
 */
exports.CommandArchive = new CommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandGroupArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.CommandGroupArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandArchive },
            { no: 2, name: "commands", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_12.Reference },
            { no: 3, name: "process_results", kind: "message", T: () => TSPMessages_8.IndexSet },
            { no: 4, name: "action_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "can_coalesce_group", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { commands: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = exports.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSP.Reference commands */ 2:
                    message.commands.push(TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.IndexSet process_results */ 3:
                    message.processResults = TSPMessages_8.IndexSet.internalBinaryRead(reader, reader.uint32(), options, message.processResults);
                    break;
                case /* optional string action_string */ 4:
                    message.actionString = reader.string();
                    break;
                case /* optional bool can_coalesce_group */ 5:
                    message.canCoalesceGroup = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            exports.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference commands = 2; */
        for (let i = 0; i < message.commands.length; i++)
            TSPMessages_12.Reference.internalBinaryWrite(message.commands[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.IndexSet process_results = 3; */
        if (message.processResults)
            TSPMessages_8.IndexSet.internalBinaryWrite(message.processResults, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string action_string = 4; */
        if (message.actionString !== undefined)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.actionString);
        /* optional bool can_coalesce_group = 5; */
        if (message.canCoalesceGroup !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.canCoalesceGroup);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.CommandGroupArchive
 */
exports.CommandGroupArchive = new CommandGroupArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InducedCommandCollectionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.InducedCommandCollectionArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandArchive },
            { no: 2, name: "inducing_command", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 3, name: "induced_commands", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_12.Reference },
            { no: 4, name: "indexes_of_processed_induced_commands", kind: "message", T: () => TSPMessages_8.IndexSet }
        ]);
    }
    create(value) {
        const message = { inducedCommands: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = exports.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference inducing_command */ 2:
                    message.inducingCommand = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.inducingCommand);
                    break;
                case /* repeated TSP.Reference induced_commands */ 3:
                    message.inducedCommands.push(TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.IndexSet indexes_of_processed_induced_commands */ 4:
                    message.indexesOfProcessedInducedCommands = TSPMessages_8.IndexSet.internalBinaryRead(reader, reader.uint32(), options, message.indexesOfProcessedInducedCommands);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            exports.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference inducing_command = 2; */
        if (message.inducingCommand)
            TSPMessages_12.Reference.internalBinaryWrite(message.inducingCommand, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference induced_commands = 3; */
        for (let i = 0; i < message.inducedCommands.length; i++)
            TSPMessages_12.Reference.internalBinaryWrite(message.inducedCommands[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.IndexSet indexes_of_processed_induced_commands = 4; */
        if (message.indexesOfProcessedInducedCommands)
            TSPMessages_8.IndexSet.internalBinaryWrite(message.indexesOfProcessedInducedCommands, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.InducedCommandCollectionArchive
 */
exports.InducedCommandCollectionArchive = new InducedCommandCollectionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PropagatedCommandCollectionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.PropagatedCommandCollectionArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandArchive },
            { no: 2, name: "propagatable_command", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 3, name: "propagatable_command_process_result", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "propagating_command", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 5, name: "propagating_command_process_result", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = exports.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Reference propagatable_command */ 2:
                    message.propagatableCommand = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.propagatableCommand);
                    break;
                case /* optional bool propagatable_command_process_result */ 3:
                    message.propagatableCommandProcessResult = reader.bool();
                    break;
                case /* TSP.Reference propagating_command */ 4:
                    message.propagatingCommand = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.propagatingCommand);
                    break;
                case /* optional bool propagating_command_process_result */ 5:
                    message.propagatingCommandProcessResult = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            exports.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference propagatable_command = 2; */
        if (message.propagatableCommand)
            TSPMessages_12.Reference.internalBinaryWrite(message.propagatableCommand, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool propagatable_command_process_result = 3; */
        if (message.propagatableCommandProcessResult !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.propagatableCommandProcessResult);
        /* TSP.Reference propagating_command = 4; */
        if (message.propagatingCommand)
            TSPMessages_12.Reference.internalBinaryWrite(message.propagatingCommand, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool propagating_command_process_result = 5; */
        if (message.propagatingCommandProcessResult !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.propagatingCommandProcessResult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.PropagatedCommandCollectionArchive
 */
exports.PropagatedCommandCollectionArchive = new PropagatedCommandCollectionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FinalCommandPairArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.FinalCommandPairArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandArchive },
            { no: 2, name: "command", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 3, name: "command_process_result", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "final_command", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 5, name: "final_command_process_result", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = exports.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Reference command */ 2:
                    message.command = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.command);
                    break;
                case /* optional bool command_process_result */ 3:
                    message.commandProcessResult = reader.bool();
                    break;
                case /* TSP.Reference final_command */ 4:
                    message.finalCommand = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.finalCommand);
                    break;
                case /* optional bool final_command_process_result */ 5:
                    message.finalCommandProcessResult = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            exports.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference command = 2; */
        if (message.command)
            TSPMessages_12.Reference.internalBinaryWrite(message.command, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool command_process_result = 3; */
        if (message.commandProcessResult !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.commandProcessResult);
        /* TSP.Reference final_command = 4; */
        if (message.finalCommand)
            TSPMessages_12.Reference.internalBinaryWrite(message.finalCommand, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool final_command_process_result = 5; */
        if (message.finalCommandProcessResult !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.finalCommandProcessResult);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.FinalCommandPairArchive
 */
exports.FinalCommandPairArchive = new FinalCommandPairArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandContainerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.CommandContainerArchive", [
            { no: 1, name: "commands", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_12.Reference }
        ]);
    }
    create(value) {
        const message = { commands: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.Reference commands */ 1:
                    message.commands.push(TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.Reference commands = 1; */
        for (let i = 0; i < message.commands.length; i++)
            TSPMessages_12.Reference.internalBinaryWrite(message.commands[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.CommandContainerArchive
 */
exports.CommandContainerArchive = new CommandContainerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProgressiveCommandGroupArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.ProgressiveCommandGroupArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandGroupArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandGroupArchive super */ 1:
                    message.super = exports.CommandGroupArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandGroupArchive super = 1; */
        if (message.super)
            exports.CommandGroupArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.ProgressiveCommandGroupArchive
 */
exports.ProgressiveCommandGroupArchive = new ProgressiveCommandGroupArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormatStructArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.FormatStructArchive", [
            { no: 1, name: "format_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "decimal_places", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "currency_code", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "negative_style", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "show_thousands_separator", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "use_accounting_style", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "duration_style", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "base", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "base_places", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "base_use_minus_sign", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "fraction_accuracy", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "suppress_date_format", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "suppress_time_format", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "date_time_format", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "duration_unit_largest", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 16, name: "duration_unit_smallest", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 17, name: "custom_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 18, name: "custom_format_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "scale_factor", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 20, name: "requires_fraction_replacement", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "control_minimum", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 22, name: "control_maximum", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 23, name: "control_increment", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 24, name: "control_format_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 25, name: "slider_orientation", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 26, name: "slider_position", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 27, name: "decimal_width", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 28, name: "min_integer_width", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 29, name: "num_nonspace_integer_digits", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 30, name: "num_nonspace_decimal_digits", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 31, name: "index_from_right_last_integer", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 32, name: "interstitial_strings", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 33, name: "inters_str_insertion_indexes", kind: "message", T: () => TSPMessages_8.IndexSet },
            { no: 34, name: "num_hash_decimal_digits", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 35, name: "total_num_decimal_digits", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 36, name: "is_complex", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 37, name: "contains_integer_token", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 38, name: "multiple_choice_list_initial_value", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 39, name: "multiple_choice_list_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 40, name: "use_automatic_duration_units", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 41, name: "custom_uid", kind: "message", T: () => TSPMessages_9.UUID },
            { no: 42, name: "custom_format", kind: "message", T: () => exports.CustomFormatArchive },
            { no: 43, name: "uses_plus_sign", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 44, name: "bool_true_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 45, name: "bool_false_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { interstitialStrings: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 format_type */ 1:
                    message.formatType = reader.uint32();
                    break;
                case /* optional uint32 decimal_places */ 2:
                    message.decimalPlaces = reader.uint32();
                    break;
                case /* optional string currency_code */ 3:
                    message.currencyCode = reader.string();
                    break;
                case /* optional uint32 negative_style */ 4:
                    message.negativeStyle = reader.uint32();
                    break;
                case /* optional bool show_thousands_separator */ 5:
                    message.showThousandsSeparator = reader.bool();
                    break;
                case /* optional bool use_accounting_style */ 6:
                    message.useAccountingStyle = reader.bool();
                    break;
                case /* optional uint32 duration_style */ 7:
                    message.durationStyle = reader.uint32();
                    break;
                case /* optional uint32 base */ 8:
                    message.base = reader.uint32();
                    break;
                case /* optional uint32 base_places */ 9:
                    message.basePlaces = reader.uint32();
                    break;
                case /* optional bool base_use_minus_sign */ 10:
                    message.baseUseMinusSign = reader.bool();
                    break;
                case /* optional uint32 fraction_accuracy */ 11:
                    message.fractionAccuracy = reader.uint32();
                    break;
                case /* optional bool suppress_date_format */ 12:
                    message.suppressDateFormat = reader.bool();
                    break;
                case /* optional bool suppress_time_format */ 13:
                    message.suppressTimeFormat = reader.bool();
                    break;
                case /* optional string date_time_format */ 14:
                    message.dateTimeFormat = reader.string();
                    break;
                case /* optional uint32 duration_unit_largest */ 15:
                    message.durationUnitLargest = reader.uint32();
                    break;
                case /* optional uint32 duration_unit_smallest */ 16:
                    message.durationUnitSmallest = reader.uint32();
                    break;
                case /* optional uint32 custom_id */ 17:
                    message.customId = reader.uint32();
                    break;
                case /* optional string custom_format_string */ 18:
                    message.customFormatString = reader.string();
                    break;
                case /* optional double scale_factor */ 19:
                    message.scaleFactor = reader.double();
                    break;
                case /* optional bool requires_fraction_replacement */ 20:
                    message.requiresFractionReplacement = reader.bool();
                    break;
                case /* optional double control_minimum */ 21:
                    message.controlMinimum = reader.double();
                    break;
                case /* optional double control_maximum */ 22:
                    message.controlMaximum = reader.double();
                    break;
                case /* optional double control_increment */ 23:
                    message.controlIncrement = reader.double();
                    break;
                case /* optional uint32 control_format_type */ 24:
                    message.controlFormatType = reader.uint32();
                    break;
                case /* optional uint32 slider_orientation */ 25:
                    message.sliderOrientation = reader.uint32();
                    break;
                case /* optional uint32 slider_position */ 26:
                    message.sliderPosition = reader.uint32();
                    break;
                case /* optional uint32 decimal_width */ 27:
                    message.decimalWidth = reader.uint32();
                    break;
                case /* optional uint32 min_integer_width */ 28:
                    message.minIntegerWidth = reader.uint32();
                    break;
                case /* optional uint32 num_nonspace_integer_digits */ 29:
                    message.numNonspaceIntegerDigits = reader.uint32();
                    break;
                case /* optional uint32 num_nonspace_decimal_digits */ 30:
                    message.numNonspaceDecimalDigits = reader.uint32();
                    break;
                case /* optional uint32 index_from_right_last_integer */ 31:
                    message.indexFromRightLastInteger = reader.uint32();
                    break;
                case /* repeated string interstitial_strings */ 32:
                    message.interstitialStrings.push(reader.string());
                    break;
                case /* optional TSP.IndexSet inters_str_insertion_indexes */ 33:
                    message.intersStrInsertionIndexes = TSPMessages_8.IndexSet.internalBinaryRead(reader, reader.uint32(), options, message.intersStrInsertionIndexes);
                    break;
                case /* optional uint32 num_hash_decimal_digits */ 34:
                    message.numHashDecimalDigits = reader.uint32();
                    break;
                case /* optional uint32 total_num_decimal_digits */ 35:
                    message.totalNumDecimalDigits = reader.uint32();
                    break;
                case /* optional bool is_complex */ 36:
                    message.isComplex = reader.bool();
                    break;
                case /* optional bool contains_integer_token */ 37:
                    message.containsIntegerToken = reader.bool();
                    break;
                case /* optional uint32 multiple_choice_list_initial_value */ 38:
                    message.multipleChoiceListInitialValue = reader.uint32();
                    break;
                case /* optional uint32 multiple_choice_list_id */ 39:
                    message.multipleChoiceListId = reader.uint32();
                    break;
                case /* optional bool use_automatic_duration_units */ 40:
                    message.useAutomaticDurationUnits = reader.bool();
                    break;
                case /* optional TSP.UUID custom_uid */ 41:
                    message.customUid = TSPMessages_9.UUID.internalBinaryRead(reader, reader.uint32(), options, message.customUid);
                    break;
                case /* optional TSK.CustomFormatArchive custom_format */ 42:
                    message.customFormat = exports.CustomFormatArchive.internalBinaryRead(reader, reader.uint32(), options, message.customFormat);
                    break;
                case /* optional bool uses_plus_sign */ 43:
                    message.usesPlusSign = reader.bool();
                    break;
                case /* optional string bool_true_string */ 44:
                    message.boolTrueString = reader.string();
                    break;
                case /* optional string bool_false_string */ 45:
                    message.boolFalseString = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional uint32 format_type = 1; */
        if (message.formatType !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.formatType);
        /* optional uint32 decimal_places = 2; */
        if (message.decimalPlaces !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.decimalPlaces);
        /* optional string currency_code = 3; */
        if (message.currencyCode !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.currencyCode);
        /* optional uint32 negative_style = 4; */
        if (message.negativeStyle !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.negativeStyle);
        /* optional bool show_thousands_separator = 5; */
        if (message.showThousandsSeparator !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.showThousandsSeparator);
        /* optional bool use_accounting_style = 6; */
        if (message.useAccountingStyle !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.useAccountingStyle);
        /* optional uint32 duration_style = 7; */
        if (message.durationStyle !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).uint32(message.durationStyle);
        /* optional uint32 base = 8; */
        if (message.base !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).uint32(message.base);
        /* optional uint32 base_places = 9; */
        if (message.basePlaces !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).uint32(message.basePlaces);
        /* optional bool base_use_minus_sign = 10; */
        if (message.baseUseMinusSign !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).bool(message.baseUseMinusSign);
        /* optional uint32 fraction_accuracy = 11; */
        if (message.fractionAccuracy !== undefined)
            writer.tag(11, runtime_1.WireType.Varint).uint32(message.fractionAccuracy);
        /* optional bool suppress_date_format = 12; */
        if (message.suppressDateFormat !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).bool(message.suppressDateFormat);
        /* optional bool suppress_time_format = 13; */
        if (message.suppressTimeFormat !== undefined)
            writer.tag(13, runtime_1.WireType.Varint).bool(message.suppressTimeFormat);
        /* optional string date_time_format = 14; */
        if (message.dateTimeFormat !== undefined)
            writer.tag(14, runtime_1.WireType.LengthDelimited).string(message.dateTimeFormat);
        /* optional uint32 duration_unit_largest = 15; */
        if (message.durationUnitLargest !== undefined)
            writer.tag(15, runtime_1.WireType.Varint).uint32(message.durationUnitLargest);
        /* optional uint32 duration_unit_smallest = 16; */
        if (message.durationUnitSmallest !== undefined)
            writer.tag(16, runtime_1.WireType.Varint).uint32(message.durationUnitSmallest);
        /* optional uint32 custom_id = 17; */
        if (message.customId !== undefined)
            writer.tag(17, runtime_1.WireType.Varint).uint32(message.customId);
        /* optional string custom_format_string = 18; */
        if (message.customFormatString !== undefined)
            writer.tag(18, runtime_1.WireType.LengthDelimited).string(message.customFormatString);
        /* optional double scale_factor = 19; */
        if (message.scaleFactor !== undefined)
            writer.tag(19, runtime_1.WireType.Bit64).double(message.scaleFactor);
        /* optional bool requires_fraction_replacement = 20; */
        if (message.requiresFractionReplacement !== undefined)
            writer.tag(20, runtime_1.WireType.Varint).bool(message.requiresFractionReplacement);
        /* optional double control_minimum = 21; */
        if (message.controlMinimum !== undefined)
            writer.tag(21, runtime_1.WireType.Bit64).double(message.controlMinimum);
        /* optional double control_maximum = 22; */
        if (message.controlMaximum !== undefined)
            writer.tag(22, runtime_1.WireType.Bit64).double(message.controlMaximum);
        /* optional double control_increment = 23; */
        if (message.controlIncrement !== undefined)
            writer.tag(23, runtime_1.WireType.Bit64).double(message.controlIncrement);
        /* optional uint32 control_format_type = 24; */
        if (message.controlFormatType !== undefined)
            writer.tag(24, runtime_1.WireType.Varint).uint32(message.controlFormatType);
        /* optional uint32 slider_orientation = 25; */
        if (message.sliderOrientation !== undefined)
            writer.tag(25, runtime_1.WireType.Varint).uint32(message.sliderOrientation);
        /* optional uint32 slider_position = 26; */
        if (message.sliderPosition !== undefined)
            writer.tag(26, runtime_1.WireType.Varint).uint32(message.sliderPosition);
        /* optional uint32 decimal_width = 27; */
        if (message.decimalWidth !== undefined)
            writer.tag(27, runtime_1.WireType.Varint).uint32(message.decimalWidth);
        /* optional uint32 min_integer_width = 28; */
        if (message.minIntegerWidth !== undefined)
            writer.tag(28, runtime_1.WireType.Varint).uint32(message.minIntegerWidth);
        /* optional uint32 num_nonspace_integer_digits = 29; */
        if (message.numNonspaceIntegerDigits !== undefined)
            writer.tag(29, runtime_1.WireType.Varint).uint32(message.numNonspaceIntegerDigits);
        /* optional uint32 num_nonspace_decimal_digits = 30; */
        if (message.numNonspaceDecimalDigits !== undefined)
            writer.tag(30, runtime_1.WireType.Varint).uint32(message.numNonspaceDecimalDigits);
        /* optional uint32 index_from_right_last_integer = 31; */
        if (message.indexFromRightLastInteger !== undefined)
            writer.tag(31, runtime_1.WireType.Varint).uint32(message.indexFromRightLastInteger);
        /* repeated string interstitial_strings = 32; */
        for (let i = 0; i < message.interstitialStrings.length; i++)
            writer.tag(32, runtime_1.WireType.LengthDelimited).string(message.interstitialStrings[i]);
        /* optional TSP.IndexSet inters_str_insertion_indexes = 33; */
        if (message.intersStrInsertionIndexes)
            TSPMessages_8.IndexSet.internalBinaryWrite(message.intersStrInsertionIndexes, writer.tag(33, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 num_hash_decimal_digits = 34; */
        if (message.numHashDecimalDigits !== undefined)
            writer.tag(34, runtime_1.WireType.Varint).uint32(message.numHashDecimalDigits);
        /* optional uint32 total_num_decimal_digits = 35; */
        if (message.totalNumDecimalDigits !== undefined)
            writer.tag(35, runtime_1.WireType.Varint).uint32(message.totalNumDecimalDigits);
        /* optional bool is_complex = 36; */
        if (message.isComplex !== undefined)
            writer.tag(36, runtime_1.WireType.Varint).bool(message.isComplex);
        /* optional bool contains_integer_token = 37; */
        if (message.containsIntegerToken !== undefined)
            writer.tag(37, runtime_1.WireType.Varint).bool(message.containsIntegerToken);
        /* optional uint32 multiple_choice_list_initial_value = 38; */
        if (message.multipleChoiceListInitialValue !== undefined)
            writer.tag(38, runtime_1.WireType.Varint).uint32(message.multipleChoiceListInitialValue);
        /* optional uint32 multiple_choice_list_id = 39; */
        if (message.multipleChoiceListId !== undefined)
            writer.tag(39, runtime_1.WireType.Varint).uint32(message.multipleChoiceListId);
        /* optional bool use_automatic_duration_units = 40; */
        if (message.useAutomaticDurationUnits !== undefined)
            writer.tag(40, runtime_1.WireType.Varint).bool(message.useAutomaticDurationUnits);
        /* optional TSP.UUID custom_uid = 41; */
        if (message.customUid)
            TSPMessages_9.UUID.internalBinaryWrite(message.customUid, writer.tag(41, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.CustomFormatArchive custom_format = 42; */
        if (message.customFormat)
            exports.CustomFormatArchive.internalBinaryWrite(message.customFormat, writer.tag(42, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool uses_plus_sign = 43; */
        if (message.usesPlusSign !== undefined)
            writer.tag(43, runtime_1.WireType.Varint).bool(message.usesPlusSign);
        /* optional string bool_true_string = 44; */
        if (message.boolTrueString !== undefined)
            writer.tag(44, runtime_1.WireType.LengthDelimited).string(message.boolTrueString);
        /* optional string bool_false_string = 45; */
        if (message.boolFalseString !== undefined)
            writer.tag(45, runtime_1.WireType.LengthDelimited).string(message.boolFalseString);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.FormatStructArchive
 */
exports.FormatStructArchive = new FormatStructArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CustomFormatArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.CustomFormatArchive", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "format_type_pre_bnc", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "default_format", kind: "message", T: () => exports.FormatStructArchive },
            { no: 4, name: "conditions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CustomFormatArchive_Condition },
            { no: 5, name: "format_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { name: "", formatTypePreBnc: 0, conditions: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* uint32 format_type_pre_bnc */ 2:
                    message.formatTypePreBnc = reader.uint32();
                    break;
                case /* TSK.FormatStructArchive default_format */ 3:
                    message.defaultFormat = exports.FormatStructArchive.internalBinaryRead(reader, reader.uint32(), options, message.defaultFormat);
                    break;
                case /* repeated TSK.CustomFormatArchive.Condition conditions */ 4:
                    message.conditions.push(exports.CustomFormatArchive_Condition.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 format_type */ 5:
                    message.formatType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* uint32 format_type_pre_bnc = 2; */
        if (message.formatTypePreBnc !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.formatTypePreBnc);
        /* TSK.FormatStructArchive default_format = 3; */
        if (message.defaultFormat)
            exports.FormatStructArchive.internalBinaryWrite(message.defaultFormat, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSK.CustomFormatArchive.Condition conditions = 4; */
        for (let i = 0; i < message.conditions.length; i++)
            exports.CustomFormatArchive_Condition.internalBinaryWrite(message.conditions[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 format_type = 5; */
        if (message.formatType !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.formatType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.CustomFormatArchive
 */
exports.CustomFormatArchive = new CustomFormatArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CustomFormatArchive_Condition$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.CustomFormatArchive.Condition", [
            { no: 1, name: "condition_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "condition_value", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "condition_format", kind: "message", T: () => exports.FormatStructArchive },
            { no: 4, name: "condition_value_dbl", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value) {
        const message = { conditionType: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 condition_type */ 1:
                    message.conditionType = reader.uint32();
                    break;
                case /* optional float condition_value */ 2:
                    message.conditionValue = reader.float();
                    break;
                case /* TSK.FormatStructArchive condition_format */ 3:
                    message.conditionFormat = exports.FormatStructArchive.internalBinaryRead(reader, reader.uint32(), options, message.conditionFormat);
                    break;
                case /* optional double condition_value_dbl */ 4:
                    message.conditionValueDbl = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 condition_type = 1; */
        if (message.conditionType !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.conditionType);
        /* optional float condition_value = 2; */
        if (message.conditionValue !== undefined)
            writer.tag(2, runtime_1.WireType.Bit32).float(message.conditionValue);
        /* TSK.FormatStructArchive condition_format = 3; */
        if (message.conditionFormat)
            exports.FormatStructArchive.internalBinaryWrite(message.conditionFormat, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional double condition_value_dbl = 4; */
        if (message.conditionValueDbl !== undefined)
            writer.tag(4, runtime_1.WireType.Bit64).double(message.conditionValueDbl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.CustomFormatArchive.Condition
 */
exports.CustomFormatArchive_Condition = new CustomFormatArchive_Condition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CustomFormatListArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.CustomFormatListArchive", [
            { no: 1, name: "uuids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_9.UUID },
            { no: 2, name: "custom_formats", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CustomFormatArchive }
        ]);
    }
    create(value) {
        const message = { uuids: [], customFormats: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.UUID uuids */ 1:
                    message.uuids.push(TSPMessages_9.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSK.CustomFormatArchive custom_formats */ 2:
                    message.customFormats.push(exports.CustomFormatArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.UUID uuids = 1; */
        for (let i = 0; i < message.uuids.length; i++)
            TSPMessages_9.UUID.internalBinaryWrite(message.uuids[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSK.CustomFormatArchive custom_formats = 2; */
        for (let i = 0; i < message.customFormats.length; i++)
            exports.CustomFormatArchive.internalBinaryWrite(message.customFormats[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.CustomFormatListArchive
 */
exports.CustomFormatListArchive = new CustomFormatListArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AnnotationAuthorArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.AnnotationAuthorArchive", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "color", kind: "message", T: () => TSPMessages_7.Color },
            { no: 3, name: "public_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "is_public_author", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "public_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { publicIds: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional TSP.Color color */ 2:
                    message.color = TSPMessages_7.Color.internalBinaryRead(reader, reader.uint32(), options, message.color);
                    break;
                case /* optional string public_id */ 3:
                    message.publicId = reader.string();
                    break;
                case /* optional bool is_public_author */ 4:
                    message.isPublicAuthor = reader.bool();
                    break;
                case /* repeated string public_ids */ 5:
                    message.publicIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* optional TSP.Color color = 2; */
        if (message.color)
            TSPMessages_7.Color.internalBinaryWrite(message.color, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string public_id = 3; */
        if (message.publicId !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.publicId);
        /* optional bool is_public_author = 4; */
        if (message.isPublicAuthor !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.isPublicAuthor);
        /* repeated string public_ids = 5; */
        for (let i = 0; i < message.publicIds.length; i++)
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.publicIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.AnnotationAuthorArchive
 */
exports.AnnotationAuthorArchive = new AnnotationAuthorArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeprecatedChangeAuthorArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.DeprecatedChangeAuthorArchive", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "change_color", kind: "message", T: () => TSPMessages_7.Color }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional TSP.Color change_color */ 2:
                    message.changeColor = TSPMessages_7.Color.internalBinaryRead(reader, reader.uint32(), options, message.changeColor);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* optional TSP.Color change_color = 2; */
        if (message.changeColor)
            TSPMessages_7.Color.internalBinaryWrite(message.changeColor, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.DeprecatedChangeAuthorArchive
 */
exports.DeprecatedChangeAuthorArchive = new DeprecatedChangeAuthorArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AnnotationAuthorStorageArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.AnnotationAuthorStorageArchive", [
            { no: 1, name: "annotation_author", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_12.Reference }
        ]);
    }
    create(value) {
        const message = { annotationAuthor: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.Reference annotation_author */ 1:
                    message.annotationAuthor.push(TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.Reference annotation_author = 1; */
        for (let i = 0; i < message.annotationAuthor.length; i++)
            TSPMessages_12.Reference.internalBinaryWrite(message.annotationAuthor[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.AnnotationAuthorStorageArchive
 */
exports.AnnotationAuthorStorageArchive = new AnnotationAuthorStorageArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetAnnotationAuthorColorCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.SetAnnotationAuthorColorCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandArchive },
            { no: 2, name: "annotation_author", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 3, name: "color", kind: "message", T: () => TSPMessages_7.Color },
            { no: 4, name: "old_color", kind: "message", T: () => TSPMessages_7.Color }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = exports.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference annotation_author */ 2:
                    message.annotationAuthor = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.annotationAuthor);
                    break;
                case /* optional TSP.Color color */ 3:
                    message.color = TSPMessages_7.Color.internalBinaryRead(reader, reader.uint32(), options, message.color);
                    break;
                case /* optional TSP.Color old_color */ 4:
                    message.oldColor = TSPMessages_7.Color.internalBinaryRead(reader, reader.uint32(), options, message.oldColor);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            exports.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference annotation_author = 2; */
        if (message.annotationAuthor)
            TSPMessages_12.Reference.internalBinaryWrite(message.annotationAuthor, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Color color = 3; */
        if (message.color)
            TSPMessages_7.Color.internalBinaryWrite(message.color, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Color old_color = 4; */
        if (message.oldColor)
            TSPMessages_7.Color.internalBinaryWrite(message.oldColor, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.SetAnnotationAuthorColorCommandArchive
 */
exports.SetAnnotationAuthorColorCommandArchive = new SetAnnotationAuthorColorCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetActivityAuthorShareParticipantIDCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.SetActivityAuthorShareParticipantIDCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandArchive },
            { no: 2, name: "activity_author", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 3, name: "share_participant_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "old_share_participant_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = exports.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference activity_author */ 2:
                    message.activityAuthor = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.activityAuthor);
                    break;
                case /* optional string share_participant_id */ 3:
                    message.shareParticipantId = reader.string();
                    break;
                case /* optional string old_share_participant_id */ 4:
                    message.oldShareParticipantId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            exports.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference activity_author = 2; */
        if (message.activityAuthor)
            TSPMessages_12.Reference.internalBinaryWrite(message.activityAuthor, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string share_participant_id = 3; */
        if (message.shareParticipantId !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.shareParticipantId);
        /* optional string old_share_participant_id = 4; */
        if (message.oldShareParticipantId !== undefined)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.oldShareParticipantId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.SetActivityAuthorShareParticipantIDCommandArchive
 */
exports.SetActivityAuthorShareParticipantIDCommandArchive = new SetActivityAuthorShareParticipantIDCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandBehaviorSelectionPathStorageArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.CommandBehaviorSelectionPathStorageArchive", [
            { no: 1, name: "archived_selection", kind: "message", T: () => exports.SelectionPathArchive },
            { no: 2, name: "archived_old_selection", kind: "message", T: () => exports.SelectionPathArchive },
            { no: 3, name: "archived_new_selection", kind: "message", T: () => exports.SelectionPathArchive },
            { no: 4, name: "forward_selection_path_transformer", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 5, name: "reverse_selection_path_transformer", kind: "message", T: () => TSPMessages_12.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSK.SelectionPathArchive archived_selection */ 1:
                    message.archivedSelection = exports.SelectionPathArchive.internalBinaryRead(reader, reader.uint32(), options, message.archivedSelection);
                    break;
                case /* optional TSK.SelectionPathArchive archived_old_selection */ 2:
                    message.archivedOldSelection = exports.SelectionPathArchive.internalBinaryRead(reader, reader.uint32(), options, message.archivedOldSelection);
                    break;
                case /* optional TSK.SelectionPathArchive archived_new_selection */ 3:
                    message.archivedNewSelection = exports.SelectionPathArchive.internalBinaryRead(reader, reader.uint32(), options, message.archivedNewSelection);
                    break;
                case /* optional TSP.Reference forward_selection_path_transformer */ 4:
                    message.forwardSelectionPathTransformer = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.forwardSelectionPathTransformer);
                    break;
                case /* optional TSP.Reference reverse_selection_path_transformer */ 5:
                    message.reverseSelectionPathTransformer = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.reverseSelectionPathTransformer);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSK.SelectionPathArchive archived_selection = 1; */
        if (message.archivedSelection)
            exports.SelectionPathArchive.internalBinaryWrite(message.archivedSelection, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.SelectionPathArchive archived_old_selection = 2; */
        if (message.archivedOldSelection)
            exports.SelectionPathArchive.internalBinaryWrite(message.archivedOldSelection, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.SelectionPathArchive archived_new_selection = 3; */
        if (message.archivedNewSelection)
            exports.SelectionPathArchive.internalBinaryWrite(message.archivedNewSelection, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference forward_selection_path_transformer = 4; */
        if (message.forwardSelectionPathTransformer)
            TSPMessages_12.Reference.internalBinaryWrite(message.forwardSelectionPathTransformer, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference reverse_selection_path_transformer = 5; */
        if (message.reverseSelectionPathTransformer)
            TSPMessages_12.Reference.internalBinaryWrite(message.reverseSelectionPathTransformer, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.CommandBehaviorSelectionPathStorageArchive
 */
exports.CommandBehaviorSelectionPathStorageArchive = new CommandBehaviorSelectionPathStorageArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandBehaviorArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.CommandBehaviorArchive", [
            { no: 1, name: "selection_behavior", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 2, name: "activity_behavior", kind: "message", T: () => TSPMessages_12.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference selection_behavior */ 1:
                    message.selectionBehavior = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.selectionBehavior);
                    break;
                case /* optional TSP.Reference activity_behavior */ 2:
                    message.activityBehavior = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.activityBehavior);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference selection_behavior = 1; */
        if (message.selectionBehavior)
            TSPMessages_12.Reference.internalBinaryWrite(message.selectionBehavior, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference activity_behavior = 2; */
        if (message.activityBehavior)
            TSPMessages_12.Reference.internalBinaryWrite(message.activityBehavior, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.CommandBehaviorArchive
 */
exports.CommandBehaviorArchive = new CommandBehaviorArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSelectionBehaviorArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.CommandSelectionBehaviorArchive", [
            { no: 1, name: "selection_path_storage", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 2, name: "selection_flags", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "additional_forward_selection_flags", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "additional_reverse_selection_flags", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "additional_selection_behaviors", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_12.Reference }
        ]);
    }
    create(value) {
        const message = { additionalSelectionBehaviors: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference selection_path_storage */ 1:
                    message.selectionPathStorage = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.selectionPathStorage);
                    break;
                case /* optional uint64 selection_flags */ 2:
                    message.selectionFlags = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 additional_forward_selection_flags */ 3:
                    message.additionalForwardSelectionFlags = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 additional_reverse_selection_flags */ 4:
                    message.additionalReverseSelectionFlags = reader.uint64().toBigInt();
                    break;
                case /* repeated TSP.Reference additional_selection_behaviors */ 5:
                    message.additionalSelectionBehaviors.push(TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference selection_path_storage = 1; */
        if (message.selectionPathStorage)
            TSPMessages_12.Reference.internalBinaryWrite(message.selectionPathStorage, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint64 selection_flags = 2; */
        if (message.selectionFlags !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint64(message.selectionFlags);
        /* optional uint64 additional_forward_selection_flags = 3; */
        if (message.additionalForwardSelectionFlags !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint64(message.additionalForwardSelectionFlags);
        /* optional uint64 additional_reverse_selection_flags = 4; */
        if (message.additionalReverseSelectionFlags !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint64(message.additionalReverseSelectionFlags);
        /* repeated TSP.Reference additional_selection_behaviors = 5; */
        for (let i = 0; i < message.additionalSelectionBehaviors.length; i++)
            TSPMessages_12.Reference.internalBinaryWrite(message.additionalSelectionBehaviors[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.CommandSelectionBehaviorArchive
 */
exports.CommandSelectionBehaviorArchive = new CommandSelectionBehaviorArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelectionPathTransformerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.SelectionPathTransformerArchive", [
            { no: 1, name: "selection_transformers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_12.Reference }
        ]);
    }
    create(value) {
        const message = { selectionTransformers: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.Reference selection_transformers */ 1:
                    message.selectionTransformers.push(TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.Reference selection_transformers = 1; */
        for (let i = 0; i < message.selectionTransformers.length; i++)
            TSPMessages_12.Reference.internalBinaryWrite(message.selectionTransformers[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.SelectionPathTransformerArchive
 */
exports.SelectionPathTransformerArchive = new SelectionPathTransformerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelectionPathArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.SelectionPathArchive", [
            { no: 1, name: "ordered_selections", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_12.Reference }
        ]);
    }
    create(value) {
        const message = { orderedSelections: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.Reference ordered_selections */ 1:
                    message.orderedSelections.push(TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.Reference ordered_selections = 1; */
        for (let i = 0; i < message.orderedSelections.length; i++)
            TSPMessages_12.Reference.internalBinaryWrite(message.orderedSelections[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.SelectionPathArchive
 */
exports.SelectionPathArchive = new SelectionPathArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentSelectionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.DocumentSelectionArchive", [
            { no: 1, name: "document_root", kind: "message", T: () => TSPMessages_12.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference document_root */ 1:
                    message.documentRoot = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.documentRoot);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference document_root = 1; */
        if (message.documentRoot)
            TSPMessages_12.Reference.internalBinaryWrite(message.documentRoot, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.DocumentSelectionArchive
 */
exports.DocumentSelectionArchive = new DocumentSelectionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IdOperationArgs$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.IdOperationArgs", [
            { no: 1, name: "id_path", kind: "message", T: () => TSPMessages_6.UUIDPath }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUIDPath id_path */ 1:
                    message.idPath = TSPMessages_6.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.idPath);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUIDPath id_path = 1; */
        if (message.idPath)
            TSPMessages_6.UUIDPath.internalBinaryWrite(message.idPath, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.IdOperationArgs
 */
exports.IdOperationArgs = new IdOperationArgs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddIdOperationArgs$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.AddIdOperationArgs", [
            { no: 1, name: "super", kind: "message", T: () => exports.IdOperationArgs },
            { no: 2, name: "index", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = { index: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.IdOperationArgs super */ 1:
                    message.super = exports.IdOperationArgs.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* int32 index */ 2:
                    message.index = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.IdOperationArgs super = 1; */
        if (message.super)
            exports.IdOperationArgs.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* int32 index = 2; */
        if (message.index !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.index);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.AddIdOperationArgs
 */
exports.AddIdOperationArgs = new AddIdOperationArgs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveIdOperationArgs$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.RemoveIdOperationArgs", [
            { no: 1, name: "super", kind: "message", T: () => exports.IdOperationArgs },
            { no: 2, name: "index", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = { index: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.IdOperationArgs super */ 1:
                    message.super = exports.IdOperationArgs.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* int32 index */ 2:
                    message.index = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.IdOperationArgs super = 1; */
        if (message.super)
            exports.IdOperationArgs.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* int32 index = 2; */
        if (message.index !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.index);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.RemoveIdOperationArgs
 */
exports.RemoveIdOperationArgs = new RemoveIdOperationArgs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RearrangeIdOperationArgs$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.RearrangeIdOperationArgs", [
            { no: 1, name: "super", kind: "message", T: () => exports.IdOperationArgs },
            { no: 2, name: "from_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "to_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = { fromIndex: 0, toIndex: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.IdOperationArgs super */ 1:
                    message.super = exports.IdOperationArgs.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* int32 from_index */ 2:
                    message.fromIndex = reader.int32();
                    break;
                case /* int32 to_index */ 3:
                    message.toIndex = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.IdOperationArgs super = 1; */
        if (message.super)
            exports.IdOperationArgs.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* int32 from_index = 2; */
        if (message.fromIndex !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.fromIndex);
        /* int32 to_index = 3; */
        if (message.toIndex !== 0)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.toIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.RearrangeIdOperationArgs
 */
exports.RearrangeIdOperationArgs = new RearrangeIdOperationArgs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IdPlacementOperationArgs$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.IdPlacementOperationArgs", [
            { no: 1, name: "super", kind: "message", T: () => exports.IdOperationArgs },
            { no: 2, name: "from_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "to_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = { fromIndex: 0, toIndex: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.IdOperationArgs super */ 1:
                    message.super = exports.IdOperationArgs.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* int32 from_index */ 2:
                    message.fromIndex = reader.int32();
                    break;
                case /* int32 to_index */ 3:
                    message.toIndex = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.IdOperationArgs super = 1; */
        if (message.super)
            exports.IdOperationArgs.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* int32 from_index = 2; */
        if (message.fromIndex !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.fromIndex);
        /* int32 to_index = 3; */
        if (message.toIndex !== 0)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.toIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.IdPlacementOperationArgs
 */
exports.IdPlacementOperationArgs = new IdPlacementOperationArgs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NullCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.NullCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = exports.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            exports.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.NullCommandArchive
 */
exports.NullCommandArchive = new NullCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupCommitCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.GroupCommitCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandArchive },
            { no: 2, name: "can_coalesce_group", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = exports.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional bool can_coalesce_group */ 2:
                    message.canCoalesceGroup = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            exports.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool can_coalesce_group = 2; */
        if (message.canCoalesceGroup !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.canCoalesceGroup);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.GroupCommitCommandArchive
 */
exports.GroupCommitCommandArchive = new GroupCommitCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpgradeDocPostProcessingCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.UpgradeDocPostProcessingCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = exports.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            exports.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.UpgradeDocPostProcessingCommandArchive
 */
exports.UpgradeDocPostProcessingCommandArchive = new UpgradeDocPostProcessingCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InducedCommandCollectionCommitCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.InducedCommandCollectionCommitCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = exports.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            exports.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.InducedCommandCollectionCommitCommandArchive
 */
exports.InducedCommandCollectionCommitCommandArchive = new InducedCommandCollectionCommitCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityCommitCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.ActivityCommitCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandArchive },
            { no: 2, name: "activity", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 3, name: "author", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 4, name: "was_activity_committed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = exports.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference activity */ 2:
                    message.activity = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.activity);
                    break;
                case /* optional TSP.Reference author */ 3:
                    message.author = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.author);
                    break;
                case /* optional bool was_activity_committed */ 4:
                    message.wasActivityCommitted = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            exports.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference activity = 2; */
        if (message.activity)
            TSPMessages_12.Reference.internalBinaryWrite(message.activity, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference author = 3; */
        if (message.author)
            TSPMessages_12.Reference.internalBinaryWrite(message.author, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool was_activity_committed = 4; */
        if (message.wasActivityCommitted !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.wasActivityCommitted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.ActivityCommitCommandArchive
 */
exports.ActivityCommitCommandArchive = new ActivityCommitCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteTestBetweenRollbackAndReapplyCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.ExecuteTestBetweenRollbackAndReapplyCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = exports.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            exports.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.ExecuteTestBetweenRollbackAndReapplyCommandArchive
 */
exports.ExecuteTestBetweenRollbackAndReapplyCommandArchive = new ExecuteTestBetweenRollbackAndReapplyCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeDocumentPackageTypeCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.ChangeDocumentPackageTypeCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandArchive },
            { no: 2, name: "new_package_type", kind: "enum", T: () => ["TSK.ChangeDocumentPackageTypeCommandArchive.PackageType", ChangeDocumentPackageTypeCommandArchive_PackageType] },
            { no: 3, name: "old_package_type", kind: "enum", T: () => ["TSK.ChangeDocumentPackageTypeCommandArchive.PackageType", ChangeDocumentPackageTypeCommandArchive_PackageType] }
        ]);
    }
    create(value) {
        const message = { newPackageType: 0, oldPackageType: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = exports.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSK.ChangeDocumentPackageTypeCommandArchive.PackageType new_package_type */ 2:
                    message.newPackageType = reader.int32();
                    break;
                case /* TSK.ChangeDocumentPackageTypeCommandArchive.PackageType old_package_type */ 3:
                    message.oldPackageType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            exports.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSK.ChangeDocumentPackageTypeCommandArchive.PackageType new_package_type = 2; */
        if (message.newPackageType !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.newPackageType);
        /* TSK.ChangeDocumentPackageTypeCommandArchive.PackageType old_package_type = 3; */
        if (message.oldPackageType !== 0)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.oldPackageType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.ChangeDocumentPackageTypeCommandArchive
 */
exports.ChangeDocumentPackageTypeCommandArchive = new ChangeDocumentPackageTypeCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateLocalStorageSnapshotCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.CreateLocalStorageSnapshotCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandArchive },
            { no: 2, name: "snapshot_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = exports.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional string snapshot_id */ 2:
                    message.snapshotId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            exports.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string snapshot_id = 2; */
        if (message.snapshotId !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.snapshotId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.CreateLocalStorageSnapshotCommandArchive
 */
exports.CreateLocalStorageSnapshotCommandArchive = new CreateLocalStorageSnapshotCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlockDiffsAtCurrentRevisionCommand$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.BlockDiffsAtCurrentRevisionCommand", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = exports.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            exports.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.BlockDiffsAtCurrentRevisionCommand
 */
exports.BlockDiffsAtCurrentRevisionCommand = new BlockDiffsAtCurrentRevisionCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RangeAddress$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.RangeAddress", [
            { no: 1, name: "address_identifier", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "range_list", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { addressIdentifier: [], rangeList: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint64 address_identifier */ 1:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.addressIdentifier.push(reader.uint64().toBigInt());
                    else
                        message.addressIdentifier.push(reader.uint64().toBigInt());
                    break;
                case /* repeated uint32 range_list */ 2:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.rangeList.push(reader.uint32());
                    else
                        message.rangeList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated uint64 address_identifier = 1; */
        for (let i = 0; i < message.addressIdentifier.length; i++)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.addressIdentifier[i]);
        /* repeated uint32 range_list = 2; */
        for (let i = 0; i < message.rangeList.length; i++)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.rangeList[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.RangeAddress
 */
exports.RangeAddress = new RangeAddress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Operation$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.Operation", [
            { no: 1, name: "type", kind: "enum", opt: true, T: () => ["TSK.Operation.OperationType", Operation_OperationType] },
            { no: 2, name: "noop", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "address_identifier", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "insert_length", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "preserve_lower_priority_location", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "range_list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "transform_behavior", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "property_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "from_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "to_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "dominating", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "object_count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "object_counter_space", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = { addressIdentifier: [], rangeList: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSK.Operation.OperationType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional bool noop */ 2:
                    message.noop = reader.bool();
                    break;
                case /* repeated fixed64 address_identifier = 3 [packed = true];*/ 3:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.addressIdentifier.push(reader.fixed64().toBigInt());
                    else
                        message.addressIdentifier.push(reader.fixed64().toBigInt());
                    break;
                case /* optional uint64 insert_length */ 4:
                    message.insertLength = reader.uint64().toBigInt();
                    break;
                case /* optional bool preserve_lower_priority_location */ 5:
                    message.preserveLowerPriorityLocation = reader.bool();
                    break;
                case /* repeated uint32 range_list = 6 [packed = true];*/ 6:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.rangeList.push(reader.uint32());
                    else
                        message.rangeList.push(reader.uint32());
                    break;
                case /* optional uint32 transform_behavior */ 7:
                    message.transformBehavior = reader.uint32();
                    break;
                case /* optional uint32 property_id */ 8:
                    message.propertyId = reader.uint32();
                    break;
                case /* optional int32 from_index */ 9:
                    message.fromIndex = reader.int32();
                    break;
                case /* optional int32 to_index */ 10:
                    message.toIndex = reader.int32();
                    break;
                case /* optional bool dominating */ 11:
                    message.dominating = reader.bool();
                    break;
                case /* optional int32 object_count */ 12:
                    message.objectCount = reader.int32();
                    break;
                case /* optional int32 object_counter_space */ 13:
                    message.objectCounterSpace = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSK.Operation.OperationType type = 1; */
        if (message.type !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.type);
        /* optional bool noop = 2; */
        if (message.noop !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.noop);
        /* repeated fixed64 address_identifier = 3 [packed = true]; */
        if (message.addressIdentifier.length) {
            writer.tag(3, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.addressIdentifier.length; i++)
                writer.fixed64(message.addressIdentifier[i]);
            writer.join();
        }
        /* optional uint64 insert_length = 4; */
        if (message.insertLength !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint64(message.insertLength);
        /* optional bool preserve_lower_priority_location = 5; */
        if (message.preserveLowerPriorityLocation !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.preserveLowerPriorityLocation);
        /* repeated uint32 range_list = 6 [packed = true]; */
        if (message.rangeList.length) {
            writer.tag(6, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.rangeList.length; i++)
                writer.uint32(message.rangeList[i]);
            writer.join();
        }
        /* optional uint32 transform_behavior = 7; */
        if (message.transformBehavior !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).uint32(message.transformBehavior);
        /* optional uint32 property_id = 8; */
        if (message.propertyId !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).uint32(message.propertyId);
        /* optional int32 from_index = 9; */
        if (message.fromIndex !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).int32(message.fromIndex);
        /* optional int32 to_index = 10; */
        if (message.toIndex !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).int32(message.toIndex);
        /* optional bool dominating = 11; */
        if (message.dominating !== undefined)
            writer.tag(11, runtime_1.WireType.Varint).bool(message.dominating);
        /* optional int32 object_count = 12; */
        if (message.objectCount !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).int32(message.objectCount);
        /* optional int32 object_counter_space = 13; */
        if (message.objectCounterSpace !== undefined)
            writer.tag(13, runtime_1.WireType.Varint).int32(message.objectCounterSpace);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.Operation
 */
exports.Operation = new Operation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OperationTransformer$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.OperationTransformer", [
            { no: 1, name: "higher_priority", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "operations", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Operation }
        ]);
    }
    create(value) {
        const message = { higherPriority: false, operations: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool higher_priority */ 1:
                    message.higherPriority = reader.bool();
                    break;
                case /* repeated TSK.Operation operations */ 2:
                    message.operations.push(exports.Operation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool higher_priority = 1; */
        if (message.higherPriority !== false)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.higherPriority);
        /* repeated TSK.Operation operations = 2; */
        for (let i = 0; i < message.operations.length; i++)
            exports.Operation.internalBinaryWrite(message.operations[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.OperationTransformer
 */
exports.OperationTransformer = new OperationTransformer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransformerEntry$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.TransformerEntry", [
            { no: 1, name: "sequence", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "creation_time", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "transformer", kind: "message", T: () => exports.OperationTransformer }
        ]);
    }
    create(value) {
        const message = { sequence: 0n, creationTime: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 sequence */ 1:
                    message.sequence = reader.uint64().toBigInt();
                    break;
                case /* double creation_time */ 2:
                    message.creationTime = reader.double();
                    break;
                case /* TSK.OperationTransformer transformer */ 3:
                    message.transformer = exports.OperationTransformer.internalBinaryRead(reader, reader.uint32(), options, message.transformer);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 sequence = 1; */
        if (message.sequence !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.sequence);
        /* double creation_time = 2; */
        if (message.creationTime !== 0)
            writer.tag(2, runtime_1.WireType.Bit64).double(message.creationTime);
        /* TSK.OperationTransformer transformer = 3; */
        if (message.transformer)
            exports.OperationTransformer.internalBinaryWrite(message.transformer, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.TransformerEntry
 */
exports.TransformerEntry = new TransformerEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OutgoingCommandQueueItem$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.OutgoingCommandQueueItem", [
            { no: 1, name: "command", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 2, name: "serialized_json_without_data_base64_encoded_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "serialized_json_without_data_base64_encoded_data", kind: "message", T: () => TSPMessages_5.DataReference },
            { no: 3, name: "uuid_to_data_map_entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.OutgoingCommandQueueItemUUIDToDataMapEntry },
            { no: 5, name: "large_data_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.DataReference }
        ]);
    }
    create(value) {
        const message = { uuidToDataMapEntries: [], largeDataList: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference command */ 1:
                    message.command = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.command);
                    break;
                case /* optional string serialized_json_without_data_base64_encoded_string */ 2:
                    message.serializedJsonWithoutDataBase64EncodedString = reader.string();
                    break;
                case /* optional TSP.DataReference serialized_json_without_data_base64_encoded_data */ 4:
                    message.serializedJsonWithoutDataBase64EncodedData = TSPMessages_5.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.serializedJsonWithoutDataBase64EncodedData);
                    break;
                case /* repeated TSK.OutgoingCommandQueueItemUUIDToDataMapEntry uuid_to_data_map_entries */ 3:
                    message.uuidToDataMapEntries.push(exports.OutgoingCommandQueueItemUUIDToDataMapEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.DataReference large_data_list */ 5:
                    message.largeDataList.push(TSPMessages_5.DataReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference command = 1; */
        if (message.command)
            TSPMessages_12.Reference.internalBinaryWrite(message.command, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string serialized_json_without_data_base64_encoded_string = 2; */
        if (message.serializedJsonWithoutDataBase64EncodedString !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.serializedJsonWithoutDataBase64EncodedString);
        /* optional TSP.DataReference serialized_json_without_data_base64_encoded_data = 4; */
        if (message.serializedJsonWithoutDataBase64EncodedData)
            TSPMessages_5.DataReference.internalBinaryWrite(message.serializedJsonWithoutDataBase64EncodedData, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSK.OutgoingCommandQueueItemUUIDToDataMapEntry uuid_to_data_map_entries = 3; */
        for (let i = 0; i < message.uuidToDataMapEntries.length; i++)
            exports.OutgoingCommandQueueItemUUIDToDataMapEntry.internalBinaryWrite(message.uuidToDataMapEntries[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.DataReference large_data_list = 5; */
        for (let i = 0; i < message.largeDataList.length; i++)
            TSPMessages_5.DataReference.internalBinaryWrite(message.largeDataList[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.OutgoingCommandQueueItem
 */
exports.OutgoingCommandQueueItem = new OutgoingCommandQueueItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OutgoingCommandQueueItemUUIDToDataMapEntry$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.OutgoingCommandQueueItemUUIDToDataMapEntry", [
            { no: 1, name: "uuid", kind: "message", T: () => TSPMessages_9.UUID },
            { no: 2, name: "data", kind: "message", T: () => TSPMessages_5.DataReference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID uuid */ 1:
                    message.uuid = TSPMessages_9.UUID.internalBinaryRead(reader, reader.uint32(), options, message.uuid);
                    break;
                case /* TSP.DataReference data */ 2:
                    message.data = TSPMessages_5.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID uuid = 1; */
        if (message.uuid)
            TSPMessages_9.UUID.internalBinaryWrite(message.uuid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.DataReference data = 2; */
        if (message.data)
            TSPMessages_5.DataReference.internalBinaryWrite(message.data, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.OutgoingCommandQueueItemUUIDToDataMapEntry
 */
exports.OutgoingCommandQueueItemUUIDToDataMapEntry = new OutgoingCommandQueueItemUUIDToDataMapEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CollaborationAppliedCommandDocumentRevisionMapping$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.CollaborationAppliedCommandDocumentRevisionMapping", [
            { no: 1, name: "command", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 2, name: "document_revision_identifier", kind: "message", T: () => TSPMessages_9.UUID },
            { no: 3, name: "document_revision_sequence", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "remaining_command_operations", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Operation },
            { no: 5, name: "timestamp", kind: "message", T: () => TSPMessages_4.Date }
        ]);
    }
    create(value) {
        const message = { remainingCommandOperations: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference command */ 1:
                    message.command = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.command);
                    break;
                case /* optional TSP.UUID document_revision_identifier */ 2:
                    message.documentRevisionIdentifier = TSPMessages_9.UUID.internalBinaryRead(reader, reader.uint32(), options, message.documentRevisionIdentifier);
                    break;
                case /* optional int32 document_revision_sequence */ 3:
                    message.documentRevisionSequence = reader.int32();
                    break;
                case /* repeated TSK.Operation remaining_command_operations */ 4:
                    message.remainingCommandOperations.push(exports.Operation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Date timestamp */ 5:
                    message.timestamp = TSPMessages_4.Date.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference command = 1; */
        if (message.command)
            TSPMessages_12.Reference.internalBinaryWrite(message.command, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID document_revision_identifier = 2; */
        if (message.documentRevisionIdentifier)
            TSPMessages_9.UUID.internalBinaryWrite(message.documentRevisionIdentifier, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional int32 document_revision_sequence = 3; */
        if (message.documentRevisionSequence !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.documentRevisionSequence);
        /* repeated TSK.Operation remaining_command_operations = 4; */
        for (let i = 0; i < message.remainingCommandOperations.length; i++)
            exports.Operation.internalBinaryWrite(message.remainingCommandOperations[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Date timestamp = 5; */
        if (message.timestamp)
            TSPMessages_4.Date.internalBinaryWrite(message.timestamp, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.CollaborationAppliedCommandDocumentRevisionMapping
 */
exports.CollaborationAppliedCommandDocumentRevisionMapping = new CollaborationAppliedCommandDocumentRevisionMapping$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CollaborationDocumentSessionState$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.CollaborationDocumentSessionState", [
            { no: 1, name: "collaborator_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "rsvp_command_queue_items", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_12.Reference },
            { no: 4, name: "collaborator_cursor_transformer_entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_12.Reference },
            { no: 5, name: "acknowledged_commands_pending_resume_process_diffs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_12.Reference },
            { no: 6, name: "unprocessed_commands_pending_resume_process_diffs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_12.Reference },
            { no: 7, name: "command_acknowledgement_observer_entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CollaborationDocumentSessionState_AcknowledgementObserverEntry },
            { no: 8, name: "transformer_from_unprocessed_command_operations_entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_12.Reference },
            { no: 10, name: "mailbox_request_document_revision_sequence", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "mailbox_request_document_revision_identifier", kind: "message", T: () => TSPMessages_9.UUID },
            { no: 12, name: "last_send_pending_command_queue_item_was_moved_from_rsvp_command_queue", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "last_command_send_marker_sequence", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "last_command_send_marker_identifier", kind: "message", T: () => TSPMessages_9.UUID },
            { no: 15, name: "skipped_acknowledged_commands_pending_resume_process_diffs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_12.Reference },
            { no: 16, name: "last_too_old_command_identifier", kind: "message", T: () => TSPMessages_9.UUID },
            { no: 17, name: "unprocessed_operation_entries_pending_resume_process_diffs", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 18, name: "send_pending_command_queue", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 19, name: "count_of_send_pending_command_queue_items_moved_from_rsvp_queue", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 20, name: "last_enqueued_document_load_command_identifier", kind: "message", T: () => TSPMessages_9.UUID },
            { no: 21, name: "applied_command_document_revision_mappings_to_notify_pending_resume_process_diffs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CollaborationAppliedCommandDocumentRevisionMapping },
            { no: 22, name: "count_of_command_queue_items_in_last_outgoing_command_group", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value) {
        const message = { collaboratorIds: [], rsvpCommandQueueItems: [], collaboratorCursorTransformerEntries: [], acknowledgedCommandsPendingResumeProcessDiffs: [], unprocessedCommandsPendingResumeProcessDiffs: [], commandAcknowledgementObserverEntries: [], transformerFromUnprocessedCommandOperationsEntries: [], skippedAcknowledgedCommandsPendingResumeProcessDiffs: [], appliedCommandDocumentRevisionMappingsToNotifyPendingResumeProcessDiffs: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string collaborator_ids */ 1:
                    message.collaboratorIds.push(reader.string());
                    break;
                case /* repeated TSP.Reference rsvp_command_queue_items */ 3:
                    message.rsvpCommandQueueItems.push(TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference collaborator_cursor_transformer_entries */ 4:
                    message.collaboratorCursorTransformerEntries.push(TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference acknowledged_commands_pending_resume_process_diffs */ 5:
                    message.acknowledgedCommandsPendingResumeProcessDiffs.push(TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference unprocessed_commands_pending_resume_process_diffs */ 6:
                    message.unprocessedCommandsPendingResumeProcessDiffs.push(TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSK.CollaborationDocumentSessionState.AcknowledgementObserverEntry command_acknowledgement_observer_entries */ 7:
                    message.commandAcknowledgementObserverEntries.push(exports.CollaborationDocumentSessionState_AcknowledgementObserverEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference transformer_from_unprocessed_command_operations_entries */ 8:
                    message.transformerFromUnprocessedCommandOperationsEntries.push(TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int32 mailbox_request_document_revision_sequence */ 10:
                    message.mailboxRequestDocumentRevisionSequence = reader.int32();
                    break;
                case /* optional TSP.UUID mailbox_request_document_revision_identifier */ 11:
                    message.mailboxRequestDocumentRevisionIdentifier = TSPMessages_9.UUID.internalBinaryRead(reader, reader.uint32(), options, message.mailboxRequestDocumentRevisionIdentifier);
                    break;
                case /* optional bool last_send_pending_command_queue_item_was_moved_from_rsvp_command_queue */ 12:
                    message.lastSendPendingCommandQueueItemWasMovedFromRsvpCommandQueue = reader.bool();
                    break;
                case /* optional int32 last_command_send_marker_sequence */ 13:
                    message.lastCommandSendMarkerSequence = reader.int32();
                    break;
                case /* optional TSP.UUID last_command_send_marker_identifier */ 14:
                    message.lastCommandSendMarkerIdentifier = TSPMessages_9.UUID.internalBinaryRead(reader, reader.uint32(), options, message.lastCommandSendMarkerIdentifier);
                    break;
                case /* repeated TSP.Reference skipped_acknowledged_commands_pending_resume_process_diffs */ 15:
                    message.skippedAcknowledgedCommandsPendingResumeProcessDiffs.push(TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.UUID last_too_old_command_identifier */ 16:
                    message.lastTooOldCommandIdentifier = TSPMessages_9.UUID.internalBinaryRead(reader, reader.uint32(), options, message.lastTooOldCommandIdentifier);
                    break;
                case /* optional TSP.Reference unprocessed_operation_entries_pending_resume_process_diffs */ 17:
                    message.unprocessedOperationEntriesPendingResumeProcessDiffs = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.unprocessedOperationEntriesPendingResumeProcessDiffs);
                    break;
                case /* optional TSP.Reference send_pending_command_queue */ 18:
                    message.sendPendingCommandQueue = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.sendPendingCommandQueue);
                    break;
                case /* optional uint64 count_of_send_pending_command_queue_items_moved_from_rsvp_queue */ 19:
                    message.countOfSendPendingCommandQueueItemsMovedFromRsvpQueue = reader.uint64().toBigInt();
                    break;
                case /* optional TSP.UUID last_enqueued_document_load_command_identifier */ 20:
                    message.lastEnqueuedDocumentLoadCommandIdentifier = TSPMessages_9.UUID.internalBinaryRead(reader, reader.uint32(), options, message.lastEnqueuedDocumentLoadCommandIdentifier);
                    break;
                case /* repeated TSK.CollaborationAppliedCommandDocumentRevisionMapping applied_command_document_revision_mappings_to_notify_pending_resume_process_diffs */ 21:
                    message.appliedCommandDocumentRevisionMappingsToNotifyPendingResumeProcessDiffs.push(exports.CollaborationAppliedCommandDocumentRevisionMapping.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint64 count_of_command_queue_items_in_last_outgoing_command_group */ 22:
                    message.countOfCommandQueueItemsInLastOutgoingCommandGroup = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated string collaborator_ids = 1; */
        for (let i = 0; i < message.collaboratorIds.length; i++)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.collaboratorIds[i]);
        /* repeated TSP.Reference rsvp_command_queue_items = 3; */
        for (let i = 0; i < message.rsvpCommandQueueItems.length; i++)
            TSPMessages_12.Reference.internalBinaryWrite(message.rsvpCommandQueueItems[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference collaborator_cursor_transformer_entries = 4; */
        for (let i = 0; i < message.collaboratorCursorTransformerEntries.length; i++)
            TSPMessages_12.Reference.internalBinaryWrite(message.collaboratorCursorTransformerEntries[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference acknowledged_commands_pending_resume_process_diffs = 5; */
        for (let i = 0; i < message.acknowledgedCommandsPendingResumeProcessDiffs.length; i++)
            TSPMessages_12.Reference.internalBinaryWrite(message.acknowledgedCommandsPendingResumeProcessDiffs[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference unprocessed_commands_pending_resume_process_diffs = 6; */
        for (let i = 0; i < message.unprocessedCommandsPendingResumeProcessDiffs.length; i++)
            TSPMessages_12.Reference.internalBinaryWrite(message.unprocessedCommandsPendingResumeProcessDiffs[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSK.CollaborationDocumentSessionState.AcknowledgementObserverEntry command_acknowledgement_observer_entries = 7; */
        for (let i = 0; i < message.commandAcknowledgementObserverEntries.length; i++)
            exports.CollaborationDocumentSessionState_AcknowledgementObserverEntry.internalBinaryWrite(message.commandAcknowledgementObserverEntries[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference transformer_from_unprocessed_command_operations_entries = 8; */
        for (let i = 0; i < message.transformerFromUnprocessedCommandOperationsEntries.length; i++)
            TSPMessages_12.Reference.internalBinaryWrite(message.transformerFromUnprocessedCommandOperationsEntries[i], writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional int32 mailbox_request_document_revision_sequence = 10; */
        if (message.mailboxRequestDocumentRevisionSequence !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).int32(message.mailboxRequestDocumentRevisionSequence);
        /* optional TSP.UUID mailbox_request_document_revision_identifier = 11; */
        if (message.mailboxRequestDocumentRevisionIdentifier)
            TSPMessages_9.UUID.internalBinaryWrite(message.mailboxRequestDocumentRevisionIdentifier, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool last_send_pending_command_queue_item_was_moved_from_rsvp_command_queue = 12; */
        if (message.lastSendPendingCommandQueueItemWasMovedFromRsvpCommandQueue !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).bool(message.lastSendPendingCommandQueueItemWasMovedFromRsvpCommandQueue);
        /* optional int32 last_command_send_marker_sequence = 13; */
        if (message.lastCommandSendMarkerSequence !== undefined)
            writer.tag(13, runtime_1.WireType.Varint).int32(message.lastCommandSendMarkerSequence);
        /* optional TSP.UUID last_command_send_marker_identifier = 14; */
        if (message.lastCommandSendMarkerIdentifier)
            TSPMessages_9.UUID.internalBinaryWrite(message.lastCommandSendMarkerIdentifier, writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference skipped_acknowledged_commands_pending_resume_process_diffs = 15; */
        for (let i = 0; i < message.skippedAcknowledgedCommandsPendingResumeProcessDiffs.length; i++)
            TSPMessages_12.Reference.internalBinaryWrite(message.skippedAcknowledgedCommandsPendingResumeProcessDiffs[i], writer.tag(15, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID last_too_old_command_identifier = 16; */
        if (message.lastTooOldCommandIdentifier)
            TSPMessages_9.UUID.internalBinaryWrite(message.lastTooOldCommandIdentifier, writer.tag(16, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference unprocessed_operation_entries_pending_resume_process_diffs = 17; */
        if (message.unprocessedOperationEntriesPendingResumeProcessDiffs)
            TSPMessages_12.Reference.internalBinaryWrite(message.unprocessedOperationEntriesPendingResumeProcessDiffs, writer.tag(17, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference send_pending_command_queue = 18; */
        if (message.sendPendingCommandQueue)
            TSPMessages_12.Reference.internalBinaryWrite(message.sendPendingCommandQueue, writer.tag(18, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint64 count_of_send_pending_command_queue_items_moved_from_rsvp_queue = 19; */
        if (message.countOfSendPendingCommandQueueItemsMovedFromRsvpQueue !== undefined)
            writer.tag(19, runtime_1.WireType.Varint).uint64(message.countOfSendPendingCommandQueueItemsMovedFromRsvpQueue);
        /* optional TSP.UUID last_enqueued_document_load_command_identifier = 20; */
        if (message.lastEnqueuedDocumentLoadCommandIdentifier)
            TSPMessages_9.UUID.internalBinaryWrite(message.lastEnqueuedDocumentLoadCommandIdentifier, writer.tag(20, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSK.CollaborationAppliedCommandDocumentRevisionMapping applied_command_document_revision_mappings_to_notify_pending_resume_process_diffs = 21; */
        for (let i = 0; i < message.appliedCommandDocumentRevisionMappingsToNotifyPendingResumeProcessDiffs.length; i++)
            exports.CollaborationAppliedCommandDocumentRevisionMapping.internalBinaryWrite(message.appliedCommandDocumentRevisionMappingsToNotifyPendingResumeProcessDiffs[i], writer.tag(21, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint64 count_of_command_queue_items_in_last_outgoing_command_group = 22; */
        if (message.countOfCommandQueueItemsInLastOutgoingCommandGroup !== undefined)
            writer.tag(22, runtime_1.WireType.Varint).uint64(message.countOfCommandQueueItemsInLastOutgoingCommandGroup);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.CollaborationDocumentSessionState
 */
exports.CollaborationDocumentSessionState = new CollaborationDocumentSessionState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CollaborationDocumentSessionState_AcknowledgementObserverEntry$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.CollaborationDocumentSessionState.AcknowledgementObserverEntry", [
            { no: 1, name: "command_identifier", kind: "message", T: () => TSPMessages_9.UUID },
            { no: 2, name: "acknowledgement_observers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_12.Reference }
        ]);
    }
    create(value) {
        const message = { acknowledgementObservers: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID command_identifier */ 1:
                    message.commandIdentifier = TSPMessages_9.UUID.internalBinaryRead(reader, reader.uint32(), options, message.commandIdentifier);
                    break;
                case /* repeated TSP.Reference acknowledgement_observers */ 2:
                    message.acknowledgementObservers.push(TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID command_identifier = 1; */
        if (message.commandIdentifier)
            TSPMessages_9.UUID.internalBinaryWrite(message.commandIdentifier, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference acknowledgement_observers = 2; */
        for (let i = 0; i < message.acknowledgementObservers.length; i++)
            TSPMessages_12.Reference.internalBinaryWrite(message.acknowledgementObservers[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.CollaborationDocumentSessionState.AcknowledgementObserverEntry
 */
exports.CollaborationDocumentSessionState_AcknowledgementObserverEntry = new CollaborationDocumentSessionState_AcknowledgementObserverEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NativeContentDescription$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.NativeContentDescription", [
            { no: 1, name: "app_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "app_version", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "document_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "drawable_descriptions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_12.Reference }
        ]);
    }
    create(value) {
        const message = { drawableDescriptions: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string app_name */ 1:
                    message.appName = reader.string();
                    break;
                case /* optional string app_version */ 2:
                    message.appVersion = reader.string();
                    break;
                case /* optional string document_id */ 3:
                    message.documentId = reader.string();
                    break;
                case /* repeated TSP.Reference drawable_descriptions */ 4:
                    message.drawableDescriptions.push(TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string app_name = 1; */
        if (message.appName !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.appName);
        /* optional string app_version = 2; */
        if (message.appVersion !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.appVersion);
        /* optional string document_id = 3; */
        if (message.documentId !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.documentId);
        /* repeated TSP.Reference drawable_descriptions = 4; */
        for (let i = 0; i < message.drawableDescriptions.length; i++)
            TSPMessages_12.Reference.internalBinaryWrite(message.drawableDescriptions[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.NativeContentDescription
 */
exports.NativeContentDescription = new NativeContentDescription$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StructuredTextImportSettings$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.StructuredTextImportSettings", [
            { no: 1, name: "type", kind: "enum", T: () => ["TSK.StructuredTextImportType", StructuredTextImportType] },
            { no: 2, name: "starting_row", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "decimal_separators", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "thousands_separators", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "transpose_rows_and_columns", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "delimiters", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "text_qualifiers", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "collapse_consecutive", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "column_offsets", kind: "message", T: () => TSPMessages_8.IndexSet },
            { no: 10, name: "automatic_delimiters", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "automatic_offsets", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "source_encoding", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value) {
        const message = { type: 0, startingRow: 0, decimalSeparators: [], thousandsSeparators: [], delimiters: [], textQualifiers: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.StructuredTextImportType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* int32 starting_row */ 2:
                    message.startingRow = reader.int32();
                    break;
                case /* repeated string decimal_separators */ 3:
                    message.decimalSeparators.push(reader.string());
                    break;
                case /* repeated string thousands_separators */ 4:
                    message.thousandsSeparators.push(reader.string());
                    break;
                case /* optional bool transpose_rows_and_columns */ 5:
                    message.transposeRowsAndColumns = reader.bool();
                    break;
                case /* repeated string delimiters */ 6:
                    message.delimiters.push(reader.string());
                    break;
                case /* repeated string text_qualifiers */ 7:
                    message.textQualifiers.push(reader.string());
                    break;
                case /* optional bool collapse_consecutive */ 8:
                    message.collapseConsecutive = reader.bool();
                    break;
                case /* optional TSP.IndexSet column_offsets */ 9:
                    message.columnOffsets = TSPMessages_8.IndexSet.internalBinaryRead(reader, reader.uint32(), options, message.columnOffsets);
                    break;
                case /* optional bool automatic_delimiters */ 10:
                    message.automaticDelimiters = reader.bool();
                    break;
                case /* optional bool automatic_offsets */ 11:
                    message.automaticOffsets = reader.bool();
                    break;
                case /* optional uint64 source_encoding */ 12:
                    message.sourceEncoding = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.StructuredTextImportType type = 1; */
        if (message.type !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.type);
        /* int32 starting_row = 2; */
        if (message.startingRow !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.startingRow);
        /* repeated string decimal_separators = 3; */
        for (let i = 0; i < message.decimalSeparators.length; i++)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.decimalSeparators[i]);
        /* repeated string thousands_separators = 4; */
        for (let i = 0; i < message.thousandsSeparators.length; i++)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.thousandsSeparators[i]);
        /* optional bool transpose_rows_and_columns = 5; */
        if (message.transposeRowsAndColumns !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.transposeRowsAndColumns);
        /* repeated string delimiters = 6; */
        for (let i = 0; i < message.delimiters.length; i++)
            writer.tag(6, runtime_1.WireType.LengthDelimited).string(message.delimiters[i]);
        /* repeated string text_qualifiers = 7; */
        for (let i = 0; i < message.textQualifiers.length; i++)
            writer.tag(7, runtime_1.WireType.LengthDelimited).string(message.textQualifiers[i]);
        /* optional bool collapse_consecutive = 8; */
        if (message.collapseConsecutive !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.collapseConsecutive);
        /* optional TSP.IndexSet column_offsets = 9; */
        if (message.columnOffsets)
            TSPMessages_8.IndexSet.internalBinaryWrite(message.columnOffsets, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool automatic_delimiters = 10; */
        if (message.automaticDelimiters !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).bool(message.automaticDelimiters);
        /* optional bool automatic_offsets = 11; */
        if (message.automaticOffsets !== undefined)
            writer.tag(11, runtime_1.WireType.Varint).bool(message.automaticOffsets);
        /* optional uint64 source_encoding = 12; */
        if (message.sourceEncoding !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).uint64(message.sourceEncoding);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.StructuredTextImportSettings
 */
exports.StructuredTextImportSettings = new StructuredTextImportSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OperationStorageCommandOperationsEntry$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.OperationStorageCommandOperationsEntry", [
            { no: 1, name: "command_identifier_same_as_revision_identifier", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "command_identifier", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "operations", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Operation },
            { no: 4, name: "server_originated", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "coalesced_command_entry_count", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value) {
        const message = { commandIdentifier: [], operations: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool command_identifier_same_as_revision_identifier */ 1:
                    message.commandIdentifierSameAsRevisionIdentifier = reader.bool();
                    break;
                case /* repeated fixed64 command_identifier = 2 [packed = true];*/ 2:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.commandIdentifier.push(reader.fixed64().toBigInt());
                    else
                        message.commandIdentifier.push(reader.fixed64().toBigInt());
                    break;
                case /* repeated TSK.Operation operations */ 3:
                    message.operations.push(exports.Operation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool server_originated */ 4:
                    message.serverOriginated = reader.bool();
                    break;
                case /* optional uint64 coalesced_command_entry_count */ 5:
                    message.coalescedCommandEntryCount = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional bool command_identifier_same_as_revision_identifier = 1; */
        if (message.commandIdentifierSameAsRevisionIdentifier !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.commandIdentifierSameAsRevisionIdentifier);
        /* repeated fixed64 command_identifier = 2 [packed = true]; */
        if (message.commandIdentifier.length) {
            writer.tag(2, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.commandIdentifier.length; i++)
                writer.fixed64(message.commandIdentifier[i]);
            writer.join();
        }
        /* repeated TSK.Operation operations = 3; */
        for (let i = 0; i < message.operations.length; i++)
            exports.Operation.internalBinaryWrite(message.operations[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool server_originated = 4; */
        if (message.serverOriginated !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.serverOriginated);
        /* optional uint64 coalesced_command_entry_count = 5; */
        if (message.coalescedCommandEntryCount !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).uint64(message.coalescedCommandEntryCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.OperationStorageCommandOperationsEntry
 */
exports.OperationStorageCommandOperationsEntry = new OperationStorageCommandOperationsEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OperationStorageEntry$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.OperationStorageEntry", [
            { no: 1, name: "document_revision_identifier", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "document_revision_sequence_delta", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "command_operation_entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.OperationStorageCommandOperationsEntry },
            { no: 4, name: "first_entry_creation_time", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "creation_time_diff_bucket", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "file_format_version", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { documentRevisionIdentifier: [], commandOperationEntries: [], fileFormatVersion: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated fixed64 document_revision_identifier = 1 [packed = true];*/ 1:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.documentRevisionIdentifier.push(reader.fixed64().toBigInt());
                    else
                        message.documentRevisionIdentifier.push(reader.fixed64().toBigInt());
                    break;
                case /* optional int32 document_revision_sequence_delta */ 2:
                    message.documentRevisionSequenceDelta = reader.int32();
                    break;
                case /* repeated TSK.OperationStorageCommandOperationsEntry command_operation_entries */ 3:
                    message.commandOperationEntries.push(exports.OperationStorageCommandOperationsEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional double first_entry_creation_time */ 4:
                    message.firstEntryCreationTime = reader.double();
                    break;
                case /* optional int32 creation_time_diff_bucket */ 5:
                    message.creationTimeDiffBucket = reader.int32();
                    break;
                case /* repeated uint32 file_format_version = 6 [packed = true];*/ 6:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.fileFormatVersion.push(reader.uint32());
                    else
                        message.fileFormatVersion.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated fixed64 document_revision_identifier = 1 [packed = true]; */
        if (message.documentRevisionIdentifier.length) {
            writer.tag(1, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.documentRevisionIdentifier.length; i++)
                writer.fixed64(message.documentRevisionIdentifier[i]);
            writer.join();
        }
        /* optional int32 document_revision_sequence_delta = 2; */
        if (message.documentRevisionSequenceDelta !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.documentRevisionSequenceDelta);
        /* repeated TSK.OperationStorageCommandOperationsEntry command_operation_entries = 3; */
        for (let i = 0; i < message.commandOperationEntries.length; i++)
            exports.OperationStorageCommandOperationsEntry.internalBinaryWrite(message.commandOperationEntries[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional double first_entry_creation_time = 4; */
        if (message.firstEntryCreationTime !== undefined)
            writer.tag(4, runtime_1.WireType.Bit64).double(message.firstEntryCreationTime);
        /* optional int32 creation_time_diff_bucket = 5; */
        if (message.creationTimeDiffBucket !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).int32(message.creationTimeDiffBucket);
        /* repeated uint32 file_format_version = 6 [packed = true]; */
        if (message.fileFormatVersion.length) {
            writer.tag(6, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.fileFormatVersion.length; i++)
                writer.uint32(message.fileFormatVersion[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.OperationStorageEntry
 */
exports.OperationStorageEntry = new OperationStorageEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OperationStorageEntryArray$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.OperationStorageEntryArray", [
            { no: 1, name: "large_array", kind: "message", T: () => TSPMessages_11.LargeArray }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.LargeArray large_array */ 1:
                    message.largeArray = TSPMessages_11.LargeArray.internalBinaryRead(reader, reader.uint32(), options, message.largeArray);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.LargeArray large_array = 1; */
        if (message.largeArray)
            TSPMessages_11.LargeArray.internalBinaryWrite(message.largeArray, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.OperationStorageEntryArray
 */
exports.OperationStorageEntryArray = new OperationStorageEntryArray$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OperationStorageEntryArraySegment$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.OperationStorageEntryArraySegment", [
            { no: 1, name: "large_array_segment", kind: "message", T: () => TSPMessages_3.LargeArraySegment },
            { no: 2, name: "elements", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.OperationStorageEntry },
            { no: 3, name: "last_document_revision_sequence_before_segment", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "last_document_revision_sequence", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "segment_first_entry_creation_time", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value) {
        const message = { elements: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.LargeArraySegment large_array_segment */ 1:
                    message.largeArraySegment = TSPMessages_3.LargeArraySegment.internalBinaryRead(reader, reader.uint32(), options, message.largeArraySegment);
                    break;
                case /* repeated TSK.OperationStorageEntry elements */ 2:
                    message.elements.push(exports.OperationStorageEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int32 last_document_revision_sequence_before_segment */ 3:
                    message.lastDocumentRevisionSequenceBeforeSegment = reader.int32();
                    break;
                case /* optional int32 last_document_revision_sequence */ 4:
                    message.lastDocumentRevisionSequence = reader.int32();
                    break;
                case /* optional double segment_first_entry_creation_time */ 5:
                    message.segmentFirstEntryCreationTime = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.LargeArraySegment large_array_segment = 1; */
        if (message.largeArraySegment)
            TSPMessages_3.LargeArraySegment.internalBinaryWrite(message.largeArraySegment, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSK.OperationStorageEntry elements = 2; */
        for (let i = 0; i < message.elements.length; i++)
            exports.OperationStorageEntry.internalBinaryWrite(message.elements[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional int32 last_document_revision_sequence_before_segment = 3; */
        if (message.lastDocumentRevisionSequenceBeforeSegment !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.lastDocumentRevisionSequenceBeforeSegment);
        /* optional int32 last_document_revision_sequence = 4; */
        if (message.lastDocumentRevisionSequence !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).int32(message.lastDocumentRevisionSequence);
        /* optional double segment_first_entry_creation_time = 5; */
        if (message.segmentFirstEntryCreationTime !== undefined)
            writer.tag(5, runtime_1.WireType.Bit64).double(message.segmentFirstEntryCreationTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.OperationStorageEntryArraySegment
 */
exports.OperationStorageEntryArraySegment = new OperationStorageEntryArraySegment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OperationStorage$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.OperationStorage", [
            { no: 1, name: "entries", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 2, name: "operation_count", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "last_document_revision_sequence", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "last_document_revision_identifier", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "last_unskippable_document_revision_before_entries_sequence", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "last_unskippable_document_revision_before_entries_identifier", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "last_unskippable_document_revision_in_entries_sequence", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "last_unskippable_document_revision_in_entries_identifier", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "days_with_an_entry", kind: "message", T: () => TSPMessages_8.IndexSet }
        ]);
    }
    create(value) {
        const message = { operationCount: 0n, lastDocumentRevisionIdentifier: [], lastUnskippableDocumentRevisionBeforeEntriesIdentifier: [], lastUnskippableDocumentRevisionInEntriesIdentifier: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.Reference entries */ 1:
                    message.entries = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.entries);
                    break;
                case /* uint64 operation_count */ 2:
                    message.operationCount = reader.uint64().toBigInt();
                    break;
                case /* optional int32 last_document_revision_sequence */ 3:
                    message.lastDocumentRevisionSequence = reader.int32();
                    break;
                case /* repeated fixed64 last_document_revision_identifier = 4 [packed = true];*/ 4:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.lastDocumentRevisionIdentifier.push(reader.fixed64().toBigInt());
                    else
                        message.lastDocumentRevisionIdentifier.push(reader.fixed64().toBigInt());
                    break;
                case /* optional int32 last_unskippable_document_revision_before_entries_sequence */ 5:
                    message.lastUnskippableDocumentRevisionBeforeEntriesSequence = reader.int32();
                    break;
                case /* repeated fixed64 last_unskippable_document_revision_before_entries_identifier = 6 [packed = true];*/ 6:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.lastUnskippableDocumentRevisionBeforeEntriesIdentifier.push(reader.fixed64().toBigInt());
                    else
                        message.lastUnskippableDocumentRevisionBeforeEntriesIdentifier.push(reader.fixed64().toBigInt());
                    break;
                case /* optional int32 last_unskippable_document_revision_in_entries_sequence */ 7:
                    message.lastUnskippableDocumentRevisionInEntriesSequence = reader.int32();
                    break;
                case /* repeated fixed64 last_unskippable_document_revision_in_entries_identifier = 8 [packed = true];*/ 8:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.lastUnskippableDocumentRevisionInEntriesIdentifier.push(reader.fixed64().toBigInt());
                    else
                        message.lastUnskippableDocumentRevisionInEntriesIdentifier.push(reader.fixed64().toBigInt());
                    break;
                case /* optional TSP.IndexSet days_with_an_entry */ 9:
                    message.daysWithAnEntry = TSPMessages_8.IndexSet.internalBinaryRead(reader, reader.uint32(), options, message.daysWithAnEntry);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.Reference entries = 1; */
        if (message.entries)
            TSPMessages_12.Reference.internalBinaryWrite(message.entries, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint64 operation_count = 2; */
        if (message.operationCount !== 0n)
            writer.tag(2, runtime_1.WireType.Varint).uint64(message.operationCount);
        /* optional int32 last_document_revision_sequence = 3; */
        if (message.lastDocumentRevisionSequence !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.lastDocumentRevisionSequence);
        /* repeated fixed64 last_document_revision_identifier = 4 [packed = true]; */
        if (message.lastDocumentRevisionIdentifier.length) {
            writer.tag(4, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.lastDocumentRevisionIdentifier.length; i++)
                writer.fixed64(message.lastDocumentRevisionIdentifier[i]);
            writer.join();
        }
        /* optional int32 last_unskippable_document_revision_before_entries_sequence = 5; */
        if (message.lastUnskippableDocumentRevisionBeforeEntriesSequence !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).int32(message.lastUnskippableDocumentRevisionBeforeEntriesSequence);
        /* repeated fixed64 last_unskippable_document_revision_before_entries_identifier = 6 [packed = true]; */
        if (message.lastUnskippableDocumentRevisionBeforeEntriesIdentifier.length) {
            writer.tag(6, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.lastUnskippableDocumentRevisionBeforeEntriesIdentifier.length; i++)
                writer.fixed64(message.lastUnskippableDocumentRevisionBeforeEntriesIdentifier[i]);
            writer.join();
        }
        /* optional int32 last_unskippable_document_revision_in_entries_sequence = 7; */
        if (message.lastUnskippableDocumentRevisionInEntriesSequence !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).int32(message.lastUnskippableDocumentRevisionInEntriesSequence);
        /* repeated fixed64 last_unskippable_document_revision_in_entries_identifier = 8 [packed = true]; */
        if (message.lastUnskippableDocumentRevisionInEntriesIdentifier.length) {
            writer.tag(8, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.lastUnskippableDocumentRevisionInEntriesIdentifier.length; i++)
                writer.fixed64(message.lastUnskippableDocumentRevisionInEntriesIdentifier[i]);
            writer.join();
        }
        /* optional TSP.IndexSet days_with_an_entry = 9; */
        if (message.daysWithAnEntry)
            TSPMessages_8.IndexSet.internalBinaryWrite(message.daysWithAnEntry, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.OperationStorage
 */
exports.OperationStorage = new OperationStorage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OutgoingCommandQueue$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.OutgoingCommandQueue", [
            { no: 1, name: "large_object_array", kind: "message", T: () => TSPMessages_2.LargeObjectArray }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.LargeObjectArray large_object_array */ 1:
                    message.largeObjectArray = TSPMessages_2.LargeObjectArray.internalBinaryRead(reader, reader.uint32(), options, message.largeObjectArray);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.LargeObjectArray large_object_array = 1; */
        if (message.largeObjectArray)
            TSPMessages_2.LargeObjectArray.internalBinaryWrite(message.largeObjectArray, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.OutgoingCommandQueue
 */
exports.OutgoingCommandQueue = new OutgoingCommandQueue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OutgoingCommandQueueSegment$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.OutgoingCommandQueueSegment", [
            { no: 1, name: "large_object_array_segment", kind: "message", T: () => TSPMessages_10.LargeObjectArraySegment }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.LargeObjectArraySegment large_object_array_segment */ 1:
                    message.largeObjectArraySegment = TSPMessages_10.LargeObjectArraySegment.internalBinaryRead(reader, reader.uint32(), options, message.largeObjectArraySegment);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.LargeObjectArraySegment large_object_array_segment = 1; */
        if (message.largeObjectArraySegment)
            TSPMessages_10.LargeObjectArraySegment.internalBinaryWrite(message.largeObjectArraySegment, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.OutgoingCommandQueueSegment
 */
exports.OutgoingCommandQueueSegment = new OutgoingCommandQueueSegment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataReferenceRecord$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.DataReferenceRecord", [
            { no: 1, name: "added_container_uuid_to_referenced_data_pairs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.DataReferenceRecord_ContainerUUIDToReferencedDataPair },
            { no: 2, name: "removed_container_uuid_to_referenced_data_pairs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.DataReferenceRecord_ContainerUUIDToReferencedDataPair },
            { no: 3, name: "unbounded_referenced_datas", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.DataReference }
        ]);
    }
    create(value) {
        const message = { addedContainerUuidToReferencedDataPairs: [], removedContainerUuidToReferencedDataPairs: [], unboundedReferencedDatas: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSK.DataReferenceRecord.ContainerUUIDToReferencedDataPair added_container_uuid_to_referenced_data_pairs */ 1:
                    message.addedContainerUuidToReferencedDataPairs.push(exports.DataReferenceRecord_ContainerUUIDToReferencedDataPair.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSK.DataReferenceRecord.ContainerUUIDToReferencedDataPair removed_container_uuid_to_referenced_data_pairs */ 2:
                    message.removedContainerUuidToReferencedDataPairs.push(exports.DataReferenceRecord_ContainerUUIDToReferencedDataPair.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.DataReference unbounded_referenced_datas */ 3:
                    message.unboundedReferencedDatas.push(TSPMessages_5.DataReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSK.DataReferenceRecord.ContainerUUIDToReferencedDataPair added_container_uuid_to_referenced_data_pairs = 1; */
        for (let i = 0; i < message.addedContainerUuidToReferencedDataPairs.length; i++)
            exports.DataReferenceRecord_ContainerUUIDToReferencedDataPair.internalBinaryWrite(message.addedContainerUuidToReferencedDataPairs[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSK.DataReferenceRecord.ContainerUUIDToReferencedDataPair removed_container_uuid_to_referenced_data_pairs = 2; */
        for (let i = 0; i < message.removedContainerUuidToReferencedDataPairs.length; i++)
            exports.DataReferenceRecord_ContainerUUIDToReferencedDataPair.internalBinaryWrite(message.removedContainerUuidToReferencedDataPairs[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.DataReference unbounded_referenced_datas = 3; */
        for (let i = 0; i < message.unboundedReferencedDatas.length; i++)
            TSPMessages_5.DataReference.internalBinaryWrite(message.unboundedReferencedDatas[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.DataReferenceRecord
 */
exports.DataReferenceRecord = new DataReferenceRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataReferenceRecord_ContainerUUIDToReferencedDataPair$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.DataReferenceRecord.ContainerUUIDToReferencedDataPair", [
            { no: 1, name: "container_uuid", kind: "message", T: () => TSPMessages_9.UUID },
            { no: 2, name: "referenced_data", kind: "message", T: () => TSPMessages_5.DataReference },
            { no: 3, name: "reference_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { referenceCount: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID container_uuid */ 1:
                    message.containerUuid = TSPMessages_9.UUID.internalBinaryRead(reader, reader.uint32(), options, message.containerUuid);
                    break;
                case /* TSP.DataReference referenced_data */ 2:
                    message.referencedData = TSPMessages_5.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.referencedData);
                    break;
                case /* uint32 reference_count */ 3:
                    message.referenceCount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID container_uuid = 1; */
        if (message.containerUuid)
            TSPMessages_9.UUID.internalBinaryWrite(message.containerUuid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.DataReference referenced_data = 2; */
        if (message.referencedData)
            TSPMessages_5.DataReference.internalBinaryWrite(message.referencedData, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 reference_count = 3; */
        if (message.referenceCount !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.referenceCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.DataReferenceRecord.ContainerUUIDToReferencedDataPair
 */
exports.DataReferenceRecord_ContainerUUIDToReferencedDataPair = new DataReferenceRecord_ContainerUUIDToReferencedDataPair$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandAssetChunkArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.CommandAssetChunkArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandArchive },
            { no: 2, name: "digest", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "asset_chunk", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "asset_chunk_length", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "resume_position", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "materialized_length", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value) {
        const message = { assetChunkLength: 0n, resumePosition: 0n, materializedLength: 0n };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = exports.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional string digest */ 2:
                    message.digest = reader.string();
                    break;
                case /* optional string asset_chunk */ 3:
                    message.assetChunk = reader.string();
                    break;
                case /* int64 asset_chunk_length */ 4:
                    message.assetChunkLength = reader.int64().toBigInt();
                    break;
                case /* int64 resume_position */ 5:
                    message.resumePosition = reader.int64().toBigInt();
                    break;
                case /* int64 materialized_length */ 6:
                    message.materializedLength = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            exports.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string digest = 2; */
        if (message.digest !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.digest);
        /* optional string asset_chunk = 3; */
        if (message.assetChunk !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.assetChunk);
        /* int64 asset_chunk_length = 4; */
        if (message.assetChunkLength !== 0n)
            writer.tag(4, runtime_1.WireType.Varint).int64(message.assetChunkLength);
        /* int64 resume_position = 5; */
        if (message.resumePosition !== 0n)
            writer.tag(5, runtime_1.WireType.Varint).int64(message.resumePosition);
        /* int64 materialized_length = 6; */
        if (message.materializedLength !== 0n)
            writer.tag(6, runtime_1.WireType.Varint).int64(message.materializedLength);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.CommandAssetChunkArchive
 */
exports.CommandAssetChunkArchive = new CommandAssetChunkArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AssetUploadStatusCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.AssetUploadStatusCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandArchive },
            { no: 2, name: "info_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.AssetUploadStatusCommandArchive_AssetUploadStatusInfo }
        ]);
    }
    create(value) {
        const message = { infoList: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = exports.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSK.AssetUploadStatusCommandArchive.AssetUploadStatusInfo info_list */ 2:
                    message.infoList.push(exports.AssetUploadStatusCommandArchive_AssetUploadStatusInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            exports.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSK.AssetUploadStatusCommandArchive.AssetUploadStatusInfo info_list = 2; */
        for (let i = 0; i < message.infoList.length; i++)
            exports.AssetUploadStatusCommandArchive_AssetUploadStatusInfo.internalBinaryWrite(message.infoList[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.AssetUploadStatusCommandArchive
 */
exports.AssetUploadStatusCommandArchive = new AssetUploadStatusCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AssetUploadStatusCommandArchive_AssetUploadStatusInfo$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.AssetUploadStatusCommandArchive.AssetUploadStatusInfo", [
            { no: 1, name: "digest", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "upload_status", kind: "enum", opt: true, T: () => ["TSP.DataUploadStatus", TSPMessages_1.DataUploadStatus] }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string digest */ 1:
                    message.digest = reader.string();
                    break;
                case /* optional TSP.DataUploadStatus upload_status */ 2:
                    message.uploadStatus = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string digest = 1; */
        if (message.digest !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.digest);
        /* optional TSP.DataUploadStatus upload_status = 2; */
        if (message.uploadStatus !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.uploadStatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.AssetUploadStatusCommandArchive.AssetUploadStatusInfo
 */
exports.AssetUploadStatusCommandArchive_AssetUploadStatusInfo = new AssetUploadStatusCommandArchive_AssetUploadStatusInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AssetUnmaterializedOnServerCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.AssetUnmaterializedOnServerCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandArchive },
            { no: 2, name: "digest_list", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { digestList: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = exports.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated string digest_list */ 2:
                    message.digestList.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            exports.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated string digest_list = 2; */
        for (let i = 0; i < message.digestList.length; i++)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.digestList[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.AssetUnmaterializedOnServerCommandArchive
 */
exports.AssetUnmaterializedOnServerCommandArchive = new AssetUnmaterializedOnServerCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PencilAnnotationUIState$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.PencilAnnotationUIState", [
            { no: 1, name: "current_tool_type", kind: "enum", opt: true, T: () => ["TSK.PencilAnnotationUIState.PencilAnnotationToolType", PencilAnnotationUIState_PencilAnnotationToolType] },
            { no: 2, name: "pen_tool_color", kind: "message", T: () => TSPMessages_7.Color },
            { no: 3, name: "pen_tool_opacity", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "pen_tool_width", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "highlighter_tool_color", kind: "message", T: () => TSPMessages_7.Color },
            { no: 6, name: "highlighter_tool_opacity", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "highlighter_tool_width", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSK.PencilAnnotationUIState.PencilAnnotationToolType current_tool_type */ 1:
                    message.currentToolType = reader.int32();
                    break;
                case /* optional TSP.Color pen_tool_color */ 2:
                    message.penToolColor = TSPMessages_7.Color.internalBinaryRead(reader, reader.uint32(), options, message.penToolColor);
                    break;
                case /* optional float pen_tool_opacity */ 3:
                    message.penToolOpacity = reader.float();
                    break;
                case /* optional float pen_tool_width */ 4:
                    message.penToolWidth = reader.float();
                    break;
                case /* optional TSP.Color highlighter_tool_color */ 5:
                    message.highlighterToolColor = TSPMessages_7.Color.internalBinaryRead(reader, reader.uint32(), options, message.highlighterToolColor);
                    break;
                case /* optional float highlighter_tool_opacity */ 6:
                    message.highlighterToolOpacity = reader.float();
                    break;
                case /* optional float highlighter_tool_width */ 7:
                    message.highlighterToolWidth = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSK.PencilAnnotationUIState.PencilAnnotationToolType current_tool_type = 1; */
        if (message.currentToolType !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.currentToolType);
        /* optional TSP.Color pen_tool_color = 2; */
        if (message.penToolColor)
            TSPMessages_7.Color.internalBinaryWrite(message.penToolColor, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional float pen_tool_opacity = 3; */
        if (message.penToolOpacity !== undefined)
            writer.tag(3, runtime_1.WireType.Bit32).float(message.penToolOpacity);
        /* optional float pen_tool_width = 4; */
        if (message.penToolWidth !== undefined)
            writer.tag(4, runtime_1.WireType.Bit32).float(message.penToolWidth);
        /* optional TSP.Color highlighter_tool_color = 5; */
        if (message.highlighterToolColor)
            TSPMessages_7.Color.internalBinaryWrite(message.highlighterToolColor, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional float highlighter_tool_opacity = 6; */
        if (message.highlighterToolOpacity !== undefined)
            writer.tag(6, runtime_1.WireType.Bit32).float(message.highlighterToolOpacity);
        /* optional float highlighter_tool_width = 7; */
        if (message.highlighterToolWidth !== undefined)
            writer.tag(7, runtime_1.WireType.Bit32).float(message.highlighterToolWidth);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.PencilAnnotationUIState
 */
exports.PencilAnnotationUIState = new PencilAnnotationUIState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CollaboratorCursorArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.CollaboratorCursorArchive", [
            { no: 1, name: "id_path", kind: "message", T: () => TSPMessages_6.UUIDPath }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.UUIDPath id_path */ 1:
                    message.idPath = TSPMessages_6.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.idPath);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.UUIDPath id_path = 1; */
        if (message.idPath)
            TSPMessages_6.UUIDPath.internalBinaryWrite(message.idPath, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.CollaboratorCursorArchive
 */
exports.CollaboratorCursorArchive = new CollaboratorCursorArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityStreamArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.ActivityStreamArchive", [
            { no: 1, name: "acknowledged_activity_array", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 2, name: "unacknowledged_local_activity_array", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 3, name: "author_cache", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 5, name: "unacknowledged_remote_activity_array", kind: "message", T: () => TSPMessages_12.Reference },
            { no: 6, name: "did_upgrade_comments_to_activities", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "activity_stream_transformation_state", kind: "message", T: () => exports.ActivityStreamTransformationStateArchive },
            { no: 16, name: "activity_counter", kind: "message", T: () => exports.ActivityStreamActivityCounterArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference acknowledged_activity_array */ 1:
                    message.acknowledgedActivityArray = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.acknowledgedActivityArray);
                    break;
                case /* optional TSP.Reference unacknowledged_local_activity_array */ 2:
                    message.unacknowledgedLocalActivityArray = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.unacknowledgedLocalActivityArray);
                    break;
                case /* optional TSP.Reference author_cache */ 3:
                    message.authorCache = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.authorCache);
                    break;
                case /* optional TSP.Reference unacknowledged_remote_activity_array */ 5:
                    message.unacknowledgedRemoteActivityArray = TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options, message.unacknowledgedRemoteActivityArray);
                    break;
                case /* optional bool did_upgrade_comments_to_activities */ 6:
                    message.didUpgradeCommentsToActivities = reader.bool();
                    break;
                case /* optional TSK.ActivityStreamTransformationStateArchive activity_stream_transformation_state */ 15:
                    message.activityStreamTransformationState = exports.ActivityStreamTransformationStateArchive.internalBinaryRead(reader, reader.uint32(), options, message.activityStreamTransformationState);
                    break;
                case /* optional TSK.ActivityStreamActivityCounterArchive activity_counter */ 16:
                    message.activityCounter = exports.ActivityStreamActivityCounterArchive.internalBinaryRead(reader, reader.uint32(), options, message.activityCounter);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference acknowledged_activity_array = 1; */
        if (message.acknowledgedActivityArray)
            TSPMessages_12.Reference.internalBinaryWrite(message.acknowledgedActivityArray, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference unacknowledged_local_activity_array = 2; */
        if (message.unacknowledgedLocalActivityArray)
            TSPMessages_12.Reference.internalBinaryWrite(message.unacknowledgedLocalActivityArray, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference author_cache = 3; */
        if (message.authorCache)
            TSPMessages_12.Reference.internalBinaryWrite(message.authorCache, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference unacknowledged_remote_activity_array = 5; */
        if (message.unacknowledgedRemoteActivityArray)
            TSPMessages_12.Reference.internalBinaryWrite(message.unacknowledgedRemoteActivityArray, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool did_upgrade_comments_to_activities = 6; */
        if (message.didUpgradeCommentsToActivities !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.didUpgradeCommentsToActivities);
        /* optional TSK.ActivityStreamTransformationStateArchive activity_stream_transformation_state = 15; */
        if (message.activityStreamTransformationState)
            exports.ActivityStreamTransformationStateArchive.internalBinaryWrite(message.activityStreamTransformationState, writer.tag(15, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.ActivityStreamActivityCounterArchive activity_counter = 16; */
        if (message.activityCounter)
            exports.ActivityStreamActivityCounterArchive.internalBinaryWrite(message.activityCounter, writer.tag(16, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.ActivityStreamArchive
 */
exports.ActivityStreamArchive = new ActivityStreamArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityStreamActivityArray$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.ActivityStreamActivityArray", [
            { no: 1, name: "large_array", kind: "message", T: () => TSPMessages_2.LargeObjectArray }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.LargeObjectArray large_array */ 1:
                    message.largeArray = TSPMessages_2.LargeObjectArray.internalBinaryRead(reader, reader.uint32(), options, message.largeArray);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.LargeObjectArray large_array = 1; */
        if (message.largeArray)
            TSPMessages_2.LargeObjectArray.internalBinaryWrite(message.largeArray, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.ActivityStreamActivityArray
 */
exports.ActivityStreamActivityArray = new ActivityStreamActivityArray$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityStreamActivityArraySegment$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.ActivityStreamActivityArraySegment", [
            { no: 1, name: "large_array_segment", kind: "message", T: () => TSPMessages_10.LargeObjectArraySegment }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.LargeObjectArraySegment large_array_segment */ 1:
                    message.largeArraySegment = TSPMessages_10.LargeObjectArraySegment.internalBinaryRead(reader, reader.uint32(), options, message.largeArraySegment);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.LargeObjectArraySegment large_array_segment = 1; */
        if (message.largeArraySegment)
            TSPMessages_10.LargeObjectArraySegment.internalBinaryWrite(message.largeArraySegment, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.ActivityStreamActivityArraySegment
 */
exports.ActivityStreamActivityArraySegment = new ActivityStreamActivityArraySegment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.ActivityArchive", [
            { no: 1, name: "cursor_collection_persistence_wrappers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_12.Reference },
            { no: 2, name: "author_identifier", kind: "message", T: () => TSPMessages_9.UUID },
            { no: 3, name: "nondirectional_action_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "direction", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "should_send_notification", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "timestamp", kind: "message", T: () => TSPMessages_4.Date },
            { no: 7, name: "revision_sequence", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "additional_navigation_info", kind: "message", T: () => exports.ActivityNavigationInfoArchive },
            { no: 9, name: "did_prepare_serialized_string_on_server", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "oldest_revision_sequence_of_next_activities", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "action_sub_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "min_updatable_version", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { cursorCollectionPersistenceWrappers: [], minUpdatableVersion: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.Reference cursor_collection_persistence_wrappers */ 1:
                    message.cursorCollectionPersistenceWrappers.push(TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.UUID author_identifier */ 2:
                    message.authorIdentifier = TSPMessages_9.UUID.internalBinaryRead(reader, reader.uint32(), options, message.authorIdentifier);
                    break;
                case /* optional int32 nondirectional_action_type */ 3:
                    message.nondirectionalActionType = reader.int32();
                    break;
                case /* optional int32 direction */ 4:
                    message.direction = reader.int32();
                    break;
                case /* optional bool should_send_notification */ 5:
                    message.shouldSendNotification = reader.bool();
                    break;
                case /* optional TSP.Date timestamp */ 6:
                    message.timestamp = TSPMessages_4.Date.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);
                    break;
                case /* optional int32 revision_sequence */ 7:
                    message.revisionSequence = reader.int32();
                    break;
                case /* optional TSK.ActivityNavigationInfoArchive additional_navigation_info */ 8:
                    message.additionalNavigationInfo = exports.ActivityNavigationInfoArchive.internalBinaryRead(reader, reader.uint32(), options, message.additionalNavigationInfo);
                    break;
                case /* optional bool did_prepare_serialized_string_on_server */ 9:
                    message.didPrepareSerializedStringOnServer = reader.bool();
                    break;
                case /* optional int32 oldest_revision_sequence_of_next_activities */ 10:
                    message.oldestRevisionSequenceOfNextActivities = reader.int32();
                    break;
                case /* optional int32 action_sub_type */ 11:
                    message.actionSubType = reader.int32();
                    break;
                case /* repeated uint32 min_updatable_version = 12 [packed = true];*/ 12:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.minUpdatableVersion.push(reader.uint32());
                    else
                        message.minUpdatableVersion.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.Reference cursor_collection_persistence_wrappers = 1; */
        for (let i = 0; i < message.cursorCollectionPersistenceWrappers.length; i++)
            TSPMessages_12.Reference.internalBinaryWrite(message.cursorCollectionPersistenceWrappers[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID author_identifier = 2; */
        if (message.authorIdentifier)
            TSPMessages_9.UUID.internalBinaryWrite(message.authorIdentifier, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional int32 nondirectional_action_type = 3; */
        if (message.nondirectionalActionType !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.nondirectionalActionType);
        /* optional int32 direction = 4; */
        if (message.direction !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).int32(message.direction);
        /* optional bool should_send_notification = 5; */
        if (message.shouldSendNotification !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.shouldSendNotification);
        /* optional TSP.Date timestamp = 6; */
        if (message.timestamp)
            TSPMessages_4.Date.internalBinaryWrite(message.timestamp, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional int32 revision_sequence = 7; */
        if (message.revisionSequence !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).int32(message.revisionSequence);
        /* optional TSK.ActivityNavigationInfoArchive additional_navigation_info = 8; */
        if (message.additionalNavigationInfo)
            exports.ActivityNavigationInfoArchive.internalBinaryWrite(message.additionalNavigationInfo, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool did_prepare_serialized_string_on_server = 9; */
        if (message.didPrepareSerializedStringOnServer !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).bool(message.didPrepareSerializedStringOnServer);
        /* optional int32 oldest_revision_sequence_of_next_activities = 10; */
        if (message.oldestRevisionSequenceOfNextActivities !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).int32(message.oldestRevisionSequenceOfNextActivities);
        /* optional int32 action_sub_type = 11; */
        if (message.actionSubType !== undefined)
            writer.tag(11, runtime_1.WireType.Varint).int32(message.actionSubType);
        /* repeated uint32 min_updatable_version = 12 [packed = true]; */
        if (message.minUpdatableVersion.length) {
            writer.tag(12, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.minUpdatableVersion.length; i++)
                writer.uint32(message.minUpdatableVersion[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.ActivityArchive
 */
exports.ActivityArchive = new ActivityArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityAuthorArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.ActivityAuthorArchive", [
            { no: 1, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "color", kind: "message", T: () => TSPMessages_7.Color },
            { no: 3, name: "public_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "is_public_author", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "share_participant_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { publicIds: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional TSP.Color color */ 2:
                    message.color = TSPMessages_7.Color.internalBinaryRead(reader, reader.uint32(), options, message.color);
                    break;
                case /* repeated string public_ids */ 3:
                    message.publicIds.push(reader.string());
                    break;
                case /* optional bool is_public_author */ 4:
                    message.isPublicAuthor = reader.bool();
                    break;
                case /* optional string share_participant_id */ 5:
                    message.shareParticipantId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string name = 1; */
        if (message.name !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* optional TSP.Color color = 2; */
        if (message.color)
            TSPMessages_7.Color.internalBinaryWrite(message.color, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated string public_ids = 3; */
        for (let i = 0; i < message.publicIds.length; i++)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.publicIds[i]);
        /* optional bool is_public_author = 4; */
        if (message.isPublicAuthor !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.isPublicAuthor);
        /* optional string share_participant_id = 5; */
        if (message.shareParticipantId !== undefined)
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.shareParticipantId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.ActivityAuthorArchive
 */
exports.ActivityAuthorArchive = new ActivityAuthorArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandActivityBehaviorArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.CommandActivityBehaviorArchive", [
            { no: 1, name: "selection_path_storages", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_12.Reference },
            { no: 2, name: "action_type", kind: "enum", opt: true, T: () => ["TSK.CommandActivityBehaviorArchive.ActionType", CommandActivityBehaviorArchive_ActionType] },
            { no: 3, name: "should_send_notification", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "additional_navigation_info", kind: "message", T: () => exports.ActivityNavigationInfoArchive },
            { no: 5, name: "action_sub_type", kind: "enum", opt: true, T: () => ["TSK.CommandActivityBehaviorArchive.ActionSubType", CommandActivityBehaviorArchive_ActionSubType] }
        ]);
    }
    create(value) {
        const message = { selectionPathStorages: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.Reference selection_path_storages */ 1:
                    message.selectionPathStorages.push(TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSK.CommandActivityBehaviorArchive.ActionType action_type */ 2:
                    message.actionType = reader.int32();
                    break;
                case /* optional bool should_send_notification */ 3:
                    message.shouldSendNotification = reader.bool();
                    break;
                case /* optional TSK.ActivityNavigationInfoArchive additional_navigation_info */ 4:
                    message.additionalNavigationInfo = exports.ActivityNavigationInfoArchive.internalBinaryRead(reader, reader.uint32(), options, message.additionalNavigationInfo);
                    break;
                case /* optional TSK.CommandActivityBehaviorArchive.ActionSubType action_sub_type */ 5:
                    message.actionSubType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.Reference selection_path_storages = 1; */
        for (let i = 0; i < message.selectionPathStorages.length; i++)
            TSPMessages_12.Reference.internalBinaryWrite(message.selectionPathStorages[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.CommandActivityBehaviorArchive.ActionType action_type = 2; */
        if (message.actionType !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.actionType);
        /* optional bool should_send_notification = 3; */
        if (message.shouldSendNotification !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.shouldSendNotification);
        /* optional TSK.ActivityNavigationInfoArchive additional_navigation_info = 4; */
        if (message.additionalNavigationInfo)
            exports.ActivityNavigationInfoArchive.internalBinaryWrite(message.additionalNavigationInfo, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.CommandActivityBehaviorArchive.ActionSubType action_sub_type = 5; */
        if (message.actionSubType !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).int32(message.actionSubType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.CommandActivityBehaviorArchive
 */
exports.CommandActivityBehaviorArchive = new CommandActivityBehaviorArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityCursorCollectionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.ActivityCursorCollectionArchive", [
            { no: 1, name: "id_cursors", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CollaboratorCursorArchive },
            { no: 2, name: "text_cursor", kind: "message", T: () => exports.CollaboratorCursorArchive },
            { no: 3, name: "table_cursor", kind: "message", T: () => exports.CollaboratorCursorArchive },
            { no: 4, name: "cde_cursor", kind: "message", T: () => exports.CollaboratorCursorArchive },
            { no: 5, name: "chart_title_cursor", kind: "message", T: () => exports.CollaboratorCursorArchive },
            { no: 6, name: "gallery_item_cursor", kind: "message", T: () => exports.CollaboratorCursorArchive }
        ]);
    }
    create(value) {
        const message = { idCursors: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSK.CollaboratorCursorArchive id_cursors */ 1:
                    message.idCursors.push(exports.CollaboratorCursorArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSK.CollaboratorCursorArchive text_cursor */ 2:
                    message.textCursor = exports.CollaboratorCursorArchive.internalBinaryRead(reader, reader.uint32(), options, message.textCursor);
                    break;
                case /* optional TSK.CollaboratorCursorArchive table_cursor */ 3:
                    message.tableCursor = exports.CollaboratorCursorArchive.internalBinaryRead(reader, reader.uint32(), options, message.tableCursor);
                    break;
                case /* optional TSK.CollaboratorCursorArchive cde_cursor */ 4:
                    message.cdeCursor = exports.CollaboratorCursorArchive.internalBinaryRead(reader, reader.uint32(), options, message.cdeCursor);
                    break;
                case /* optional TSK.CollaboratorCursorArchive chart_title_cursor */ 5:
                    message.chartTitleCursor = exports.CollaboratorCursorArchive.internalBinaryRead(reader, reader.uint32(), options, message.chartTitleCursor);
                    break;
                case /* optional TSK.CollaboratorCursorArchive gallery_item_cursor */ 6:
                    message.galleryItemCursor = exports.CollaboratorCursorArchive.internalBinaryRead(reader, reader.uint32(), options, message.galleryItemCursor);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSK.CollaboratorCursorArchive id_cursors = 1; */
        for (let i = 0; i < message.idCursors.length; i++)
            exports.CollaboratorCursorArchive.internalBinaryWrite(message.idCursors[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.CollaboratorCursorArchive text_cursor = 2; */
        if (message.textCursor)
            exports.CollaboratorCursorArchive.internalBinaryWrite(message.textCursor, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.CollaboratorCursorArchive table_cursor = 3; */
        if (message.tableCursor)
            exports.CollaboratorCursorArchive.internalBinaryWrite(message.tableCursor, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.CollaboratorCursorArchive cde_cursor = 4; */
        if (message.cdeCursor)
            exports.CollaboratorCursorArchive.internalBinaryWrite(message.cdeCursor, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.CollaboratorCursorArchive chart_title_cursor = 5; */
        if (message.chartTitleCursor)
            exports.CollaboratorCursorArchive.internalBinaryWrite(message.chartTitleCursor, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.CollaboratorCursorArchive gallery_item_cursor = 6; */
        if (message.galleryItemCursor)
            exports.CollaboratorCursorArchive.internalBinaryWrite(message.galleryItemCursor, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.ActivityCursorCollectionArchive
 */
exports.ActivityCursorCollectionArchive = new ActivityCursorCollectionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityCursorCollectionPersistenceWrapperArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.ActivityCursorCollectionPersistenceWrapperArchive", [
            { no: 1, name: "activity_cursor_collection", kind: "message", T: () => exports.ActivityCursorCollectionArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSK.ActivityCursorCollectionArchive activity_cursor_collection */ 1:
                    message.activityCursorCollection = exports.ActivityCursorCollectionArchive.internalBinaryRead(reader, reader.uint32(), options, message.activityCursorCollection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSK.ActivityCursorCollectionArchive activity_cursor_collection = 1; */
        if (message.activityCursorCollection)
            exports.ActivityCursorCollectionArchive.internalBinaryWrite(message.activityCursorCollection, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.ActivityCursorCollectionPersistenceWrapperArchive
 */
exports.ActivityCursorCollectionPersistenceWrapperArchive = new ActivityCursorCollectionPersistenceWrapperArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityNavigationInfoArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.ActivityNavigationInfoArchive", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.ActivityNavigationInfoArchive
 */
exports.ActivityNavigationInfoArchive = new ActivityNavigationInfoArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommentActivityNavigationInfoArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.CommentActivityNavigationInfoArchive", [
            { no: 1, name: "comment_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "parent_uuid", kind: "message", T: () => TSPMessages_9.UUID },
            { no: 3, name: "storage_uuid", kind: "message", T: () => TSPMessages_9.UUID }
        ]);
    }
    create(value) {
        const message = { commentId: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string comment_id */ 1:
                    message.commentId = reader.string();
                    break;
                case /* TSP.UUID parent_uuid */ 2:
                    message.parentUuid = TSPMessages_9.UUID.internalBinaryRead(reader, reader.uint32(), options, message.parentUuid);
                    break;
                case /* TSP.UUID storage_uuid */ 3:
                    message.storageUuid = TSPMessages_9.UUID.internalBinaryRead(reader, reader.uint32(), options, message.storageUuid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string comment_id = 1; */
        if (message.commentId !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.commentId);
        /* TSP.UUID parent_uuid = 2; */
        if (message.parentUuid)
            TSPMessages_9.UUID.internalBinaryWrite(message.parentUuid, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID storage_uuid = 3; */
        if (message.storageUuid)
            TSPMessages_9.UUID.internalBinaryWrite(message.storageUuid, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.CommentActivityNavigationInfoArchive
 */
exports.CommentActivityNavigationInfoArchive = new CommentActivityNavigationInfoArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityAuthorCacheArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.ActivityAuthorCacheArchive", [
            { no: 1, name: "share_participant_id_cache", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ActivityAuthorCacheArchive_ShareParticipantIDCache },
            { no: 3, name: "fallback_public_id_cache", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ActivityAuthorCacheArchive_PublicIDCache },
            { no: 4, name: "index_cache", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ActivityAuthorCacheArchive_IndexCache },
            { no: 5, name: "first_join_cache", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ActivityAuthorCacheArchive_FirstJoinCache },
            { no: 6, name: "authors", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_12.Reference },
            { no: 7, name: "last_audit_date", kind: "message", T: () => TSPMessages_4.Date },
            { no: 8, name: "author_identifiers_to_remove", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_9.UUID }
        ]);
    }
    create(value) {
        const message = { shareParticipantIdCache: [], fallbackPublicIdCache: [], indexCache: [], firstJoinCache: [], authors: [], authorIdentifiersToRemove: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSK.ActivityAuthorCacheArchive.ShareParticipantIDCache share_participant_id_cache */ 1:
                    message.shareParticipantIdCache.push(exports.ActivityAuthorCacheArchive_ShareParticipantIDCache.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSK.ActivityAuthorCacheArchive.PublicIDCache fallback_public_id_cache */ 3:
                    message.fallbackPublicIdCache.push(exports.ActivityAuthorCacheArchive_PublicIDCache.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSK.ActivityAuthorCacheArchive.IndexCache index_cache */ 4:
                    message.indexCache.push(exports.ActivityAuthorCacheArchive_IndexCache.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSK.ActivityAuthorCacheArchive.FirstJoinCache first_join_cache */ 5:
                    message.firstJoinCache.push(exports.ActivityAuthorCacheArchive_FirstJoinCache.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference authors */ 6:
                    message.authors.push(TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Date last_audit_date */ 7:
                    message.lastAuditDate = TSPMessages_4.Date.internalBinaryRead(reader, reader.uint32(), options, message.lastAuditDate);
                    break;
                case /* repeated TSP.UUID author_identifiers_to_remove */ 8:
                    message.authorIdentifiersToRemove.push(TSPMessages_9.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSK.ActivityAuthorCacheArchive.ShareParticipantIDCache share_participant_id_cache = 1; */
        for (let i = 0; i < message.shareParticipantIdCache.length; i++)
            exports.ActivityAuthorCacheArchive_ShareParticipantIDCache.internalBinaryWrite(message.shareParticipantIdCache[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSK.ActivityAuthorCacheArchive.PublicIDCache fallback_public_id_cache = 3; */
        for (let i = 0; i < message.fallbackPublicIdCache.length; i++)
            exports.ActivityAuthorCacheArchive_PublicIDCache.internalBinaryWrite(message.fallbackPublicIdCache[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSK.ActivityAuthorCacheArchive.IndexCache index_cache = 4; */
        for (let i = 0; i < message.indexCache.length; i++)
            exports.ActivityAuthorCacheArchive_IndexCache.internalBinaryWrite(message.indexCache[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSK.ActivityAuthorCacheArchive.FirstJoinCache first_join_cache = 5; */
        for (let i = 0; i < message.firstJoinCache.length; i++)
            exports.ActivityAuthorCacheArchive_FirstJoinCache.internalBinaryWrite(message.firstJoinCache[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference authors = 6; */
        for (let i = 0; i < message.authors.length; i++)
            TSPMessages_12.Reference.internalBinaryWrite(message.authors[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Date last_audit_date = 7; */
        if (message.lastAuditDate)
            TSPMessages_4.Date.internalBinaryWrite(message.lastAuditDate, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID author_identifiers_to_remove = 8; */
        for (let i = 0; i < message.authorIdentifiersToRemove.length; i++)
            TSPMessages_9.UUID.internalBinaryWrite(message.authorIdentifiersToRemove[i], writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.ActivityAuthorCacheArchive
 */
exports.ActivityAuthorCacheArchive = new ActivityAuthorCacheArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityAuthorCacheArchive_ShareParticipantIDCache$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.ActivityAuthorCacheArchive.ShareParticipantIDCache", [
            { no: 1, name: "identifier", kind: "message", T: () => TSPMessages_9.UUID },
            { no: 2, name: "share_participant_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { shareParticipantId: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID identifier */ 1:
                    message.identifier = TSPMessages_9.UUID.internalBinaryRead(reader, reader.uint32(), options, message.identifier);
                    break;
                case /* string share_participant_id */ 2:
                    message.shareParticipantId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID identifier = 1; */
        if (message.identifier)
            TSPMessages_9.UUID.internalBinaryWrite(message.identifier, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string share_participant_id = 2; */
        if (message.shareParticipantId !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.shareParticipantId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.ActivityAuthorCacheArchive.ShareParticipantIDCache
 */
exports.ActivityAuthorCacheArchive_ShareParticipantIDCache = new ActivityAuthorCacheArchive_ShareParticipantIDCache$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityAuthorCacheArchive_PublicIDCache$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.ActivityAuthorCacheArchive.PublicIDCache", [
            { no: 1, name: "identifier", kind: "message", T: () => TSPMessages_9.UUID },
            { no: 2, name: "public_identifier", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { publicIdentifier: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID identifier */ 1:
                    message.identifier = TSPMessages_9.UUID.internalBinaryRead(reader, reader.uint32(), options, message.identifier);
                    break;
                case /* string public_identifier */ 2:
                    message.publicIdentifier = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID identifier = 1; */
        if (message.identifier)
            TSPMessages_9.UUID.internalBinaryWrite(message.identifier, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string public_identifier = 2; */
        if (message.publicIdentifier !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.publicIdentifier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.ActivityAuthorCacheArchive.PublicIDCache
 */
exports.ActivityAuthorCacheArchive_PublicIDCache = new ActivityAuthorCacheArchive_PublicIDCache$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityAuthorCacheArchive_IndexCache$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.ActivityAuthorCacheArchive.IndexCache", [
            { no: 1, name: "identifier", kind: "message", T: () => TSPMessages_9.UUID },
            { no: 2, name: "author_index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value) {
        const message = { authorIndex: 0n };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID identifier */ 1:
                    message.identifier = TSPMessages_9.UUID.internalBinaryRead(reader, reader.uint32(), options, message.identifier);
                    break;
                case /* uint64 author_index */ 2:
                    message.authorIndex = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID identifier = 1; */
        if (message.identifier)
            TSPMessages_9.UUID.internalBinaryWrite(message.identifier, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint64 author_index = 2; */
        if (message.authorIndex !== 0n)
            writer.tag(2, runtime_1.WireType.Varint).uint64(message.authorIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.ActivityAuthorCacheArchive.IndexCache
 */
exports.ActivityAuthorCacheArchive_IndexCache = new ActivityAuthorCacheArchive_IndexCache$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityAuthorCacheArchive_FirstJoinCache$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.ActivityAuthorCacheArchive.FirstJoinCache", [
            { no: 1, name: "identifier", kind: "message", T: () => TSPMessages_9.UUID },
            { no: 2, name: "first_join_date", kind: "message", T: () => TSPMessages_4.Date }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID identifier */ 1:
                    message.identifier = TSPMessages_9.UUID.internalBinaryRead(reader, reader.uint32(), options, message.identifier);
                    break;
                case /* optional TSP.Date first_join_date */ 2:
                    message.firstJoinDate = TSPMessages_4.Date.internalBinaryRead(reader, reader.uint32(), options, message.firstJoinDate);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID identifier = 1; */
        if (message.identifier)
            TSPMessages_9.UUID.internalBinaryWrite(message.identifier, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Date first_join_date = 2; */
        if (message.firstJoinDate)
            TSPMessages_4.Date.internalBinaryWrite(message.firstJoinDate, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.ActivityAuthorCacheArchive.FirstJoinCache
 */
exports.ActivityAuthorCacheArchive_FirstJoinCache = new ActivityAuthorCacheArchive_FirstJoinCache$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityOnlyCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.ActivityOnlyCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = exports.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            exports.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.ActivityOnlyCommandArchive
 */
exports.ActivityOnlyCommandArchive = new ActivityOnlyCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityNotificationItemArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.ActivityNotificationItemArchive", [
            { no: 1, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "unique_identifier", kind: "message", T: () => TSPMessages_9.UUID },
            { no: 3, name: "activities", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_12.Reference },
            { no: 4, name: "first_timestamp", kind: "message", T: () => TSPMessages_4.Date }
        ]);
    }
    create(value) {
        const message = { type: 0, activities: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 type */ 1:
                    message.type = reader.int32();
                    break;
                case /* TSP.UUID unique_identifier */ 2:
                    message.uniqueIdentifier = TSPMessages_9.UUID.internalBinaryRead(reader, reader.uint32(), options, message.uniqueIdentifier);
                    break;
                case /* repeated TSP.Reference activities */ 3:
                    message.activities.push(TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Date first_timestamp */ 4:
                    message.firstTimestamp = TSPMessages_4.Date.internalBinaryRead(reader, reader.uint32(), options, message.firstTimestamp);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int32 type = 1; */
        if (message.type !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.type);
        /* TSP.UUID unique_identifier = 2; */
        if (message.uniqueIdentifier)
            TSPMessages_9.UUID.internalBinaryWrite(message.uniqueIdentifier, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference activities = 3; */
        for (let i = 0; i < message.activities.length; i++)
            TSPMessages_12.Reference.internalBinaryWrite(message.activities[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Date first_timestamp = 4; */
        if (message.firstTimestamp)
            TSPMessages_4.Date.internalBinaryWrite(message.firstTimestamp, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.ActivityNotificationItemArchive
 */
exports.ActivityNotificationItemArchive = new ActivityNotificationItemArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityNotificationParticipantCacheArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.ActivityNotificationParticipantCacheArchive", [
            { no: 1, name: "notification_items", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_12.Reference },
            { no: 2, name: "last_edit_notification_item_sent_date", kind: "message", T: () => TSPMessages_4.Date },
            { no: 3, name: "sender_failed_to_enqueue_attempts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ActivityNotificationParticipantCacheArchive_UniqueIdentifierAndAttempts },
            { no: 4, name: "private_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "last_comment_notification_item_sent_date", kind: "message", T: () => TSPMessages_4.Date }
        ]);
    }
    create(value) {
        const message = { notificationItems: [], senderFailedToEnqueueAttempts: [], privateId: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.Reference notification_items */ 1:
                    message.notificationItems.push(TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Date last_edit_notification_item_sent_date */ 2:
                    message.lastEditNotificationItemSentDate = TSPMessages_4.Date.internalBinaryRead(reader, reader.uint32(), options, message.lastEditNotificationItemSentDate);
                    break;
                case /* repeated TSK.ActivityNotificationParticipantCacheArchive.UniqueIdentifierAndAttempts sender_failed_to_enqueue_attempts */ 3:
                    message.senderFailedToEnqueueAttempts.push(exports.ActivityNotificationParticipantCacheArchive_UniqueIdentifierAndAttempts.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string private_id */ 4:
                    message.privateId = reader.string();
                    break;
                case /* optional TSP.Date last_comment_notification_item_sent_date */ 5:
                    message.lastCommentNotificationItemSentDate = TSPMessages_4.Date.internalBinaryRead(reader, reader.uint32(), options, message.lastCommentNotificationItemSentDate);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.Reference notification_items = 1; */
        for (let i = 0; i < message.notificationItems.length; i++)
            TSPMessages_12.Reference.internalBinaryWrite(message.notificationItems[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Date last_edit_notification_item_sent_date = 2; */
        if (message.lastEditNotificationItemSentDate)
            TSPMessages_4.Date.internalBinaryWrite(message.lastEditNotificationItemSentDate, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSK.ActivityNotificationParticipantCacheArchive.UniqueIdentifierAndAttempts sender_failed_to_enqueue_attempts = 3; */
        for (let i = 0; i < message.senderFailedToEnqueueAttempts.length; i++)
            exports.ActivityNotificationParticipantCacheArchive_UniqueIdentifierAndAttempts.internalBinaryWrite(message.senderFailedToEnqueueAttempts[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string private_id = 4; */
        if (message.privateId !== "")
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.privateId);
        /* optional TSP.Date last_comment_notification_item_sent_date = 5; */
        if (message.lastCommentNotificationItemSentDate)
            TSPMessages_4.Date.internalBinaryWrite(message.lastCommentNotificationItemSentDate, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.ActivityNotificationParticipantCacheArchive
 */
exports.ActivityNotificationParticipantCacheArchive = new ActivityNotificationParticipantCacheArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityNotificationParticipantCacheArchive_UniqueIdentifierAndAttempts$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.ActivityNotificationParticipantCacheArchive.UniqueIdentifierAndAttempts", [
            { no: 1, name: "unique_identifier", kind: "message", T: () => TSPMessages_9.UUID },
            { no: 2, name: "attempts", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { attempts: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID unique_identifier */ 1:
                    message.uniqueIdentifier = TSPMessages_9.UUID.internalBinaryRead(reader, reader.uint32(), options, message.uniqueIdentifier);
                    break;
                case /* uint32 attempts */ 2:
                    message.attempts = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID unique_identifier = 1; */
        if (message.uniqueIdentifier)
            TSPMessages_9.UUID.internalBinaryWrite(message.uniqueIdentifier, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 attempts = 2; */
        if (message.attempts !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.attempts);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.ActivityNotificationParticipantCacheArchive.UniqueIdentifierAndAttempts
 */
exports.ActivityNotificationParticipantCacheArchive_UniqueIdentifierAndAttempts = new ActivityNotificationParticipantCacheArchive_UniqueIdentifierAndAttempts$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityNotificationQueueArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.ActivityNotificationQueueArchive", [
            { no: 1, name: "unprocessed_notification_items", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_12.Reference },
            { no: 3, name: "pending_participant_caches", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_12.Reference },
            { no: 5, name: "sent_participant_caches", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_12.Reference }
        ]);
    }
    create(value) {
        const message = { unprocessedNotificationItems: [], pendingParticipantCaches: [], sentParticipantCaches: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.Reference unprocessed_notification_items */ 1:
                    message.unprocessedNotificationItems.push(TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference pending_participant_caches */ 3:
                    message.pendingParticipantCaches.push(TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference sent_participant_caches */ 5:
                    message.sentParticipantCaches.push(TSPMessages_12.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.Reference unprocessed_notification_items = 1; */
        for (let i = 0; i < message.unprocessedNotificationItems.length; i++)
            TSPMessages_12.Reference.internalBinaryWrite(message.unprocessedNotificationItems[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference pending_participant_caches = 3; */
        for (let i = 0; i < message.pendingParticipantCaches.length; i++)
            TSPMessages_12.Reference.internalBinaryWrite(message.pendingParticipantCaches[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference sent_participant_caches = 5; */
        for (let i = 0; i < message.sentParticipantCaches.length; i++)
            TSPMessages_12.Reference.internalBinaryWrite(message.sentParticipantCaches[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.ActivityNotificationQueueArchive
 */
exports.ActivityNotificationQueueArchive = new ActivityNotificationQueueArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityStreamTransformationStateArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.ActivityStreamTransformationStateArchive", [
            { no: 1, name: "next_activity_to_transform_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "oldest_revision_sequence_after_transformed", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "last_activity_coalesced_date", kind: "message", T: () => TSPMessages_4.Date },
            { no: 4, name: "action_type", kind: "enum", opt: true, T: () => ["TSK.ActivityStreamTransformationStateArchive.ActionType", ActivityStreamTransformationStateArchive_ActionType] },
            { no: 5, name: "transform_to_document_revision_sequence", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "transform_to_document_revision_identifier", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "timestamp_of_last_activity_when_last_activity_coalescing", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 8, name: "preserving_revision_sequence_order", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { nextActivityToTransformIndex: 0, transformToDocumentRevisionIdentifier: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 next_activity_to_transform_index */ 1:
                    message.nextActivityToTransformIndex = reader.int32();
                    break;
                case /* optional int32 oldest_revision_sequence_after_transformed */ 2:
                    message.oldestRevisionSequenceAfterTransformed = reader.int32();
                    break;
                case /* optional TSP.Date last_activity_coalesced_date */ 3:
                    message.lastActivityCoalescedDate = TSPMessages_4.Date.internalBinaryRead(reader, reader.uint32(), options, message.lastActivityCoalescedDate);
                    break;
                case /* optional TSK.ActivityStreamTransformationStateArchive.ActionType action_type */ 4:
                    message.actionType = reader.int32();
                    break;
                case /* optional int32 transform_to_document_revision_sequence */ 5:
                    message.transformToDocumentRevisionSequence = reader.int32();
                    break;
                case /* repeated fixed64 transform_to_document_revision_identifier = 6 [packed = true];*/ 6:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.transformToDocumentRevisionIdentifier.push(reader.fixed64().toBigInt());
                    else
                        message.transformToDocumentRevisionIdentifier.push(reader.fixed64().toBigInt());
                    break;
                case /* optional double timestamp_of_last_activity_when_last_activity_coalescing */ 7:
                    message.timestampOfLastActivityWhenLastActivityCoalescing = reader.double();
                    break;
                case /* optional bool preserving_revision_sequence_order */ 8:
                    message.preservingRevisionSequenceOrder = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int32 next_activity_to_transform_index = 1; */
        if (message.nextActivityToTransformIndex !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.nextActivityToTransformIndex);
        /* optional int32 oldest_revision_sequence_after_transformed = 2; */
        if (message.oldestRevisionSequenceAfterTransformed !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.oldestRevisionSequenceAfterTransformed);
        /* optional TSP.Date last_activity_coalesced_date = 3; */
        if (message.lastActivityCoalescedDate)
            TSPMessages_4.Date.internalBinaryWrite(message.lastActivityCoalescedDate, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.ActivityStreamTransformationStateArchive.ActionType action_type = 4; */
        if (message.actionType !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).int32(message.actionType);
        /* optional int32 transform_to_document_revision_sequence = 5; */
        if (message.transformToDocumentRevisionSequence !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).int32(message.transformToDocumentRevisionSequence);
        /* repeated fixed64 transform_to_document_revision_identifier = 6 [packed = true]; */
        if (message.transformToDocumentRevisionIdentifier.length) {
            writer.tag(6, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.transformToDocumentRevisionIdentifier.length; i++)
                writer.fixed64(message.transformToDocumentRevisionIdentifier[i]);
            writer.join();
        }
        /* optional double timestamp_of_last_activity_when_last_activity_coalescing = 7; */
        if (message.timestampOfLastActivityWhenLastActivityCoalescing !== undefined)
            writer.tag(7, runtime_1.WireType.Bit64).double(message.timestampOfLastActivityWhenLastActivityCoalescing);
        /* optional bool preserving_revision_sequence_order = 8; */
        if (message.preservingRevisionSequenceOrder !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.preservingRevisionSequenceOrder);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.ActivityStreamTransformationStateArchive
 */
exports.ActivityStreamTransformationStateArchive = new ActivityStreamTransformationStateArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityStreamActivityCounterArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.ActivityStreamActivityCounterArchive", [
            { no: 1, name: "action_type_counter", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ActivityStreamActivityCounterArchive_ActionTypeCounter },
            { no: 2, name: "cursor_type_counter", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ActivityStreamActivityCounterArchive_CursorTypeCounter }
        ]);
    }
    create(value) {
        const message = { actionTypeCounter: [], cursorTypeCounter: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSK.ActivityStreamActivityCounterArchive.ActionTypeCounter action_type_counter */ 1:
                    message.actionTypeCounter.push(exports.ActivityStreamActivityCounterArchive_ActionTypeCounter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSK.ActivityStreamActivityCounterArchive.CursorTypeCounter cursor_type_counter */ 2:
                    message.cursorTypeCounter.push(exports.ActivityStreamActivityCounterArchive_CursorTypeCounter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSK.ActivityStreamActivityCounterArchive.ActionTypeCounter action_type_counter = 1; */
        for (let i = 0; i < message.actionTypeCounter.length; i++)
            exports.ActivityStreamActivityCounterArchive_ActionTypeCounter.internalBinaryWrite(message.actionTypeCounter[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSK.ActivityStreamActivityCounterArchive.CursorTypeCounter cursor_type_counter = 2; */
        for (let i = 0; i < message.cursorTypeCounter.length; i++)
            exports.ActivityStreamActivityCounterArchive_CursorTypeCounter.internalBinaryWrite(message.cursorTypeCounter[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.ActivityStreamActivityCounterArchive
 */
exports.ActivityStreamActivityCounterArchive = new ActivityStreamActivityCounterArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityStreamActivityCounterArchive_ActionTypeCounter$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.ActivityStreamActivityCounterArchive.ActionTypeCounter", [
            { no: 1, name: "action_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 action_type */ 1:
                    message.actionType = reader.int32();
                    break;
                case /* optional uint32 count */ 2:
                    message.count = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional int32 action_type = 1; */
        if (message.actionType !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.actionType);
        /* optional uint32 count = 2; */
        if (message.count !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.ActivityStreamActivityCounterArchive.ActionTypeCounter
 */
exports.ActivityStreamActivityCounterArchive_ActionTypeCounter = new ActivityStreamActivityCounterArchive_ActionTypeCounter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityStreamActivityCounterArchive_CursorTypeCounter$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.ActivityStreamActivityCounterArchive.CursorTypeCounter", [
            { no: 1, name: "cursor_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 cursor_type */ 1:
                    message.cursorType = reader.int32();
                    break;
                case /* optional uint32 count */ 2:
                    message.count = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional int32 cursor_type = 1; */
        if (message.cursorType !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.cursorType);
        /* optional uint32 count = 2; */
        if (message.count !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.ActivityStreamActivityCounterArchive.CursorTypeCounter
 */
exports.ActivityStreamActivityCounterArchive_CursorTypeCounter = new ActivityStreamActivityCounterArchive_CursorTypeCounter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityStreamRemovedAuthorAuditorPendingStateArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.ActivityStreamRemovedAuthorAuditorPendingStateArchive", [
            { no: 1, name: "current_author_identifiers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_9.UUID },
            { no: 3, name: "dates_to_audit", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ActivityStreamRemovedAuthorAuditorPendingStateArchive_DateToAuditAndType }
        ]);
    }
    create(value) {
        const message = { currentAuthorIdentifiers: [], datesToAudit: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.UUID current_author_identifiers */ 1:
                    message.currentAuthorIdentifiers.push(TSPMessages_9.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSK.ActivityStreamRemovedAuthorAuditorPendingStateArchive.DateToAuditAndType dates_to_audit */ 3:
                    message.datesToAudit.push(exports.ActivityStreamRemovedAuthorAuditorPendingStateArchive_DateToAuditAndType.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.UUID current_author_identifiers = 1; */
        for (let i = 0; i < message.currentAuthorIdentifiers.length; i++)
            TSPMessages_9.UUID.internalBinaryWrite(message.currentAuthorIdentifiers[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSK.ActivityStreamRemovedAuthorAuditorPendingStateArchive.DateToAuditAndType dates_to_audit = 3; */
        for (let i = 0; i < message.datesToAudit.length; i++)
            exports.ActivityStreamRemovedAuthorAuditorPendingStateArchive_DateToAuditAndType.internalBinaryWrite(message.datesToAudit[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.ActivityStreamRemovedAuthorAuditorPendingStateArchive
 */
exports.ActivityStreamRemovedAuthorAuditorPendingStateArchive = new ActivityStreamRemovedAuthorAuditorPendingStateArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityStreamRemovedAuthorAuditorPendingStateArchive_DateToAuditAndType$Type extends runtime_5.MessageType {
    constructor() {
        super("TSK.ActivityStreamRemovedAuthorAuditorPendingStateArchive.DateToAuditAndType", [
            { no: 1, name: "date_to_audit", kind: "message", T: () => TSPMessages_4.Date },
            { no: 2, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = { type: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.Date date_to_audit */ 1:
                    message.dateToAudit = TSPMessages_4.Date.internalBinaryRead(reader, reader.uint32(), options, message.dateToAudit);
                    break;
                case /* int32 type */ 2:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.Date date_to_audit = 1; */
        if (message.dateToAudit)
            TSPMessages_4.Date.internalBinaryWrite(message.dateToAudit, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* int32 type = 2; */
        if (message.type !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSK.ActivityStreamRemovedAuthorAuditorPendingStateArchive.DateToAuditAndType
 */
exports.ActivityStreamRemovedAuthorAuditorPendingStateArchive_DateToAuditAndType = new ActivityStreamRemovedAuthorAuditorPendingStateArchive_DateToAuditAndType$Type();
//# sourceMappingURL=TSKArchives.js.map