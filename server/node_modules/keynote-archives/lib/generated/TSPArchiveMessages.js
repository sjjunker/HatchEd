"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SupportMetadata_DataCollaborationProperties = exports.SupportMetadata = exports.DocumentMetadata = exports.DataPropertiesV1 = exports.DataPropertiesEntryV1 = exports.ObjectSerializationDirectory_Entry = exports.ObjectSerializationDirectory = exports.ObjectSerializationMetadata = exports.ViewStateMetadata = exports.EncryptionBlockInfo = exports.EncryptionInfo = exports.DataMetadata = exports.DataMetadataMap_DataMetadataMapEntry = exports.DataMetadataMap = exports.DataInfo = exports.PasteboardMetadata = exports.DocumentRevision = exports.PackageMetadata = exports.FeatureInfo = exports.ObjectUUIDMapEntry = exports.ComponentDataReference_ObjectReference = exports.ComponentDataReference = exports.ComponentExternalReference = exports.ComponentInfo = exports.FieldPath = exports.FieldInfo = exports.MessageInfo = exports.ArchiveInfo = exports.DataInfo_DownloadPriority = exports.PackageMetadata_PackageType = exports.FieldInfo_KnownFieldRule = exports.FieldInfo_UnknownFieldRule = exports.FieldInfo_Type = void 0;
const runtime_1 = require("@protobuf-ts/runtime");
const runtime_2 = require("@protobuf-ts/runtime");
const runtime_3 = require("@protobuf-ts/runtime");
const runtime_4 = require("@protobuf-ts/runtime");
const runtime_5 = require("@protobuf-ts/runtime");
const TSPMessages_1 = require("./TSPMessages");
const TSPMessages_2 = require("./TSPMessages");
const TSPMessages_3 = require("./TSPMessages");
const TSPMessages_4 = require("./TSPMessages");
const TSPMessages_5 = require("./TSPMessages");
const TSPMessages_6 = require("./TSPMessages");
/**
 * @generated from protobuf enum TSP.FieldInfo.Type
 */
var FieldInfo_Type;
(function (FieldInfo_Type) {
    /**
     * @generated from protobuf enum value: Value = 0;
     */
    FieldInfo_Type[FieldInfo_Type["Value"] = 0] = "Value";
    /**
     * @generated from protobuf enum value: ObjectReference = 1;
     */
    FieldInfo_Type[FieldInfo_Type["ObjectReference"] = 1] = "ObjectReference";
    /**
     * @generated from protobuf enum value: DataReference = 2;
     */
    FieldInfo_Type[FieldInfo_Type["DataReference"] = 2] = "DataReference";
    /**
     * @generated from protobuf enum value: Message = 3;
     */
    FieldInfo_Type[FieldInfo_Type["Message"] = 3] = "Message";
})(FieldInfo_Type = exports.FieldInfo_Type || (exports.FieldInfo_Type = {}));
/**
 * @generated from protobuf enum TSP.FieldInfo.UnknownFieldRule
 */
var FieldInfo_UnknownFieldRule;
(function (FieldInfo_UnknownFieldRule) {
    /**
     * @generated from protobuf enum value: IgnoreAndPreserveUntilModified = 0;
     */
    FieldInfo_UnknownFieldRule[FieldInfo_UnknownFieldRule["IgnoreAndPreserveUntilModified"] = 0] = "IgnoreAndPreserveUntilModified";
    /**
     * @generated from protobuf enum value: IgnoreAndPreserve = 1;
     */
    FieldInfo_UnknownFieldRule[FieldInfo_UnknownFieldRule["IgnoreAndPreserve"] = 1] = "IgnoreAndPreserve";
    /**
     * @generated from protobuf enum value: MustUnderstand = 2;
     */
    FieldInfo_UnknownFieldRule[FieldInfo_UnknownFieldRule["MustUnderstand"] = 2] = "MustUnderstand";
    /**
     * @generated from protobuf enum value: NotSupported = -1;
     */
    FieldInfo_UnknownFieldRule[FieldInfo_UnknownFieldRule["NotSupported"] = -1] = "NotSupported";
})(FieldInfo_UnknownFieldRule = exports.FieldInfo_UnknownFieldRule || (exports.FieldInfo_UnknownFieldRule = {}));
/**
 * @generated from protobuf enum TSP.FieldInfo.KnownFieldRule
 */
var FieldInfo_KnownFieldRule;
(function (FieldInfo_KnownFieldRule) {
    /**
     * @generated from protobuf enum value: None = 0;
     */
    FieldInfo_KnownFieldRule[FieldInfo_KnownFieldRule["None"] = 0] = "None";
    /**
     * @generated from protobuf enum value: PreserveNewerValueUntilModified = 1;
     */
    FieldInfo_KnownFieldRule[FieldInfo_KnownFieldRule["PreserveNewerValueUntilModified"] = 1] = "PreserveNewerValueUntilModified";
    /**
     * @generated from protobuf enum value: PreserveNewerValue = 2;
     */
    FieldInfo_KnownFieldRule[FieldInfo_KnownFieldRule["PreserveNewerValue"] = 2] = "PreserveNewerValue";
})(FieldInfo_KnownFieldRule = exports.FieldInfo_KnownFieldRule || (exports.FieldInfo_KnownFieldRule = {}));
/**
 * @generated from protobuf enum TSP.PackageMetadata.PackageType
 */
var PackageMetadata_PackageType;
(function (PackageMetadata_PackageType) {
    /**
     * @generated from protobuf enum value: Default = 0;
     */
    PackageMetadata_PackageType[PackageMetadata_PackageType["Default"] = 0] = "Default";
    /**
     * @generated from protobuf enum value: Directory = 1;
     */
    PackageMetadata_PackageType[PackageMetadata_PackageType["Directory"] = 1] = "Directory";
    /**
     * @generated from protobuf enum value: SingleFile = 2;
     */
    PackageMetadata_PackageType[PackageMetadata_PackageType["SingleFile"] = 2] = "SingleFile";
})(PackageMetadata_PackageType = exports.PackageMetadata_PackageType || (exports.PackageMetadata_PackageType = {}));
/**
 * @generated from protobuf enum TSP.DataInfo.DownloadPriority
 */
var DataInfo_DownloadPriority;
(function (DataInfo_DownloadPriority) {
    /**
     * @generated from protobuf enum value: High = 0;
     */
    DataInfo_DownloadPriority[DataInfo_DownloadPriority["High"] = 0] = "High";
    /**
     * @generated from protobuf enum value: Default = 1;
     */
    DataInfo_DownloadPriority[DataInfo_DownloadPriority["Default"] = 1] = "Default";
})(DataInfo_DownloadPriority = exports.DataInfo_DownloadPriority || (exports.DataInfo_DownloadPriority = {}));
// @generated message type with reflection information, may provide speed optimized methods
class ArchiveInfo$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.ArchiveInfo", [
            { no: 1, name: "identifier", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "message_infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.MessageInfo },
            { no: 3, name: "should_merge", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { messageInfos: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 identifier */ 1:
                    message.identifier = reader.uint64().toBigInt();
                    break;
                case /* repeated TSP.MessageInfo message_infos */ 2:
                    message.messageInfos.push(exports.MessageInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool should_merge */ 3:
                    message.shouldMerge = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional uint64 identifier = 1; */
        if (message.identifier !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.identifier);
        /* repeated TSP.MessageInfo message_infos = 2; */
        for (let i = 0; i < message.messageInfos.length; i++)
            exports.MessageInfo.internalBinaryWrite(message.messageInfos[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool should_merge = 3; */
        if (message.shouldMerge !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.shouldMerge);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.ArchiveInfo
 */
exports.ArchiveInfo = new ArchiveInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageInfo$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.MessageInfo", [
            { no: 1, name: "type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "version", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "length", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "field_infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.FieldInfo },
            { no: 5, name: "object_references", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "data_references", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "base_message_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "diff_merge_version", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "diff_field_path", kind: "message", T: () => exports.FieldPath },
            { no: 10, name: "fields_to_remove", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.FieldPath },
            { no: 11, name: "diff_read_version", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { type: 0, version: [], length: 0, fieldInfos: [], objectReferences: [], dataReferences: [], diffMergeVersion: [], fieldsToRemove: [], diffReadVersion: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 type */ 1:
                    message.type = reader.uint32();
                    break;
                case /* repeated uint32 version = 2 [packed = true];*/ 2:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.version.push(reader.uint32());
                    else
                        message.version.push(reader.uint32());
                    break;
                case /* uint32 length */ 3:
                    message.length = reader.uint32();
                    break;
                case /* repeated TSP.FieldInfo field_infos */ 4:
                    message.fieldInfos.push(exports.FieldInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint64 object_references = 5 [packed = true];*/ 5:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.objectReferences.push(reader.uint64().toBigInt());
                    else
                        message.objectReferences.push(reader.uint64().toBigInt());
                    break;
                case /* repeated uint64 data_references = 6 [packed = true];*/ 6:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.dataReferences.push(reader.uint64().toBigInt());
                    else
                        message.dataReferences.push(reader.uint64().toBigInt());
                    break;
                case /* optional uint32 base_message_index */ 7:
                    message.baseMessageIndex = reader.uint32();
                    break;
                case /* repeated uint32 diff_merge_version = 8 [packed = true];*/ 8:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.diffMergeVersion.push(reader.uint32());
                    else
                        message.diffMergeVersion.push(reader.uint32());
                    break;
                case /* optional TSP.FieldPath diff_field_path */ 9:
                    message.diffFieldPath = exports.FieldPath.internalBinaryRead(reader, reader.uint32(), options, message.diffFieldPath);
                    break;
                case /* repeated TSP.FieldPath fields_to_remove */ 10:
                    message.fieldsToRemove.push(exports.FieldPath.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 diff_read_version = 11 [packed = true];*/ 11:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.diffReadVersion.push(reader.uint32());
                    else
                        message.diffReadVersion.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 type = 1; */
        if (message.type !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.type);
        /* repeated uint32 version = 2 [packed = true]; */
        if (message.version.length) {
            writer.tag(2, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.version.length; i++)
                writer.uint32(message.version[i]);
            writer.join();
        }
        /* uint32 length = 3; */
        if (message.length !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.length);
        /* repeated TSP.FieldInfo field_infos = 4; */
        for (let i = 0; i < message.fieldInfos.length; i++)
            exports.FieldInfo.internalBinaryWrite(message.fieldInfos[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint64 object_references = 5 [packed = true]; */
        if (message.objectReferences.length) {
            writer.tag(5, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.objectReferences.length; i++)
                writer.uint64(message.objectReferences[i]);
            writer.join();
        }
        /* repeated uint64 data_references = 6 [packed = true]; */
        if (message.dataReferences.length) {
            writer.tag(6, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.dataReferences.length; i++)
                writer.uint64(message.dataReferences[i]);
            writer.join();
        }
        /* optional uint32 base_message_index = 7; */
        if (message.baseMessageIndex !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).uint32(message.baseMessageIndex);
        /* repeated uint32 diff_merge_version = 8 [packed = true]; */
        if (message.diffMergeVersion.length) {
            writer.tag(8, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.diffMergeVersion.length; i++)
                writer.uint32(message.diffMergeVersion[i]);
            writer.join();
        }
        /* optional TSP.FieldPath diff_field_path = 9; */
        if (message.diffFieldPath)
            exports.FieldPath.internalBinaryWrite(message.diffFieldPath, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.FieldPath fields_to_remove = 10; */
        for (let i = 0; i < message.fieldsToRemove.length; i++)
            exports.FieldPath.internalBinaryWrite(message.fieldsToRemove[i], writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 diff_read_version = 11 [packed = true]; */
        if (message.diffReadVersion.length) {
            writer.tag(11, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.diffReadVersion.length; i++)
                writer.uint32(message.diffReadVersion[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.MessageInfo
 */
exports.MessageInfo = new MessageInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FieldInfo$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.FieldInfo", [
            { no: 1, name: "path", kind: "message", T: () => exports.FieldPath },
            { no: 2, name: "type", kind: "enum", opt: true, T: () => ["TSP.FieldInfo.Type", FieldInfo_Type] },
            { no: 3, name: "unknown_field_rule", kind: "enum", opt: true, T: () => ["TSP.FieldInfo.UnknownFieldRule", FieldInfo_UnknownFieldRule] },
            { no: 4, name: "object_references", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "data_references", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "known_field_rule", kind: "enum", opt: true, T: () => ["TSP.FieldInfo.KnownFieldRule", FieldInfo_KnownFieldRule] },
            { no: 7, name: "known_field_version", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "known_field_feature_identifier", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { objectReferences: [], dataReferences: [], knownFieldVersion: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.FieldPath path */ 1:
                    message.path = exports.FieldPath.internalBinaryRead(reader, reader.uint32(), options, message.path);
                    break;
                case /* optional TSP.FieldInfo.Type type */ 2:
                    message.type = reader.int32();
                    break;
                case /* optional TSP.FieldInfo.UnknownFieldRule unknown_field_rule */ 3:
                    message.unknownFieldRule = reader.int32();
                    break;
                case /* repeated uint64 object_references = 4 [packed = true];*/ 4:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.objectReferences.push(reader.uint64().toBigInt());
                    else
                        message.objectReferences.push(reader.uint64().toBigInt());
                    break;
                case /* repeated uint64 data_references = 5 [packed = true];*/ 5:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.dataReferences.push(reader.uint64().toBigInt());
                    else
                        message.dataReferences.push(reader.uint64().toBigInt());
                    break;
                case /* optional TSP.FieldInfo.KnownFieldRule known_field_rule */ 6:
                    message.knownFieldRule = reader.int32();
                    break;
                case /* repeated uint32 known_field_version = 7 [packed = true];*/ 7:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.knownFieldVersion.push(reader.uint32());
                    else
                        message.knownFieldVersion.push(reader.uint32());
                    break;
                case /* optional string known_field_feature_identifier */ 8:
                    message.knownFieldFeatureIdentifier = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.FieldPath path = 1; */
        if (message.path)
            exports.FieldPath.internalBinaryWrite(message.path, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.FieldInfo.Type type = 2; */
        if (message.type !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.type);
        /* optional TSP.FieldInfo.UnknownFieldRule unknown_field_rule = 3; */
        if (message.unknownFieldRule !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.unknownFieldRule);
        /* repeated uint64 object_references = 4 [packed = true]; */
        if (message.objectReferences.length) {
            writer.tag(4, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.objectReferences.length; i++)
                writer.uint64(message.objectReferences[i]);
            writer.join();
        }
        /* repeated uint64 data_references = 5 [packed = true]; */
        if (message.dataReferences.length) {
            writer.tag(5, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.dataReferences.length; i++)
                writer.uint64(message.dataReferences[i]);
            writer.join();
        }
        /* optional TSP.FieldInfo.KnownFieldRule known_field_rule = 6; */
        if (message.knownFieldRule !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).int32(message.knownFieldRule);
        /* repeated uint32 known_field_version = 7 [packed = true]; */
        if (message.knownFieldVersion.length) {
            writer.tag(7, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.knownFieldVersion.length; i++)
                writer.uint32(message.knownFieldVersion[i]);
            writer.join();
        }
        /* optional string known_field_feature_identifier = 8; */
        if (message.knownFieldFeatureIdentifier !== undefined)
            writer.tag(8, runtime_1.WireType.LengthDelimited).string(message.knownFieldFeatureIdentifier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.FieldInfo
 */
exports.FieldInfo = new FieldInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FieldPath$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.FieldPath", [
            { no: 1, name: "path", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { path: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 path = 1 [packed = true];*/ 1:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.path.push(reader.uint32());
                    else
                        message.path.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated uint32 path = 1 [packed = true]; */
        if (message.path.length) {
            writer.tag(1, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.path.length; i++)
                writer.uint32(message.path[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.FieldPath
 */
exports.FieldPath = new FieldPath$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ComponentInfo$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.ComponentInfo", [
            { no: 1, name: "identifier", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "preferred_locator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "locator", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "document_read_version", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "document_write_version", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "external_references", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ComponentExternalReference },
            { no: 7, name: "data_references", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ComponentDataReference },
            { no: 10, name: "is_stored_outside_object_archive", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "object_uuid_map_entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ObjectUUIDMapEntry },
            { no: 12, name: "save_token", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "feature_infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.FeatureInfo },
            { no: 14, name: "component_read_version", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "component_required_version", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 16, name: "compression_algorithm", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 17, name: "can_be_dropped", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "versioned_external_references", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ComponentExternalReference },
            { no: 19, name: "is_wasteful", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 20, name: "ambiguous_object_identifiers", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 21, name: "required_package_identifier", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { identifier: 0n, preferredLocator: "", documentReadVersion: [], documentWriteVersion: [], externalReferences: [], dataReferences: [], objectUuidMapEntries: [], featureInfos: [], componentReadVersion: [], componentRequiredVersion: [], versionedExternalReferences: [], ambiguousObjectIdentifiers: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 identifier */ 1:
                    message.identifier = reader.uint64().toBigInt();
                    break;
                case /* string preferred_locator */ 2:
                    message.preferredLocator = reader.string();
                    break;
                case /* optional string locator */ 3:
                    message.locator = reader.string();
                    break;
                case /* repeated uint32 document_read_version = 4 [packed = true];*/ 4:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.documentReadVersion.push(reader.uint32());
                    else
                        message.documentReadVersion.push(reader.uint32());
                    break;
                case /* repeated uint32 document_write_version = 5 [packed = true];*/ 5:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.documentWriteVersion.push(reader.uint32());
                    else
                        message.documentWriteVersion.push(reader.uint32());
                    break;
                case /* repeated TSP.ComponentExternalReference external_references */ 6:
                    message.externalReferences.push(exports.ComponentExternalReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.ComponentDataReference data_references */ 7:
                    message.dataReferences.push(exports.ComponentDataReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool is_stored_outside_object_archive */ 10:
                    message.isStoredOutsideObjectArchive = reader.bool();
                    break;
                case /* repeated TSP.ObjectUUIDMapEntry object_uuid_map_entries */ 11:
                    message.objectUuidMapEntries.push(exports.ObjectUUIDMapEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint64 save_token */ 12:
                    message.saveToken = reader.uint64().toBigInt();
                    break;
                case /* repeated TSP.FeatureInfo feature_infos */ 13:
                    message.featureInfos.push(exports.FeatureInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 component_read_version = 14 [packed = true];*/ 14:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.componentReadVersion.push(reader.uint32());
                    else
                        message.componentReadVersion.push(reader.uint32());
                    break;
                case /* repeated uint32 component_required_version = 15 [packed = true];*/ 15:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.componentRequiredVersion.push(reader.uint32());
                    else
                        message.componentRequiredVersion.push(reader.uint32());
                    break;
                case /* optional uint32 compression_algorithm */ 16:
                    message.compressionAlgorithm = reader.uint32();
                    break;
                case /* optional bool can_be_dropped */ 17:
                    message.canBeDropped = reader.bool();
                    break;
                case /* repeated TSP.ComponentExternalReference versioned_external_references */ 18:
                    message.versionedExternalReferences.push(exports.ComponentExternalReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool is_wasteful */ 19:
                    message.isWasteful = reader.bool();
                    break;
                case /* repeated uint64 ambiguous_object_identifiers = 20 [packed = true];*/ 20:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.ambiguousObjectIdentifiers.push(reader.uint64().toBigInt());
                    else
                        message.ambiguousObjectIdentifiers.push(reader.uint64().toBigInt());
                    break;
                case /* optional uint32 required_package_identifier */ 21:
                    message.requiredPackageIdentifier = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 identifier = 1; */
        if (message.identifier !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.identifier);
        /* string preferred_locator = 2; */
        if (message.preferredLocator !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.preferredLocator);
        /* optional string locator = 3; */
        if (message.locator !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.locator);
        /* repeated uint32 document_read_version = 4 [packed = true]; */
        if (message.documentReadVersion.length) {
            writer.tag(4, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.documentReadVersion.length; i++)
                writer.uint32(message.documentReadVersion[i]);
            writer.join();
        }
        /* repeated uint32 document_write_version = 5 [packed = true]; */
        if (message.documentWriteVersion.length) {
            writer.tag(5, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.documentWriteVersion.length; i++)
                writer.uint32(message.documentWriteVersion[i]);
            writer.join();
        }
        /* repeated TSP.ComponentExternalReference external_references = 6; */
        for (let i = 0; i < message.externalReferences.length; i++)
            exports.ComponentExternalReference.internalBinaryWrite(message.externalReferences[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.ComponentDataReference data_references = 7; */
        for (let i = 0; i < message.dataReferences.length; i++)
            exports.ComponentDataReference.internalBinaryWrite(message.dataReferences[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_stored_outside_object_archive = 10; */
        if (message.isStoredOutsideObjectArchive !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).bool(message.isStoredOutsideObjectArchive);
        /* repeated TSP.ObjectUUIDMapEntry object_uuid_map_entries = 11; */
        for (let i = 0; i < message.objectUuidMapEntries.length; i++)
            exports.ObjectUUIDMapEntry.internalBinaryWrite(message.objectUuidMapEntries[i], writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint64 save_token = 12; */
        if (message.saveToken !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).uint64(message.saveToken);
        /* repeated TSP.FeatureInfo feature_infos = 13; */
        for (let i = 0; i < message.featureInfos.length; i++)
            exports.FeatureInfo.internalBinaryWrite(message.featureInfos[i], writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 component_read_version = 14 [packed = true]; */
        if (message.componentReadVersion.length) {
            writer.tag(14, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.componentReadVersion.length; i++)
                writer.uint32(message.componentReadVersion[i]);
            writer.join();
        }
        /* repeated uint32 component_required_version = 15 [packed = true]; */
        if (message.componentRequiredVersion.length) {
            writer.tag(15, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.componentRequiredVersion.length; i++)
                writer.uint32(message.componentRequiredVersion[i]);
            writer.join();
        }
        /* optional uint32 compression_algorithm = 16; */
        if (message.compressionAlgorithm !== undefined)
            writer.tag(16, runtime_1.WireType.Varint).uint32(message.compressionAlgorithm);
        /* optional bool can_be_dropped = 17; */
        if (message.canBeDropped !== undefined)
            writer.tag(17, runtime_1.WireType.Varint).bool(message.canBeDropped);
        /* repeated TSP.ComponentExternalReference versioned_external_references = 18; */
        for (let i = 0; i < message.versionedExternalReferences.length; i++)
            exports.ComponentExternalReference.internalBinaryWrite(message.versionedExternalReferences[i], writer.tag(18, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_wasteful = 19; */
        if (message.isWasteful !== undefined)
            writer.tag(19, runtime_1.WireType.Varint).bool(message.isWasteful);
        /* repeated uint64 ambiguous_object_identifiers = 20 [packed = true]; */
        if (message.ambiguousObjectIdentifiers.length) {
            writer.tag(20, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.ambiguousObjectIdentifiers.length; i++)
                writer.uint64(message.ambiguousObjectIdentifiers[i]);
            writer.join();
        }
        /* optional uint32 required_package_identifier = 21; */
        if (message.requiredPackageIdentifier !== undefined)
            writer.tag(21, runtime_1.WireType.Varint).uint32(message.requiredPackageIdentifier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.ComponentInfo
 */
exports.ComponentInfo = new ComponentInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ComponentExternalReference$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.ComponentExternalReference", [
            { no: 1, name: "component_identifier", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "object_identifier", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "is_weak", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { componentIdentifier: 0n };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 component_identifier */ 1:
                    message.componentIdentifier = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 object_identifier */ 2:
                    message.objectIdentifier = reader.uint64().toBigInt();
                    break;
                case /* optional bool is_weak */ 3:
                    message.isWeak = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 component_identifier = 1; */
        if (message.componentIdentifier !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.componentIdentifier);
        /* optional uint64 object_identifier = 2; */
        if (message.objectIdentifier !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint64(message.objectIdentifier);
        /* optional bool is_weak = 3; */
        if (message.isWeak !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.isWeak);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.ComponentExternalReference
 */
exports.ComponentExternalReference = new ComponentExternalReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ComponentDataReference$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.ComponentDataReference", [
            { no: 1, name: "data_identifier", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "object_reference_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ComponentDataReference_ObjectReference }
        ]);
    }
    create(value) {
        const message = { dataIdentifier: 0n, objectReferenceList: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 data_identifier */ 1:
                    message.dataIdentifier = reader.uint64().toBigInt();
                    break;
                case /* repeated TSP.ComponentDataReference.ObjectReference object_reference_list */ 2:
                    message.objectReferenceList.push(exports.ComponentDataReference_ObjectReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 data_identifier = 1; */
        if (message.dataIdentifier !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.dataIdentifier);
        /* repeated TSP.ComponentDataReference.ObjectReference object_reference_list = 2; */
        for (let i = 0; i < message.objectReferenceList.length; i++)
            exports.ComponentDataReference_ObjectReference.internalBinaryWrite(message.objectReferenceList[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.ComponentDataReference
 */
exports.ComponentDataReference = new ComponentDataReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ComponentDataReference_ObjectReference$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.ComponentDataReference.ObjectReference", [
            { no: 1, name: "object_identifier", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { objectIdentifier: 0n, count: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 object_identifier */ 1:
                    message.objectIdentifier = reader.uint64().toBigInt();
                    break;
                case /* uint32 count */ 2:
                    message.count = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 object_identifier = 1; */
        if (message.objectIdentifier !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.objectIdentifier);
        /* uint32 count = 2; */
        if (message.count !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.ComponentDataReference.ObjectReference
 */
exports.ComponentDataReference_ObjectReference = new ComponentDataReference_ObjectReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ObjectUUIDMapEntry$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.ObjectUUIDMapEntry", [
            { no: 1, name: "identifier", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "uuid", kind: "message", T: () => TSPMessages_6.UUID }
        ]);
    }
    create(value) {
        const message = { identifier: 0n };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 identifier */ 1:
                    message.identifier = reader.uint64().toBigInt();
                    break;
                case /* TSP.UUID uuid */ 2:
                    message.uuid = TSPMessages_6.UUID.internalBinaryRead(reader, reader.uint32(), options, message.uuid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 identifier = 1; */
        if (message.identifier !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.identifier);
        /* TSP.UUID uuid = 2; */
        if (message.uuid)
            TSPMessages_6.UUID.internalBinaryWrite(message.uuid, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.ObjectUUIDMapEntry
 */
exports.ObjectUUIDMapEntry = new ObjectUUIDMapEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeatureInfo$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.FeatureInfo", [
            { no: 1, name: "identifier", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "read_version", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "write_version", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { identifier: "", readVersion: [], writeVersion: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string identifier */ 1:
                    message.identifier = reader.string();
                    break;
                case /* repeated uint32 read_version = 2 [packed = true];*/ 2:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.readVersion.push(reader.uint32());
                    else
                        message.readVersion.push(reader.uint32());
                    break;
                case /* repeated uint32 write_version = 3 [packed = true];*/ 3:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.writeVersion.push(reader.uint32());
                    else
                        message.writeVersion.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string identifier = 1; */
        if (message.identifier !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.identifier);
        /* repeated uint32 read_version = 2 [packed = true]; */
        if (message.readVersion.length) {
            writer.tag(2, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.readVersion.length; i++)
                writer.uint32(message.readVersion[i]);
            writer.join();
        }
        /* repeated uint32 write_version = 3 [packed = true]; */
        if (message.writeVersion.length) {
            writer.tag(3, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.writeVersion.length; i++)
                writer.uint32(message.writeVersion[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.FeatureInfo
 */
exports.FeatureInfo = new FeatureInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PackageMetadata$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.PackageMetadata", [
            { no: 1, name: "last_object_identifier", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "revision", kind: "message", T: () => exports.DocumentRevision },
            { no: 3, name: "components", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ComponentInfo },
            { no: 4, name: "datas", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.DataInfo },
            { no: 5, name: "read_version", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "write_version", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "file_format_version", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "save_token", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "preferred_package_type", kind: "enum", opt: true, T: () => ["TSP.PackageMetadata.PackageType", PackageMetadata_PackageType] },
            { no: 10, name: "data_metadata_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 11, name: "versioned_components", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ComponentInfo }
        ]);
    }
    create(value) {
        const message = { lastObjectIdentifier: 0n, components: [], datas: [], readVersion: [], writeVersion: [], fileFormatVersion: [], versionedComponents: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 last_object_identifier */ 1:
                    message.lastObjectIdentifier = reader.uint64().toBigInt();
                    break;
                case /* optional TSP.DocumentRevision revision */ 2:
                    message.revision = exports.DocumentRevision.internalBinaryRead(reader, reader.uint32(), options, message.revision);
                    break;
                case /* repeated TSP.ComponentInfo components */ 3:
                    message.components.push(exports.ComponentInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.DataInfo datas */ 4:
                    message.datas.push(exports.DataInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 read_version = 5 [packed = true];*/ 5:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.readVersion.push(reader.uint32());
                    else
                        message.readVersion.push(reader.uint32());
                    break;
                case /* repeated uint32 write_version = 6 [packed = true];*/ 6:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.writeVersion.push(reader.uint32());
                    else
                        message.writeVersion.push(reader.uint32());
                    break;
                case /* repeated uint32 file_format_version = 7 [packed = true];*/ 7:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.fileFormatVersion.push(reader.uint32());
                    else
                        message.fileFormatVersion.push(reader.uint32());
                    break;
                case /* optional uint64 save_token */ 8:
                    message.saveToken = reader.uint64().toBigInt();
                    break;
                case /* optional TSP.PackageMetadata.PackageType preferred_package_type */ 9:
                    message.preferredPackageType = reader.int32();
                    break;
                case /* optional TSP.Reference data_metadata_map */ 10:
                    message.dataMetadataMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.dataMetadataMap);
                    break;
                case /* repeated TSP.ComponentInfo versioned_components */ 11:
                    message.versionedComponents.push(exports.ComponentInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 last_object_identifier = 1; */
        if (message.lastObjectIdentifier !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.lastObjectIdentifier);
        /* optional TSP.DocumentRevision revision = 2; */
        if (message.revision)
            exports.DocumentRevision.internalBinaryWrite(message.revision, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.ComponentInfo components = 3; */
        for (let i = 0; i < message.components.length; i++)
            exports.ComponentInfo.internalBinaryWrite(message.components[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.DataInfo datas = 4; */
        for (let i = 0; i < message.datas.length; i++)
            exports.DataInfo.internalBinaryWrite(message.datas[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 read_version = 5 [packed = true]; */
        if (message.readVersion.length) {
            writer.tag(5, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.readVersion.length; i++)
                writer.uint32(message.readVersion[i]);
            writer.join();
        }
        /* repeated uint32 write_version = 6 [packed = true]; */
        if (message.writeVersion.length) {
            writer.tag(6, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.writeVersion.length; i++)
                writer.uint32(message.writeVersion[i]);
            writer.join();
        }
        /* repeated uint32 file_format_version = 7 [packed = true]; */
        if (message.fileFormatVersion.length) {
            writer.tag(7, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.fileFormatVersion.length; i++)
                writer.uint32(message.fileFormatVersion[i]);
            writer.join();
        }
        /* optional uint64 save_token = 8; */
        if (message.saveToken !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).uint64(message.saveToken);
        /* optional TSP.PackageMetadata.PackageType preferred_package_type = 9; */
        if (message.preferredPackageType !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).int32(message.preferredPackageType);
        /* optional TSP.Reference data_metadata_map = 10; */
        if (message.dataMetadataMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.dataMetadataMap, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.ComponentInfo versioned_components = 11; */
        for (let i = 0; i < message.versionedComponents.length; i++)
            exports.ComponentInfo.internalBinaryWrite(message.versionedComponents[i], writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.PackageMetadata
 */
exports.PackageMetadata = new PackageMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentRevision$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.DocumentRevision", [
            { no: 3, name: "sequence_32", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "identifier", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 1, name: "sequence_64", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 sequence_32 */ 3:
                    message.sequence32 = reader.int32();
                    break;
                case /* optional string identifier */ 2:
                    message.identifier = reader.string();
                    break;
                case /* optional uint64 sequence_64 */ 1:
                    message.sequence64 = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional int32 sequence_32 = 3; */
        if (message.sequence32 !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.sequence32);
        /* optional string identifier = 2; */
        if (message.identifier !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.identifier);
        /* optional uint64 sequence_64 = 1; */
        if (message.sequence64 !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.sequence64);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.DocumentRevision
 */
exports.DocumentRevision = new DocumentRevision$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PasteboardMetadata$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.PasteboardMetadata", [
            { no: 1, name: "version", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "app_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "datas", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.DataInfo },
            { no: 5, name: "source_document_uuid", kind: "message", T: () => TSPMessages_6.UUID },
            { no: 6, name: "data_metadata_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 7, name: "read_version", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { version: [], appName: "", datas: [], readVersion: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 version = 1 [packed = true];*/ 1:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.version.push(reader.uint32());
                    else
                        message.version.push(reader.uint32());
                    break;
                case /* string app_name */ 2:
                    message.appName = reader.string();
                    break;
                case /* repeated TSP.DataInfo datas */ 3:
                    message.datas.push(exports.DataInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.UUID source_document_uuid */ 5:
                    message.sourceDocumentUuid = TSPMessages_6.UUID.internalBinaryRead(reader, reader.uint32(), options, message.sourceDocumentUuid);
                    break;
                case /* optional TSP.Reference data_metadata_map */ 6:
                    message.dataMetadataMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.dataMetadataMap);
                    break;
                case /* repeated uint32 read_version = 7 [packed = true];*/ 7:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.readVersion.push(reader.uint32());
                    else
                        message.readVersion.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated uint32 version = 1 [packed = true]; */
        if (message.version.length) {
            writer.tag(1, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.version.length; i++)
                writer.uint32(message.version[i]);
            writer.join();
        }
        /* string app_name = 2; */
        if (message.appName !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.appName);
        /* repeated TSP.DataInfo datas = 3; */
        for (let i = 0; i < message.datas.length; i++)
            exports.DataInfo.internalBinaryWrite(message.datas[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID source_document_uuid = 5; */
        if (message.sourceDocumentUuid)
            TSPMessages_6.UUID.internalBinaryWrite(message.sourceDocumentUuid, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference data_metadata_map = 6; */
        if (message.dataMetadataMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.dataMetadataMap, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 read_version = 7 [packed = true]; */
        if (message.readVersion.length) {
            writer.tag(7, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.readVersion.length; i++)
                writer.uint32(message.readVersion[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.PasteboardMetadata
 */
exports.PasteboardMetadata = new PasteboardMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataInfo$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.DataInfo", [
            { no: 1, name: "identifier", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "digest", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "preferred_file_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "file_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "document_resource_locator", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "source_bookmark_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "remote_url", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "can_download", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "download_priority", kind: "enum", opt: true, T: () => ["TSP.DataInfo.DownloadPriority", DataInfo_DownloadPriority] },
            { no: 10, name: "attributes", kind: "message", T: () => TSPMessages_4.DataAttributes },
            { no: 11, name: "encryption_info", kind: "message", T: () => exports.EncryptionInfo },
            { no: 12, name: "last_mismatched_digest", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 13, name: "unmaterialized_ranges", kind: "message", T: () => TSPMessages_3.IndexSet },
            { no: 14, name: "remote_data_length", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "remote_data_has_package_storage", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "upload_status", kind: "enum", opt: true, T: () => ["TSP.DataUploadStatus", TSPMessages_2.DataUploadStatus] },
            { no: 17, name: "remote_data_mtime", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 18, name: "materialized_length", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 99, name: "pasteboard_external_file_path", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { identifier: 0n, digest: new Uint8Array(0), preferredFileName: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 identifier */ 1:
                    message.identifier = reader.uint64().toBigInt();
                    break;
                case /* bytes digest */ 2:
                    message.digest = reader.bytes();
                    break;
                case /* string preferred_file_name */ 3:
                    message.preferredFileName = reader.string();
                    break;
                case /* optional string file_name */ 4:
                    message.fileName = reader.string();
                    break;
                case /* optional string document_resource_locator */ 5:
                    message.documentResourceLocator = reader.string();
                    break;
                case /* optional bytes source_bookmark_data */ 6:
                    message.sourceBookmarkData = reader.bytes();
                    break;
                case /* optional string remote_url */ 7:
                    message.remoteUrl = reader.string();
                    break;
                case /* optional bool can_download */ 8:
                    message.canDownload = reader.bool();
                    break;
                case /* optional TSP.DataInfo.DownloadPriority download_priority */ 9:
                    message.downloadPriority = reader.int32();
                    break;
                case /* optional TSP.DataAttributes attributes */ 10:
                    message.attributes = TSPMessages_4.DataAttributes.internalBinaryRead(reader, reader.uint32(), options, message.attributes);
                    break;
                case /* optional TSP.EncryptionInfo encryption_info */ 11:
                    message.encryptionInfo = exports.EncryptionInfo.internalBinaryRead(reader, reader.uint32(), options, message.encryptionInfo);
                    break;
                case /* optional bytes last_mismatched_digest */ 12:
                    message.lastMismatchedDigest = reader.bytes();
                    break;
                case /* optional TSP.IndexSet unmaterialized_ranges */ 13:
                    message.unmaterializedRanges = TSPMessages_3.IndexSet.internalBinaryRead(reader, reader.uint32(), options, message.unmaterializedRanges);
                    break;
                case /* optional uint64 remote_data_length */ 14:
                    message.remoteDataLength = reader.uint64().toBigInt();
                    break;
                case /* optional bool remote_data_has_package_storage */ 15:
                    message.remoteDataHasPackageStorage = reader.bool();
                    break;
                case /* optional TSP.DataUploadStatus upload_status */ 16:
                    message.uploadStatus = reader.int32();
                    break;
                case /* optional double remote_data_mtime */ 17:
                    message.remoteDataMtime = reader.double();
                    break;
                case /* optional uint64 materialized_length */ 18:
                    message.materializedLength = reader.uint64().toBigInt();
                    break;
                case /* optional string pasteboard_external_file_path */ 99:
                    message.pasteboardExternalFilePath = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 identifier = 1; */
        if (message.identifier !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.identifier);
        /* bytes digest = 2; */
        if (message.digest.length)
            writer.tag(2, runtime_1.WireType.LengthDelimited).bytes(message.digest);
        /* string preferred_file_name = 3; */
        if (message.preferredFileName !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.preferredFileName);
        /* optional string file_name = 4; */
        if (message.fileName !== undefined)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.fileName);
        /* optional string document_resource_locator = 5; */
        if (message.documentResourceLocator !== undefined)
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.documentResourceLocator);
        /* optional bytes source_bookmark_data = 6; */
        if (message.sourceBookmarkData !== undefined)
            writer.tag(6, runtime_1.WireType.LengthDelimited).bytes(message.sourceBookmarkData);
        /* optional string remote_url = 7; */
        if (message.remoteUrl !== undefined)
            writer.tag(7, runtime_1.WireType.LengthDelimited).string(message.remoteUrl);
        /* optional bool can_download = 8; */
        if (message.canDownload !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.canDownload);
        /* optional TSP.DataInfo.DownloadPriority download_priority = 9; */
        if (message.downloadPriority !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).int32(message.downloadPriority);
        /* optional TSP.DataAttributes attributes = 10; */
        if (message.attributes)
            TSPMessages_4.DataAttributes.internalBinaryWrite(message.attributes, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.EncryptionInfo encryption_info = 11; */
        if (message.encryptionInfo)
            exports.EncryptionInfo.internalBinaryWrite(message.encryptionInfo, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bytes last_mismatched_digest = 12; */
        if (message.lastMismatchedDigest !== undefined)
            writer.tag(12, runtime_1.WireType.LengthDelimited).bytes(message.lastMismatchedDigest);
        /* optional TSP.IndexSet unmaterialized_ranges = 13; */
        if (message.unmaterializedRanges)
            TSPMessages_3.IndexSet.internalBinaryWrite(message.unmaterializedRanges, writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint64 remote_data_length = 14; */
        if (message.remoteDataLength !== undefined)
            writer.tag(14, runtime_1.WireType.Varint).uint64(message.remoteDataLength);
        /* optional bool remote_data_has_package_storage = 15; */
        if (message.remoteDataHasPackageStorage !== undefined)
            writer.tag(15, runtime_1.WireType.Varint).bool(message.remoteDataHasPackageStorage);
        /* optional TSP.DataUploadStatus upload_status = 16; */
        if (message.uploadStatus !== undefined)
            writer.tag(16, runtime_1.WireType.Varint).int32(message.uploadStatus);
        /* optional double remote_data_mtime = 17; */
        if (message.remoteDataMtime !== undefined)
            writer.tag(17, runtime_1.WireType.Bit64).double(message.remoteDataMtime);
        /* optional uint64 materialized_length = 18; */
        if (message.materializedLength !== undefined)
            writer.tag(18, runtime_1.WireType.Varint).uint64(message.materializedLength);
        /* optional string pasteboard_external_file_path = 99; */
        if (message.pasteboardExternalFilePath !== undefined)
            writer.tag(99, runtime_1.WireType.LengthDelimited).string(message.pasteboardExternalFilePath);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.DataInfo
 */
exports.DataInfo = new DataInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataMetadataMap$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.DataMetadataMap", [
            { no: 1, name: "data_metadata_entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.DataMetadataMap_DataMetadataMapEntry }
        ]);
    }
    create(value) {
        const message = { dataMetadataEntries: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.DataMetadataMap.DataMetadataMapEntry data_metadata_entries */ 1:
                    message.dataMetadataEntries.push(exports.DataMetadataMap_DataMetadataMapEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.DataMetadataMap.DataMetadataMapEntry data_metadata_entries = 1; */
        for (let i = 0; i < message.dataMetadataEntries.length; i++)
            exports.DataMetadataMap_DataMetadataMapEntry.internalBinaryWrite(message.dataMetadataEntries[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.DataMetadataMap
 */
exports.DataMetadataMap = new DataMetadataMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataMetadataMap_DataMetadataMapEntry$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.DataMetadataMap.DataMetadataMapEntry", [
            { no: 1, name: "data_identifier", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "data_metadata", kind: "message", T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = { dataIdentifier: 0n };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 data_identifier */ 1:
                    message.dataIdentifier = reader.uint64().toBigInt();
                    break;
                case /* TSP.Reference data_metadata */ 2:
                    message.dataMetadata = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.dataMetadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 data_identifier = 1; */
        if (message.dataIdentifier !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.dataIdentifier);
        /* TSP.Reference data_metadata = 2; */
        if (message.dataMetadata)
            TSPMessages_5.Reference.internalBinaryWrite(message.dataMetadata, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.DataMetadataMap.DataMetadataMapEntry
 */
exports.DataMetadataMap_DataMetadataMapEntry = new DataMetadataMap_DataMetadataMapEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataMetadata$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.DataMetadata", [
            { no: 1, name: "fallback_color", kind: "message", T: () => TSPMessages_1.Color }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Color fallback_color */ 1:
                    message.fallbackColor = TSPMessages_1.Color.internalBinaryRead(reader, reader.uint32(), options, message.fallbackColor);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Color fallback_color = 1; */
        if (message.fallbackColor)
            TSPMessages_1.Color.internalBinaryWrite(message.fallbackColor, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.DataMetadata
 */
exports.DataMetadata = new DataMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EncryptionInfo$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.EncryptionInfo", [
            { no: 1, name: "decoded_length", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "preferred_block_size", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "block_infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.EncryptionBlockInfo }
        ]);
    }
    create(value) {
        const message = { blockInfos: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 decoded_length */ 1:
                    message.decodedLength = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 preferred_block_size */ 2:
                    message.preferredBlockSize = reader.uint64().toBigInt();
                    break;
                case /* repeated TSP.EncryptionBlockInfo block_infos */ 3:
                    message.blockInfos.push(exports.EncryptionBlockInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional uint64 decoded_length = 1; */
        if (message.decodedLength !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.decodedLength);
        /* optional uint64 preferred_block_size = 2; */
        if (message.preferredBlockSize !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint64(message.preferredBlockSize);
        /* repeated TSP.EncryptionBlockInfo block_infos = 3; */
        for (let i = 0; i < message.blockInfos.length; i++)
            exports.EncryptionBlockInfo.internalBinaryWrite(message.blockInfos[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.EncryptionInfo
 */
exports.EncryptionInfo = new EncryptionInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EncryptionBlockInfo$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.EncryptionBlockInfo", [
            { no: 1, name: "encoded_length", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "decoded_length", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value) {
        const message = { encodedLength: 0n };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 encoded_length */ 1:
                    message.encodedLength = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 decoded_length */ 2:
                    message.decodedLength = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 encoded_length = 1; */
        if (message.encodedLength !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.encodedLength);
        /* optional uint64 decoded_length = 2; */
        if (message.decodedLength !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint64(message.decodedLength);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.EncryptionBlockInfo
 */
exports.EncryptionBlockInfo = new EncryptionBlockInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ViewStateMetadata$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.ViewStateMetadata", [
            { no: 1, name: "version", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "version_uuid", kind: "message", T: () => TSPMessages_6.UUID },
            { no: 3, name: "component", kind: "message", T: () => exports.ComponentInfo },
            { no: 5, name: "external_object_uuid_map_entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ObjectUUIDMapEntry },
            { no: 6, name: "read_version", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { version: [], externalObjectUuidMapEntries: [], readVersion: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 version = 1 [packed = true];*/ 1:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.version.push(reader.uint32());
                    else
                        message.version.push(reader.uint32());
                    break;
                case /* optional TSP.UUID version_uuid */ 4:
                    message.versionUuid = TSPMessages_6.UUID.internalBinaryRead(reader, reader.uint32(), options, message.versionUuid);
                    break;
                case /* TSP.ComponentInfo component */ 3:
                    message.component = exports.ComponentInfo.internalBinaryRead(reader, reader.uint32(), options, message.component);
                    break;
                case /* repeated TSP.ObjectUUIDMapEntry external_object_uuid_map_entries */ 5:
                    message.externalObjectUuidMapEntries.push(exports.ObjectUUIDMapEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 read_version = 6 [packed = true];*/ 6:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.readVersion.push(reader.uint32());
                    else
                        message.readVersion.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated uint32 version = 1 [packed = true]; */
        if (message.version.length) {
            writer.tag(1, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.version.length; i++)
                writer.uint32(message.version[i]);
            writer.join();
        }
        /* optional TSP.UUID version_uuid = 4; */
        if (message.versionUuid)
            TSPMessages_6.UUID.internalBinaryWrite(message.versionUuid, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.ComponentInfo component = 3; */
        if (message.component)
            exports.ComponentInfo.internalBinaryWrite(message.component, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.ObjectUUIDMapEntry external_object_uuid_map_entries = 5; */
        for (let i = 0; i < message.externalObjectUuidMapEntries.length; i++)
            exports.ObjectUUIDMapEntry.internalBinaryWrite(message.externalObjectUuidMapEntries[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 read_version = 6 [packed = true]; */
        if (message.readVersion.length) {
            writer.tag(6, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.readVersion.length; i++)
                writer.uint32(message.readVersion[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.ViewStateMetadata
 */
exports.ViewStateMetadata = new ViewStateMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ObjectSerializationMetadata$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.ObjectSerializationMetadata", [
            { no: 1, name: "version", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "source_document_uuid", kind: "message", T: () => TSPMessages_6.UUID },
            { no: 3, name: "version_uuid", kind: "message", T: () => TSPMessages_6.UUID },
            { no: 4, name: "component", kind: "message", T: () => exports.ComponentInfo },
            { no: 5, name: "datas", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.DataInfo },
            { no: 6, name: "external_object_uuid_map_entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ObjectUUIDMapEntry },
            { no: 7, name: "data_metadata_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 8, name: "read_version", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { version: [], datas: [], externalObjectUuidMapEntries: [], readVersion: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 version = 1 [packed = true];*/ 1:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.version.push(reader.uint32());
                    else
                        message.version.push(reader.uint32());
                    break;
                case /* optional TSP.UUID source_document_uuid */ 2:
                    message.sourceDocumentUuid = TSPMessages_6.UUID.internalBinaryRead(reader, reader.uint32(), options, message.sourceDocumentUuid);
                    break;
                case /* optional TSP.UUID version_uuid */ 3:
                    message.versionUuid = TSPMessages_6.UUID.internalBinaryRead(reader, reader.uint32(), options, message.versionUuid);
                    break;
                case /* TSP.ComponentInfo component */ 4:
                    message.component = exports.ComponentInfo.internalBinaryRead(reader, reader.uint32(), options, message.component);
                    break;
                case /* repeated TSP.DataInfo datas */ 5:
                    message.datas.push(exports.DataInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.ObjectUUIDMapEntry external_object_uuid_map_entries */ 6:
                    message.externalObjectUuidMapEntries.push(exports.ObjectUUIDMapEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Reference data_metadata_map */ 7:
                    message.dataMetadataMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.dataMetadataMap);
                    break;
                case /* repeated uint32 read_version = 8 [packed = true];*/ 8:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.readVersion.push(reader.uint32());
                    else
                        message.readVersion.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated uint32 version = 1 [packed = true]; */
        if (message.version.length) {
            writer.tag(1, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.version.length; i++)
                writer.uint32(message.version[i]);
            writer.join();
        }
        /* optional TSP.UUID source_document_uuid = 2; */
        if (message.sourceDocumentUuid)
            TSPMessages_6.UUID.internalBinaryWrite(message.sourceDocumentUuid, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID version_uuid = 3; */
        if (message.versionUuid)
            TSPMessages_6.UUID.internalBinaryWrite(message.versionUuid, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.ComponentInfo component = 4; */
        if (message.component)
            exports.ComponentInfo.internalBinaryWrite(message.component, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.DataInfo datas = 5; */
        for (let i = 0; i < message.datas.length; i++)
            exports.DataInfo.internalBinaryWrite(message.datas[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.ObjectUUIDMapEntry external_object_uuid_map_entries = 6; */
        for (let i = 0; i < message.externalObjectUuidMapEntries.length; i++)
            exports.ObjectUUIDMapEntry.internalBinaryWrite(message.externalObjectUuidMapEntries[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference data_metadata_map = 7; */
        if (message.dataMetadataMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.dataMetadataMap, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 read_version = 8 [packed = true]; */
        if (message.readVersion.length) {
            writer.tag(8, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.readVersion.length; i++)
                writer.uint32(message.readVersion[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.ObjectSerializationMetadata
 */
exports.ObjectSerializationMetadata = new ObjectSerializationMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ObjectSerializationDirectory$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.ObjectSerializationDirectory", [
            { no: 1, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ObjectSerializationDirectory_Entry }
        ]);
    }
    create(value) {
        const message = { entries: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.ObjectSerializationDirectory.Entry entries */ 1:
                    message.entries.push(exports.ObjectSerializationDirectory_Entry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.ObjectSerializationDirectory.Entry entries = 1; */
        for (let i = 0; i < message.entries.length; i++)
            exports.ObjectSerializationDirectory_Entry.internalBinaryWrite(message.entries[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.ObjectSerializationDirectory
 */
exports.ObjectSerializationDirectory = new ObjectSerializationDirectory$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ObjectSerializationDirectory_Entry$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.ObjectSerializationDirectory.Entry", [
            { no: 1, name: "locator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "offset", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "size", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value) {
        const message = { locator: "", offset: 0n, size: 0n };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string locator */ 1:
                    message.locator = reader.string();
                    break;
                case /* uint64 offset */ 2:
                    message.offset = reader.uint64().toBigInt();
                    break;
                case /* uint64 size */ 3:
                    message.size = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string locator = 1; */
        if (message.locator !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.locator);
        /* uint64 offset = 2; */
        if (message.offset !== 0n)
            writer.tag(2, runtime_1.WireType.Varint).uint64(message.offset);
        /* uint64 size = 3; */
        if (message.size !== 0n)
            writer.tag(3, runtime_1.WireType.Varint).uint64(message.size);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.ObjectSerializationDirectory.Entry
 */
exports.ObjectSerializationDirectory_Entry = new ObjectSerializationDirectory_Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataPropertiesEntryV1$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.DataPropertiesEntryV1", [
            { no: 1, name: "digest", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "expects_matched_digest", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "creation_time_interval_since_1970", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "creation_version", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "last_mismatched_digest", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value) {
        const message = { digest: new Uint8Array(0), creationVersion: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes digest */ 1:
                    message.digest = reader.bytes();
                    break;
                case /* optional bool expects_matched_digest */ 2:
                    message.expectsMatchedDigest = reader.bool();
                    break;
                case /* optional double creation_time_interval_since_1970 */ 3:
                    message.creationTimeIntervalSince1970 = reader.double();
                    break;
                case /* repeated uint32 creation_version = 4 [packed = true];*/ 4:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.creationVersion.push(reader.uint32());
                    else
                        message.creationVersion.push(reader.uint32());
                    break;
                case /* optional bytes last_mismatched_digest */ 5:
                    message.lastMismatchedDigest = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes digest = 1; */
        if (message.digest.length)
            writer.tag(1, runtime_1.WireType.LengthDelimited).bytes(message.digest);
        /* optional bool expects_matched_digest = 2; */
        if (message.expectsMatchedDigest !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.expectsMatchedDigest);
        /* optional double creation_time_interval_since_1970 = 3; */
        if (message.creationTimeIntervalSince1970 !== undefined)
            writer.tag(3, runtime_1.WireType.Bit64).double(message.creationTimeIntervalSince1970);
        /* repeated uint32 creation_version = 4 [packed = true]; */
        if (message.creationVersion.length) {
            writer.tag(4, runtime_1.WireType.LengthDelimited).fork();
            for (let i = 0; i < message.creationVersion.length; i++)
                writer.uint32(message.creationVersion[i]);
            writer.join();
        }
        /* optional bytes last_mismatched_digest = 5; */
        if (message.lastMismatchedDigest !== undefined)
            writer.tag(5, runtime_1.WireType.LengthDelimited).bytes(message.lastMismatchedDigest);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.DataPropertiesEntryV1
 */
exports.DataPropertiesEntryV1 = new DataPropertiesEntryV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataPropertiesV1$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.DataPropertiesV1", [
            { no: 1, name: "properties", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.DataPropertiesEntryV1 }
        ]);
    }
    create(value) {
        const message = { properties: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.DataPropertiesEntryV1 properties */ 1:
                    message.properties.push(exports.DataPropertiesEntryV1.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.DataPropertiesEntryV1 properties = 1; */
        for (let i = 0; i < message.properties.length; i++)
            exports.DataPropertiesEntryV1.internalBinaryWrite(message.properties[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.DataPropertiesV1
 */
exports.DataPropertiesV1 = new DataPropertiesV1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DocumentMetadata$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.DocumentMetadata", [
            { no: 1, name: "is_in_collaboration_mode", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "data_properties_v1", kind: "message", T: () => exports.DataPropertiesV1 }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool is_in_collaboration_mode */ 1:
                    message.isInCollaborationMode = reader.bool();
                    break;
                case /* optional TSP.DataPropertiesV1 data_properties_v1 */ 3:
                    message.dataPropertiesV1 = exports.DataPropertiesV1.internalBinaryRead(reader, reader.uint32(), options, message.dataPropertiesV1);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional bool is_in_collaboration_mode = 1; */
        if (message.isInCollaborationMode !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.isInCollaborationMode);
        /* optional TSP.DataPropertiesV1 data_properties_v1 = 3; */
        if (message.dataPropertiesV1)
            exports.DataPropertiesV1.internalBinaryWrite(message.dataPropertiesV1, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.DocumentMetadata
 */
exports.DocumentMetadata = new DocumentMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SupportMetadata$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.SupportMetadata", [
            { no: 1, name: "is_in_collaboration_mode", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "data_collaboration_properties", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.SupportMetadata_DataCollaborationProperties }
        ]);
    }
    create(value) {
        const message = { dataCollaborationProperties: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool is_in_collaboration_mode */ 1:
                    message.isInCollaborationMode = reader.bool();
                    break;
                case /* repeated TSP.SupportMetadata.DataCollaborationProperties data_collaboration_properties */ 2:
                    message.dataCollaborationProperties.push(exports.SupportMetadata_DataCollaborationProperties.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional bool is_in_collaboration_mode = 1; */
        if (message.isInCollaborationMode !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.isInCollaborationMode);
        /* repeated TSP.SupportMetadata.DataCollaborationProperties data_collaboration_properties = 2; */
        for (let i = 0; i < message.dataCollaborationProperties.length; i++)
            exports.SupportMetadata_DataCollaborationProperties.internalBinaryWrite(message.dataCollaborationProperties[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.SupportMetadata
 */
exports.SupportMetadata = new SupportMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SupportMetadata_DataCollaborationProperties$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.SupportMetadata.DataCollaborationProperties", [
            { no: 1, name: "digest", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "acknowledged_by_server", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "materialized_on_server", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "revision_sequence_for_materialized_on_server", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "upload_status", kind: "enum", opt: true, T: () => ["TSP.DataUploadStatus", TSPMessages_2.DataUploadStatus] },
            { no: 6, name: "is_remote_data_ever", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "revision_sequence_for_acknowledged_by_server", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = { digest: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes digest */ 1:
                    message.digest = reader.bytes();
                    break;
                case /* optional bool acknowledged_by_server */ 2:
                    message.acknowledgedByServer = reader.bool();
                    break;
                case /* optional bool materialized_on_server */ 3:
                    message.materializedOnServer = reader.bool();
                    break;
                case /* optional int32 revision_sequence_for_materialized_on_server */ 5:
                    message.revisionSequenceForMaterializedOnServer = reader.int32();
                    break;
                case /* optional TSP.DataUploadStatus upload_status */ 4:
                    message.uploadStatus = reader.int32();
                    break;
                case /* optional bool is_remote_data_ever */ 6:
                    message.isRemoteDataEver = reader.bool();
                    break;
                case /* optional int32 revision_sequence_for_acknowledged_by_server */ 7:
                    message.revisionSequenceForAcknowledgedByServer = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes digest = 1; */
        if (message.digest.length)
            writer.tag(1, runtime_1.WireType.LengthDelimited).bytes(message.digest);
        /* optional bool acknowledged_by_server = 2; */
        if (message.acknowledgedByServer !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.acknowledgedByServer);
        /* optional bool materialized_on_server = 3; */
        if (message.materializedOnServer !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.materializedOnServer);
        /* optional int32 revision_sequence_for_materialized_on_server = 5; */
        if (message.revisionSequenceForMaterializedOnServer !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).int32(message.revisionSequenceForMaterializedOnServer);
        /* optional TSP.DataUploadStatus upload_status = 4; */
        if (message.uploadStatus !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).int32(message.uploadStatus);
        /* optional bool is_remote_data_ever = 6; */
        if (message.isRemoteDataEver !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.isRemoteDataEver);
        /* optional int32 revision_sequence_for_acknowledged_by_server = 7; */
        if (message.revisionSequenceForAcknowledgedByServer !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).int32(message.revisionSequenceForAcknowledgedByServer);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.SupportMetadata.DataCollaborationProperties
 */
exports.SupportMetadata_DataCollaborationProperties = new SupportMetadata_DataCollaborationProperties$Type();
//# sourceMappingURL=TSPArchiveMessages.js.map