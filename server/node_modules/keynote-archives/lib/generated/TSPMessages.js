"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LargeUUIDArray = exports.LargeObjectArray = exports.LargeLazyObjectArray = exports.LargeStringArray = exports.LargeNumberArray = exports.LargeArray = exports.LargeObjectArraySegment = exports.LargeLazyObjectArraySegment = exports.LargeUUIDArraySegment = exports.LargeStringArraySegment_OptionalElement = exports.LargeStringArraySegment = exports.LargeNumberArraySegment = exports.LargeArraySegment = exports.DataAttributes = exports.ObjectContainer = exports.ObjectCollection = exports.PasteboardObject = exports.SparseUUIDPathArray_Entry = exports.SparseUUIDPathArray = exports.UUIDPath = exports.SparseUUIDArray_Entry = exports.SparseUUIDArray = exports.UUIDRectArchive = exports.UUIDCoordArchive = exports.UUIDMultiMapArchive = exports.UUIDMapArchive = exports.UUIDSetArchive = exports.CFUUIDArchive = exports.UUID = exports.ReferenceDictionary_Entry = exports.ReferenceDictionary = exports.Path_Element = exports.Path = exports.Color = exports.IndexSet = exports.Date = exports.Range = exports.Size = exports.Point = exports.SparseReferenceArray_Entry = exports.SparseReferenceArray = exports.DataReference = exports.Reference = exports.DataUploadStatus = exports.Path_ElementType = exports.Color_RGBColorSpace = exports.Color_ColorModel = void 0;
const runtime_1 = require("@protobuf-ts/runtime");
const runtime_2 = require("@protobuf-ts/runtime");
const runtime_3 = require("@protobuf-ts/runtime");
const runtime_4 = require("@protobuf-ts/runtime");
const runtime_5 = require("@protobuf-ts/runtime");
/**
 * @generated from protobuf enum TSP.Color.ColorModel
 */
var Color_ColorModel;
(function (Color_ColorModel) {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    Color_ColorModel[Color_ColorModel["UNSPECIFIED$"] = 0] = "UNSPECIFIED$";
    /**
     * @generated from protobuf enum value: rgb = 1;
     */
    Color_ColorModel[Color_ColorModel["rgb"] = 1] = "rgb";
    /**
     * @generated from protobuf enum value: cmyk = 2;
     */
    Color_ColorModel[Color_ColorModel["cmyk"] = 2] = "cmyk";
    /**
     * @generated from protobuf enum value: white = 3;
     */
    Color_ColorModel[Color_ColorModel["white"] = 3] = "white";
})(Color_ColorModel = exports.Color_ColorModel || (exports.Color_ColorModel = {}));
/**
 * @generated from protobuf enum TSP.Color.RGBColorSpace
 */
var Color_RGBColorSpace;
(function (Color_RGBColorSpace) {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    Color_RGBColorSpace[Color_RGBColorSpace["UNSPECIFIED$"] = 0] = "UNSPECIFIED$";
    /**
     * @generated from protobuf enum value: srgb = 1;
     */
    Color_RGBColorSpace[Color_RGBColorSpace["srgb"] = 1] = "srgb";
    /**
     * @generated from protobuf enum value: p3 = 2;
     */
    Color_RGBColorSpace[Color_RGBColorSpace["p3"] = 2] = "p3";
})(Color_RGBColorSpace = exports.Color_RGBColorSpace || (exports.Color_RGBColorSpace = {}));
/**
 * @generated from protobuf enum TSP.Path.ElementType
 */
var Path_ElementType;
(function (Path_ElementType) {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    Path_ElementType[Path_ElementType["UNSPECIFIED$"] = 0] = "UNSPECIFIED$";
    /**
     * @generated from protobuf enum value: moveTo = 1;
     */
    Path_ElementType[Path_ElementType["moveTo"] = 1] = "moveTo";
    /**
     * @generated from protobuf enum value: lineTo = 2;
     */
    Path_ElementType[Path_ElementType["lineTo"] = 2] = "lineTo";
    /**
     * @generated from protobuf enum value: quadCurveTo = 3;
     */
    Path_ElementType[Path_ElementType["quadCurveTo"] = 3] = "quadCurveTo";
    /**
     * @generated from protobuf enum value: curveTo = 4;
     */
    Path_ElementType[Path_ElementType["curveTo"] = 4] = "curveTo";
    /**
     * @generated from protobuf enum value: closeSubpath = 5;
     */
    Path_ElementType[Path_ElementType["closeSubpath"] = 5] = "closeSubpath";
})(Path_ElementType = exports.Path_ElementType || (exports.Path_ElementType = {}));
/**
 * @generated from protobuf enum TSP.DataUploadStatus
 */
var DataUploadStatus;
(function (DataUploadStatus) {
    /**
     * @generated from protobuf enum value: DataUploadStatus_Pending = 0;
     */
    DataUploadStatus[DataUploadStatus["DataUploadStatus_Pending"] = 0] = "DataUploadStatus_Pending";
    /**
     * @generated from protobuf enum value: DataUploadStatus_Reserved = 1;
     */
    DataUploadStatus[DataUploadStatus["DataUploadStatus_Reserved"] = 1] = "DataUploadStatus_Reserved";
    /**
     * @generated from protobuf enum value: DataUploadStatus_UnableToReserve = 2;
     */
    DataUploadStatus[DataUploadStatus["DataUploadStatus_UnableToReserve"] = 2] = "DataUploadStatus_UnableToReserve";
    /**
     * @generated from protobuf enum value: DataUploadStatus_Corrupted = 3;
     */
    DataUploadStatus[DataUploadStatus["DataUploadStatus_Corrupted"] = 3] = "DataUploadStatus_Corrupted";
    /**
     * @generated from protobuf enum value: DataUploadStatus_DocumentMayExceedDocumentSizeLimit = 4;
     */
    DataUploadStatus[DataUploadStatus["DataUploadStatus_DocumentMayExceedDocumentSizeLimit"] = 4] = "DataUploadStatus_DocumentMayExceedDocumentSizeLimit";
    /**
     * @generated from protobuf enum value: DataUploadStatus_Expired = 5;
     */
    DataUploadStatus[DataUploadStatus["DataUploadStatus_Expired"] = 5] = "DataUploadStatus_Expired";
})(DataUploadStatus = exports.DataUploadStatus || (exports.DataUploadStatus = {}));
// @generated message type with reflection information, may provide speed optimized methods
class Reference$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.Reference", [
            { no: 1, name: "identifier", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "deprecated_type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "deprecated_is_external", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { identifier: 0n };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 identifier */ 1:
                    message.identifier = reader.uint64().toBigInt();
                    break;
                case /* optional int32 deprecated_type */ 2:
                    message.deprecatedType = reader.int32();
                    break;
                case /* optional bool deprecated_is_external */ 3:
                    message.deprecatedIsExternal = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 identifier = 1; */
        if (message.identifier !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.identifier);
        /* optional int32 deprecated_type = 2; */
        if (message.deprecatedType !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.deprecatedType);
        /* optional bool deprecated_is_external = 3; */
        if (message.deprecatedIsExternal !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.deprecatedIsExternal);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.Reference
 */
exports.Reference = new Reference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataReference$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.DataReference", [
            { no: 1, name: "identifier", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value) {
        const message = { identifier: 0n };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 identifier */ 1:
                    message.identifier = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 identifier = 1; */
        if (message.identifier !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.identifier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.DataReference
 */
exports.DataReference = new DataReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SparseReferenceArray$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.SparseReferenceArray", [
            { no: 1, name: "count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.SparseReferenceArray_Entry }
        ]);
    }
    create(value) {
        const message = { count: 0, entries: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 count */ 1:
                    message.count = reader.uint32();
                    break;
                case /* repeated TSP.SparseReferenceArray.Entry entries */ 2:
                    message.entries.push(exports.SparseReferenceArray_Entry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 count = 1; */
        if (message.count !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.count);
        /* repeated TSP.SparseReferenceArray.Entry entries = 2; */
        for (let i = 0; i < message.entries.length; i++)
            exports.SparseReferenceArray_Entry.internalBinaryWrite(message.entries[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.SparseReferenceArray
 */
exports.SparseReferenceArray = new SparseReferenceArray$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SparseReferenceArray_Entry$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.SparseReferenceArray.Entry", [
            { no: 1, name: "index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "reference", kind: "message", T: () => exports.Reference }
        ]);
    }
    create(value) {
        const message = { index: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 index */ 1:
                    message.index = reader.uint32();
                    break;
                case /* TSP.Reference reference */ 2:
                    message.reference = exports.Reference.internalBinaryRead(reader, reader.uint32(), options, message.reference);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 index = 1; */
        if (message.index !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.index);
        /* TSP.Reference reference = 2; */
        if (message.reference)
            exports.Reference.internalBinaryWrite(message.reference, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.SparseReferenceArray.Entry
 */
exports.SparseReferenceArray_Entry = new SparseReferenceArray_Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Point$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.Point", [
            { no: 1, name: "x", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "y", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value) {
        const message = { x: 0, y: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float x */ 1:
                    message.x = reader.float();
                    break;
                case /* float y */ 2:
                    message.y = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* float x = 1; */
        if (message.x !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).float(message.x);
        /* float y = 2; */
        if (message.y !== 0)
            writer.tag(2, runtime_1.WireType.Bit32).float(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.Point
 */
exports.Point = new Point$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Size$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.Size", [
            { no: 1, name: "width", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "height", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value) {
        const message = { width: 0, height: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float width */ 1:
                    message.width = reader.float();
                    break;
                case /* float height */ 2:
                    message.height = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* float width = 1; */
        if (message.width !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).float(message.width);
        /* float height = 2; */
        if (message.height !== 0)
            writer.tag(2, runtime_1.WireType.Bit32).float(message.height);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.Size
 */
exports.Size = new Size$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Range$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.Range", [
            { no: 1, name: "location", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "length", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { location: 0, length: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 location */ 1:
                    message.location = reader.uint32();
                    break;
                case /* uint32 length */ 2:
                    message.length = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 location = 1; */
        if (message.location !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.location);
        /* uint32 length = 2; */
        if (message.length !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.length);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.Range
 */
exports.Range = new Range$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Date$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.Date", [
            { no: 1, name: "seconds", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value) {
        const message = { seconds: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double seconds */ 1:
                    message.seconds = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* double seconds = 1; */
        if (message.seconds !== 0)
            writer.tag(1, runtime_1.WireType.Bit64).double(message.seconds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.Date
 */
exports.Date = new Date$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IndexSet$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.IndexSet", [
            { no: 1, name: "ranges", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Range }
        ]);
    }
    create(value) {
        const message = { ranges: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.Range ranges */ 1:
                    message.ranges.push(exports.Range.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.Range ranges = 1; */
        for (let i = 0; i < message.ranges.length; i++)
            exports.Range.internalBinaryWrite(message.ranges[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.IndexSet
 */
exports.IndexSet = new IndexSet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Color$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.Color", [
            { no: 1, name: "model", kind: "enum", T: () => ["TSP.Color.ColorModel", Color_ColorModel] },
            { no: 3, name: "r", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "g", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "b", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "rgbspace", kind: "enum", opt: true, T: () => ["TSP.Color.RGBColorSpace", Color_RGBColorSpace] },
            { no: 6, name: "a", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "c", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "m", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "y", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "k", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "w", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value) {
        const message = { model: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.Color.ColorModel model */ 1:
                    message.model = reader.int32();
                    break;
                case /* optional float r */ 3:
                    message.r = reader.float();
                    break;
                case /* optional float g */ 4:
                    message.g = reader.float();
                    break;
                case /* optional float b */ 5:
                    message.b = reader.float();
                    break;
                case /* optional TSP.Color.RGBColorSpace rgbspace */ 12:
                    message.rgbspace = reader.int32();
                    break;
                case /* optional float a */ 6:
                    message.a = reader.float();
                    break;
                case /* optional float c */ 7:
                    message.c = reader.float();
                    break;
                case /* optional float m */ 8:
                    message.m = reader.float();
                    break;
                case /* optional float y */ 9:
                    message.y = reader.float();
                    break;
                case /* optional float k */ 10:
                    message.k = reader.float();
                    break;
                case /* optional float w */ 11:
                    message.w = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.Color.ColorModel model = 1; */
        if (message.model !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.model);
        /* optional float r = 3; */
        if (message.r !== undefined)
            writer.tag(3, runtime_1.WireType.Bit32).float(message.r);
        /* optional float g = 4; */
        if (message.g !== undefined)
            writer.tag(4, runtime_1.WireType.Bit32).float(message.g);
        /* optional float b = 5; */
        if (message.b !== undefined)
            writer.tag(5, runtime_1.WireType.Bit32).float(message.b);
        /* optional TSP.Color.RGBColorSpace rgbspace = 12; */
        if (message.rgbspace !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).int32(message.rgbspace);
        /* optional float a = 6; */
        if (message.a !== undefined)
            writer.tag(6, runtime_1.WireType.Bit32).float(message.a);
        /* optional float c = 7; */
        if (message.c !== undefined)
            writer.tag(7, runtime_1.WireType.Bit32).float(message.c);
        /* optional float m = 8; */
        if (message.m !== undefined)
            writer.tag(8, runtime_1.WireType.Bit32).float(message.m);
        /* optional float y = 9; */
        if (message.y !== undefined)
            writer.tag(9, runtime_1.WireType.Bit32).float(message.y);
        /* optional float k = 10; */
        if (message.k !== undefined)
            writer.tag(10, runtime_1.WireType.Bit32).float(message.k);
        /* optional float w = 11; */
        if (message.w !== undefined)
            writer.tag(11, runtime_1.WireType.Bit32).float(message.w);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.Color
 */
exports.Color = new Color$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Path$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.Path", [
            { no: 1, name: "elements", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Path_Element }
        ]);
    }
    create(value) {
        const message = { elements: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.Path.Element elements */ 1:
                    message.elements.push(exports.Path_Element.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.Path.Element elements = 1; */
        for (let i = 0; i < message.elements.length; i++)
            exports.Path_Element.internalBinaryWrite(message.elements[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.Path
 */
exports.Path = new Path$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Path_Element$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.Path.Element", [
            { no: 1, name: "type", kind: "enum", T: () => ["TSP.Path.ElementType", Path_ElementType] },
            { no: 2, name: "points", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Point }
        ]);
    }
    create(value) {
        const message = { type: 0, points: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.Path.ElementType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* repeated TSP.Point points */ 2:
                    message.points.push(exports.Point.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.Path.ElementType type = 1; */
        if (message.type !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.type);
        /* repeated TSP.Point points = 2; */
        for (let i = 0; i < message.points.length; i++)
            exports.Point.internalBinaryWrite(message.points[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.Path.Element
 */
exports.Path_Element = new Path_Element$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReferenceDictionary$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.ReferenceDictionary", [
            { no: 1, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ReferenceDictionary_Entry }
        ]);
    }
    create(value) {
        const message = { entries: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.ReferenceDictionary.Entry entries */ 1:
                    message.entries.push(exports.ReferenceDictionary_Entry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.ReferenceDictionary.Entry entries = 1; */
        for (let i = 0; i < message.entries.length; i++)
            exports.ReferenceDictionary_Entry.internalBinaryWrite(message.entries[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.ReferenceDictionary
 */
exports.ReferenceDictionary = new ReferenceDictionary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReferenceDictionary_Entry$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.ReferenceDictionary.Entry", [
            { no: 1, name: "key", kind: "message", T: () => exports.Reference },
            { no: 2, name: "value", kind: "message", T: () => exports.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.Reference key */ 1:
                    message.key = exports.Reference.internalBinaryRead(reader, reader.uint32(), options, message.key);
                    break;
                case /* TSP.Reference value */ 2:
                    message.value = exports.Reference.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.Reference key = 1; */
        if (message.key)
            exports.Reference.internalBinaryWrite(message.key, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference value = 2; */
        if (message.value)
            exports.Reference.internalBinaryWrite(message.value, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.ReferenceDictionary.Entry
 */
exports.ReferenceDictionary_Entry = new ReferenceDictionary_Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UUID$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.UUID", [
            { no: 1, name: "lower", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "upper", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value) {
        const message = { lower: 0n, upper: 0n };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 lower */ 1:
                    message.lower = reader.uint64().toBigInt();
                    break;
                case /* uint64 upper */ 2:
                    message.upper = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 lower = 1; */
        if (message.lower !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.lower);
        /* uint64 upper = 2; */
        if (message.upper !== 0n)
            writer.tag(2, runtime_1.WireType.Varint).uint64(message.upper);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.UUID
 */
exports.UUID = new UUID$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CFUUIDArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.CFUUIDArchive", [
            { no: 1, name: "uuid_bytes", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "uuid_w0", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "uuid_w1", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "uuid_w2", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "uuid_w3", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes uuid_bytes */ 1:
                    message.uuidBytes = reader.bytes();
                    break;
                case /* optional uint32 uuid_w0 */ 2:
                    message.uuidW0 = reader.uint32();
                    break;
                case /* optional uint32 uuid_w1 */ 3:
                    message.uuidW1 = reader.uint32();
                    break;
                case /* optional uint32 uuid_w2 */ 4:
                    message.uuidW2 = reader.uint32();
                    break;
                case /* optional uint32 uuid_w3 */ 5:
                    message.uuidW3 = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional bytes uuid_bytes = 1; */
        if (message.uuidBytes !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).bytes(message.uuidBytes);
        /* optional uint32 uuid_w0 = 2; */
        if (message.uuidW0 !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.uuidW0);
        /* optional uint32 uuid_w1 = 3; */
        if (message.uuidW1 !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.uuidW1);
        /* optional uint32 uuid_w2 = 4; */
        if (message.uuidW2 !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.uuidW2);
        /* optional uint32 uuid_w3 = 5; */
        if (message.uuidW3 !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.uuidW3);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.CFUUIDArchive
 */
exports.CFUUIDArchive = new CFUUIDArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UUIDSetArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.UUIDSetArchive", [
            { no: 1, name: "uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.UUID }
        ]);
    }
    create(value) {
        const message = { uids: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.UUID uids */ 1:
                    message.uids.push(exports.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.UUID uids = 1; */
        for (let i = 0; i < message.uids.length; i++)
            exports.UUID.internalBinaryWrite(message.uids[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.UUIDSetArchive
 */
exports.UUIDSetArchive = new UUIDSetArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UUIDMapArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.UUIDMapArchive", [
            { no: 1, name: "source", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.UUID },
            { no: 2, name: "target", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.UUID }
        ]);
    }
    create(value) {
        const message = { source: [], target: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.UUID source */ 1:
                    message.source.push(exports.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID target */ 2:
                    message.target.push(exports.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.UUID source = 1; */
        for (let i = 0; i < message.source.length; i++)
            exports.UUID.internalBinaryWrite(message.source[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID target = 2; */
        for (let i = 0; i < message.target.length; i++)
            exports.UUID.internalBinaryWrite(message.target[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.UUIDMapArchive
 */
exports.UUIDMapArchive = new UUIDMapArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UUIDMultiMapArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.UUIDMultiMapArchive", [
            { no: 1, name: "source", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.UUID },
            { no: 2, name: "target", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.UUID }
        ]);
    }
    create(value) {
        const message = { source: [], target: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.UUID source */ 1:
                    message.source.push(exports.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID target */ 2:
                    message.target.push(exports.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.UUID source = 1; */
        for (let i = 0; i < message.source.length; i++)
            exports.UUID.internalBinaryWrite(message.source[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID target = 2; */
        for (let i = 0; i < message.target.length; i++)
            exports.UUID.internalBinaryWrite(message.target[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.UUIDMultiMapArchive
 */
exports.UUIDMultiMapArchive = new UUIDMultiMapArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UUIDCoordArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.UUIDCoordArchive", [
            { no: 1, name: "row_uid", kind: "message", T: () => exports.UUID },
            { no: 2, name: "column_uid", kind: "message", T: () => exports.UUID }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID row_uid */ 1:
                    message.rowUid = exports.UUID.internalBinaryRead(reader, reader.uint32(), options, message.rowUid);
                    break;
                case /* TSP.UUID column_uid */ 2:
                    message.columnUid = exports.UUID.internalBinaryRead(reader, reader.uint32(), options, message.columnUid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID row_uid = 1; */
        if (message.rowUid)
            exports.UUID.internalBinaryWrite(message.rowUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID column_uid = 2; */
        if (message.columnUid)
            exports.UUID.internalBinaryWrite(message.columnUid, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.UUIDCoordArchive
 */
exports.UUIDCoordArchive = new UUIDCoordArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UUIDRectArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.UUIDRectArchive", [
            { no: 1, name: "column_uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.UUID },
            { no: 2, name: "row_uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.UUID }
        ]);
    }
    create(value) {
        const message = { columnUids: [], rowUids: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.UUID column_uids */ 1:
                    message.columnUids.push(exports.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID row_uids */ 2:
                    message.rowUids.push(exports.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.UUID column_uids = 1; */
        for (let i = 0; i < message.columnUids.length; i++)
            exports.UUID.internalBinaryWrite(message.columnUids[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID row_uids = 2; */
        for (let i = 0; i < message.rowUids.length; i++)
            exports.UUID.internalBinaryWrite(message.rowUids[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.UUIDRectArchive
 */
exports.UUIDRectArchive = new UUIDRectArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SparseUUIDArray$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.SparseUUIDArray", [
            { no: 1, name: "count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.SparseUUIDArray_Entry }
        ]);
    }
    create(value) {
        const message = { count: 0, entries: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 count */ 1:
                    message.count = reader.uint32();
                    break;
                case /* repeated TSP.SparseUUIDArray.Entry entries */ 2:
                    message.entries.push(exports.SparseUUIDArray_Entry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 count = 1; */
        if (message.count !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.count);
        /* repeated TSP.SparseUUIDArray.Entry entries = 2; */
        for (let i = 0; i < message.entries.length; i++)
            exports.SparseUUIDArray_Entry.internalBinaryWrite(message.entries[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.SparseUUIDArray
 */
exports.SparseUUIDArray = new SparseUUIDArray$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SparseUUIDArray_Entry$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.SparseUUIDArray.Entry", [
            { no: 1, name: "index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "uuid", kind: "message", T: () => exports.UUID }
        ]);
    }
    create(value) {
        const message = { index: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 index */ 1:
                    message.index = reader.uint32();
                    break;
                case /* TSP.UUID uuid */ 2:
                    message.uuid = exports.UUID.internalBinaryRead(reader, reader.uint32(), options, message.uuid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 index = 1; */
        if (message.index !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.index);
        /* TSP.UUID uuid = 2; */
        if (message.uuid)
            exports.UUID.internalBinaryWrite(message.uuid, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.SparseUUIDArray.Entry
 */
exports.SparseUUIDArray_Entry = new SparseUUIDArray_Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UUIDPath$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.UUIDPath", [
            { no: 1, name: "uuids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.UUID }
        ]);
    }
    create(value) {
        const message = { uuids: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.UUID uuids */ 1:
                    message.uuids.push(exports.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.UUID uuids = 1; */
        for (let i = 0; i < message.uuids.length; i++)
            exports.UUID.internalBinaryWrite(message.uuids[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.UUIDPath
 */
exports.UUIDPath = new UUIDPath$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SparseUUIDPathArray$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.SparseUUIDPathArray", [
            { no: 1, name: "count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.SparseUUIDPathArray_Entry }
        ]);
    }
    create(value) {
        const message = { count: 0, entries: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 count */ 1:
                    message.count = reader.uint32();
                    break;
                case /* repeated TSP.SparseUUIDPathArray.Entry entries */ 2:
                    message.entries.push(exports.SparseUUIDPathArray_Entry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 count = 1; */
        if (message.count !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.count);
        /* repeated TSP.SparseUUIDPathArray.Entry entries = 2; */
        for (let i = 0; i < message.entries.length; i++)
            exports.SparseUUIDPathArray_Entry.internalBinaryWrite(message.entries[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.SparseUUIDPathArray
 */
exports.SparseUUIDPathArray = new SparseUUIDPathArray$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SparseUUIDPathArray_Entry$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.SparseUUIDPathArray.Entry", [
            { no: 1, name: "index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "uuid_path", kind: "message", T: () => exports.UUIDPath }
        ]);
    }
    create(value) {
        const message = { index: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 index */ 1:
                    message.index = reader.uint32();
                    break;
                case /* TSP.UUIDPath uuid_path */ 2:
                    message.uuidPath = exports.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.uuidPath);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 index = 1; */
        if (message.index !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.index);
        /* TSP.UUIDPath uuid_path = 2; */
        if (message.uuidPath)
            exports.UUIDPath.internalBinaryWrite(message.uuidPath, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.SparseUUIDPathArray.Entry
 */
exports.SparseUUIDPathArray_Entry = new SparseUUIDPathArray_Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PasteboardObject$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.PasteboardObject", [
            { no: 1, name: "stylesheet", kind: "message", T: () => exports.Reference },
            { no: 2, name: "drawables", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Reference },
            { no: 3, name: "styles", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Reference },
            { no: 5, name: "wp_storage", kind: "message", T: () => exports.Reference },
            { no: 9, name: "guide_storage", kind: "message", T: () => exports.Reference },
            { no: 6, name: "app_native_object", kind: "message", T: () => exports.Reference },
            { no: 7, name: "is_text_primary", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "is_smart", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "presets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Reference },
            { no: 11, name: "top_level_objects", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Reference },
            { no: 12, name: "native_content_description", kind: "message", T: () => exports.Reference }
        ]);
    }
    create(value) {
        const message = { drawables: [], styles: [], presets: [], topLevelObjects: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference stylesheet */ 1:
                    message.stylesheet = exports.Reference.internalBinaryRead(reader, reader.uint32(), options, message.stylesheet);
                    break;
                case /* repeated TSP.Reference drawables */ 2:
                    message.drawables.push(exports.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference styles */ 3:
                    message.styles.push(exports.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Reference wp_storage */ 5:
                    message.wpStorage = exports.Reference.internalBinaryRead(reader, reader.uint32(), options, message.wpStorage);
                    break;
                case /* optional TSP.Reference guide_storage */ 9:
                    message.guideStorage = exports.Reference.internalBinaryRead(reader, reader.uint32(), options, message.guideStorage);
                    break;
                case /* optional TSP.Reference app_native_object */ 6:
                    message.appNativeObject = exports.Reference.internalBinaryRead(reader, reader.uint32(), options, message.appNativeObject);
                    break;
                case /* optional bool is_text_primary */ 7:
                    message.isTextPrimary = reader.bool();
                    break;
                case /* optional bool is_smart */ 8:
                    message.isSmart = reader.bool();
                    break;
                case /* repeated TSP.Reference presets */ 10:
                    message.presets.push(exports.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference top_level_objects */ 11:
                    message.topLevelObjects.push(exports.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Reference native_content_description */ 12:
                    message.nativeContentDescription = exports.Reference.internalBinaryRead(reader, reader.uint32(), options, message.nativeContentDescription);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference stylesheet = 1; */
        if (message.stylesheet)
            exports.Reference.internalBinaryWrite(message.stylesheet, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference drawables = 2; */
        for (let i = 0; i < message.drawables.length; i++)
            exports.Reference.internalBinaryWrite(message.drawables[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference styles = 3; */
        for (let i = 0; i < message.styles.length; i++)
            exports.Reference.internalBinaryWrite(message.styles[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference wp_storage = 5; */
        if (message.wpStorage)
            exports.Reference.internalBinaryWrite(message.wpStorage, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference guide_storage = 9; */
        if (message.guideStorage)
            exports.Reference.internalBinaryWrite(message.guideStorage, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference app_native_object = 6; */
        if (message.appNativeObject)
            exports.Reference.internalBinaryWrite(message.appNativeObject, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_text_primary = 7; */
        if (message.isTextPrimary !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.isTextPrimary);
        /* optional bool is_smart = 8; */
        if (message.isSmart !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.isSmart);
        /* repeated TSP.Reference presets = 10; */
        for (let i = 0; i < message.presets.length; i++)
            exports.Reference.internalBinaryWrite(message.presets[i], writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference top_level_objects = 11; */
        for (let i = 0; i < message.topLevelObjects.length; i++)
            exports.Reference.internalBinaryWrite(message.topLevelObjects[i], writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference native_content_description = 12; */
        if (message.nativeContentDescription)
            exports.Reference.internalBinaryWrite(message.nativeContentDescription, writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.PasteboardObject
 */
exports.PasteboardObject = new PasteboardObject$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ObjectCollection$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.ObjectCollection", [
            { no: 1, name: "objects", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Reference }
        ]);
    }
    create(value) {
        const message = { objects: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.Reference objects */ 1:
                    message.objects.push(exports.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.Reference objects = 1; */
        for (let i = 0; i < message.objects.length; i++)
            exports.Reference.internalBinaryWrite(message.objects[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.ObjectCollection
 */
exports.ObjectCollection = new ObjectCollection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ObjectContainer$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.ObjectContainer", [
            { no: 1, name: "identifier", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "objects", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Reference }
        ]);
    }
    create(value) {
        const message = { objects: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 identifier */ 1:
                    message.identifier = reader.uint32();
                    break;
                case /* repeated TSP.Reference objects */ 2:
                    message.objects.push(exports.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional uint32 identifier = 1; */
        if (message.identifier !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.identifier);
        /* repeated TSP.Reference objects = 2; */
        for (let i = 0; i < message.objects.length; i++)
            exports.Reference.internalBinaryWrite(message.objects[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.ObjectContainer
 */
exports.ObjectContainer = new ObjectContainer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataAttributes$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.DataAttributes", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.DataAttributes
 */
exports.DataAttributes = new DataAttributes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LargeArraySegment$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.LargeArraySegment", [
            { no: 1, name: "should_delay_archiving", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "delayed_archiving_priority", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "package_locator", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool should_delay_archiving */ 1:
                    message.shouldDelayArchiving = reader.bool();
                    break;
                case /* optional uint32 delayed_archiving_priority */ 2:
                    message.delayedArchivingPriority = reader.uint32();
                    break;
                case /* optional string package_locator */ 3:
                    message.packageLocator = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional bool should_delay_archiving = 1; */
        if (message.shouldDelayArchiving !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.shouldDelayArchiving);
        /* optional uint32 delayed_archiving_priority = 2; */
        if (message.delayedArchivingPriority !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.delayedArchivingPriority);
        /* optional string package_locator = 3; */
        if (message.packageLocator !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.packageLocator);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.LargeArraySegment
 */
exports.LargeArraySegment = new LargeArraySegment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LargeNumberArraySegment$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.LargeNumberArraySegment", [
            { no: 1, name: "large_array_segment", kind: "message", T: () => exports.LargeArraySegment },
            { no: 2, name: "elements", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value) {
        const message = { elements: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.LargeArraySegment large_array_segment */ 1:
                    message.largeArraySegment = exports.LargeArraySegment.internalBinaryRead(reader, reader.uint32(), options, message.largeArraySegment);
                    break;
                case /* repeated double elements */ 2:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.elements.push(reader.double());
                    else
                        message.elements.push(reader.double());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.LargeArraySegment large_array_segment = 1; */
        if (message.largeArraySegment)
            exports.LargeArraySegment.internalBinaryWrite(message.largeArraySegment, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated double elements = 2; */
        for (let i = 0; i < message.elements.length; i++)
            writer.tag(2, runtime_1.WireType.Bit64).double(message.elements[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.LargeNumberArraySegment
 */
exports.LargeNumberArraySegment = new LargeNumberArraySegment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LargeStringArraySegment$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.LargeStringArraySegment", [
            { no: 1, name: "large_array_segment", kind: "message", T: () => exports.LargeArraySegment },
            { no: 2, name: "elements", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.LargeStringArraySegment_OptionalElement }
        ]);
    }
    create(value) {
        const message = { elements: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.LargeArraySegment large_array_segment */ 1:
                    message.largeArraySegment = exports.LargeArraySegment.internalBinaryRead(reader, reader.uint32(), options, message.largeArraySegment);
                    break;
                case /* repeated TSP.LargeStringArraySegment.OptionalElement elements */ 2:
                    message.elements.push(exports.LargeStringArraySegment_OptionalElement.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.LargeArraySegment large_array_segment = 1; */
        if (message.largeArraySegment)
            exports.LargeArraySegment.internalBinaryWrite(message.largeArraySegment, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.LargeStringArraySegment.OptionalElement elements = 2; */
        for (let i = 0; i < message.elements.length; i++)
            exports.LargeStringArraySegment_OptionalElement.internalBinaryWrite(message.elements[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.LargeStringArraySegment
 */
exports.LargeStringArraySegment = new LargeStringArraySegment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LargeStringArraySegment_OptionalElement$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.LargeStringArraySegment.OptionalElement", [
            { no: 1, name: "element", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string element */ 1:
                    message.element = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string element = 1; */
        if (message.element !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.element);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.LargeStringArraySegment.OptionalElement
 */
exports.LargeStringArraySegment_OptionalElement = new LargeStringArraySegment_OptionalElement$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LargeUUIDArraySegment$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.LargeUUIDArraySegment", [
            { no: 1, name: "large_array_segment", kind: "message", T: () => exports.LargeArraySegment },
            { no: 2, name: "elements", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.UUID }
        ]);
    }
    create(value) {
        const message = { elements: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.LargeArraySegment large_array_segment */ 1:
                    message.largeArraySegment = exports.LargeArraySegment.internalBinaryRead(reader, reader.uint32(), options, message.largeArraySegment);
                    break;
                case /* repeated TSP.UUID elements */ 2:
                    message.elements.push(exports.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.LargeArraySegment large_array_segment = 1; */
        if (message.largeArraySegment)
            exports.LargeArraySegment.internalBinaryWrite(message.largeArraySegment, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID elements = 2; */
        for (let i = 0; i < message.elements.length; i++)
            exports.UUID.internalBinaryWrite(message.elements[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.LargeUUIDArraySegment
 */
exports.LargeUUIDArraySegment = new LargeUUIDArraySegment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LargeLazyObjectArraySegment$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.LargeLazyObjectArraySegment", [
            { no: 1, name: "large_array_segment", kind: "message", T: () => exports.LargeArraySegment },
            { no: 2, name: "elements", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Reference }
        ]);
    }
    create(value) {
        const message = { elements: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.LargeArraySegment large_array_segment */ 1:
                    message.largeArraySegment = exports.LargeArraySegment.internalBinaryRead(reader, reader.uint32(), options, message.largeArraySegment);
                    break;
                case /* repeated TSP.Reference elements */ 2:
                    message.elements.push(exports.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.LargeArraySegment large_array_segment = 1; */
        if (message.largeArraySegment)
            exports.LargeArraySegment.internalBinaryWrite(message.largeArraySegment, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference elements = 2; */
        for (let i = 0; i < message.elements.length; i++)
            exports.Reference.internalBinaryWrite(message.elements[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.LargeLazyObjectArraySegment
 */
exports.LargeLazyObjectArraySegment = new LargeLazyObjectArraySegment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LargeObjectArraySegment$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.LargeObjectArraySegment", [
            { no: 1, name: "large_array_segment", kind: "message", T: () => exports.LargeArraySegment },
            { no: 2, name: "elements", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Reference }
        ]);
    }
    create(value) {
        const message = { elements: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.LargeArraySegment large_array_segment */ 1:
                    message.largeArraySegment = exports.LargeArraySegment.internalBinaryRead(reader, reader.uint32(), options, message.largeArraySegment);
                    break;
                case /* repeated TSP.Reference elements */ 2:
                    message.elements.push(exports.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.LargeArraySegment large_array_segment = 1; */
        if (message.largeArraySegment)
            exports.LargeArraySegment.internalBinaryWrite(message.largeArraySegment, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference elements = 2; */
        for (let i = 0; i < message.elements.length; i++)
            exports.Reference.internalBinaryWrite(message.elements[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.LargeObjectArraySegment
 */
exports.LargeObjectArraySegment = new LargeObjectArraySegment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LargeArray$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.LargeArray", [
            { no: 1, name: "ranges", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Range },
            { no: 2, name: "segments", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.Reference },
            { no: 3, name: "max_segment_element_count", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "max_segment_size", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "should_delay_archiving", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "delayed_archiving_priority", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "store_outside_object_archive", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "estimated_byte_size", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "max_segment_cost", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value) {
        const message = { ranges: [], segments: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.Range ranges */ 1:
                    message.ranges.push(exports.Range.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference segments */ 2:
                    message.segments.push(exports.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint64 max_segment_element_count */ 3:
                    message.maxSegmentElementCount = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 max_segment_size */ 4:
                    message.maxSegmentSize = reader.uint64().toBigInt();
                    break;
                case /* optional bool should_delay_archiving */ 5:
                    message.shouldDelayArchiving = reader.bool();
                    break;
                case /* optional uint32 delayed_archiving_priority */ 6:
                    message.delayedArchivingPriority = reader.uint32();
                    break;
                case /* optional bool store_outside_object_archive */ 7:
                    message.storeOutsideObjectArchive = reader.bool();
                    break;
                case /* optional uint64 estimated_byte_size */ 8:
                    message.estimatedByteSize = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 max_segment_cost */ 9:
                    message.maxSegmentCost = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.Range ranges = 1; */
        for (let i = 0; i < message.ranges.length; i++)
            exports.Range.internalBinaryWrite(message.ranges[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference segments = 2; */
        for (let i = 0; i < message.segments.length; i++)
            exports.Reference.internalBinaryWrite(message.segments[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint64 max_segment_element_count = 3; */
        if (message.maxSegmentElementCount !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint64(message.maxSegmentElementCount);
        /* optional uint64 max_segment_size = 4; */
        if (message.maxSegmentSize !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint64(message.maxSegmentSize);
        /* optional bool should_delay_archiving = 5; */
        if (message.shouldDelayArchiving !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.shouldDelayArchiving);
        /* optional uint32 delayed_archiving_priority = 6; */
        if (message.delayedArchivingPriority !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).uint32(message.delayedArchivingPriority);
        /* optional bool store_outside_object_archive = 7; */
        if (message.storeOutsideObjectArchive !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.storeOutsideObjectArchive);
        /* optional uint64 estimated_byte_size = 8; */
        if (message.estimatedByteSize !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).uint64(message.estimatedByteSize);
        /* optional uint64 max_segment_cost = 9; */
        if (message.maxSegmentCost !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).uint64(message.maxSegmentCost);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.LargeArray
 */
exports.LargeArray = new LargeArray$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LargeNumberArray$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.LargeNumberArray", [
            { no: 1, name: "large_array", kind: "message", T: () => exports.LargeArray }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.LargeArray large_array */ 1:
                    message.largeArray = exports.LargeArray.internalBinaryRead(reader, reader.uint32(), options, message.largeArray);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.LargeArray large_array = 1; */
        if (message.largeArray)
            exports.LargeArray.internalBinaryWrite(message.largeArray, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.LargeNumberArray
 */
exports.LargeNumberArray = new LargeNumberArray$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LargeStringArray$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.LargeStringArray", [
            { no: 1, name: "large_array", kind: "message", T: () => exports.LargeArray }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.LargeArray large_array */ 1:
                    message.largeArray = exports.LargeArray.internalBinaryRead(reader, reader.uint32(), options, message.largeArray);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.LargeArray large_array = 1; */
        if (message.largeArray)
            exports.LargeArray.internalBinaryWrite(message.largeArray, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.LargeStringArray
 */
exports.LargeStringArray = new LargeStringArray$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LargeLazyObjectArray$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.LargeLazyObjectArray", [
            { no: 1, name: "large_array", kind: "message", T: () => exports.LargeArray }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.LargeArray large_array */ 1:
                    message.largeArray = exports.LargeArray.internalBinaryRead(reader, reader.uint32(), options, message.largeArray);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.LargeArray large_array = 1; */
        if (message.largeArray)
            exports.LargeArray.internalBinaryWrite(message.largeArray, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.LargeLazyObjectArray
 */
exports.LargeLazyObjectArray = new LargeLazyObjectArray$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LargeObjectArray$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.LargeObjectArray", [
            { no: 1, name: "large_array", kind: "message", T: () => exports.LargeArray }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.LargeArray large_array */ 1:
                    message.largeArray = exports.LargeArray.internalBinaryRead(reader, reader.uint32(), options, message.largeArray);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.LargeArray large_array = 1; */
        if (message.largeArray)
            exports.LargeArray.internalBinaryWrite(message.largeArray, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.LargeObjectArray
 */
exports.LargeObjectArray = new LargeObjectArray$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LargeUUIDArray$Type extends runtime_5.MessageType {
    constructor() {
        super("TSP.LargeUUIDArray", [
            { no: 1, name: "large_array", kind: "message", T: () => exports.LargeArray }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.LargeArray large_array */ 1:
                    message.largeArray = exports.LargeArray.internalBinaryRead(reader, reader.uint32(), options, message.largeArray);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.LargeArray large_array = 1; */
        if (message.largeArray)
            exports.LargeArray.internalBinaryWrite(message.largeArray, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSP.LargeUUIDArray
 */
exports.LargeUUIDArray = new LargeUUIDArray$Type();
//# sourceMappingURL=TSPMessages.js.map