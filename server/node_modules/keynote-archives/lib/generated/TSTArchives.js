"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TableGroupSortOrderUIDArchive = exports.TableStyleNetworkArchive = exports.WPTableInfoArchive = exports.CategoryInfoArchive = exports.TableInfoArchive = exports.DataStore = exports.HeaderStorage = exports.HeaderStorageBucket_Header = exports.HeaderStorageBucket = exports.TableRBTree_Node = exports.TableRBTree = exports.TableDataListSegment = exports.TableDataList_ListEntry = exports.TableDataList = exports.ImportWarningSetByCellRefArchive = exports.CellRefImportWarningSetPairArchive = exports.ImportWarningSetArchive_FormulaImportWarning = exports.ImportWarningSetArchive = exports.PopUpMenuModel_CellValue = exports.PopUpMenuModel = exports.TileStorage_Tile = exports.TileStorage = exports.Tile = exports.TileRowInfo = exports.TableSelection = exports.ExpandedCellRange = exports.CellRange = exports.ExpandedTableSize = exports.TableSize = exports.CellUIDListArchive = exports.CellUIDLookupListArchive = exports.CellID = exports.HideShowActionArchive = exports.MergeActionArchive = exports.FillDirectionArchive = exports.SelectionTypeArchive = exports.TableDimensionArchive = exports.CellValueType = exports.CellType = exports.MultiTableRemapperArchive_Purpose = exports.HiddenStateExtentArchive_RowOrColumnDirection = exports.FilterSetArchive_FilterSetType = exports.TableSortOrderUIDArchive_SortType = exports.TableSortOrderUIDArchive_SortRuleArchive_Direction = exports.TableSortOrderArchive_SortType = exports.TableSortOrderArchive_SortRuleArchive_Direction = exports.TableGroupSortOrderUIDArchive_GroupSortRuleUIDArchive_Direction = exports.TableDataList_ListType = exports.ImportWarningSetArchive_FormulaWarningType = exports.PopUpMenuModel_CellValueType = void 0;
exports.FormulaPredArgDataArchive = exports.CellStyleArchive = exports.TableStyleArchive = exports.FilterRuleArchive = exports.FilterRulePrePivotArchive = exports.AutofillSelectionArchive = exports.TableNameSelectionArchive = exports.StockCellSelectionArchive = exports.ControlCellSelectionArchive = exports.StrokeSelectionArchive = exports.DeathhawkRdar39989167CellSelectionArchive = exports.SelectionArchive = exports.StyleTableMapArchive_StyleTableMapEntryArchive = exports.StyleTableMapArchive = exports.DoubleStyleMapArchive_DoubleStyleMapEntryArchive = exports.DoubleStyleMapArchive = exports.HierarchicalCellDiffMapArchive_BoxedRow = exports.HierarchicalCellDiffMapArchive = exports.CellDiffMapArchive = exports.CellDiffArraySegment = exports.CellDiffArray = exports.CellDiffArchive = exports.CommentStorageWrapperArchive = exports.CellSpecArchive = exports.CellFormatAndValueArchive = exports.ConcurrentCellListArchive_OptionalCell = exports.ConcurrentCellListArchive = exports.ConcurrentCellMapArchive = exports.CellListArchive_OptionalCell = exports.CellListArchive = exports.CellMapArchive = exports.MergeRegionMapArchive = exports.Cell = exports.DurationWrapperArchive = exports.StrokeSidecarArchive = exports.StrokeLayerArchive_StrokeRunArchive = exports.StrokeLayerArchive = exports.ColumnRowUIDMapArchive = exports.SummaryModelGroupByChangeStateArchive = exports.SummaryModelArchive = exports.TableModelArchive = exports.StructuredTextImportRecord = exports.CellUIDRegionArchive = exports.CellRegion = exports.SortRuleReferenceTrackerArchive = exports.TableSortOrderUIDArchive_SortRuleArchive = exports.TableSortOrderUIDArchive = exports.TableSortOrderArchive_SortRuleArchive = exports.TableSortOrderArchive = exports.TableGroupSortOrderUIDArchive_GroupSortRuleUIDArchive = void 0;
exports.ColumnAggregateArchive = exports.GroupColumnListArchive = exports.GroupColumnArchive = exports.AccumulatorArchive = exports.PencilAnnotationOwnerArchive = exports.PencilAnnotationArchive = exports.MergeOwnerArchive = exports.MergeOperationArchive = exports.FormulaStoreArchive_FormulaStorePair = exports.FormulaStoreArchive = exports.HiddenStateFormulaOwnerArchive = exports.CompletionTokenAttachmentArchive = exports.LayoutHintArchive = exports.VariableNodeArchive = exports.InNodeArchive = exports.LetNodeArchive = exports.EmptyExpressionNodeArchive = exports.ArgumentPlaceholderNodeArchive = exports.DurationNodeArchive = exports.ReferenceNodeArchive = exports.DateNodeArchive = exports.FunctionEndNodeArchive = exports.FunctionNodeArchive = exports.PrefixOperatorNodeArchive = exports.PostfixOperatorNodeArchive = exports.OperatorNodeArchive = exports.ListNodeArchive = exports.ArrayNodeArchive = exports.IdentifierNodeArchive = exports.StringNodeArchive = exports.NumberNodeArchive = exports.BooleanNodeArchive = exports.ExpressionNodeArchive = exports.FormulaArchive = exports.TokenAttachmentArchive = exports.ExpandCollapseStateArchive = exports.HiddenStatesOwnerArchive = exports.HiddenStatesArchive = exports.HiddenStateExtentArchive_RowOrColumnState = exports.HiddenStateExtentArchive = exports.UniqueIndexArchive_UniqueIndexEntryArchive = exports.UniqueIndexArchive = exports.FilterSetArchive = exports.ConditionalStyleSetArchive_ConditionalStyleRules = exports.ConditionalStyleSetArchive_ConditionalStyleRule = exports.ConditionalStyleSetArchive_ConditionalStyleRulePrePivot = exports.ConditionalStyleSetArchive = exports.FormulaPredicateArchive = exports.FormulaPredicatePrePivotArchive = exports.FormulaPredArgArchive = void 0;
exports.CollaboratorTableCursorSubselectionArchive = exports.LayoutEngineArchive = exports.WidthHeightCache = exports.WidthHeightCacheFittingEntry = exports.HeaderNameMgrArchive_PerTableArchive = exports.HeaderNameMgrArchive = exports.HeaderNameMgrTileArchive_NameFragmentArchive = exports.HeaderNameMgrTileArchive = exports.PivotOrderArchive = exports.CategoryOrderArchive = exports.SummaryCellVendorArchive_SummaryCellEntry = exports.SummaryCellVendorArchive = exports.ChangePropagationMapWrapper = exports.MultiTableRemapperArchive = exports.DefaultCellStylesContainerArchive = exports.CellBorderArchive = exports.FormulaSelectionArchive = exports.CellFillStandIn = exports.FormulaEqualsTokenAttachmentArchive = exports.RichTextPayloadArchive = exports.PivotOwnerArchive = exports.PivotGroupingColumnOptionsMapArchive = exports.CategoryOwnerRefArchive = exports.CategoryOwnerArchive = exports.GroupByArchive_GroupNodeArchive_FormatManagerArchive_RowSetArchive = exports.GroupByArchive_GroupNodeArchive_FormatManagerArchive = exports.GroupByArchive_GroupNodeArchive = exports.GroupByArchive_AggregatorArchive = exports.GroupByArchive_AggNodeArchive = exports.GroupByArchive = exports.ColumnAggregateListArchive = void 0;
const runtime_1 = require("@protobuf-ts/runtime");
const runtime_2 = require("@protobuf-ts/runtime");
const runtime_3 = require("@protobuf-ts/runtime");
const runtime_4 = require("@protobuf-ts/runtime");
const runtime_5 = require("@protobuf-ts/runtime");
const TSCEArchives_1 = require("./TSCEArchives");
const TSPMessages_1 = require("./TSPMessages");
const TSCEArchives_2 = require("./TSCEArchives");
const TSWPArchives_1 = require("./TSWPArchives");
const TSDArchives_1 = require("./TSDArchives");
const TSCEArchives_3 = require("./TSCEArchives");
const TSPMessages_2 = require("./TSPMessages");
const TSCEArchives_4 = require("./TSCEArchives");
const TSWPArchives_2 = require("./TSWPArchives");
const TSCEArchives_5 = require("./TSCEArchives");
const TSCEArchives_6 = require("./TSCEArchives");
const TSCEArchives_7 = require("./TSCEArchives");
const TSCEArchives_8 = require("./TSCEArchives");
const TSCEArchives_9 = require("./TSCEArchives");
const TSTStylePropertyArchiving_1 = require("./TSTStylePropertyArchiving");
const TSTStylePropertyArchiving_2 = require("./TSTStylePropertyArchiving");
const TSSArchives_1 = require("./TSSArchives");
const TSPMessages_3 = require("./TSPMessages");
const TSPMessages_4 = require("./TSPMessages");
const TSPMessages_5 = require("./TSPMessages");
const TSPMessages_6 = require("./TSPMessages");
const TSSArchives_2 = require("./TSSArchives");
const TSDArchives_2 = require("./TSDArchives");
const TSCEArchives_10 = require("./TSCEArchives");
const TSPMessages_7 = require("./TSPMessages");
const TSKArchives_1 = require("./TSKArchives");
const TSPMessages_8 = require("./TSPMessages");
const TSCEArchives_11 = require("./TSCEArchives");
const TSDArchives_3 = require("./TSDArchives");
const TSPMessages_9 = require("./TSPMessages");
const TSKArchives_2 = require("./TSKArchives");
const TSKArchives_3 = require("./TSKArchives");
const TSCEArchives_12 = require("./TSCEArchives");
const TSCEArchives_13 = require("./TSCEArchives");
const TSCEArchives_14 = require("./TSCEArchives");
const TSCEArchives_15 = require("./TSCEArchives");
const TSCEArchives_16 = require("./TSCEArchives");
const TSCEArchives_17 = require("./TSCEArchives");
const TSCEArchives_18 = require("./TSCEArchives");
const TSPMessages_10 = require("./TSPMessages");
const TSPMessages_11 = require("./TSPMessages");
const TSCEArchives_19 = require("./TSCEArchives");
const TSCEArchives_20 = require("./TSCEArchives");
/**
 * @generated from protobuf enum TST.PopUpMenuModel.CellValueType
 */
var PopUpMenuModel_CellValueType;
(function (PopUpMenuModel_CellValueType) {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    PopUpMenuModel_CellValueType[PopUpMenuModel_CellValueType["UNSPECIFIED$"] = 0] = "UNSPECIFIED$";
    /**
     * @generated from protobuf enum value: NIL_TYPE = 1;
     */
    PopUpMenuModel_CellValueType[PopUpMenuModel_CellValueType["NIL_TYPE"] = 1] = "NIL_TYPE";
    /**
     * @generated from protobuf enum value: BOOLEAN_TYPE = 2;
     */
    PopUpMenuModel_CellValueType[PopUpMenuModel_CellValueType["BOOLEAN_TYPE"] = 2] = "BOOLEAN_TYPE";
    /**
     * @generated from protobuf enum value: DATE_TYPE = 3;
     */
    PopUpMenuModel_CellValueType[PopUpMenuModel_CellValueType["DATE_TYPE"] = 3] = "DATE_TYPE";
    /**
     * @generated from protobuf enum value: NUMBER_TYPE = 4;
     */
    PopUpMenuModel_CellValueType[PopUpMenuModel_CellValueType["NUMBER_TYPE"] = 4] = "NUMBER_TYPE";
    /**
     * @generated from protobuf enum value: STRING_TYPE = 5;
     */
    PopUpMenuModel_CellValueType[PopUpMenuModel_CellValueType["STRING_TYPE"] = 5] = "STRING_TYPE";
})(PopUpMenuModel_CellValueType = exports.PopUpMenuModel_CellValueType || (exports.PopUpMenuModel_CellValueType = {}));
/**
 * @generated from protobuf enum TST.ImportWarningSetArchive.FormulaWarningType
 */
var ImportWarningSetArchive_FormulaWarningType;
(function (ImportWarningSetArchive_FormulaWarningType) {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    ImportWarningSetArchive_FormulaWarningType[ImportWarningSetArchive_FormulaWarningType["UNSPECIFIED$"] = 0] = "UNSPECIFIED$";
    /**
     * @generated from protobuf enum value: THREE_D_REFERENCE = 1;
     */
    ImportWarningSetArchive_FormulaWarningType[ImportWarningSetArchive_FormulaWarningType["THREE_D_REFERENCE"] = 1] = "THREE_D_REFERENCE";
    /**
     * @generated from protobuf enum value: ARRAYED_FORMULA = 2;
     */
    ImportWarningSetArchive_FormulaWarningType[ImportWarningSetArchive_FormulaWarningType["ARRAYED_FORMULA"] = 2] = "ARRAYED_FORMULA";
    /**
     * @generated from protobuf enum value: DIFFERENT_BEHAVIOR_FOR_FUNCTION = 3;
     */
    ImportWarningSetArchive_FormulaWarningType[ImportWarningSetArchive_FormulaWarningType["DIFFERENT_BEHAVIOR_FOR_FUNCTION"] = 3] = "DIFFERENT_BEHAVIOR_FOR_FUNCTION";
    /**
     * @generated from protobuf enum value: ERROR_TOKEN = 4;
     */
    ImportWarningSetArchive_FormulaWarningType[ImportWarningSetArchive_FormulaWarningType["ERROR_TOKEN"] = 4] = "ERROR_TOKEN";
    /**
     * @generated from protobuf enum value: EXTERNAL_REFERENCE = 5;
     */
    ImportWarningSetArchive_FormulaWarningType[ImportWarningSetArchive_FormulaWarningType["EXTERNAL_REFERENCE"] = 5] = "EXTERNAL_REFERENCE";
    /**
     * @generated from protobuf enum value: NATURAL_LANGUAGE_FORMULA = 6;
     */
    ImportWarningSetArchive_FormulaWarningType[ImportWarningSetArchive_FormulaWarningType["NATURAL_LANGUAGE_FORMULA"] = 6] = "NATURAL_LANGUAGE_FORMULA";
    /**
     * @generated from protobuf enum value: REFERENCE_OUT_OF_BOUNDS = 7;
     */
    ImportWarningSetArchive_FormulaWarningType[ImportWarningSetArchive_FormulaWarningType["REFERENCE_OUT_OF_BOUNDS"] = 7] = "REFERENCE_OUT_OF_BOUNDS";
    /**
     * @generated from protobuf enum value: SHARED_FORMULA_BASE_NOT_FOUND = 8;
     */
    ImportWarningSetArchive_FormulaWarningType[ImportWarningSetArchive_FormulaWarningType["SHARED_FORMULA_BASE_NOT_FOUND"] = 8] = "SHARED_FORMULA_BASE_NOT_FOUND";
    /**
     * @generated from protobuf enum value: UNKNOWN_NAME = 9;
     */
    ImportWarningSetArchive_FormulaWarningType[ImportWarningSetArchive_FormulaWarningType["UNKNOWN_NAME"] = 9] = "UNKNOWN_NAME";
    /**
     * @generated from protobuf enum value: UNSUPPORTED_FORMULA = 10;
     */
    ImportWarningSetArchive_FormulaWarningType[ImportWarningSetArchive_FormulaWarningType["UNSUPPORTED_FORMULA"] = 10] = "UNSUPPORTED_FORMULA";
    /**
     * @generated from protobuf enum value: UNSUPPORTED_FUNCTION = 11;
     */
    ImportWarningSetArchive_FormulaWarningType[ImportWarningSetArchive_FormulaWarningType["UNSUPPORTED_FUNCTION"] = 11] = "UNSUPPORTED_FUNCTION";
    /**
     * @generated from protobuf enum value: UNSUPPORTED_NAME = 12;
     */
    ImportWarningSetArchive_FormulaWarningType[ImportWarningSetArchive_FormulaWarningType["UNSUPPORTED_NAME"] = 12] = "UNSUPPORTED_NAME";
    /**
     * @generated from protobuf enum value: TRANSPOSED_NO_ISSUES = 13;
     */
    ImportWarningSetArchive_FormulaWarningType[ImportWarningSetArchive_FormulaWarningType["TRANSPOSED_NO_ISSUES"] = 13] = "TRANSPOSED_NO_ISSUES";
    /**
     * @generated from protobuf enum value: TRANSPOSED_WITH_ISSUES = 14;
     */
    ImportWarningSetArchive_FormulaWarningType[ImportWarningSetArchive_FormulaWarningType["TRANSPOSED_WITH_ISSUES"] = 14] = "TRANSPOSED_WITH_ISSUES";
    /**
     * @generated from protobuf enum value: TRANSPOSED_WITH_ISSUES_UNCHANGED = 15;
     */
    ImportWarningSetArchive_FormulaWarningType[ImportWarningSetArchive_FormulaWarningType["TRANSPOSED_WITH_ISSUES_UNCHANGED"] = 15] = "TRANSPOSED_WITH_ISSUES_UNCHANGED";
})(ImportWarningSetArchive_FormulaWarningType = exports.ImportWarningSetArchive_FormulaWarningType || (exports.ImportWarningSetArchive_FormulaWarningType = {}));
/**
 * @generated from protobuf enum TST.TableDataList.ListType
 */
var TableDataList_ListType;
(function (TableDataList_ListType) {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    TableDataList_ListType[TableDataList_ListType["UNSPECIFIED$"] = 0] = "UNSPECIFIED$";
    /**
     * @generated from protobuf enum value: STRING = 1;
     */
    TableDataList_ListType[TableDataList_ListType["STRING"] = 1] = "STRING";
    /**
     * @generated from protobuf enum value: FORMAT = 2;
     */
    TableDataList_ListType[TableDataList_ListType["FORMAT"] = 2] = "FORMAT";
    /**
     * @generated from protobuf enum value: FORMULA = 3;
     */
    TableDataList_ListType[TableDataList_ListType["FORMULA"] = 3] = "FORMULA";
    /**
     * @generated from protobuf enum value: STYLE = 4;
     */
    TableDataList_ListType[TableDataList_ListType["STYLE"] = 4] = "STYLE";
    /**
     * @generated from protobuf enum value: FORMULA_ERROR = 5;
     */
    TableDataList_ListType[TableDataList_ListType["FORMULA_ERROR"] = 5] = "FORMULA_ERROR";
    /**
     * @generated from protobuf enum value: CUSTOM_FORMAT = 6;
     */
    TableDataList_ListType[TableDataList_ListType["CUSTOM_FORMAT"] = 6] = "CUSTOM_FORMAT";
    /**
     * @generated from protobuf enum value: MULTIPLE_CHOICE_LIST_FORMAT = 7;
     */
    TableDataList_ListType[TableDataList_ListType["MULTIPLE_CHOICE_LIST_FORMAT"] = 7] = "MULTIPLE_CHOICE_LIST_FORMAT";
    /**
     * @generated from protobuf enum value: RICH_TEXT_PAYLOAD = 8;
     */
    TableDataList_ListType[TableDataList_ListType["RICH_TEXT_PAYLOAD"] = 8] = "RICH_TEXT_PAYLOAD";
    /**
     * @generated from protobuf enum value: CONDITIONAL_STYLE = 9;
     */
    TableDataList_ListType[TableDataList_ListType["CONDITIONAL_STYLE"] = 9] = "CONDITIONAL_STYLE";
    /**
     * @generated from protobuf enum value: COMMENT_STORAGE = 10;
     */
    TableDataList_ListType[TableDataList_ListType["COMMENT_STORAGE"] = 10] = "COMMENT_STORAGE";
    /**
     * @generated from protobuf enum value: IMPORT_WARNING = 11;
     */
    TableDataList_ListType[TableDataList_ListType["IMPORT_WARNING"] = 11] = "IMPORT_WARNING";
    /**
     * @generated from protobuf enum value: CONTROL_CELL_SPEC = 12;
     */
    TableDataList_ListType[TableDataList_ListType["CONTROL_CELL_SPEC"] = 12] = "CONTROL_CELL_SPEC";
})(TableDataList_ListType = exports.TableDataList_ListType || (exports.TableDataList_ListType = {}));
/**
 * @generated from protobuf enum TST.TableGroupSortOrderUIDArchive.GroupSortRuleUIDArchive.Direction
 */
var TableGroupSortOrderUIDArchive_GroupSortRuleUIDArchive_Direction;
(function (TableGroupSortOrderUIDArchive_GroupSortRuleUIDArchive_Direction) {
    /**
     * @generated from protobuf enum value: ascending = 0;
     */
    TableGroupSortOrderUIDArchive_GroupSortRuleUIDArchive_Direction[TableGroupSortOrderUIDArchive_GroupSortRuleUIDArchive_Direction["ascending"] = 0] = "ascending";
    /**
     * @generated from protobuf enum value: descending = 1;
     */
    TableGroupSortOrderUIDArchive_GroupSortRuleUIDArchive_Direction[TableGroupSortOrderUIDArchive_GroupSortRuleUIDArchive_Direction["descending"] = 1] = "descending";
})(TableGroupSortOrderUIDArchive_GroupSortRuleUIDArchive_Direction = exports.TableGroupSortOrderUIDArchive_GroupSortRuleUIDArchive_Direction || (exports.TableGroupSortOrderUIDArchive_GroupSortRuleUIDArchive_Direction = {}));
/**
 * @generated from protobuf enum TST.TableSortOrderArchive.SortRuleArchive.Direction
 */
var TableSortOrderArchive_SortRuleArchive_Direction;
(function (TableSortOrderArchive_SortRuleArchive_Direction) {
    /**
     * @generated from protobuf enum value: ascending = 0;
     */
    TableSortOrderArchive_SortRuleArchive_Direction[TableSortOrderArchive_SortRuleArchive_Direction["ascending"] = 0] = "ascending";
    /**
     * @generated from protobuf enum value: descending = 1;
     */
    TableSortOrderArchive_SortRuleArchive_Direction[TableSortOrderArchive_SortRuleArchive_Direction["descending"] = 1] = "descending";
})(TableSortOrderArchive_SortRuleArchive_Direction = exports.TableSortOrderArchive_SortRuleArchive_Direction || (exports.TableSortOrderArchive_SortRuleArchive_Direction = {}));
/**
 * @generated from protobuf enum TST.TableSortOrderArchive.SortType
 */
var TableSortOrderArchive_SortType;
(function (TableSortOrderArchive_SortType) {
    /**
     * @generated from protobuf enum value: entire_table = 0;
     */
    TableSortOrderArchive_SortType[TableSortOrderArchive_SortType["entire_table"] = 0] = "entire_table";
    /**
     * @generated from protobuf enum value: row_range = 1;
     */
    TableSortOrderArchive_SortType[TableSortOrderArchive_SortType["row_range"] = 1] = "row_range";
})(TableSortOrderArchive_SortType = exports.TableSortOrderArchive_SortType || (exports.TableSortOrderArchive_SortType = {}));
/**
 * @generated from protobuf enum TST.TableSortOrderUIDArchive.SortRuleArchive.Direction
 */
var TableSortOrderUIDArchive_SortRuleArchive_Direction;
(function (TableSortOrderUIDArchive_SortRuleArchive_Direction) {
    /**
     * @generated from protobuf enum value: ascending = 0;
     */
    TableSortOrderUIDArchive_SortRuleArchive_Direction[TableSortOrderUIDArchive_SortRuleArchive_Direction["ascending"] = 0] = "ascending";
    /**
     * @generated from protobuf enum value: descending = 1;
     */
    TableSortOrderUIDArchive_SortRuleArchive_Direction[TableSortOrderUIDArchive_SortRuleArchive_Direction["descending"] = 1] = "descending";
})(TableSortOrderUIDArchive_SortRuleArchive_Direction = exports.TableSortOrderUIDArchive_SortRuleArchive_Direction || (exports.TableSortOrderUIDArchive_SortRuleArchive_Direction = {}));
/**
 * @generated from protobuf enum TST.TableSortOrderUIDArchive.SortType
 */
var TableSortOrderUIDArchive_SortType;
(function (TableSortOrderUIDArchive_SortType) {
    /**
     * @generated from protobuf enum value: entire_table = 0;
     */
    TableSortOrderUIDArchive_SortType[TableSortOrderUIDArchive_SortType["entire_table"] = 0] = "entire_table";
    /**
     * @generated from protobuf enum value: row_range = 1;
     */
    TableSortOrderUIDArchive_SortType[TableSortOrderUIDArchive_SortType["row_range"] = 1] = "row_range";
})(TableSortOrderUIDArchive_SortType = exports.TableSortOrderUIDArchive_SortType || (exports.TableSortOrderUIDArchive_SortType = {}));
/**
 * @generated from protobuf enum TST.FilterSetArchive.FilterSetType
 */
var FilterSetArchive_FilterSetType;
(function (FilterSetArchive_FilterSetType) {
    /**
     * @generated from protobuf enum value: FilterSetArchiveTypeAll = 0;
     */
    FilterSetArchive_FilterSetType[FilterSetArchive_FilterSetType["FilterSetArchiveTypeAll"] = 0] = "FilterSetArchiveTypeAll";
    /**
     * @generated from protobuf enum value: FilterSetArchiveTypeAny = 1;
     */
    FilterSetArchive_FilterSetType[FilterSetArchive_FilterSetType["FilterSetArchiveTypeAny"] = 1] = "FilterSetArchiveTypeAny";
})(FilterSetArchive_FilterSetType = exports.FilterSetArchive_FilterSetType || (exports.FilterSetArchive_FilterSetType = {}));
/**
 * @generated from protobuf enum TST.HiddenStateExtentArchive.RowOrColumnDirection
 */
var HiddenStateExtentArchive_RowOrColumnDirection;
(function (HiddenStateExtentArchive_RowOrColumnDirection) {
    /**
     * @generated from protobuf enum value: ColumnDirection = 0;
     */
    HiddenStateExtentArchive_RowOrColumnDirection[HiddenStateExtentArchive_RowOrColumnDirection["ColumnDirection"] = 0] = "ColumnDirection";
    /**
     * @generated from protobuf enum value: RowDirection = 1;
     */
    HiddenStateExtentArchive_RowOrColumnDirection[HiddenStateExtentArchive_RowOrColumnDirection["RowDirection"] = 1] = "RowDirection";
})(HiddenStateExtentArchive_RowOrColumnDirection = exports.HiddenStateExtentArchive_RowOrColumnDirection || (exports.HiddenStateExtentArchive_RowOrColumnDirection = {}));
/**
 * @generated from protobuf enum TST.MultiTableRemapperArchive.Purpose
 */
var MultiTableRemapperArchive_Purpose;
(function (MultiTableRemapperArchive_Purpose) {
    /**
     * @generated from protobuf enum value: DEFAULT = 0;
     */
    MultiTableRemapperArchive_Purpose[MultiTableRemapperArchive_Purpose["DEFAULT"] = 0] = "DEFAULT";
    /**
     * @generated from protobuf enum value: GROUPING = 1;
     */
    MultiTableRemapperArchive_Purpose[MultiTableRemapperArchive_Purpose["GROUPING"] = 1] = "GROUPING";
    /**
     * @generated from protobuf enum value: PAGES_SECTION_DUPLICATION_NONCOLLAB = 2;
     */
    MultiTableRemapperArchive_Purpose[MultiTableRemapperArchive_Purpose["PAGES_SECTION_DUPLICATION_NONCOLLAB"] = 2] = "PAGES_SECTION_DUPLICATION_NONCOLLAB";
})(MultiTableRemapperArchive_Purpose = exports.MultiTableRemapperArchive_Purpose || (exports.MultiTableRemapperArchive_Purpose = {}));
/**
 * @generated from protobuf enum TST.CellType
 */
var CellType;
(function (CellType) {
    /**
     * @generated from protobuf enum value: genericCellType = 0;
     */
    CellType[CellType["genericCellType"] = 0] = "genericCellType";
    /**
     * @generated from protobuf enum value: spanCellType = 1;
     */
    CellType[CellType["spanCellType"] = 1] = "spanCellType";
    /**
     * @generated from protobuf enum value: numberCellType = 2;
     */
    CellType[CellType["numberCellType"] = 2] = "numberCellType";
    /**
     * @generated from protobuf enum value: textCellType = 3;
     */
    CellType[CellType["textCellType"] = 3] = "textCellType";
    /**
     * @generated from protobuf enum value: formulaCellType = 4;
     */
    CellType[CellType["formulaCellType"] = 4] = "formulaCellType";
    /**
     * @generated from protobuf enum value: dateCellType = 5;
     */
    CellType[CellType["dateCellType"] = 5] = "dateCellType";
    /**
     * @generated from protobuf enum value: boolCellType = 6;
     */
    CellType[CellType["boolCellType"] = 6] = "boolCellType";
    /**
     * @generated from protobuf enum value: durationCellType = 7;
     */
    CellType[CellType["durationCellType"] = 7] = "durationCellType";
    /**
     * @generated from protobuf enum value: formulaErrorCellType = 8;
     */
    CellType[CellType["formulaErrorCellType"] = 8] = "formulaErrorCellType";
    /**
     * @generated from protobuf enum value: automaticCellType = 9;
     */
    CellType[CellType["automaticCellType"] = 9] = "automaticCellType";
})(CellType = exports.CellType || (exports.CellType = {}));
/**
 * @generated from protobuf enum TST.CellValueType
 */
var CellValueType;
(function (CellValueType) {
    /**
     * @generated from protobuf enum value: emptyCellValueType = 0;
     */
    CellValueType[CellValueType["emptyCellValueType"] = 0] = "emptyCellValueType";
    /**
     * @generated from protobuf enum value: numberCellValueType = 1;
     */
    CellValueType[CellValueType["numberCellValueType"] = 1] = "numberCellValueType";
    /**
     * @generated from protobuf enum value: stringCellValueType = 2;
     */
    CellValueType[CellValueType["stringCellValueType"] = 2] = "stringCellValueType";
    /**
     * @generated from protobuf enum value: providedCellValueType = 3;
     */
    CellValueType[CellValueType["providedCellValueType"] = 3] = "providedCellValueType";
    /**
     * @generated from protobuf enum value: dateCellValueType = 4;
     */
    CellValueType[CellValueType["dateCellValueType"] = 4] = "dateCellValueType";
    /**
     * @generated from protobuf enum value: boolCellValueType = 5;
     */
    CellValueType[CellValueType["boolCellValueType"] = 5] = "boolCellValueType";
    /**
     * @generated from protobuf enum value: durationCellValueType = 6;
     */
    CellValueType[CellValueType["durationCellValueType"] = 6] = "durationCellValueType";
    /**
     * @generated from protobuf enum value: errorCellValueType = 7;
     */
    CellValueType[CellValueType["errorCellValueType"] = 7] = "errorCellValueType";
    /**
     * @generated from protobuf enum value: richTextCellType = 8;
     */
    CellValueType[CellValueType["richTextCellType"] = 8] = "richTextCellType";
    /**
     * @generated from protobuf enum value: currencyCellValueType = 9;
     */
    CellValueType[CellValueType["currencyCellValueType"] = 9] = "currencyCellValueType";
})(CellValueType = exports.CellValueType || (exports.CellValueType = {}));
/**
 * @generated from protobuf enum TST.TableDimensionArchive
 */
var TableDimensionArchive;
(function (TableDimensionArchive) {
    /**
     * @generated from protobuf enum value: dimensionNeither = -1;
     */
    TableDimensionArchive[TableDimensionArchive["dimensionNeither"] = -1] = "dimensionNeither";
    /**
     * @generated from protobuf enum value: dimensionRow = 0;
     */
    TableDimensionArchive[TableDimensionArchive["dimensionRow"] = 0] = "dimensionRow";
    /**
     * @generated from protobuf enum value: dimensionColumn = 1;
     */
    TableDimensionArchive[TableDimensionArchive["dimensionColumn"] = 1] = "dimensionColumn";
})(TableDimensionArchive = exports.TableDimensionArchive || (exports.TableDimensionArchive = {}));
/**
 * @generated from protobuf enum TST.SelectionTypeArchive
 */
var SelectionTypeArchive;
(function (SelectionTypeArchive) {
    /**
     * @generated from protobuf enum value: deprecatedCellSelectionType = 0;
     */
    SelectionTypeArchive[SelectionTypeArchive["deprecatedCellSelectionType"] = 0] = "deprecatedCellSelectionType";
    /**
     * @generated from protobuf enum value: rowSelectionType = 1;
     */
    SelectionTypeArchive[SelectionTypeArchive["rowSelectionType"] = 1] = "rowSelectionType";
    /**
     * @generated from protobuf enum value: columnSelectionType = 2;
     */
    SelectionTypeArchive[SelectionTypeArchive["columnSelectionType"] = 2] = "columnSelectionType";
    /**
     * @generated from protobuf enum value: deprecatedCellEditingSelectionType = 3;
     */
    SelectionTypeArchive[SelectionTypeArchive["deprecatedCellEditingSelectionType"] = 3] = "deprecatedCellEditingSelectionType";
    /**
     * @generated from protobuf enum value: deprecatedTableNameSelectionType = 4;
     */
    SelectionTypeArchive[SelectionTypeArchive["deprecatedTableNameSelectionType"] = 4] = "deprecatedTableNameSelectionType";
    /**
     * @generated from protobuf enum value: deprecatedTableSelectionType = 5;
     */
    SelectionTypeArchive[SelectionTypeArchive["deprecatedTableSelectionType"] = 5] = "deprecatedTableSelectionType";
    /**
     * @generated from protobuf enum value: regionSelectionType = 6;
     */
    SelectionTypeArchive[SelectionTypeArchive["regionSelectionType"] = 6] = "regionSelectionType";
    /**
     * @generated from protobuf enum value: noSelectionType = 7;
     */
    SelectionTypeArchive[SelectionTypeArchive["noSelectionType"] = 7] = "noSelectionType";
})(SelectionTypeArchive = exports.SelectionTypeArchive || (exports.SelectionTypeArchive = {}));
/**
 * @generated from protobuf enum TST.FillDirectionArchive
 */
var FillDirectionArchive;
(function (FillDirectionArchive) {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    FillDirectionArchive[FillDirectionArchive["UNSPECIFIED$"] = 0] = "UNSPECIFIED$";
    /**
     * @generated from protobuf enum value: kTSTFillDownArchive = 1;
     */
    FillDirectionArchive[FillDirectionArchive["kTSTFillDownArchive"] = 1] = "kTSTFillDownArchive";
    /**
     * @generated from protobuf enum value: kTSTFillUpArchive = 2;
     */
    FillDirectionArchive[FillDirectionArchive["kTSTFillUpArchive"] = 2] = "kTSTFillUpArchive";
    /**
     * @generated from protobuf enum value: kTSTFillRightArchive = 3;
     */
    FillDirectionArchive[FillDirectionArchive["kTSTFillRightArchive"] = 3] = "kTSTFillRightArchive";
    /**
     * @generated from protobuf enum value: kTSTFillLeftArchive = 4;
     */
    FillDirectionArchive[FillDirectionArchive["kTSTFillLeftArchive"] = 4] = "kTSTFillLeftArchive";
})(FillDirectionArchive = exports.FillDirectionArchive || (exports.FillDirectionArchive = {}));
/**
 * @generated from protobuf enum TST.MergeActionArchive
 */
var MergeActionArchive;
(function (MergeActionArchive) {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    MergeActionArchive[MergeActionArchive["UNSPECIFIED$"] = 0] = "UNSPECIFIED$";
    /**
     * @generated from protobuf enum value: mergeActionInsert = 1;
     */
    MergeActionArchive[MergeActionArchive["mergeActionInsert"] = 1] = "mergeActionInsert";
    /**
     * @generated from protobuf enum value: mergeActionRemove = 2;
     */
    MergeActionArchive[MergeActionArchive["mergeActionRemove"] = 2] = "mergeActionRemove";
    /**
     * @generated from protobuf enum value: mergeActionShrink = 3;
     */
    MergeActionArchive[MergeActionArchive["mergeActionShrink"] = 3] = "mergeActionShrink";
    /**
     * @generated from protobuf enum value: mergeActionGrow = 4;
     */
    MergeActionArchive[MergeActionArchive["mergeActionGrow"] = 4] = "mergeActionGrow";
})(MergeActionArchive = exports.MergeActionArchive || (exports.MergeActionArchive = {}));
/**
 * @generated from protobuf enum TST.HideShowActionArchive
 */
var HideShowActionArchive;
(function (HideShowActionArchive) {
    /**
     * @generated from protobuf enum value: hideShowActionHide = 0;
     */
    HideShowActionArchive[HideShowActionArchive["hideShowActionHide"] = 0] = "hideShowActionHide";
    /**
     * @generated from protobuf enum value: hideShowActionShow = 1;
     */
    HideShowActionArchive[HideShowActionArchive["hideShowActionShow"] = 1] = "hideShowActionShow";
})(HideShowActionArchive = exports.HideShowActionArchive || (exports.HideShowActionArchive = {}));
// @generated message type with reflection information, may provide speed optimized methods
class CellID$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CellID", [
            { no: 1, name: "packedData", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "expanded_coord", kind: "message", T: () => TSCEArchives_20.CellCoordinateArchive }
        ]);
    }
    create(value) {
        const message = { packedData: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 packedData */ 1:
                    message.packedData = reader.fixed32();
                    break;
                case /* optional TSCE.CellCoordinateArchive expanded_coord */ 2:
                    message.expandedCoord = TSCEArchives_20.CellCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.expandedCoord);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 packedData = 1; */
        if (message.packedData !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.packedData);
        /* optional TSCE.CellCoordinateArchive expanded_coord = 2; */
        if (message.expandedCoord)
            TSCEArchives_20.CellCoordinateArchive.internalBinaryWrite(message.expandedCoord, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CellID
 */
exports.CellID = new CellID$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellUIDLookupListArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CellUIDLookupListArchive", [
            { no: 1, name: "column_uids", kind: "message", T: () => TSCEArchives_19.UidLookupListArchive },
            { no: 2, name: "row_uids", kind: "message", T: () => TSCEArchives_19.UidLookupListArchive },
            { no: 3, name: "column_indexes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "row_indexes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = { columnIndexes: [], rowIndexes: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSCE.UidLookupListArchive column_uids */ 1:
                    message.columnUids = TSCEArchives_19.UidLookupListArchive.internalBinaryRead(reader, reader.uint32(), options, message.columnUids);
                    break;
                case /* optional TSCE.UidLookupListArchive row_uids */ 2:
                    message.rowUids = TSCEArchives_19.UidLookupListArchive.internalBinaryRead(reader, reader.uint32(), options, message.rowUids);
                    break;
                case /* repeated int32 column_indexes */ 3:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.columnIndexes.push(reader.int32());
                    else
                        message.columnIndexes.push(reader.int32());
                    break;
                case /* repeated int32 row_indexes */ 4:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.rowIndexes.push(reader.int32());
                    else
                        message.rowIndexes.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSCE.UidLookupListArchive column_uids = 1; */
        if (message.columnUids)
            TSCEArchives_19.UidLookupListArchive.internalBinaryWrite(message.columnUids, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.UidLookupListArchive row_uids = 2; */
        if (message.rowUids)
            TSCEArchives_19.UidLookupListArchive.internalBinaryWrite(message.rowUids, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated int32 column_indexes = 3; */
        for (let i = 0; i < message.columnIndexes.length; i++)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.columnIndexes[i]);
        /* repeated int32 row_indexes = 4; */
        for (let i = 0; i < message.rowIndexes.length; i++)
            writer.tag(4, runtime_1.WireType.Varint).int32(message.rowIndexes[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CellUIDLookupListArchive
 */
exports.CellUIDLookupListArchive = new CellUIDLookupListArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellUIDListArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CellUIDListArchive", [
            { no: 1, name: "row_uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_11.UUID },
            { no: 2, name: "column_uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_11.UUID },
            { no: 3, name: "compressed_row_indexes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "compressed_column_indexes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "uncompressed_lookup_list", kind: "message", T: () => exports.CellUIDLookupListArchive }
        ]);
    }
    create(value) {
        const message = { rowUids: [], columnUids: [], compressedRowIndexes: [], compressedColumnIndexes: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.UUID row_uids */ 1:
                    message.rowUids.push(TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID column_uids */ 2:
                    message.columnUids.push(TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated int32 compressed_row_indexes */ 3:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.compressedRowIndexes.push(reader.int32());
                    else
                        message.compressedRowIndexes.push(reader.int32());
                    break;
                case /* repeated int32 compressed_column_indexes */ 4:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.compressedColumnIndexes.push(reader.int32());
                    else
                        message.compressedColumnIndexes.push(reader.int32());
                    break;
                case /* optional TST.CellUIDLookupListArchive uncompressed_lookup_list */ 5:
                    message.uncompressedLookupList = exports.CellUIDLookupListArchive.internalBinaryRead(reader, reader.uint32(), options, message.uncompressedLookupList);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.UUID row_uids = 1; */
        for (let i = 0; i < message.rowUids.length; i++)
            TSPMessages_11.UUID.internalBinaryWrite(message.rowUids[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID column_uids = 2; */
        for (let i = 0; i < message.columnUids.length; i++)
            TSPMessages_11.UUID.internalBinaryWrite(message.columnUids[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated int32 compressed_row_indexes = 3; */
        for (let i = 0; i < message.compressedRowIndexes.length; i++)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.compressedRowIndexes[i]);
        /* repeated int32 compressed_column_indexes = 4; */
        for (let i = 0; i < message.compressedColumnIndexes.length; i++)
            writer.tag(4, runtime_1.WireType.Varint).int32(message.compressedColumnIndexes[i]);
        /* optional TST.CellUIDLookupListArchive uncompressed_lookup_list = 5; */
        if (message.uncompressedLookupList)
            exports.CellUIDLookupListArchive.internalBinaryWrite(message.uncompressedLookupList, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CellUIDListArchive
 */
exports.CellUIDListArchive = new CellUIDListArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TableSize$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.TableSize", [
            { no: 1, name: "packedData", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 2, name: "num_columns", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "num_rows", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { packedData: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed32 packedData */ 1:
                    message.packedData = reader.fixed32();
                    break;
                case /* optional uint32 num_columns */ 2:
                    message.numColumns = reader.uint32();
                    break;
                case /* optional uint32 num_rows */ 3:
                    message.numRows = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* fixed32 packedData = 1; */
        if (message.packedData !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).fixed32(message.packedData);
        /* optional uint32 num_columns = 2; */
        if (message.numColumns !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.numColumns);
        /* optional uint32 num_rows = 3; */
        if (message.numRows !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.numRows);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.TableSize
 */
exports.TableSize = new TableSize$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpandedTableSize$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.ExpandedTableSize", [
            { no: 1, name: "num_columns", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "num_rows", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { numColumns: 0, numRows: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 num_columns */ 1:
                    message.numColumns = reader.uint32();
                    break;
                case /* uint32 num_rows */ 2:
                    message.numRows = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 num_columns = 1; */
        if (message.numColumns !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.numColumns);
        /* uint32 num_rows = 2; */
        if (message.numRows !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.numRows);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.ExpandedTableSize
 */
exports.ExpandedTableSize = new ExpandedTableSize$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellRange$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CellRange", [
            { no: 1, name: "origin", kind: "message", T: () => exports.CellID },
            { no: 2, name: "size", kind: "message", T: () => exports.TableSize }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.CellID origin */ 1:
                    message.origin = exports.CellID.internalBinaryRead(reader, reader.uint32(), options, message.origin);
                    break;
                case /* TST.TableSize size */ 2:
                    message.size = exports.TableSize.internalBinaryRead(reader, reader.uint32(), options, message.size);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.CellID origin = 1; */
        if (message.origin)
            exports.CellID.internalBinaryWrite(message.origin, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.TableSize size = 2; */
        if (message.size)
            exports.TableSize.internalBinaryWrite(message.size, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CellRange
 */
exports.CellRange = new CellRange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpandedCellRange$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.ExpandedCellRange", [
            { no: 1, name: "origin", kind: "message", T: () => TSCEArchives_20.CellCoordinateArchive },
            { no: 2, name: "size", kind: "message", T: () => exports.ExpandedTableSize }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSCE.CellCoordinateArchive origin */ 1:
                    message.origin = TSCEArchives_20.CellCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.origin);
                    break;
                case /* TST.ExpandedTableSize size */ 2:
                    message.size = exports.ExpandedTableSize.internalBinaryRead(reader, reader.uint32(), options, message.size);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSCE.CellCoordinateArchive origin = 1; */
        if (message.origin)
            TSCEArchives_20.CellCoordinateArchive.internalBinaryWrite(message.origin, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.ExpandedTableSize size = 2; */
        if (message.size)
            exports.ExpandedTableSize.internalBinaryWrite(message.size, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.ExpandedCellRange
 */
exports.ExpandedCellRange = new ExpandedCellRange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TableSelection$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.TableSelection", [
            { no: 1, name: "cellRange", kind: "message", T: () => exports.CellRange },
            { no: 2, name: "extendedCellRange", kind: "message", T: () => exports.CellRange },
            { no: 3, name: "extendedCellRangeValid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "selection_type", kind: "enum", T: () => ["TST.SelectionTypeArchive", SelectionTypeArchive] }
        ]);
    }
    create(value) {
        const message = { extendedCellRangeValid: false, selectionType: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.CellRange cellRange */ 1:
                    message.cellRange = exports.CellRange.internalBinaryRead(reader, reader.uint32(), options, message.cellRange);
                    break;
                case /* TST.CellRange extendedCellRange */ 2:
                    message.extendedCellRange = exports.CellRange.internalBinaryRead(reader, reader.uint32(), options, message.extendedCellRange);
                    break;
                case /* bool extendedCellRangeValid */ 3:
                    message.extendedCellRangeValid = reader.bool();
                    break;
                case /* TST.SelectionTypeArchive selection_type */ 4:
                    message.selectionType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.CellRange cellRange = 1; */
        if (message.cellRange)
            exports.CellRange.internalBinaryWrite(message.cellRange, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.CellRange extendedCellRange = 2; */
        if (message.extendedCellRange)
            exports.CellRange.internalBinaryWrite(message.extendedCellRange, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool extendedCellRangeValid = 3; */
        if (message.extendedCellRangeValid !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.extendedCellRangeValid);
        /* TST.SelectionTypeArchive selection_type = 4; */
        if (message.selectionType !== 0)
            writer.tag(4, runtime_1.WireType.Varint).int32(message.selectionType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.TableSelection
 */
exports.TableSelection = new TableSelection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TileRowInfo$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.TileRowInfo", [
            { no: 1, name: "tile_row_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "cell_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "cell_storage_buffer_pre_bnc", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "cell_offsets_pre_bnc", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "storage_version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "cell_storage_buffer", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "cell_offsets", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "has_wide_offsets", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { tileRowIndex: 0, cellCount: 0, cellStorageBufferPreBnc: new Uint8Array(0), cellOffsetsPreBnc: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 tile_row_index */ 1:
                    message.tileRowIndex = reader.uint32();
                    break;
                case /* uint32 cell_count */ 2:
                    message.cellCount = reader.uint32();
                    break;
                case /* bytes cell_storage_buffer_pre_bnc */ 3:
                    message.cellStorageBufferPreBnc = reader.bytes();
                    break;
                case /* bytes cell_offsets_pre_bnc */ 4:
                    message.cellOffsetsPreBnc = reader.bytes();
                    break;
                case /* optional uint32 storage_version */ 5:
                    message.storageVersion = reader.uint32();
                    break;
                case /* optional bytes cell_storage_buffer */ 6:
                    message.cellStorageBuffer = reader.bytes();
                    break;
                case /* optional bytes cell_offsets */ 7:
                    message.cellOffsets = reader.bytes();
                    break;
                case /* optional bool has_wide_offsets */ 8:
                    message.hasWideOffsets = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 tile_row_index = 1; */
        if (message.tileRowIndex !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.tileRowIndex);
        /* uint32 cell_count = 2; */
        if (message.cellCount !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.cellCount);
        /* bytes cell_storage_buffer_pre_bnc = 3; */
        if (message.cellStorageBufferPreBnc.length)
            writer.tag(3, runtime_1.WireType.LengthDelimited).bytes(message.cellStorageBufferPreBnc);
        /* bytes cell_offsets_pre_bnc = 4; */
        if (message.cellOffsetsPreBnc.length)
            writer.tag(4, runtime_1.WireType.LengthDelimited).bytes(message.cellOffsetsPreBnc);
        /* optional uint32 storage_version = 5; */
        if (message.storageVersion !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.storageVersion);
        /* optional bytes cell_storage_buffer = 6; */
        if (message.cellStorageBuffer !== undefined)
            writer.tag(6, runtime_1.WireType.LengthDelimited).bytes(message.cellStorageBuffer);
        /* optional bytes cell_offsets = 7; */
        if (message.cellOffsets !== undefined)
            writer.tag(7, runtime_1.WireType.LengthDelimited).bytes(message.cellOffsets);
        /* optional bool has_wide_offsets = 8; */
        if (message.hasWideOffsets !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.hasWideOffsets);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.TileRowInfo
 */
exports.TileRowInfo = new TileRowInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tile$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.Tile", [
            { no: 1, name: "maxColumn", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "maxRow", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "numCells", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "numrows", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "rowInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.TileRowInfo },
            { no: 6, name: "storage_version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "last_saved_in_BNC", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "should_use_wide_rows", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { maxColumn: 0, maxRow: 0, numCells: 0, numrows: 0, rowInfos: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 maxColumn */ 1:
                    message.maxColumn = reader.uint32();
                    break;
                case /* uint32 maxRow */ 2:
                    message.maxRow = reader.uint32();
                    break;
                case /* uint32 numCells */ 3:
                    message.numCells = reader.uint32();
                    break;
                case /* uint32 numrows */ 4:
                    message.numrows = reader.uint32();
                    break;
                case /* repeated TST.TileRowInfo rowInfos */ 5:
                    message.rowInfos.push(exports.TileRowInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 storage_version */ 6:
                    message.storageVersion = reader.uint32();
                    break;
                case /* optional bool last_saved_in_BNC */ 7:
                    message.lastSavedInBNC = reader.bool();
                    break;
                case /* optional bool should_use_wide_rows */ 8:
                    message.shouldUseWideRows = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 maxColumn = 1; */
        if (message.maxColumn !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.maxColumn);
        /* uint32 maxRow = 2; */
        if (message.maxRow !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.maxRow);
        /* uint32 numCells = 3; */
        if (message.numCells !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.numCells);
        /* uint32 numrows = 4; */
        if (message.numrows !== 0)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.numrows);
        /* repeated TST.TileRowInfo rowInfos = 5; */
        for (let i = 0; i < message.rowInfos.length; i++)
            exports.TileRowInfo.internalBinaryWrite(message.rowInfos[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 storage_version = 6; */
        if (message.storageVersion !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).uint32(message.storageVersion);
        /* optional bool last_saved_in_BNC = 7; */
        if (message.lastSavedInBNC !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.lastSavedInBNC);
        /* optional bool should_use_wide_rows = 8; */
        if (message.shouldUseWideRows !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.shouldUseWideRows);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.Tile
 */
exports.Tile = new Tile$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TileStorage$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.TileStorage", [
            { no: 1, name: "tiles", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.TileStorage_Tile },
            { no: 2, name: "tile_size", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "should_use_wide_rows", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { tiles: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TST.TileStorage.Tile tiles */ 1:
                    message.tiles.push(exports.TileStorage_Tile.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 tile_size */ 2:
                    message.tileSize = reader.uint32();
                    break;
                case /* optional bool should_use_wide_rows */ 3:
                    message.shouldUseWideRows = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TST.TileStorage.Tile tiles = 1; */
        for (let i = 0; i < message.tiles.length; i++)
            exports.TileStorage_Tile.internalBinaryWrite(message.tiles[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 tile_size = 2; */
        if (message.tileSize !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.tileSize);
        /* optional bool should_use_wide_rows = 3; */
        if (message.shouldUseWideRows !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.shouldUseWideRows);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.TileStorage
 */
exports.TileStorage = new TileStorage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TileStorage_Tile$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.TileStorage.Tile", [
            { no: 1, name: "tileid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "tile", kind: "message", T: () => TSPMessages_10.Reference }
        ]);
    }
    create(value) {
        const message = { tileid: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 tileid */ 1:
                    message.tileid = reader.uint32();
                    break;
                case /* TSP.Reference tile */ 2:
                    message.tile = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.tile);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 tileid = 1; */
        if (message.tileid !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.tileid);
        /* TSP.Reference tile = 2; */
        if (message.tile)
            TSPMessages_10.Reference.internalBinaryWrite(message.tile, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.TileStorage.Tile
 */
exports.TileStorage_Tile = new TileStorage_Tile$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PopUpMenuModel$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.PopUpMenuModel", [
            { no: 1, name: "item", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.PopUpMenuModel_CellValue },
            { no: 2, name: "tsce_item", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSCEArchives_18.CellValueArchive }
        ]);
    }
    create(value) {
        const message = { item: [], tsceItem: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TST.PopUpMenuModel.CellValue item = 1 [deprecated = true];*/ 1:
                    message.item.push(exports.PopUpMenuModel_CellValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSCE.CellValueArchive tsce_item */ 2:
                    message.tsceItem.push(TSCEArchives_18.CellValueArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TST.PopUpMenuModel.CellValue item = 1 [deprecated = true]; */
        for (let i = 0; i < message.item.length; i++)
            exports.PopUpMenuModel_CellValue.internalBinaryWrite(message.item[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.CellValueArchive tsce_item = 2; */
        for (let i = 0; i < message.tsceItem.length; i++)
            TSCEArchives_18.CellValueArchive.internalBinaryWrite(message.tsceItem[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.PopUpMenuModel
 */
exports.PopUpMenuModel = new PopUpMenuModel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PopUpMenuModel_CellValue$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.PopUpMenuModel.CellValue", [
            { no: 1, name: "cell_value_type", kind: "enum", T: () => ["TST.PopUpMenuModel.CellValueType", PopUpMenuModel_CellValueType] },
            { no: 2, name: "boolean_value", kind: "message", T: () => TSCEArchives_17.BooleanCellValueArchive },
            { no: 3, name: "date_value", kind: "message", T: () => TSCEArchives_16.DateCellValueArchive },
            { no: 4, name: "number_value", kind: "message", T: () => TSCEArchives_15.NumberCellValueArchive },
            { no: 5, name: "string_value", kind: "message", T: () => TSCEArchives_14.StringCellValueArchive }
        ]);
    }
    create(value) {
        const message = { cellValueType: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.PopUpMenuModel.CellValueType cell_value_type */ 1:
                    message.cellValueType = reader.int32();
                    break;
                case /* optional TSCE.BooleanCellValueArchive boolean_value */ 2:
                    message.booleanValue = TSCEArchives_17.BooleanCellValueArchive.internalBinaryRead(reader, reader.uint32(), options, message.booleanValue);
                    break;
                case /* optional TSCE.DateCellValueArchive date_value */ 3:
                    message.dateValue = TSCEArchives_16.DateCellValueArchive.internalBinaryRead(reader, reader.uint32(), options, message.dateValue);
                    break;
                case /* optional TSCE.NumberCellValueArchive number_value */ 4:
                    message.numberValue = TSCEArchives_15.NumberCellValueArchive.internalBinaryRead(reader, reader.uint32(), options, message.numberValue);
                    break;
                case /* optional TSCE.StringCellValueArchive string_value */ 5:
                    message.stringValue = TSCEArchives_14.StringCellValueArchive.internalBinaryRead(reader, reader.uint32(), options, message.stringValue);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.PopUpMenuModel.CellValueType cell_value_type = 1; */
        if (message.cellValueType !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.cellValueType);
        /* optional TSCE.BooleanCellValueArchive boolean_value = 2; */
        if (message.booleanValue)
            TSCEArchives_17.BooleanCellValueArchive.internalBinaryWrite(message.booleanValue, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.DateCellValueArchive date_value = 3; */
        if (message.dateValue)
            TSCEArchives_16.DateCellValueArchive.internalBinaryWrite(message.dateValue, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.NumberCellValueArchive number_value = 4; */
        if (message.numberValue)
            TSCEArchives_15.NumberCellValueArchive.internalBinaryWrite(message.numberValue, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.StringCellValueArchive string_value = 5; */
        if (message.stringValue)
            TSCEArchives_14.StringCellValueArchive.internalBinaryWrite(message.stringValue, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.PopUpMenuModel.CellValue
 */
exports.PopUpMenuModel_CellValue = new PopUpMenuModel_CellValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportWarningSetArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.ImportWarningSetArchive", [
            { no: 1, name: "formula_import_warning", kind: "message", T: () => exports.ImportWarningSetArchive_FormulaImportWarning },
            { no: 2, name: "cond_format_above_avg_equal_avg", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "cond_format_above_avg_std_dev", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "cond_format_complex_formula", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "cond_format_contains_errors", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "cond_format_expr", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "cond_format_not_contains_errors", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "cond_format_parameters_not_all_same_type", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "cond_format_stop_if_true", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "cond_format_unsupported_operator", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "cond_format_unsupported_styling", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "cond_format_unsupported_time_period", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "error_cell_with_no_formula", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "unsupported_cond_format", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "original_data_format", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "formula_warning_filtered_column_formula_not_copied", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "duration_format_range_changed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TST.ImportWarningSetArchive.FormulaImportWarning formula_import_warning */ 1:
                    message.formulaImportWarning = exports.ImportWarningSetArchive_FormulaImportWarning.internalBinaryRead(reader, reader.uint32(), options, message.formulaImportWarning);
                    break;
                case /* optional bool cond_format_above_avg_equal_avg */ 2:
                    message.condFormatAboveAvgEqualAvg = reader.bool();
                    break;
                case /* optional bool cond_format_above_avg_std_dev */ 3:
                    message.condFormatAboveAvgStdDev = reader.bool();
                    break;
                case /* optional bool cond_format_complex_formula */ 4:
                    message.condFormatComplexFormula = reader.bool();
                    break;
                case /* optional bool cond_format_contains_errors */ 5:
                    message.condFormatContainsErrors = reader.bool();
                    break;
                case /* optional bool cond_format_expr */ 6:
                    message.condFormatExpr = reader.bool();
                    break;
                case /* optional bool cond_format_not_contains_errors */ 7:
                    message.condFormatNotContainsErrors = reader.bool();
                    break;
                case /* optional bool cond_format_parameters_not_all_same_type */ 8:
                    message.condFormatParametersNotAllSameType = reader.bool();
                    break;
                case /* optional bool cond_format_stop_if_true */ 9:
                    message.condFormatStopIfTrue = reader.bool();
                    break;
                case /* optional bool cond_format_unsupported_operator */ 10:
                    message.condFormatUnsupportedOperator = reader.bool();
                    break;
                case /* optional bool cond_format_unsupported_styling */ 11:
                    message.condFormatUnsupportedStyling = reader.bool();
                    break;
                case /* optional bool cond_format_unsupported_time_period */ 12:
                    message.condFormatUnsupportedTimePeriod = reader.bool();
                    break;
                case /* optional bool error_cell_with_no_formula */ 13:
                    message.errorCellWithNoFormula = reader.bool();
                    break;
                case /* optional bool unsupported_cond_format */ 14:
                    message.unsupportedCondFormat = reader.bool();
                    break;
                case /* optional string original_data_format */ 15:
                    message.originalDataFormat = reader.string();
                    break;
                case /* optional bool formula_warning_filtered_column_formula_not_copied */ 16:
                    message.formulaWarningFilteredColumnFormulaNotCopied = reader.bool();
                    break;
                case /* optional bool duration_format_range_changed */ 17:
                    message.durationFormatRangeChanged = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TST.ImportWarningSetArchive.FormulaImportWarning formula_import_warning = 1; */
        if (message.formulaImportWarning)
            exports.ImportWarningSetArchive_FormulaImportWarning.internalBinaryWrite(message.formulaImportWarning, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool cond_format_above_avg_equal_avg = 2; */
        if (message.condFormatAboveAvgEqualAvg !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.condFormatAboveAvgEqualAvg);
        /* optional bool cond_format_above_avg_std_dev = 3; */
        if (message.condFormatAboveAvgStdDev !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.condFormatAboveAvgStdDev);
        /* optional bool cond_format_complex_formula = 4; */
        if (message.condFormatComplexFormula !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.condFormatComplexFormula);
        /* optional bool cond_format_contains_errors = 5; */
        if (message.condFormatContainsErrors !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.condFormatContainsErrors);
        /* optional bool cond_format_expr = 6; */
        if (message.condFormatExpr !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.condFormatExpr);
        /* optional bool cond_format_not_contains_errors = 7; */
        if (message.condFormatNotContainsErrors !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.condFormatNotContainsErrors);
        /* optional bool cond_format_parameters_not_all_same_type = 8; */
        if (message.condFormatParametersNotAllSameType !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.condFormatParametersNotAllSameType);
        /* optional bool cond_format_stop_if_true = 9; */
        if (message.condFormatStopIfTrue !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).bool(message.condFormatStopIfTrue);
        /* optional bool cond_format_unsupported_operator = 10; */
        if (message.condFormatUnsupportedOperator !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).bool(message.condFormatUnsupportedOperator);
        /* optional bool cond_format_unsupported_styling = 11; */
        if (message.condFormatUnsupportedStyling !== undefined)
            writer.tag(11, runtime_1.WireType.Varint).bool(message.condFormatUnsupportedStyling);
        /* optional bool cond_format_unsupported_time_period = 12; */
        if (message.condFormatUnsupportedTimePeriod !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).bool(message.condFormatUnsupportedTimePeriod);
        /* optional bool error_cell_with_no_formula = 13; */
        if (message.errorCellWithNoFormula !== undefined)
            writer.tag(13, runtime_1.WireType.Varint).bool(message.errorCellWithNoFormula);
        /* optional bool unsupported_cond_format = 14; */
        if (message.unsupportedCondFormat !== undefined)
            writer.tag(14, runtime_1.WireType.Varint).bool(message.unsupportedCondFormat);
        /* optional string original_data_format = 15; */
        if (message.originalDataFormat !== undefined)
            writer.tag(15, runtime_1.WireType.LengthDelimited).string(message.originalDataFormat);
        /* optional bool formula_warning_filtered_column_formula_not_copied = 16; */
        if (message.formulaWarningFilteredColumnFormulaNotCopied !== undefined)
            writer.tag(16, runtime_1.WireType.Varint).bool(message.formulaWarningFilteredColumnFormulaNotCopied);
        /* optional bool duration_format_range_changed = 17; */
        if (message.durationFormatRangeChanged !== undefined)
            writer.tag(17, runtime_1.WireType.Varint).bool(message.durationFormatRangeChanged);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.ImportWarningSetArchive
 */
exports.ImportWarningSetArchive = new ImportWarningSetArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportWarningSetArchive_FormulaImportWarning$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.ImportWarningSetArchive.FormulaImportWarning", [
            { no: 1, name: "formula_warning_type", kind: "enum", T: () => ["TST.ImportWarningSetArchive.FormulaWarningType", ImportWarningSetArchive_FormulaWarningType] },
            { no: 2, name: "original_formula", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "supplementary_text", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "formula_warning_type_int", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = { formulaWarningType: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.ImportWarningSetArchive.FormulaWarningType formula_warning_type */ 1:
                    message.formulaWarningType = reader.int32();
                    break;
                case /* optional string original_formula */ 2:
                    message.originalFormula = reader.string();
                    break;
                case /* optional string supplementary_text */ 3:
                    message.supplementaryText = reader.string();
                    break;
                case /* optional int32 formula_warning_type_int */ 4:
                    message.formulaWarningTypeInt = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.ImportWarningSetArchive.FormulaWarningType formula_warning_type = 1; */
        if (message.formulaWarningType !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.formulaWarningType);
        /* optional string original_formula = 2; */
        if (message.originalFormula !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.originalFormula);
        /* optional string supplementary_text = 3; */
        if (message.supplementaryText !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.supplementaryText);
        /* optional int32 formula_warning_type_int = 4; */
        if (message.formulaWarningTypeInt !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).int32(message.formulaWarningTypeInt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.ImportWarningSetArchive.FormulaImportWarning
 */
exports.ImportWarningSetArchive_FormulaImportWarning = new ImportWarningSetArchive_FormulaImportWarning$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellRefImportWarningSetPairArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CellRefImportWarningSetPairArchive", [
            { no: 1, name: "cell_ref", kind: "message", T: () => TSCEArchives_13.CellReferenceArchive },
            { no: 3, name: "warning_set", kind: "message", T: () => exports.ImportWarningSetArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSCE.CellReferenceArchive cell_ref */ 1:
                    message.cellRef = TSCEArchives_13.CellReferenceArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellRef);
                    break;
                case /* optional TST.ImportWarningSetArchive warning_set */ 3:
                    message.warningSet = exports.ImportWarningSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.warningSet);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSCE.CellReferenceArchive cell_ref = 1; */
        if (message.cellRef)
            TSCEArchives_13.CellReferenceArchive.internalBinaryWrite(message.cellRef, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.ImportWarningSetArchive warning_set = 3; */
        if (message.warningSet)
            exports.ImportWarningSetArchive.internalBinaryWrite(message.warningSet, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CellRefImportWarningSetPairArchive
 */
exports.CellRefImportWarningSetPairArchive = new CellRefImportWarningSetPairArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImportWarningSetByCellRefArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.ImportWarningSetByCellRefArchive", [
            { no: 1, name: "cellref_warning_set_pair", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CellRefImportWarningSetPairArchive }
        ]);
    }
    create(value) {
        const message = { cellrefWarningSetPair: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TST.CellRefImportWarningSetPairArchive cellref_warning_set_pair */ 1:
                    message.cellrefWarningSetPair.push(exports.CellRefImportWarningSetPairArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TST.CellRefImportWarningSetPairArchive cellref_warning_set_pair = 1; */
        for (let i = 0; i < message.cellrefWarningSetPair.length; i++)
            exports.CellRefImportWarningSetPairArchive.internalBinaryWrite(message.cellrefWarningSetPair[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.ImportWarningSetByCellRefArchive
 */
exports.ImportWarningSetByCellRefArchive = new ImportWarningSetByCellRefArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TableDataList$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.TableDataList", [
            { no: 1, name: "listType", kind: "enum", T: () => ["TST.TableDataList.ListType", TableDataList_ListType] },
            { no: 2, name: "nextListID", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.TableDataList_ListEntry },
            { no: 4, name: "segments", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_10.Reference },
            { no: 5, name: "is_new_for_bnc", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { listType: 0, nextListID: 0, entries: [], segments: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableDataList.ListType listType */ 1:
                    message.listType = reader.int32();
                    break;
                case /* uint32 nextListID */ 2:
                    message.nextListID = reader.uint32();
                    break;
                case /* repeated TST.TableDataList.ListEntry entries */ 3:
                    message.entries.push(exports.TableDataList_ListEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference segments */ 4:
                    message.segments.push(TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool is_new_for_bnc */ 5:
                    message.isNewForBnc = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableDataList.ListType listType = 1; */
        if (message.listType !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.listType);
        /* uint32 nextListID = 2; */
        if (message.nextListID !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.nextListID);
        /* repeated TST.TableDataList.ListEntry entries = 3; */
        for (let i = 0; i < message.entries.length; i++)
            exports.TableDataList_ListEntry.internalBinaryWrite(message.entries[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference segments = 4; */
        for (let i = 0; i < message.segments.length; i++)
            TSPMessages_10.Reference.internalBinaryWrite(message.segments[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_new_for_bnc = 5; */
        if (message.isNewForBnc !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.isNewForBnc);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.TableDataList
 */
exports.TableDataList = new TableDataList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TableDataList_ListEntry$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.TableDataList.ListEntry", [
            { no: 1, name: "key", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "refcount", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "reference", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 5, name: "formula", kind: "message", T: () => TSCEArchives_12.FormulaArchive },
            { no: 6, name: "format", kind: "message", T: () => TSKArchives_3.FormatStructArchive },
            { no: 8, name: "custom_format", kind: "message", T: () => TSKArchives_2.CustomFormatArchive },
            { no: 9, name: "rich_text_payload", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 10, name: "comment_storage", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 11, name: "import_warning_set", kind: "message", T: () => exports.ImportWarningSetArchive },
            { no: 12, name: "cell_spec", kind: "message", T: () => exports.CellSpecArchive }
        ]);
    }
    create(value) {
        const message = { key: 0, refcount: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 key */ 1:
                    message.key = reader.uint32();
                    break;
                case /* uint32 refcount */ 2:
                    message.refcount = reader.uint32();
                    break;
                case /* optional string string */ 3:
                    message.string = reader.string();
                    break;
                case /* optional TSP.Reference reference */ 4:
                    message.reference = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.reference);
                    break;
                case /* optional TSCE.FormulaArchive formula */ 5:
                    message.formula = TSCEArchives_12.FormulaArchive.internalBinaryRead(reader, reader.uint32(), options, message.formula);
                    break;
                case /* optional TSK.FormatStructArchive format */ 6:
                    message.format = TSKArchives_3.FormatStructArchive.internalBinaryRead(reader, reader.uint32(), options, message.format);
                    break;
                case /* optional TSK.CustomFormatArchive custom_format */ 8:
                    message.customFormat = TSKArchives_2.CustomFormatArchive.internalBinaryRead(reader, reader.uint32(), options, message.customFormat);
                    break;
                case /* optional TSP.Reference rich_text_payload */ 9:
                    message.richTextPayload = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.richTextPayload);
                    break;
                case /* optional TSP.Reference comment_storage */ 10:
                    message.commentStorage = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.commentStorage);
                    break;
                case /* optional TST.ImportWarningSetArchive import_warning_set */ 11:
                    message.importWarningSet = exports.ImportWarningSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.importWarningSet);
                    break;
                case /* optional TST.CellSpecArchive cell_spec */ 12:
                    message.cellSpec = exports.CellSpecArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellSpec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.key);
        /* uint32 refcount = 2; */
        if (message.refcount !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.refcount);
        /* optional string string = 3; */
        if (message.string !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.string);
        /* optional TSP.Reference reference = 4; */
        if (message.reference)
            TSPMessages_10.Reference.internalBinaryWrite(message.reference, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.FormulaArchive formula = 5; */
        if (message.formula)
            TSCEArchives_12.FormulaArchive.internalBinaryWrite(message.formula, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.FormatStructArchive format = 6; */
        if (message.format)
            TSKArchives_3.FormatStructArchive.internalBinaryWrite(message.format, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.CustomFormatArchive custom_format = 8; */
        if (message.customFormat)
            TSKArchives_2.CustomFormatArchive.internalBinaryWrite(message.customFormat, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference rich_text_payload = 9; */
        if (message.richTextPayload)
            TSPMessages_10.Reference.internalBinaryWrite(message.richTextPayload, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference comment_storage = 10; */
        if (message.commentStorage)
            TSPMessages_10.Reference.internalBinaryWrite(message.commentStorage, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.ImportWarningSetArchive import_warning_set = 11; */
        if (message.importWarningSet)
            exports.ImportWarningSetArchive.internalBinaryWrite(message.importWarningSet, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.CellSpecArchive cell_spec = 12; */
        if (message.cellSpec)
            exports.CellSpecArchive.internalBinaryWrite(message.cellSpec, writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.TableDataList.ListEntry
 */
exports.TableDataList_ListEntry = new TableDataList_ListEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TableDataListSegment$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.TableDataListSegment", [
            { no: 1, name: "list_type", kind: "enum", T: () => ["TST.TableDataList.ListType", TableDataList_ListType] },
            { no: 2, name: "key_range", kind: "message", T: () => TSPMessages_9.Range },
            { no: 3, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.TableDataList_ListEntry }
        ]);
    }
    create(value) {
        const message = { listType: 0, entries: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableDataList.ListType list_type */ 1:
                    message.listType = reader.int32();
                    break;
                case /* TSP.Range key_range */ 2:
                    message.keyRange = TSPMessages_9.Range.internalBinaryRead(reader, reader.uint32(), options, message.keyRange);
                    break;
                case /* repeated TST.TableDataList.ListEntry entries */ 3:
                    message.entries.push(exports.TableDataList_ListEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableDataList.ListType list_type = 1; */
        if (message.listType !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.listType);
        /* TSP.Range key_range = 2; */
        if (message.keyRange)
            TSPMessages_9.Range.internalBinaryWrite(message.keyRange, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TST.TableDataList.ListEntry entries = 3; */
        for (let i = 0; i < message.entries.length; i++)
            exports.TableDataList_ListEntry.internalBinaryWrite(message.entries[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.TableDataListSegment
 */
exports.TableDataListSegment = new TableDataListSegment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TableRBTree$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.TableRBTree", [
            { no: 1, name: "nodes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.TableRBTree_Node }
        ]);
    }
    create(value) {
        const message = { nodes: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TST.TableRBTree.Node nodes */ 1:
                    message.nodes.push(exports.TableRBTree_Node.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TST.TableRBTree.Node nodes = 1; */
        for (let i = 0; i < message.nodes.length; i++)
            exports.TableRBTree_Node.internalBinaryWrite(message.nodes[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.TableRBTree
 */
exports.TableRBTree = new TableRBTree$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TableRBTree_Node$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.TableRBTree.Node", [
            { no: 1, name: "key", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "value", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { key: 0, value: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 key */ 1:
                    message.key = reader.uint32();
                    break;
                case /* uint32 value */ 2:
                    message.value = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.key);
        /* uint32 value = 2; */
        if (message.value !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.TableRBTree.Node
 */
exports.TableRBTree_Node = new TableRBTree_Node$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeaderStorageBucket$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.HeaderStorageBucket", [
            { no: 1, name: "bucketHashFunction", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "headers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.HeaderStorageBucket_Header }
        ]);
    }
    create(value) {
        const message = { bucketHashFunction: 0, headers: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 bucketHashFunction */ 1:
                    message.bucketHashFunction = reader.uint32();
                    break;
                case /* repeated TST.HeaderStorageBucket.Header headers */ 2:
                    message.headers.push(exports.HeaderStorageBucket_Header.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 bucketHashFunction = 1; */
        if (message.bucketHashFunction !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.bucketHashFunction);
        /* repeated TST.HeaderStorageBucket.Header headers = 2; */
        for (let i = 0; i < message.headers.length; i++)
            exports.HeaderStorageBucket_Header.internalBinaryWrite(message.headers[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.HeaderStorageBucket
 */
exports.HeaderStorageBucket = new HeaderStorageBucket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeaderStorageBucket_Header$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.HeaderStorageBucket.Header", [
            { no: 1, name: "index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "size", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "hidingState", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "numberOfCells", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "cell_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 6, name: "text_style", kind: "message", T: () => TSPMessages_10.Reference }
        ]);
    }
    create(value) {
        const message = { index: 0, size: 0, hidingState: 0, numberOfCells: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 index */ 1:
                    message.index = reader.uint32();
                    break;
                case /* float size */ 2:
                    message.size = reader.float();
                    break;
                case /* uint32 hidingState */ 3:
                    message.hidingState = reader.uint32();
                    break;
                case /* uint32 numberOfCells */ 4:
                    message.numberOfCells = reader.uint32();
                    break;
                case /* optional TSP.Reference cell_style */ 5:
                    message.cellStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.cellStyle);
                    break;
                case /* optional TSP.Reference text_style */ 6:
                    message.textStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.textStyle);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 index = 1; */
        if (message.index !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.index);
        /* float size = 2; */
        if (message.size !== 0)
            writer.tag(2, runtime_1.WireType.Bit32).float(message.size);
        /* uint32 hidingState = 3; */
        if (message.hidingState !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.hidingState);
        /* uint32 numberOfCells = 4; */
        if (message.numberOfCells !== 0)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.numberOfCells);
        /* optional TSP.Reference cell_style = 5; */
        if (message.cellStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.cellStyle, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference text_style = 6; */
        if (message.textStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.textStyle, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.HeaderStorageBucket.Header
 */
exports.HeaderStorageBucket_Header = new HeaderStorageBucket_Header$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeaderStorage$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.HeaderStorage", [
            { no: 1, name: "bucketHashFunction", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "buckets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_10.Reference }
        ]);
    }
    create(value) {
        const message = { bucketHashFunction: 0, buckets: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 bucketHashFunction */ 1:
                    message.bucketHashFunction = reader.uint32();
                    break;
                case /* repeated TSP.Reference buckets */ 2:
                    message.buckets.push(TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 bucketHashFunction = 1; */
        if (message.bucketHashFunction !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.bucketHashFunction);
        /* repeated TSP.Reference buckets = 2; */
        for (let i = 0; i < message.buckets.length; i++)
            TSPMessages_10.Reference.internalBinaryWrite(message.buckets[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.HeaderStorage
 */
exports.HeaderStorage = new HeaderStorage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataStore$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.DataStore", [
            { no: 1, name: "rowHeaders", kind: "message", T: () => exports.HeaderStorage },
            { no: 2, name: "columnHeaders", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 3, name: "tiles", kind: "message", T: () => exports.TileStorage },
            { no: 4, name: "stringTable", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 5, name: "styleTable", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 6, name: "formula_table", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 12, name: "formulaErrorTable", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 11, name: "format_table_pre_bnc", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 16, name: "multipleChoiceListFormatTable", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 13, name: "merge_region_map", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 15, name: "deprecated_custom_format_table", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 7, name: "nextRowStripID", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "nextColumnStripID", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "rowTileTree", kind: "message", T: () => exports.TableRBTree },
            { no: 10, name: "columnTileTree", kind: "message", T: () => exports.TableRBTree },
            { no: 14, name: "storage_version_pre_bnc", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 17, name: "rich_text_table", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 18, name: "conditionalstyletable", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 19, name: "commentStorageTable", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 20, name: "importWarningSetTable", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 21, name: "control_cell_spec_table", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 22, name: "format_table", kind: "message", T: () => TSPMessages_10.Reference }
        ]);
    }
    create(value) {
        const message = { nextRowStripID: 0, nextColumnStripID: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.HeaderStorage rowHeaders */ 1:
                    message.rowHeaders = exports.HeaderStorage.internalBinaryRead(reader, reader.uint32(), options, message.rowHeaders);
                    break;
                case /* TSP.Reference columnHeaders */ 2:
                    message.columnHeaders = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.columnHeaders);
                    break;
                case /* TST.TileStorage tiles */ 3:
                    message.tiles = exports.TileStorage.internalBinaryRead(reader, reader.uint32(), options, message.tiles);
                    break;
                case /* TSP.Reference stringTable */ 4:
                    message.stringTable = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.stringTable);
                    break;
                case /* TSP.Reference styleTable */ 5:
                    message.styleTable = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.styleTable);
                    break;
                case /* TSP.Reference formula_table */ 6:
                    message.formulaTable = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.formulaTable);
                    break;
                case /* optional TSP.Reference formulaErrorTable */ 12:
                    message.formulaErrorTable = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.formulaErrorTable);
                    break;
                case /* TSP.Reference format_table_pre_bnc */ 11:
                    message.formatTablePreBnc = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.formatTablePreBnc);
                    break;
                case /* optional TSP.Reference multipleChoiceListFormatTable */ 16:
                    message.multipleChoiceListFormatTable = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.multipleChoiceListFormatTable);
                    break;
                case /* optional TSP.Reference merge_region_map */ 13:
                    message.mergeRegionMap = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.mergeRegionMap);
                    break;
                case /* optional TSP.Reference deprecated_custom_format_table */ 15:
                    message.deprecatedCustomFormatTable = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.deprecatedCustomFormatTable);
                    break;
                case /* uint32 nextRowStripID */ 7:
                    message.nextRowStripID = reader.uint32();
                    break;
                case /* uint32 nextColumnStripID */ 8:
                    message.nextColumnStripID = reader.uint32();
                    break;
                case /* TST.TableRBTree rowTileTree */ 9:
                    message.rowTileTree = exports.TableRBTree.internalBinaryRead(reader, reader.uint32(), options, message.rowTileTree);
                    break;
                case /* TST.TableRBTree columnTileTree */ 10:
                    message.columnTileTree = exports.TableRBTree.internalBinaryRead(reader, reader.uint32(), options, message.columnTileTree);
                    break;
                case /* optional uint32 storage_version_pre_bnc */ 14:
                    message.storageVersionPreBnc = reader.uint32();
                    break;
                case /* optional TSP.Reference rich_text_table */ 17:
                    message.richTextTable = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.richTextTable);
                    break;
                case /* optional TSP.Reference conditionalstyletable */ 18:
                    message.conditionalstyletable = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.conditionalstyletable);
                    break;
                case /* optional TSP.Reference commentStorageTable */ 19:
                    message.commentStorageTable = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.commentStorageTable);
                    break;
                case /* optional TSP.Reference importWarningSetTable */ 20:
                    message.importWarningSetTable = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.importWarningSetTable);
                    break;
                case /* optional TSP.Reference control_cell_spec_table */ 21:
                    message.controlCellSpecTable = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.controlCellSpecTable);
                    break;
                case /* optional TSP.Reference format_table */ 22:
                    message.formatTable = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.formatTable);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.HeaderStorage rowHeaders = 1; */
        if (message.rowHeaders)
            exports.HeaderStorage.internalBinaryWrite(message.rowHeaders, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference columnHeaders = 2; */
        if (message.columnHeaders)
            TSPMessages_10.Reference.internalBinaryWrite(message.columnHeaders, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.TileStorage tiles = 3; */
        if (message.tiles)
            exports.TileStorage.internalBinaryWrite(message.tiles, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference stringTable = 4; */
        if (message.stringTable)
            TSPMessages_10.Reference.internalBinaryWrite(message.stringTable, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference styleTable = 5; */
        if (message.styleTable)
            TSPMessages_10.Reference.internalBinaryWrite(message.styleTable, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference formula_table = 6; */
        if (message.formulaTable)
            TSPMessages_10.Reference.internalBinaryWrite(message.formulaTable, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference formulaErrorTable = 12; */
        if (message.formulaErrorTable)
            TSPMessages_10.Reference.internalBinaryWrite(message.formulaErrorTable, writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference format_table_pre_bnc = 11; */
        if (message.formatTablePreBnc)
            TSPMessages_10.Reference.internalBinaryWrite(message.formatTablePreBnc, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference multipleChoiceListFormatTable = 16; */
        if (message.multipleChoiceListFormatTable)
            TSPMessages_10.Reference.internalBinaryWrite(message.multipleChoiceListFormatTable, writer.tag(16, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference merge_region_map = 13; */
        if (message.mergeRegionMap)
            TSPMessages_10.Reference.internalBinaryWrite(message.mergeRegionMap, writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference deprecated_custom_format_table = 15; */
        if (message.deprecatedCustomFormatTable)
            TSPMessages_10.Reference.internalBinaryWrite(message.deprecatedCustomFormatTable, writer.tag(15, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 nextRowStripID = 7; */
        if (message.nextRowStripID !== 0)
            writer.tag(7, runtime_1.WireType.Varint).uint32(message.nextRowStripID);
        /* uint32 nextColumnStripID = 8; */
        if (message.nextColumnStripID !== 0)
            writer.tag(8, runtime_1.WireType.Varint).uint32(message.nextColumnStripID);
        /* TST.TableRBTree rowTileTree = 9; */
        if (message.rowTileTree)
            exports.TableRBTree.internalBinaryWrite(message.rowTileTree, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.TableRBTree columnTileTree = 10; */
        if (message.columnTileTree)
            exports.TableRBTree.internalBinaryWrite(message.columnTileTree, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 storage_version_pre_bnc = 14; */
        if (message.storageVersionPreBnc !== undefined)
            writer.tag(14, runtime_1.WireType.Varint).uint32(message.storageVersionPreBnc);
        /* optional TSP.Reference rich_text_table = 17; */
        if (message.richTextTable)
            TSPMessages_10.Reference.internalBinaryWrite(message.richTextTable, writer.tag(17, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference conditionalstyletable = 18; */
        if (message.conditionalstyletable)
            TSPMessages_10.Reference.internalBinaryWrite(message.conditionalstyletable, writer.tag(18, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference commentStorageTable = 19; */
        if (message.commentStorageTable)
            TSPMessages_10.Reference.internalBinaryWrite(message.commentStorageTable, writer.tag(19, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference importWarningSetTable = 20; */
        if (message.importWarningSetTable)
            TSPMessages_10.Reference.internalBinaryWrite(message.importWarningSetTable, writer.tag(20, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference control_cell_spec_table = 21; */
        if (message.controlCellSpecTable)
            TSPMessages_10.Reference.internalBinaryWrite(message.controlCellSpecTable, writer.tag(21, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference format_table = 22; */
        if (message.formatTable)
            TSPMessages_10.Reference.internalBinaryWrite(message.formatTable, writer.tag(22, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.DataStore
 */
exports.DataStore = new DataStore$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TableInfoArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.TableInfoArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSDArchives_3.DrawableArchive },
            { no: 2, name: "tableModel", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 3, name: "editing_state", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 4, name: "summary_model", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 5, name: "category_order", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 6, name: "view_column_row_uids", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 7, name: "group_by_uuid", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 8, name: "hidden_states_uuid", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 9, name: "formula_coord_space_in_pre40", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "formula_coord_space", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "pasteboard_coord_mapper", kind: "message", T: () => TSCEArchives_11.CoordMapperArchive },
            { no: 14, name: "layout_engine", kind: "message", T: () => exports.LayoutEngineArchive },
            { no: 15, name: "pivot_data_model", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 16, name: "is_a_pivot_table", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "pivot_order", kind: "message", T: () => TSPMessages_10.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.DrawableArchive super */ 1:
                    message.super = TSDArchives_3.DrawableArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Reference tableModel */ 2:
                    message.tableModel = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.tableModel);
                    break;
                case /* optional TSP.Reference editing_state = 3 [deprecated = true];*/ 3:
                    message.editingState = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.editingState);
                    break;
                case /* optional TSP.Reference summary_model */ 4:
                    message.summaryModel = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.summaryModel);
                    break;
                case /* optional TSP.Reference category_order */ 5:
                    message.categoryOrder = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.categoryOrder);
                    break;
                case /* optional TSP.Reference view_column_row_uids */ 6:
                    message.viewColumnRowUids = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.viewColumnRowUids);
                    break;
                case /* optional TSP.UUID group_by_uuid */ 7:
                    message.groupByUuid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.groupByUuid);
                    break;
                case /* optional TSP.UUID hidden_states_uuid */ 8:
                    message.hiddenStatesUuid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.hiddenStatesUuid);
                    break;
                case /* optional uint32 formula_coord_space_in_pre40 = 9 [deprecated = true];*/ 9:
                    message.formulaCoordSpaceInPre40 = reader.uint32();
                    break;
                case /* optional uint32 formula_coord_space */ 10:
                    message.formulaCoordSpace = reader.uint32();
                    break;
                case /* optional TSCE.CoordMapperArchive pasteboard_coord_mapper */ 13:
                    message.pasteboardCoordMapper = TSCEArchives_11.CoordMapperArchive.internalBinaryRead(reader, reader.uint32(), options, message.pasteboardCoordMapper);
                    break;
                case /* optional TST.LayoutEngineArchive layout_engine */ 14:
                    message.layoutEngine = exports.LayoutEngineArchive.internalBinaryRead(reader, reader.uint32(), options, message.layoutEngine);
                    break;
                case /* optional TSP.Reference pivot_data_model */ 15:
                    message.pivotDataModel = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.pivotDataModel);
                    break;
                case /* optional bool is_a_pivot_table */ 16:
                    message.isAPivotTable = reader.bool();
                    break;
                case /* optional TSP.Reference pivot_order */ 17:
                    message.pivotOrder = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.pivotOrder);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.DrawableArchive super = 1; */
        if (message.super)
            TSDArchives_3.DrawableArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference tableModel = 2; */
        if (message.tableModel)
            TSPMessages_10.Reference.internalBinaryWrite(message.tableModel, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference editing_state = 3 [deprecated = true]; */
        if (message.editingState)
            TSPMessages_10.Reference.internalBinaryWrite(message.editingState, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference summary_model = 4; */
        if (message.summaryModel)
            TSPMessages_10.Reference.internalBinaryWrite(message.summaryModel, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference category_order = 5; */
        if (message.categoryOrder)
            TSPMessages_10.Reference.internalBinaryWrite(message.categoryOrder, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference view_column_row_uids = 6; */
        if (message.viewColumnRowUids)
            TSPMessages_10.Reference.internalBinaryWrite(message.viewColumnRowUids, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID group_by_uuid = 7; */
        if (message.groupByUuid)
            TSPMessages_11.UUID.internalBinaryWrite(message.groupByUuid, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID hidden_states_uuid = 8; */
        if (message.hiddenStatesUuid)
            TSPMessages_11.UUID.internalBinaryWrite(message.hiddenStatesUuid, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 formula_coord_space_in_pre40 = 9 [deprecated = true]; */
        if (message.formulaCoordSpaceInPre40 !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).uint32(message.formulaCoordSpaceInPre40);
        /* optional uint32 formula_coord_space = 10; */
        if (message.formulaCoordSpace !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).uint32(message.formulaCoordSpace);
        /* optional TSCE.CoordMapperArchive pasteboard_coord_mapper = 13; */
        if (message.pasteboardCoordMapper)
            TSCEArchives_11.CoordMapperArchive.internalBinaryWrite(message.pasteboardCoordMapper, writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.LayoutEngineArchive layout_engine = 14; */
        if (message.layoutEngine)
            exports.LayoutEngineArchive.internalBinaryWrite(message.layoutEngine, writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference pivot_data_model = 15; */
        if (message.pivotDataModel)
            TSPMessages_10.Reference.internalBinaryWrite(message.pivotDataModel, writer.tag(15, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_a_pivot_table = 16; */
        if (message.isAPivotTable !== undefined)
            writer.tag(16, runtime_1.WireType.Varint).bool(message.isAPivotTable);
        /* optional TSP.Reference pivot_order = 17; */
        if (message.pivotOrder)
            TSPMessages_10.Reference.internalBinaryWrite(message.pivotOrder, writer.tag(17, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.TableInfoArchive
 */
exports.TableInfoArchive = new TableInfoArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CategoryInfoArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CategoryInfoArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSDArchives_3.DrawableArchive },
            { no: 2, name: "tableModel", kind: "message", T: () => TSPMessages_10.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.DrawableArchive super */ 1:
                    message.super = TSDArchives_3.DrawableArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Reference tableModel */ 2:
                    message.tableModel = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.tableModel);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.DrawableArchive super = 1; */
        if (message.super)
            TSDArchives_3.DrawableArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference tableModel = 2; */
        if (message.tableModel)
            TSPMessages_10.Reference.internalBinaryWrite(message.tableModel, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CategoryInfoArchive
 */
exports.CategoryInfoArchive = new CategoryInfoArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WPTableInfoArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.WPTableInfoArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableInfoArchive },
            { no: 2, name: "storage", kind: "message", T: () => TSPMessages_10.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableInfoArchive super */ 1:
                    message.super = exports.TableInfoArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference storage */ 2:
                    message.storage = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.storage);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableInfoArchive super = 1; */
        if (message.super)
            exports.TableInfoArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference storage = 2; */
        if (message.storage)
            TSPMessages_10.Reference.internalBinaryWrite(message.storage, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.WPTableInfoArchive
 */
exports.WPTableInfoArchive = new WPTableInfoArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TableStyleNetworkArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.TableStyleNetworkArchive", [
            { no: 1, name: "body_text_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 2, name: "header_row_text_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 3, name: "header_column_text_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 4, name: "footer_row_text_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 5, name: "body_cell_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 6, name: "header_row_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 7, name: "header_column_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 8, name: "footer_row_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 9, name: "table_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 10, name: "table_name_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 11, name: "table_name_shape_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 12, name: "preset_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "category_level_1_text_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 14, name: "category_level_2_text_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 15, name: "category_level_3_text_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 16, name: "category_level_4_text_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 17, name: "category_level_5_text_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 18, name: "category_level_1_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 19, name: "category_level_2_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 20, name: "category_level_3_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 21, name: "category_level_4_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 22, name: "category_level_5_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 23, name: "label_level_1_text_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 24, name: "label_level_2_text_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 25, name: "label_level_3_text_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 26, name: "label_level_4_text_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 27, name: "label_level_5_text_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 28, name: "label_level_1_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 29, name: "label_level_2_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 30, name: "label_level_3_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 31, name: "label_level_4_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 32, name: "label_level_5_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 33, name: "pivot_body_summary_row_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 34, name: "pivot_body_summary_column_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 35, name: "pivot_header_column_summary_style", kind: "message", T: () => TSPMessages_10.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.Reference body_text_style */ 1:
                    message.bodyTextStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.bodyTextStyle);
                    break;
                case /* TSP.Reference header_row_text_style */ 2:
                    message.headerRowTextStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.headerRowTextStyle);
                    break;
                case /* TSP.Reference header_column_text_style */ 3:
                    message.headerColumnTextStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.headerColumnTextStyle);
                    break;
                case /* TSP.Reference footer_row_text_style */ 4:
                    message.footerRowTextStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.footerRowTextStyle);
                    break;
                case /* TSP.Reference body_cell_style */ 5:
                    message.bodyCellStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.bodyCellStyle);
                    break;
                case /* TSP.Reference header_row_style */ 6:
                    message.headerRowStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.headerRowStyle);
                    break;
                case /* TSP.Reference header_column_style */ 7:
                    message.headerColumnStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.headerColumnStyle);
                    break;
                case /* TSP.Reference footer_row_style */ 8:
                    message.footerRowStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.footerRowStyle);
                    break;
                case /* TSP.Reference table_style */ 9:
                    message.tableStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.tableStyle);
                    break;
                case /* optional TSP.Reference table_name_style */ 10:
                    message.tableNameStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.tableNameStyle);
                    break;
                case /* optional TSP.Reference table_name_shape_style */ 11:
                    message.tableNameShapeStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.tableNameShapeStyle);
                    break;
                case /* optional uint32 preset_id */ 12:
                    message.presetId = reader.uint32();
                    break;
                case /* optional TSP.Reference category_level_1_text_style */ 13:
                    message.categoryLevel1TextStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.categoryLevel1TextStyle);
                    break;
                case /* optional TSP.Reference category_level_2_text_style */ 14:
                    message.categoryLevel2TextStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.categoryLevel2TextStyle);
                    break;
                case /* optional TSP.Reference category_level_3_text_style */ 15:
                    message.categoryLevel3TextStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.categoryLevel3TextStyle);
                    break;
                case /* optional TSP.Reference category_level_4_text_style */ 16:
                    message.categoryLevel4TextStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.categoryLevel4TextStyle);
                    break;
                case /* optional TSP.Reference category_level_5_text_style */ 17:
                    message.categoryLevel5TextStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.categoryLevel5TextStyle);
                    break;
                case /* optional TSP.Reference category_level_1_style */ 18:
                    message.categoryLevel1Style = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.categoryLevel1Style);
                    break;
                case /* optional TSP.Reference category_level_2_style */ 19:
                    message.categoryLevel2Style = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.categoryLevel2Style);
                    break;
                case /* optional TSP.Reference category_level_3_style */ 20:
                    message.categoryLevel3Style = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.categoryLevel3Style);
                    break;
                case /* optional TSP.Reference category_level_4_style */ 21:
                    message.categoryLevel4Style = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.categoryLevel4Style);
                    break;
                case /* optional TSP.Reference category_level_5_style */ 22:
                    message.categoryLevel5Style = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.categoryLevel5Style);
                    break;
                case /* optional TSP.Reference label_level_1_text_style */ 23:
                    message.labelLevel1TextStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.labelLevel1TextStyle);
                    break;
                case /* optional TSP.Reference label_level_2_text_style */ 24:
                    message.labelLevel2TextStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.labelLevel2TextStyle);
                    break;
                case /* optional TSP.Reference label_level_3_text_style */ 25:
                    message.labelLevel3TextStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.labelLevel3TextStyle);
                    break;
                case /* optional TSP.Reference label_level_4_text_style */ 26:
                    message.labelLevel4TextStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.labelLevel4TextStyle);
                    break;
                case /* optional TSP.Reference label_level_5_text_style */ 27:
                    message.labelLevel5TextStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.labelLevel5TextStyle);
                    break;
                case /* optional TSP.Reference label_level_1_style */ 28:
                    message.labelLevel1Style = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.labelLevel1Style);
                    break;
                case /* optional TSP.Reference label_level_2_style */ 29:
                    message.labelLevel2Style = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.labelLevel2Style);
                    break;
                case /* optional TSP.Reference label_level_3_style */ 30:
                    message.labelLevel3Style = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.labelLevel3Style);
                    break;
                case /* optional TSP.Reference label_level_4_style */ 31:
                    message.labelLevel4Style = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.labelLevel4Style);
                    break;
                case /* optional TSP.Reference label_level_5_style */ 32:
                    message.labelLevel5Style = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.labelLevel5Style);
                    break;
                case /* optional TSP.Reference pivot_body_summary_row_style */ 33:
                    message.pivotBodySummaryRowStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.pivotBodySummaryRowStyle);
                    break;
                case /* optional TSP.Reference pivot_body_summary_column_style */ 34:
                    message.pivotBodySummaryColumnStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.pivotBodySummaryColumnStyle);
                    break;
                case /* optional TSP.Reference pivot_header_column_summary_style */ 35:
                    message.pivotHeaderColumnSummaryStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.pivotHeaderColumnSummaryStyle);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.Reference body_text_style = 1; */
        if (message.bodyTextStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.bodyTextStyle, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference header_row_text_style = 2; */
        if (message.headerRowTextStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.headerRowTextStyle, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference header_column_text_style = 3; */
        if (message.headerColumnTextStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.headerColumnTextStyle, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference footer_row_text_style = 4; */
        if (message.footerRowTextStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.footerRowTextStyle, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference body_cell_style = 5; */
        if (message.bodyCellStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.bodyCellStyle, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference header_row_style = 6; */
        if (message.headerRowStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.headerRowStyle, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference header_column_style = 7; */
        if (message.headerColumnStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.headerColumnStyle, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference footer_row_style = 8; */
        if (message.footerRowStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.footerRowStyle, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference table_style = 9; */
        if (message.tableStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.tableStyle, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference table_name_style = 10; */
        if (message.tableNameStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.tableNameStyle, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference table_name_shape_style = 11; */
        if (message.tableNameShapeStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.tableNameShapeStyle, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 preset_id = 12; */
        if (message.presetId !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).uint32(message.presetId);
        /* optional TSP.Reference category_level_1_text_style = 13; */
        if (message.categoryLevel1TextStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.categoryLevel1TextStyle, writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference category_level_2_text_style = 14; */
        if (message.categoryLevel2TextStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.categoryLevel2TextStyle, writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference category_level_3_text_style = 15; */
        if (message.categoryLevel3TextStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.categoryLevel3TextStyle, writer.tag(15, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference category_level_4_text_style = 16; */
        if (message.categoryLevel4TextStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.categoryLevel4TextStyle, writer.tag(16, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference category_level_5_text_style = 17; */
        if (message.categoryLevel5TextStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.categoryLevel5TextStyle, writer.tag(17, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference category_level_1_style = 18; */
        if (message.categoryLevel1Style)
            TSPMessages_10.Reference.internalBinaryWrite(message.categoryLevel1Style, writer.tag(18, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference category_level_2_style = 19; */
        if (message.categoryLevel2Style)
            TSPMessages_10.Reference.internalBinaryWrite(message.categoryLevel2Style, writer.tag(19, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference category_level_3_style = 20; */
        if (message.categoryLevel3Style)
            TSPMessages_10.Reference.internalBinaryWrite(message.categoryLevel3Style, writer.tag(20, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference category_level_4_style = 21; */
        if (message.categoryLevel4Style)
            TSPMessages_10.Reference.internalBinaryWrite(message.categoryLevel4Style, writer.tag(21, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference category_level_5_style = 22; */
        if (message.categoryLevel5Style)
            TSPMessages_10.Reference.internalBinaryWrite(message.categoryLevel5Style, writer.tag(22, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference label_level_1_text_style = 23; */
        if (message.labelLevel1TextStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.labelLevel1TextStyle, writer.tag(23, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference label_level_2_text_style = 24; */
        if (message.labelLevel2TextStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.labelLevel2TextStyle, writer.tag(24, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference label_level_3_text_style = 25; */
        if (message.labelLevel3TextStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.labelLevel3TextStyle, writer.tag(25, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference label_level_4_text_style = 26; */
        if (message.labelLevel4TextStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.labelLevel4TextStyle, writer.tag(26, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference label_level_5_text_style = 27; */
        if (message.labelLevel5TextStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.labelLevel5TextStyle, writer.tag(27, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference label_level_1_style = 28; */
        if (message.labelLevel1Style)
            TSPMessages_10.Reference.internalBinaryWrite(message.labelLevel1Style, writer.tag(28, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference label_level_2_style = 29; */
        if (message.labelLevel2Style)
            TSPMessages_10.Reference.internalBinaryWrite(message.labelLevel2Style, writer.tag(29, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference label_level_3_style = 30; */
        if (message.labelLevel3Style)
            TSPMessages_10.Reference.internalBinaryWrite(message.labelLevel3Style, writer.tag(30, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference label_level_4_style = 31; */
        if (message.labelLevel4Style)
            TSPMessages_10.Reference.internalBinaryWrite(message.labelLevel4Style, writer.tag(31, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference label_level_5_style = 32; */
        if (message.labelLevel5Style)
            TSPMessages_10.Reference.internalBinaryWrite(message.labelLevel5Style, writer.tag(32, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference pivot_body_summary_row_style = 33; */
        if (message.pivotBodySummaryRowStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.pivotBodySummaryRowStyle, writer.tag(33, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference pivot_body_summary_column_style = 34; */
        if (message.pivotBodySummaryColumnStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.pivotBodySummaryColumnStyle, writer.tag(34, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference pivot_header_column_summary_style = 35; */
        if (message.pivotHeaderColumnSummaryStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.pivotHeaderColumnSummaryStyle, writer.tag(35, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.TableStyleNetworkArchive
 */
exports.TableStyleNetworkArchive = new TableStyleNetworkArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TableGroupSortOrderUIDArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.TableGroupSortOrderUIDArchive", [
            { no: 1, name: "group_sort_rules", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.TableGroupSortOrderUIDArchive_GroupSortRuleUIDArchive }
        ]);
    }
    create(value) {
        const message = { groupSortRules: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TST.TableGroupSortOrderUIDArchive.GroupSortRuleUIDArchive group_sort_rules */ 1:
                    message.groupSortRules.push(exports.TableGroupSortOrderUIDArchive_GroupSortRuleUIDArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TST.TableGroupSortOrderUIDArchive.GroupSortRuleUIDArchive group_sort_rules = 1; */
        for (let i = 0; i < message.groupSortRules.length; i++)
            exports.TableGroupSortOrderUIDArchive_GroupSortRuleUIDArchive.internalBinaryWrite(message.groupSortRules[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.TableGroupSortOrderUIDArchive
 */
exports.TableGroupSortOrderUIDArchive = new TableGroupSortOrderUIDArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TableGroupSortOrderUIDArchive_GroupSortRuleUIDArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.TableGroupSortOrderUIDArchive.GroupSortRuleUIDArchive", [
            { no: 1, name: "grouping_column_uid", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 2, name: "column_uid", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 3, name: "direction", kind: "enum", opt: true, T: () => ["TST.TableGroupSortOrderUIDArchive.GroupSortRuleUIDArchive.Direction", TableGroupSortOrderUIDArchive_GroupSortRuleUIDArchive_Direction] }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.UUID grouping_column_uid */ 1:
                    message.groupingColumnUid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.groupingColumnUid);
                    break;
                case /* optional TSP.UUID column_uid */ 2:
                    message.columnUid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.columnUid);
                    break;
                case /* optional TST.TableGroupSortOrderUIDArchive.GroupSortRuleUIDArchive.Direction direction */ 3:
                    message.direction = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.UUID grouping_column_uid = 1; */
        if (message.groupingColumnUid)
            TSPMessages_11.UUID.internalBinaryWrite(message.groupingColumnUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID column_uid = 2; */
        if (message.columnUid)
            TSPMessages_11.UUID.internalBinaryWrite(message.columnUid, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.TableGroupSortOrderUIDArchive.GroupSortRuleUIDArchive.Direction direction = 3; */
        if (message.direction !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.direction);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.TableGroupSortOrderUIDArchive.GroupSortRuleUIDArchive
 */
exports.TableGroupSortOrderUIDArchive_GroupSortRuleUIDArchive = new TableGroupSortOrderUIDArchive_GroupSortRuleUIDArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TableSortOrderArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.TableSortOrderArchive", [
            { no: 1, name: "type", kind: "enum", T: () => ["TST.TableSortOrderArchive.SortType", TableSortOrderArchive_SortType] },
            { no: 2, name: "rules", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.TableSortOrderArchive_SortRuleArchive }
        ]);
    }
    create(value) {
        const message = { type: 0, rules: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableSortOrderArchive.SortType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* repeated TST.TableSortOrderArchive.SortRuleArchive rules */ 2:
                    message.rules.push(exports.TableSortOrderArchive_SortRuleArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableSortOrderArchive.SortType type = 1; */
        if (message.type !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.type);
        /* repeated TST.TableSortOrderArchive.SortRuleArchive rules = 2; */
        for (let i = 0; i < message.rules.length; i++)
            exports.TableSortOrderArchive_SortRuleArchive.internalBinaryWrite(message.rules[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.TableSortOrderArchive
 */
exports.TableSortOrderArchive = new TableSortOrderArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TableSortOrderArchive_SortRuleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.TableSortOrderArchive.SortRuleArchive", [
            { no: 1, name: "index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "direction", kind: "enum", T: () => ["TST.TableSortOrderArchive.SortRuleArchive.Direction", TableSortOrderArchive_SortRuleArchive_Direction] }
        ]);
    }
    create(value) {
        const message = { index: 0, direction: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 index */ 1:
                    message.index = reader.uint32();
                    break;
                case /* TST.TableSortOrderArchive.SortRuleArchive.Direction direction */ 2:
                    message.direction = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 index = 1; */
        if (message.index !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.index);
        /* TST.TableSortOrderArchive.SortRuleArchive.Direction direction = 2; */
        if (message.direction !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.direction);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.TableSortOrderArchive.SortRuleArchive
 */
exports.TableSortOrderArchive_SortRuleArchive = new TableSortOrderArchive_SortRuleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TableSortOrderUIDArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.TableSortOrderUIDArchive", [
            { no: 1, name: "type", kind: "enum", T: () => ["TST.TableSortOrderUIDArchive.SortType", TableSortOrderUIDArchive_SortType] },
            { no: 2, name: "rules", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.TableSortOrderUIDArchive_SortRuleArchive }
        ]);
    }
    create(value) {
        const message = { type: 0, rules: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableSortOrderUIDArchive.SortType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* repeated TST.TableSortOrderUIDArchive.SortRuleArchive rules */ 2:
                    message.rules.push(exports.TableSortOrderUIDArchive_SortRuleArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableSortOrderUIDArchive.SortType type = 1; */
        if (message.type !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.type);
        /* repeated TST.TableSortOrderUIDArchive.SortRuleArchive rules = 2; */
        for (let i = 0; i < message.rules.length; i++)
            exports.TableSortOrderUIDArchive_SortRuleArchive.internalBinaryWrite(message.rules[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.TableSortOrderUIDArchive
 */
exports.TableSortOrderUIDArchive = new TableSortOrderUIDArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TableSortOrderUIDArchive_SortRuleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.TableSortOrderUIDArchive.SortRuleArchive", [
            { no: 1, name: "column_uid", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 2, name: "direction", kind: "enum", T: () => ["TST.TableSortOrderUIDArchive.SortRuleArchive.Direction", TableSortOrderUIDArchive_SortRuleArchive_Direction] }
        ]);
    }
    create(value) {
        const message = { direction: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID column_uid */ 1:
                    message.columnUid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.columnUid);
                    break;
                case /* TST.TableSortOrderUIDArchive.SortRuleArchive.Direction direction */ 2:
                    message.direction = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID column_uid = 1; */
        if (message.columnUid)
            TSPMessages_11.UUID.internalBinaryWrite(message.columnUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.TableSortOrderUIDArchive.SortRuleArchive.Direction direction = 2; */
        if (message.direction !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.direction);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.TableSortOrderUIDArchive.SortRuleArchive
 */
exports.TableSortOrderUIDArchive_SortRuleArchive = new TableSortOrderUIDArchive_SortRuleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SortRuleReferenceTrackerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.SortRuleReferenceTrackerArchive", [
            { no: 1, name: "reference_tracker", kind: "message", T: () => TSPMessages_10.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.Reference reference_tracker */ 1:
                    message.referenceTracker = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.referenceTracker);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.Reference reference_tracker = 1; */
        if (message.referenceTracker)
            TSPMessages_10.Reference.internalBinaryWrite(message.referenceTracker, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.SortRuleReferenceTrackerArchive
 */
exports.SortRuleReferenceTrackerArchive = new SortRuleReferenceTrackerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellRegion$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CellRegion", [
            { no: 1, name: "cell_ranges", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CellRange }
        ]);
    }
    create(value) {
        const message = { cellRanges: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TST.CellRange cell_ranges */ 1:
                    message.cellRanges.push(exports.CellRange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TST.CellRange cell_ranges = 1; */
        for (let i = 0; i < message.cellRanges.length; i++)
            exports.CellRange.internalBinaryWrite(message.cellRanges[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CellRegion
 */
exports.CellRegion = new CellRegion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellUIDRegionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CellUIDRegionArchive", [
            { no: 1, name: "cell_uid_ranges", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.UUIDRectArchive }
        ]);
    }
    create(value) {
        const message = { cellUidRanges: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.UUIDRectArchive cell_uid_ranges */ 1:
                    message.cellUidRanges.push(TSPMessages_8.UUIDRectArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.UUIDRectArchive cell_uid_ranges = 1; */
        for (let i = 0; i < message.cellUidRanges.length; i++)
            TSPMessages_8.UUIDRectArchive.internalBinaryWrite(message.cellUidRanges[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CellUIDRegionArchive
 */
exports.CellUIDRegionArchive = new CellUIDRegionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StructuredTextImportRecord$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.StructuredTextImportRecord", [
            { no: 1, name: "import_settings", kind: "message", T: () => TSKArchives_1.StructuredTextImportSettings },
            { no: 2, name: "import_source", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "import_date", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "source_data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "source_encoding", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "confidence", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "imported_region", kind: "message", T: () => exports.CellRegion },
            { no: 8, name: "source_row_count", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "source_column_count", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.StructuredTextImportSettings import_settings */ 1:
                    message.importSettings = TSKArchives_1.StructuredTextImportSettings.internalBinaryRead(reader, reader.uint32(), options, message.importSettings);
                    break;
                case /* optional string import_source */ 2:
                    message.importSource = reader.string();
                    break;
                case /* optional double import_date */ 3:
                    message.importDate = reader.double();
                    break;
                case /* optional bytes source_data */ 4:
                    message.sourceData = reader.bytes();
                    break;
                case /* optional uint64 source_encoding */ 5:
                    message.sourceEncoding = reader.uint64().toBigInt();
                    break;
                case /* optional float confidence */ 6:
                    message.confidence = reader.float();
                    break;
                case /* optional TST.CellRegion imported_region */ 7:
                    message.importedRegion = exports.CellRegion.internalBinaryRead(reader, reader.uint32(), options, message.importedRegion);
                    break;
                case /* optional uint64 source_row_count */ 8:
                    message.sourceRowCount = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 source_column_count */ 9:
                    message.sourceColumnCount = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.StructuredTextImportSettings import_settings = 1; */
        if (message.importSettings)
            TSKArchives_1.StructuredTextImportSettings.internalBinaryWrite(message.importSettings, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string import_source = 2; */
        if (message.importSource !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.importSource);
        /* optional double import_date = 3; */
        if (message.importDate !== undefined)
            writer.tag(3, runtime_1.WireType.Bit64).double(message.importDate);
        /* optional bytes source_data = 4; */
        if (message.sourceData !== undefined)
            writer.tag(4, runtime_1.WireType.LengthDelimited).bytes(message.sourceData);
        /* optional uint64 source_encoding = 5; */
        if (message.sourceEncoding !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).uint64(message.sourceEncoding);
        /* optional float confidence = 6; */
        if (message.confidence !== undefined)
            writer.tag(6, runtime_1.WireType.Bit32).float(message.confidence);
        /* optional TST.CellRegion imported_region = 7; */
        if (message.importedRegion)
            exports.CellRegion.internalBinaryWrite(message.importedRegion, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint64 source_row_count = 8; */
        if (message.sourceRowCount !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).uint64(message.sourceRowCount);
        /* optional uint64 source_column_count = 9; */
        if (message.sourceColumnCount !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).uint64(message.sourceColumnCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.StructuredTextImportRecord
 */
exports.StructuredTextImportRecord = new StructuredTextImportRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TableModelArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.TableModelArchive", [
            { no: 1, name: "table_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 43, name: "from_table_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 50, name: "was_cut", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "table_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 24, name: "body_text_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 25, name: "header_row_text_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 26, name: "header_column_text_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 27, name: "footer_row_text_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 18, name: "body_cell_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 19, name: "header_row_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 20, name: "header_column_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 21, name: "footer_row_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 30, name: "table_name_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 36, name: "table_name_shape_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 48, name: "table_style_preset", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 28, name: "preset_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "base_data_store", kind: "message", T: () => exports.DataStore },
            { no: 5, name: "provider", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 6, name: "number_of_rows", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "number_of_columns", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "table_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 22, name: "table_name_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 33, name: "table_name_height", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 37, name: "table_name_border_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "number_of_header_rows", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "number_of_header_columns", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "number_of_footer_rows", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "header_rows_frozen", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "header_columns_frozen", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "number_of_hidden_rows", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "number_of_hidden_columns", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 41, name: "number_of_user_hidden_rows", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 42, name: "number_of_user_hidden_columns", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 40, name: "number_of_filtered_rows", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 16, name: "default_row_height", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 17, name: "default_column_width", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 23, name: "origin_offset", kind: "message", T: () => exports.CellID },
            { no: 29, name: "repeating_header_rows_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 31, name: "style_apply_clears_all", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 32, name: "repeating_header_columns_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 34, name: "hidden_state_formula_owner_for_columns", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 35, name: "hidden_state_formula_owner_for_rows", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 38, name: "row_filter_set_pre_pivot", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 39, name: "conditional_style_formula_owner_id", kind: "message", T: () => TSPMessages_7.CFUUIDArchive },
            { no: 44, name: "sort_order", kind: "message", T: () => exports.TableSortOrderArchive },
            { no: 45, name: "sort_rule_reference_tracker", kind: "message", T: () => exports.SortRuleReferenceTrackerArchive },
            { no: 46, name: "base_column_row_uids", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 47, name: "merge_owner", kind: "message", T: () => exports.MergeOwnerArchive },
            { no: 49, name: "stroke_sidecar", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 51, name: "preset_needs_strong_ownership", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 52, name: "text_import_record", kind: "message", T: () => exports.StructuredTextImportRecord },
            { no: 60, name: "category_level_1_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 61, name: "category_level_2_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 62, name: "category_level_3_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 63, name: "category_level_4_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 64, name: "category_level_5_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 65, name: "category_level_1_text_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 66, name: "category_level_2_text_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 67, name: "category_level_3_text_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 68, name: "category_level_4_text_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 69, name: "category_level_5_text_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 70, name: "hidden_states_owner", kind: "message", T: () => exports.HiddenStatesOwnerArchive },
            { no: 71, name: "label_level_1_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 72, name: "label_level_2_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 73, name: "label_level_3_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 74, name: "label_level_4_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 75, name: "label_level_5_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 76, name: "label_level_1_text_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 77, name: "label_level_2_text_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 78, name: "label_level_3_text_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 79, name: "label_level_4_text_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 80, name: "label_level_5_text_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 81, name: "category_owner_deprecated", kind: "message", T: () => exports.CategoryOwnerArchive },
            { no: 82, name: "pencil_annotation_owner", kind: "message", T: () => exports.PencilAnnotationOwnerArchive },
            { no: 83, name: "from_group_by_uid", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 84, name: "haunted_owner", kind: "message", T: () => TSCEArchives_10.HauntedOwnerArchive },
            { no: 85, name: "pivot_owner", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 86, name: "category_owner", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 87, name: "pivot_body_summary_row_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 88, name: "pivot_body_summary_column_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 89, name: "pivot_header_column_summary_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 90, name: "pivot_value_types_by_col", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 91, name: "pivot_date_grouping_columns", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 92, name: "pivot_date_grouping_types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { tableId: "", numberOfRows: 0, numberOfColumns: 0, tableName: "", defaultRowHeight: 0, defaultColumnWidth: 0, pivotValueTypesByCol: [], pivotDateGroupingColumns: [], pivotDateGroupingTypes: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string table_id */ 1:
                    message.tableId = reader.string();
                    break;
                case /* optional string from_table_id */ 43:
                    message.fromTableId = reader.string();
                    break;
                case /* optional bool was_cut */ 50:
                    message.wasCut = reader.bool();
                    break;
                case /* TSP.Reference table_style */ 3:
                    message.tableStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.tableStyle);
                    break;
                case /* TSP.Reference body_text_style */ 24:
                    message.bodyTextStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.bodyTextStyle);
                    break;
                case /* TSP.Reference header_row_text_style */ 25:
                    message.headerRowTextStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.headerRowTextStyle);
                    break;
                case /* TSP.Reference header_column_text_style */ 26:
                    message.headerColumnTextStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.headerColumnTextStyle);
                    break;
                case /* TSP.Reference footer_row_text_style */ 27:
                    message.footerRowTextStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.footerRowTextStyle);
                    break;
                case /* TSP.Reference body_cell_style */ 18:
                    message.bodyCellStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.bodyCellStyle);
                    break;
                case /* TSP.Reference header_row_style */ 19:
                    message.headerRowStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.headerRowStyle);
                    break;
                case /* TSP.Reference header_column_style */ 20:
                    message.headerColumnStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.headerColumnStyle);
                    break;
                case /* TSP.Reference footer_row_style */ 21:
                    message.footerRowStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.footerRowStyle);
                    break;
                case /* optional TSP.Reference table_name_style */ 30:
                    message.tableNameStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.tableNameStyle);
                    break;
                case /* optional TSP.Reference table_name_shape_style */ 36:
                    message.tableNameShapeStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.tableNameShapeStyle);
                    break;
                case /* optional TSP.Reference table_style_preset */ 48:
                    message.tableStylePreset = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.tableStylePreset);
                    break;
                case /* optional uint32 preset_index */ 28:
                    message.presetIndex = reader.uint32();
                    break;
                case /* TST.DataStore base_data_store */ 4:
                    message.baseDataStore = exports.DataStore.internalBinaryRead(reader, reader.uint32(), options, message.baseDataStore);
                    break;
                case /* optional TSP.Reference provider */ 5:
                    message.provider = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.provider);
                    break;
                case /* uint32 number_of_rows */ 6:
                    message.numberOfRows = reader.uint32();
                    break;
                case /* uint32 number_of_columns */ 7:
                    message.numberOfColumns = reader.uint32();
                    break;
                case /* string table_name */ 8:
                    message.tableName = reader.string();
                    break;
                case /* optional bool table_name_enabled */ 22:
                    message.tableNameEnabled = reader.bool();
                    break;
                case /* optional double table_name_height */ 33:
                    message.tableNameHeight = reader.double();
                    break;
                case /* optional bool table_name_border_enabled */ 37:
                    message.tableNameBorderEnabled = reader.bool();
                    break;
                case /* optional uint32 number_of_header_rows */ 9:
                    message.numberOfHeaderRows = reader.uint32();
                    break;
                case /* optional uint32 number_of_header_columns */ 10:
                    message.numberOfHeaderColumns = reader.uint32();
                    break;
                case /* optional uint32 number_of_footer_rows */ 11:
                    message.numberOfFooterRows = reader.uint32();
                    break;
                case /* optional bool header_rows_frozen */ 12:
                    message.headerRowsFrozen = reader.bool();
                    break;
                case /* optional bool header_columns_frozen */ 13:
                    message.headerColumnsFrozen = reader.bool();
                    break;
                case /* optional uint32 number_of_hidden_rows */ 14:
                    message.numberOfHiddenRows = reader.uint32();
                    break;
                case /* optional uint32 number_of_hidden_columns */ 15:
                    message.numberOfHiddenColumns = reader.uint32();
                    break;
                case /* optional uint32 number_of_user_hidden_rows */ 41:
                    message.numberOfUserHiddenRows = reader.uint32();
                    break;
                case /* optional uint32 number_of_user_hidden_columns */ 42:
                    message.numberOfUserHiddenColumns = reader.uint32();
                    break;
                case /* optional uint32 number_of_filtered_rows */ 40:
                    message.numberOfFilteredRows = reader.uint32();
                    break;
                case /* double default_row_height */ 16:
                    message.defaultRowHeight = reader.double();
                    break;
                case /* double default_column_width */ 17:
                    message.defaultColumnWidth = reader.double();
                    break;
                case /* optional TST.CellID origin_offset = 23 [deprecated = true];*/ 23:
                    message.originOffset = exports.CellID.internalBinaryRead(reader, reader.uint32(), options, message.originOffset);
                    break;
                case /* optional bool repeating_header_rows_enabled */ 29:
                    message.repeatingHeaderRowsEnabled = reader.bool();
                    break;
                case /* optional bool style_apply_clears_all */ 31:
                    message.styleApplyClearsAll = reader.bool();
                    break;
                case /* optional bool repeating_header_columns_enabled */ 32:
                    message.repeatingHeaderColumnsEnabled = reader.bool();
                    break;
                case /* optional TSP.Reference hidden_state_formula_owner_for_columns */ 34:
                    message.hiddenStateFormulaOwnerForColumns = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.hiddenStateFormulaOwnerForColumns);
                    break;
                case /* optional TSP.Reference hidden_state_formula_owner_for_rows */ 35:
                    message.hiddenStateFormulaOwnerForRows = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.hiddenStateFormulaOwnerForRows);
                    break;
                case /* optional TSP.Reference row_filter_set_pre_pivot */ 38:
                    message.rowFilterSetPrePivot = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.rowFilterSetPrePivot);
                    break;
                case /* optional TSP.CFUUIDArchive conditional_style_formula_owner_id */ 39:
                    message.conditionalStyleFormulaOwnerId = TSPMessages_7.CFUUIDArchive.internalBinaryRead(reader, reader.uint32(), options, message.conditionalStyleFormulaOwnerId);
                    break;
                case /* optional TST.TableSortOrderArchive sort_order */ 44:
                    message.sortOrder = exports.TableSortOrderArchive.internalBinaryRead(reader, reader.uint32(), options, message.sortOrder);
                    break;
                case /* optional TST.SortRuleReferenceTrackerArchive sort_rule_reference_tracker */ 45:
                    message.sortRuleReferenceTracker = exports.SortRuleReferenceTrackerArchive.internalBinaryRead(reader, reader.uint32(), options, message.sortRuleReferenceTracker);
                    break;
                case /* optional TSP.Reference base_column_row_uids */ 46:
                    message.baseColumnRowUids = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.baseColumnRowUids);
                    break;
                case /* optional TST.MergeOwnerArchive merge_owner */ 47:
                    message.mergeOwner = exports.MergeOwnerArchive.internalBinaryRead(reader, reader.uint32(), options, message.mergeOwner);
                    break;
                case /* optional TSP.Reference stroke_sidecar */ 49:
                    message.strokeSidecar = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.strokeSidecar);
                    break;
                case /* optional bool preset_needs_strong_ownership */ 51:
                    message.presetNeedsStrongOwnership = reader.bool();
                    break;
                case /* optional TST.StructuredTextImportRecord text_import_record */ 52:
                    message.textImportRecord = exports.StructuredTextImportRecord.internalBinaryRead(reader, reader.uint32(), options, message.textImportRecord);
                    break;
                case /* optional TSP.Reference category_level_1_style */ 60:
                    message.categoryLevel1Style = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.categoryLevel1Style);
                    break;
                case /* optional TSP.Reference category_level_2_style */ 61:
                    message.categoryLevel2Style = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.categoryLevel2Style);
                    break;
                case /* optional TSP.Reference category_level_3_style */ 62:
                    message.categoryLevel3Style = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.categoryLevel3Style);
                    break;
                case /* optional TSP.Reference category_level_4_style */ 63:
                    message.categoryLevel4Style = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.categoryLevel4Style);
                    break;
                case /* optional TSP.Reference category_level_5_style */ 64:
                    message.categoryLevel5Style = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.categoryLevel5Style);
                    break;
                case /* optional TSP.Reference category_level_1_text_style */ 65:
                    message.categoryLevel1TextStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.categoryLevel1TextStyle);
                    break;
                case /* optional TSP.Reference category_level_2_text_style */ 66:
                    message.categoryLevel2TextStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.categoryLevel2TextStyle);
                    break;
                case /* optional TSP.Reference category_level_3_text_style */ 67:
                    message.categoryLevel3TextStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.categoryLevel3TextStyle);
                    break;
                case /* optional TSP.Reference category_level_4_text_style */ 68:
                    message.categoryLevel4TextStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.categoryLevel4TextStyle);
                    break;
                case /* optional TSP.Reference category_level_5_text_style */ 69:
                    message.categoryLevel5TextStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.categoryLevel5TextStyle);
                    break;
                case /* optional TST.HiddenStatesOwnerArchive hidden_states_owner */ 70:
                    message.hiddenStatesOwner = exports.HiddenStatesOwnerArchive.internalBinaryRead(reader, reader.uint32(), options, message.hiddenStatesOwner);
                    break;
                case /* optional TSP.Reference label_level_1_style */ 71:
                    message.labelLevel1Style = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.labelLevel1Style);
                    break;
                case /* optional TSP.Reference label_level_2_style */ 72:
                    message.labelLevel2Style = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.labelLevel2Style);
                    break;
                case /* optional TSP.Reference label_level_3_style */ 73:
                    message.labelLevel3Style = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.labelLevel3Style);
                    break;
                case /* optional TSP.Reference label_level_4_style */ 74:
                    message.labelLevel4Style = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.labelLevel4Style);
                    break;
                case /* optional TSP.Reference label_level_5_style */ 75:
                    message.labelLevel5Style = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.labelLevel5Style);
                    break;
                case /* optional TSP.Reference label_level_1_text_style */ 76:
                    message.labelLevel1TextStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.labelLevel1TextStyle);
                    break;
                case /* optional TSP.Reference label_level_2_text_style */ 77:
                    message.labelLevel2TextStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.labelLevel2TextStyle);
                    break;
                case /* optional TSP.Reference label_level_3_text_style */ 78:
                    message.labelLevel3TextStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.labelLevel3TextStyle);
                    break;
                case /* optional TSP.Reference label_level_4_text_style */ 79:
                    message.labelLevel4TextStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.labelLevel4TextStyle);
                    break;
                case /* optional TSP.Reference label_level_5_text_style */ 80:
                    message.labelLevel5TextStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.labelLevel5TextStyle);
                    break;
                case /* optional TST.CategoryOwnerArchive category_owner_deprecated */ 81:
                    message.categoryOwnerDeprecated = exports.CategoryOwnerArchive.internalBinaryRead(reader, reader.uint32(), options, message.categoryOwnerDeprecated);
                    break;
                case /* optional TST.PencilAnnotationOwnerArchive pencil_annotation_owner */ 82:
                    message.pencilAnnotationOwner = exports.PencilAnnotationOwnerArchive.internalBinaryRead(reader, reader.uint32(), options, message.pencilAnnotationOwner);
                    break;
                case /* optional string from_group_by_uid */ 83:
                    message.fromGroupByUid = reader.string();
                    break;
                case /* optional TSCE.HauntedOwnerArchive haunted_owner */ 84:
                    message.hauntedOwner = TSCEArchives_10.HauntedOwnerArchive.internalBinaryRead(reader, reader.uint32(), options, message.hauntedOwner);
                    break;
                case /* optional TSP.Reference pivot_owner */ 85:
                    message.pivotOwner = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.pivotOwner);
                    break;
                case /* optional TSP.Reference category_owner */ 86:
                    message.categoryOwner = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.categoryOwner);
                    break;
                case /* optional TSP.Reference pivot_body_summary_row_style */ 87:
                    message.pivotBodySummaryRowStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.pivotBodySummaryRowStyle);
                    break;
                case /* optional TSP.Reference pivot_body_summary_column_style */ 88:
                    message.pivotBodySummaryColumnStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.pivotBodySummaryColumnStyle);
                    break;
                case /* optional TSP.Reference pivot_header_column_summary_style */ 89:
                    message.pivotHeaderColumnSummaryStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.pivotHeaderColumnSummaryStyle);
                    break;
                case /* repeated uint32 pivot_value_types_by_col */ 90:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.pivotValueTypesByCol.push(reader.uint32());
                    else
                        message.pivotValueTypesByCol.push(reader.uint32());
                    break;
                case /* repeated uint32 pivot_date_grouping_columns */ 91:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.pivotDateGroupingColumns.push(reader.uint32());
                    else
                        message.pivotDateGroupingColumns.push(reader.uint32());
                    break;
                case /* repeated uint32 pivot_date_grouping_types */ 92:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.pivotDateGroupingTypes.push(reader.uint32());
                    else
                        message.pivotDateGroupingTypes.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string table_id = 1; */
        if (message.tableId !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.tableId);
        /* optional string from_table_id = 43; */
        if (message.fromTableId !== undefined)
            writer.tag(43, runtime_1.WireType.LengthDelimited).string(message.fromTableId);
        /* optional bool was_cut = 50; */
        if (message.wasCut !== undefined)
            writer.tag(50, runtime_1.WireType.Varint).bool(message.wasCut);
        /* TSP.Reference table_style = 3; */
        if (message.tableStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.tableStyle, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference body_text_style = 24; */
        if (message.bodyTextStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.bodyTextStyle, writer.tag(24, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference header_row_text_style = 25; */
        if (message.headerRowTextStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.headerRowTextStyle, writer.tag(25, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference header_column_text_style = 26; */
        if (message.headerColumnTextStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.headerColumnTextStyle, writer.tag(26, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference footer_row_text_style = 27; */
        if (message.footerRowTextStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.footerRowTextStyle, writer.tag(27, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference body_cell_style = 18; */
        if (message.bodyCellStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.bodyCellStyle, writer.tag(18, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference header_row_style = 19; */
        if (message.headerRowStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.headerRowStyle, writer.tag(19, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference header_column_style = 20; */
        if (message.headerColumnStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.headerColumnStyle, writer.tag(20, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference footer_row_style = 21; */
        if (message.footerRowStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.footerRowStyle, writer.tag(21, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference table_name_style = 30; */
        if (message.tableNameStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.tableNameStyle, writer.tag(30, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference table_name_shape_style = 36; */
        if (message.tableNameShapeStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.tableNameShapeStyle, writer.tag(36, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference table_style_preset = 48; */
        if (message.tableStylePreset)
            TSPMessages_10.Reference.internalBinaryWrite(message.tableStylePreset, writer.tag(48, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 preset_index = 28; */
        if (message.presetIndex !== undefined)
            writer.tag(28, runtime_1.WireType.Varint).uint32(message.presetIndex);
        /* TST.DataStore base_data_store = 4; */
        if (message.baseDataStore)
            exports.DataStore.internalBinaryWrite(message.baseDataStore, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference provider = 5; */
        if (message.provider)
            TSPMessages_10.Reference.internalBinaryWrite(message.provider, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 number_of_rows = 6; */
        if (message.numberOfRows !== 0)
            writer.tag(6, runtime_1.WireType.Varint).uint32(message.numberOfRows);
        /* uint32 number_of_columns = 7; */
        if (message.numberOfColumns !== 0)
            writer.tag(7, runtime_1.WireType.Varint).uint32(message.numberOfColumns);
        /* string table_name = 8; */
        if (message.tableName !== "")
            writer.tag(8, runtime_1.WireType.LengthDelimited).string(message.tableName);
        /* optional bool table_name_enabled = 22; */
        if (message.tableNameEnabled !== undefined)
            writer.tag(22, runtime_1.WireType.Varint).bool(message.tableNameEnabled);
        /* optional double table_name_height = 33; */
        if (message.tableNameHeight !== undefined)
            writer.tag(33, runtime_1.WireType.Bit64).double(message.tableNameHeight);
        /* optional bool table_name_border_enabled = 37; */
        if (message.tableNameBorderEnabled !== undefined)
            writer.tag(37, runtime_1.WireType.Varint).bool(message.tableNameBorderEnabled);
        /* optional uint32 number_of_header_rows = 9; */
        if (message.numberOfHeaderRows !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).uint32(message.numberOfHeaderRows);
        /* optional uint32 number_of_header_columns = 10; */
        if (message.numberOfHeaderColumns !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).uint32(message.numberOfHeaderColumns);
        /* optional uint32 number_of_footer_rows = 11; */
        if (message.numberOfFooterRows !== undefined)
            writer.tag(11, runtime_1.WireType.Varint).uint32(message.numberOfFooterRows);
        /* optional bool header_rows_frozen = 12; */
        if (message.headerRowsFrozen !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).bool(message.headerRowsFrozen);
        /* optional bool header_columns_frozen = 13; */
        if (message.headerColumnsFrozen !== undefined)
            writer.tag(13, runtime_1.WireType.Varint).bool(message.headerColumnsFrozen);
        /* optional uint32 number_of_hidden_rows = 14; */
        if (message.numberOfHiddenRows !== undefined)
            writer.tag(14, runtime_1.WireType.Varint).uint32(message.numberOfHiddenRows);
        /* optional uint32 number_of_hidden_columns = 15; */
        if (message.numberOfHiddenColumns !== undefined)
            writer.tag(15, runtime_1.WireType.Varint).uint32(message.numberOfHiddenColumns);
        /* optional uint32 number_of_user_hidden_rows = 41; */
        if (message.numberOfUserHiddenRows !== undefined)
            writer.tag(41, runtime_1.WireType.Varint).uint32(message.numberOfUserHiddenRows);
        /* optional uint32 number_of_user_hidden_columns = 42; */
        if (message.numberOfUserHiddenColumns !== undefined)
            writer.tag(42, runtime_1.WireType.Varint).uint32(message.numberOfUserHiddenColumns);
        /* optional uint32 number_of_filtered_rows = 40; */
        if (message.numberOfFilteredRows !== undefined)
            writer.tag(40, runtime_1.WireType.Varint).uint32(message.numberOfFilteredRows);
        /* double default_row_height = 16; */
        if (message.defaultRowHeight !== 0)
            writer.tag(16, runtime_1.WireType.Bit64).double(message.defaultRowHeight);
        /* double default_column_width = 17; */
        if (message.defaultColumnWidth !== 0)
            writer.tag(17, runtime_1.WireType.Bit64).double(message.defaultColumnWidth);
        /* optional TST.CellID origin_offset = 23 [deprecated = true]; */
        if (message.originOffset)
            exports.CellID.internalBinaryWrite(message.originOffset, writer.tag(23, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool repeating_header_rows_enabled = 29; */
        if (message.repeatingHeaderRowsEnabled !== undefined)
            writer.tag(29, runtime_1.WireType.Varint).bool(message.repeatingHeaderRowsEnabled);
        /* optional bool style_apply_clears_all = 31; */
        if (message.styleApplyClearsAll !== undefined)
            writer.tag(31, runtime_1.WireType.Varint).bool(message.styleApplyClearsAll);
        /* optional bool repeating_header_columns_enabled = 32; */
        if (message.repeatingHeaderColumnsEnabled !== undefined)
            writer.tag(32, runtime_1.WireType.Varint).bool(message.repeatingHeaderColumnsEnabled);
        /* optional TSP.Reference hidden_state_formula_owner_for_columns = 34; */
        if (message.hiddenStateFormulaOwnerForColumns)
            TSPMessages_10.Reference.internalBinaryWrite(message.hiddenStateFormulaOwnerForColumns, writer.tag(34, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference hidden_state_formula_owner_for_rows = 35; */
        if (message.hiddenStateFormulaOwnerForRows)
            TSPMessages_10.Reference.internalBinaryWrite(message.hiddenStateFormulaOwnerForRows, writer.tag(35, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference row_filter_set_pre_pivot = 38; */
        if (message.rowFilterSetPrePivot)
            TSPMessages_10.Reference.internalBinaryWrite(message.rowFilterSetPrePivot, writer.tag(38, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.CFUUIDArchive conditional_style_formula_owner_id = 39; */
        if (message.conditionalStyleFormulaOwnerId)
            TSPMessages_7.CFUUIDArchive.internalBinaryWrite(message.conditionalStyleFormulaOwnerId, writer.tag(39, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.TableSortOrderArchive sort_order = 44; */
        if (message.sortOrder)
            exports.TableSortOrderArchive.internalBinaryWrite(message.sortOrder, writer.tag(44, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.SortRuleReferenceTrackerArchive sort_rule_reference_tracker = 45; */
        if (message.sortRuleReferenceTracker)
            exports.SortRuleReferenceTrackerArchive.internalBinaryWrite(message.sortRuleReferenceTracker, writer.tag(45, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference base_column_row_uids = 46; */
        if (message.baseColumnRowUids)
            TSPMessages_10.Reference.internalBinaryWrite(message.baseColumnRowUids, writer.tag(46, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.MergeOwnerArchive merge_owner = 47; */
        if (message.mergeOwner)
            exports.MergeOwnerArchive.internalBinaryWrite(message.mergeOwner, writer.tag(47, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference stroke_sidecar = 49; */
        if (message.strokeSidecar)
            TSPMessages_10.Reference.internalBinaryWrite(message.strokeSidecar, writer.tag(49, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool preset_needs_strong_ownership = 51; */
        if (message.presetNeedsStrongOwnership !== undefined)
            writer.tag(51, runtime_1.WireType.Varint).bool(message.presetNeedsStrongOwnership);
        /* optional TST.StructuredTextImportRecord text_import_record = 52; */
        if (message.textImportRecord)
            exports.StructuredTextImportRecord.internalBinaryWrite(message.textImportRecord, writer.tag(52, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference category_level_1_style = 60; */
        if (message.categoryLevel1Style)
            TSPMessages_10.Reference.internalBinaryWrite(message.categoryLevel1Style, writer.tag(60, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference category_level_2_style = 61; */
        if (message.categoryLevel2Style)
            TSPMessages_10.Reference.internalBinaryWrite(message.categoryLevel2Style, writer.tag(61, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference category_level_3_style = 62; */
        if (message.categoryLevel3Style)
            TSPMessages_10.Reference.internalBinaryWrite(message.categoryLevel3Style, writer.tag(62, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference category_level_4_style = 63; */
        if (message.categoryLevel4Style)
            TSPMessages_10.Reference.internalBinaryWrite(message.categoryLevel4Style, writer.tag(63, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference category_level_5_style = 64; */
        if (message.categoryLevel5Style)
            TSPMessages_10.Reference.internalBinaryWrite(message.categoryLevel5Style, writer.tag(64, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference category_level_1_text_style = 65; */
        if (message.categoryLevel1TextStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.categoryLevel1TextStyle, writer.tag(65, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference category_level_2_text_style = 66; */
        if (message.categoryLevel2TextStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.categoryLevel2TextStyle, writer.tag(66, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference category_level_3_text_style = 67; */
        if (message.categoryLevel3TextStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.categoryLevel3TextStyle, writer.tag(67, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference category_level_4_text_style = 68; */
        if (message.categoryLevel4TextStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.categoryLevel4TextStyle, writer.tag(68, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference category_level_5_text_style = 69; */
        if (message.categoryLevel5TextStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.categoryLevel5TextStyle, writer.tag(69, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.HiddenStatesOwnerArchive hidden_states_owner = 70; */
        if (message.hiddenStatesOwner)
            exports.HiddenStatesOwnerArchive.internalBinaryWrite(message.hiddenStatesOwner, writer.tag(70, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference label_level_1_style = 71; */
        if (message.labelLevel1Style)
            TSPMessages_10.Reference.internalBinaryWrite(message.labelLevel1Style, writer.tag(71, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference label_level_2_style = 72; */
        if (message.labelLevel2Style)
            TSPMessages_10.Reference.internalBinaryWrite(message.labelLevel2Style, writer.tag(72, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference label_level_3_style = 73; */
        if (message.labelLevel3Style)
            TSPMessages_10.Reference.internalBinaryWrite(message.labelLevel3Style, writer.tag(73, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference label_level_4_style = 74; */
        if (message.labelLevel4Style)
            TSPMessages_10.Reference.internalBinaryWrite(message.labelLevel4Style, writer.tag(74, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference label_level_5_style = 75; */
        if (message.labelLevel5Style)
            TSPMessages_10.Reference.internalBinaryWrite(message.labelLevel5Style, writer.tag(75, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference label_level_1_text_style = 76; */
        if (message.labelLevel1TextStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.labelLevel1TextStyle, writer.tag(76, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference label_level_2_text_style = 77; */
        if (message.labelLevel2TextStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.labelLevel2TextStyle, writer.tag(77, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference label_level_3_text_style = 78; */
        if (message.labelLevel3TextStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.labelLevel3TextStyle, writer.tag(78, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference label_level_4_text_style = 79; */
        if (message.labelLevel4TextStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.labelLevel4TextStyle, writer.tag(79, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference label_level_5_text_style = 80; */
        if (message.labelLevel5TextStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.labelLevel5TextStyle, writer.tag(80, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.CategoryOwnerArchive category_owner_deprecated = 81; */
        if (message.categoryOwnerDeprecated)
            exports.CategoryOwnerArchive.internalBinaryWrite(message.categoryOwnerDeprecated, writer.tag(81, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.PencilAnnotationOwnerArchive pencil_annotation_owner = 82; */
        if (message.pencilAnnotationOwner)
            exports.PencilAnnotationOwnerArchive.internalBinaryWrite(message.pencilAnnotationOwner, writer.tag(82, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string from_group_by_uid = 83; */
        if (message.fromGroupByUid !== undefined)
            writer.tag(83, runtime_1.WireType.LengthDelimited).string(message.fromGroupByUid);
        /* optional TSCE.HauntedOwnerArchive haunted_owner = 84; */
        if (message.hauntedOwner)
            TSCEArchives_10.HauntedOwnerArchive.internalBinaryWrite(message.hauntedOwner, writer.tag(84, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference pivot_owner = 85; */
        if (message.pivotOwner)
            TSPMessages_10.Reference.internalBinaryWrite(message.pivotOwner, writer.tag(85, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference category_owner = 86; */
        if (message.categoryOwner)
            TSPMessages_10.Reference.internalBinaryWrite(message.categoryOwner, writer.tag(86, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference pivot_body_summary_row_style = 87; */
        if (message.pivotBodySummaryRowStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.pivotBodySummaryRowStyle, writer.tag(87, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference pivot_body_summary_column_style = 88; */
        if (message.pivotBodySummaryColumnStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.pivotBodySummaryColumnStyle, writer.tag(88, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference pivot_header_column_summary_style = 89; */
        if (message.pivotHeaderColumnSummaryStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.pivotHeaderColumnSummaryStyle, writer.tag(89, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 pivot_value_types_by_col = 90; */
        for (let i = 0; i < message.pivotValueTypesByCol.length; i++)
            writer.tag(90, runtime_1.WireType.Varint).uint32(message.pivotValueTypesByCol[i]);
        /* repeated uint32 pivot_date_grouping_columns = 91; */
        for (let i = 0; i < message.pivotDateGroupingColumns.length; i++)
            writer.tag(91, runtime_1.WireType.Varint).uint32(message.pivotDateGroupingColumns[i]);
        /* repeated uint32 pivot_date_grouping_types = 92; */
        for (let i = 0; i < message.pivotDateGroupingTypes.length; i++)
            writer.tag(92, runtime_1.WireType.Varint).uint32(message.pivotDateGroupingTypes[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.TableModelArchive
 */
exports.TableModelArchive = new TableModelArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SummaryModelArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.SummaryModelArchive", [
            { no: 1, name: "table_info", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 2, name: "data_store", kind: "message", T: () => exports.DataStore },
            { no: 3, name: "column_row_uids", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 4, name: "aggregate_formula_owner_uuid", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 5, name: "summary_cell_vendor", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 10, name: "category_column_width", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 11, name: "summary_row_level_1_height", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 12, name: "summary_row_level_2_height", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 13, name: "summary_row_level_3_height", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 14, name: "summary_row_level_4_height", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 15, name: "summary_row_level_5_height", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 16, name: "summary_label_row_level_1_height", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 17, name: "summary_label_row_level_2_height", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 18, name: "summary_label_row_level_3_height", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 19, name: "summary_label_row_level_4_height", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 20, name: "summary_label_row_level_5_height", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 21, name: "label_row_visibility_1", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 22, name: "label_row_visibility_2", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 23, name: "label_row_visibility_3", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 24, name: "label_row_visibility_4", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 25, name: "label_row_visibility_5", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 26, name: "summary_row_height_list", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 27, name: "label_row_height_list", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 28, name: "label_row_visibility_list", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 29, name: "group_sort_order", kind: "message", T: () => exports.TableGroupSortOrderUIDArchive }
        ]);
    }
    create(value) {
        const message = { summaryRowHeightList: [], labelRowHeightList: [], labelRowVisibilityList: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.Reference table_info */ 1:
                    message.tableInfo = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.tableInfo);
                    break;
                case /* optional TST.DataStore data_store */ 2:
                    message.dataStore = exports.DataStore.internalBinaryRead(reader, reader.uint32(), options, message.dataStore);
                    break;
                case /* optional TSP.Reference column_row_uids */ 3:
                    message.columnRowUids = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.columnRowUids);
                    break;
                case /* optional TSP.UUID aggregate_formula_owner_uuid */ 4:
                    message.aggregateFormulaOwnerUuid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.aggregateFormulaOwnerUuid);
                    break;
                case /* optional TSP.Reference summary_cell_vendor */ 5:
                    message.summaryCellVendor = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.summaryCellVendor);
                    break;
                case /* optional double category_column_width */ 10:
                    message.categoryColumnWidth = reader.double();
                    break;
                case /* optional double summary_row_level_1_height = 11 [deprecated = true];*/ 11:
                    message.summaryRowLevel1Height = reader.double();
                    break;
                case /* optional double summary_row_level_2_height = 12 [deprecated = true];*/ 12:
                    message.summaryRowLevel2Height = reader.double();
                    break;
                case /* optional double summary_row_level_3_height = 13 [deprecated = true];*/ 13:
                    message.summaryRowLevel3Height = reader.double();
                    break;
                case /* optional double summary_row_level_4_height = 14 [deprecated = true];*/ 14:
                    message.summaryRowLevel4Height = reader.double();
                    break;
                case /* optional double summary_row_level_5_height = 15 [deprecated = true];*/ 15:
                    message.summaryRowLevel5Height = reader.double();
                    break;
                case /* optional double summary_label_row_level_1_height = 16 [deprecated = true];*/ 16:
                    message.summaryLabelRowLevel1Height = reader.double();
                    break;
                case /* optional double summary_label_row_level_2_height = 17 [deprecated = true];*/ 17:
                    message.summaryLabelRowLevel2Height = reader.double();
                    break;
                case /* optional double summary_label_row_level_3_height = 18 [deprecated = true];*/ 18:
                    message.summaryLabelRowLevel3Height = reader.double();
                    break;
                case /* optional double summary_label_row_level_4_height = 19 [deprecated = true];*/ 19:
                    message.summaryLabelRowLevel4Height = reader.double();
                    break;
                case /* optional double summary_label_row_level_5_height = 20 [deprecated = true];*/ 20:
                    message.summaryLabelRowLevel5Height = reader.double();
                    break;
                case /* optional uint32 label_row_visibility_1 = 21 [deprecated = true];*/ 21:
                    message.labelRowVisibility1 = reader.uint32();
                    break;
                case /* optional uint32 label_row_visibility_2 = 22 [deprecated = true];*/ 22:
                    message.labelRowVisibility2 = reader.uint32();
                    break;
                case /* optional uint32 label_row_visibility_3 = 23 [deprecated = true];*/ 23:
                    message.labelRowVisibility3 = reader.uint32();
                    break;
                case /* optional uint32 label_row_visibility_4 = 24 [deprecated = true];*/ 24:
                    message.labelRowVisibility4 = reader.uint32();
                    break;
                case /* optional uint32 label_row_visibility_5 = 25 [deprecated = true];*/ 25:
                    message.labelRowVisibility5 = reader.uint32();
                    break;
                case /* repeated double summary_row_height_list */ 26:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.summaryRowHeightList.push(reader.double());
                    else
                        message.summaryRowHeightList.push(reader.double());
                    break;
                case /* repeated double label_row_height_list */ 27:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.labelRowHeightList.push(reader.double());
                    else
                        message.labelRowHeightList.push(reader.double());
                    break;
                case /* repeated uint32 label_row_visibility_list */ 28:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.labelRowVisibilityList.push(reader.uint32());
                    else
                        message.labelRowVisibilityList.push(reader.uint32());
                    break;
                case /* optional TST.TableGroupSortOrderUIDArchive group_sort_order */ 29:
                    message.groupSortOrder = exports.TableGroupSortOrderUIDArchive.internalBinaryRead(reader, reader.uint32(), options, message.groupSortOrder);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.Reference table_info = 1; */
        if (message.tableInfo)
            TSPMessages_10.Reference.internalBinaryWrite(message.tableInfo, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.DataStore data_store = 2; */
        if (message.dataStore)
            exports.DataStore.internalBinaryWrite(message.dataStore, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference column_row_uids = 3; */
        if (message.columnRowUids)
            TSPMessages_10.Reference.internalBinaryWrite(message.columnRowUids, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID aggregate_formula_owner_uuid = 4; */
        if (message.aggregateFormulaOwnerUuid)
            TSPMessages_11.UUID.internalBinaryWrite(message.aggregateFormulaOwnerUuid, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference summary_cell_vendor = 5; */
        if (message.summaryCellVendor)
            TSPMessages_10.Reference.internalBinaryWrite(message.summaryCellVendor, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional double category_column_width = 10; */
        if (message.categoryColumnWidth !== undefined)
            writer.tag(10, runtime_1.WireType.Bit64).double(message.categoryColumnWidth);
        /* optional double summary_row_level_1_height = 11 [deprecated = true]; */
        if (message.summaryRowLevel1Height !== undefined)
            writer.tag(11, runtime_1.WireType.Bit64).double(message.summaryRowLevel1Height);
        /* optional double summary_row_level_2_height = 12 [deprecated = true]; */
        if (message.summaryRowLevel2Height !== undefined)
            writer.tag(12, runtime_1.WireType.Bit64).double(message.summaryRowLevel2Height);
        /* optional double summary_row_level_3_height = 13 [deprecated = true]; */
        if (message.summaryRowLevel3Height !== undefined)
            writer.tag(13, runtime_1.WireType.Bit64).double(message.summaryRowLevel3Height);
        /* optional double summary_row_level_4_height = 14 [deprecated = true]; */
        if (message.summaryRowLevel4Height !== undefined)
            writer.tag(14, runtime_1.WireType.Bit64).double(message.summaryRowLevel4Height);
        /* optional double summary_row_level_5_height = 15 [deprecated = true]; */
        if (message.summaryRowLevel5Height !== undefined)
            writer.tag(15, runtime_1.WireType.Bit64).double(message.summaryRowLevel5Height);
        /* optional double summary_label_row_level_1_height = 16 [deprecated = true]; */
        if (message.summaryLabelRowLevel1Height !== undefined)
            writer.tag(16, runtime_1.WireType.Bit64).double(message.summaryLabelRowLevel1Height);
        /* optional double summary_label_row_level_2_height = 17 [deprecated = true]; */
        if (message.summaryLabelRowLevel2Height !== undefined)
            writer.tag(17, runtime_1.WireType.Bit64).double(message.summaryLabelRowLevel2Height);
        /* optional double summary_label_row_level_3_height = 18 [deprecated = true]; */
        if (message.summaryLabelRowLevel3Height !== undefined)
            writer.tag(18, runtime_1.WireType.Bit64).double(message.summaryLabelRowLevel3Height);
        /* optional double summary_label_row_level_4_height = 19 [deprecated = true]; */
        if (message.summaryLabelRowLevel4Height !== undefined)
            writer.tag(19, runtime_1.WireType.Bit64).double(message.summaryLabelRowLevel4Height);
        /* optional double summary_label_row_level_5_height = 20 [deprecated = true]; */
        if (message.summaryLabelRowLevel5Height !== undefined)
            writer.tag(20, runtime_1.WireType.Bit64).double(message.summaryLabelRowLevel5Height);
        /* optional uint32 label_row_visibility_1 = 21 [deprecated = true]; */
        if (message.labelRowVisibility1 !== undefined)
            writer.tag(21, runtime_1.WireType.Varint).uint32(message.labelRowVisibility1);
        /* optional uint32 label_row_visibility_2 = 22 [deprecated = true]; */
        if (message.labelRowVisibility2 !== undefined)
            writer.tag(22, runtime_1.WireType.Varint).uint32(message.labelRowVisibility2);
        /* optional uint32 label_row_visibility_3 = 23 [deprecated = true]; */
        if (message.labelRowVisibility3 !== undefined)
            writer.tag(23, runtime_1.WireType.Varint).uint32(message.labelRowVisibility3);
        /* optional uint32 label_row_visibility_4 = 24 [deprecated = true]; */
        if (message.labelRowVisibility4 !== undefined)
            writer.tag(24, runtime_1.WireType.Varint).uint32(message.labelRowVisibility4);
        /* optional uint32 label_row_visibility_5 = 25 [deprecated = true]; */
        if (message.labelRowVisibility5 !== undefined)
            writer.tag(25, runtime_1.WireType.Varint).uint32(message.labelRowVisibility5);
        /* repeated double summary_row_height_list = 26; */
        for (let i = 0; i < message.summaryRowHeightList.length; i++)
            writer.tag(26, runtime_1.WireType.Bit64).double(message.summaryRowHeightList[i]);
        /* repeated double label_row_height_list = 27; */
        for (let i = 0; i < message.labelRowHeightList.length; i++)
            writer.tag(27, runtime_1.WireType.Bit64).double(message.labelRowHeightList[i]);
        /* repeated uint32 label_row_visibility_list = 28; */
        for (let i = 0; i < message.labelRowVisibilityList.length; i++)
            writer.tag(28, runtime_1.WireType.Varint).uint32(message.labelRowVisibilityList[i]);
        /* optional TST.TableGroupSortOrderUIDArchive group_sort_order = 29; */
        if (message.groupSortOrder)
            exports.TableGroupSortOrderUIDArchive.internalBinaryWrite(message.groupSortOrder, writer.tag(29, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.SummaryModelArchive
 */
exports.SummaryModelArchive = new SummaryModelArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SummaryModelGroupByChangeStateArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.SummaryModelGroupByChangeStateArchive", [
            { no: 1, name: "cell_map", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 2, name: "summary_row_height_list", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "label_row_height_list", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "label_row_visibility_list", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { summaryRowHeightList: [], labelRowHeightList: [], labelRowVisibilityList: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference cell_map */ 1:
                    message.cellMap = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.cellMap);
                    break;
                case /* repeated double summary_row_height_list */ 2:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.summaryRowHeightList.push(reader.double());
                    else
                        message.summaryRowHeightList.push(reader.double());
                    break;
                case /* repeated double label_row_height_list */ 3:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.labelRowHeightList.push(reader.double());
                    else
                        message.labelRowHeightList.push(reader.double());
                    break;
                case /* repeated uint32 label_row_visibility_list */ 4:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.labelRowVisibilityList.push(reader.uint32());
                    else
                        message.labelRowVisibilityList.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference cell_map = 1; */
        if (message.cellMap)
            TSPMessages_10.Reference.internalBinaryWrite(message.cellMap, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated double summary_row_height_list = 2; */
        for (let i = 0; i < message.summaryRowHeightList.length; i++)
            writer.tag(2, runtime_1.WireType.Bit64).double(message.summaryRowHeightList[i]);
        /* repeated double label_row_height_list = 3; */
        for (let i = 0; i < message.labelRowHeightList.length; i++)
            writer.tag(3, runtime_1.WireType.Bit64).double(message.labelRowHeightList[i]);
        /* repeated uint32 label_row_visibility_list = 4; */
        for (let i = 0; i < message.labelRowVisibilityList.length; i++)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.labelRowVisibilityList[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.SummaryModelGroupByChangeStateArchive
 */
exports.SummaryModelGroupByChangeStateArchive = new SummaryModelGroupByChangeStateArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ColumnRowUIDMapArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.ColumnRowUIDMapArchive", [
            { no: 1, name: "sorted_column_uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_11.UUID },
            { no: 2, name: "column_index_for_uid", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "column_uid_for_index", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "sorted_row_uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_11.UUID },
            { no: 5, name: "row_index_for_uid", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "row_uid_for_index", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { sortedColumnUids: [], columnIndexForUid: [], columnUidForIndex: [], sortedRowUids: [], rowIndexForUid: [], rowUidForIndex: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.UUID sorted_column_uids */ 1:
                    message.sortedColumnUids.push(TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 column_index_for_uid */ 2:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.columnIndexForUid.push(reader.uint32());
                    else
                        message.columnIndexForUid.push(reader.uint32());
                    break;
                case /* repeated uint32 column_uid_for_index */ 3:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.columnUidForIndex.push(reader.uint32());
                    else
                        message.columnUidForIndex.push(reader.uint32());
                    break;
                case /* repeated TSP.UUID sorted_row_uids */ 4:
                    message.sortedRowUids.push(TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 row_index_for_uid */ 5:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.rowIndexForUid.push(reader.uint32());
                    else
                        message.rowIndexForUid.push(reader.uint32());
                    break;
                case /* repeated uint32 row_uid_for_index */ 6:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.rowUidForIndex.push(reader.uint32());
                    else
                        message.rowUidForIndex.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.UUID sorted_column_uids = 1; */
        for (let i = 0; i < message.sortedColumnUids.length; i++)
            TSPMessages_11.UUID.internalBinaryWrite(message.sortedColumnUids[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 column_index_for_uid = 2; */
        for (let i = 0; i < message.columnIndexForUid.length; i++)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.columnIndexForUid[i]);
        /* repeated uint32 column_uid_for_index = 3; */
        for (let i = 0; i < message.columnUidForIndex.length; i++)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.columnUidForIndex[i]);
        /* repeated TSP.UUID sorted_row_uids = 4; */
        for (let i = 0; i < message.sortedRowUids.length; i++)
            TSPMessages_11.UUID.internalBinaryWrite(message.sortedRowUids[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 row_index_for_uid = 5; */
        for (let i = 0; i < message.rowIndexForUid.length; i++)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.rowIndexForUid[i]);
        /* repeated uint32 row_uid_for_index = 6; */
        for (let i = 0; i < message.rowUidForIndex.length; i++)
            writer.tag(6, runtime_1.WireType.Varint).uint32(message.rowUidForIndex[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.ColumnRowUIDMapArchive
 */
exports.ColumnRowUIDMapArchive = new ColumnRowUIDMapArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StrokeLayerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.StrokeLayerArchive", [
            { no: 1, name: "row_column_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "stroke_runs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.StrokeLayerArchive_StrokeRunArchive }
        ]);
    }
    create(value) {
        const message = { strokeRuns: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 row_column_index */ 1:
                    message.rowColumnIndex = reader.uint32();
                    break;
                case /* repeated TST.StrokeLayerArchive.StrokeRunArchive stroke_runs */ 2:
                    message.strokeRuns.push(exports.StrokeLayerArchive_StrokeRunArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional uint32 row_column_index = 1; */
        if (message.rowColumnIndex !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.rowColumnIndex);
        /* repeated TST.StrokeLayerArchive.StrokeRunArchive stroke_runs = 2; */
        for (let i = 0; i < message.strokeRuns.length; i++)
            exports.StrokeLayerArchive_StrokeRunArchive.internalBinaryWrite(message.strokeRuns[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.StrokeLayerArchive
 */
exports.StrokeLayerArchive = new StrokeLayerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StrokeLayerArchive_StrokeRunArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.StrokeLayerArchive.StrokeRunArchive", [
            { no: 1, name: "origin", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "length", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "stroke", kind: "message", T: () => TSDArchives_2.StrokeArchive },
            { no: 4, name: "order", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 origin */ 1:
                    message.origin = reader.int32();
                    break;
                case /* optional uint32 length */ 2:
                    message.length = reader.uint32();
                    break;
                case /* optional TSD.StrokeArchive stroke */ 3:
                    message.stroke = TSDArchives_2.StrokeArchive.internalBinaryRead(reader, reader.uint32(), options, message.stroke);
                    break;
                case /* optional uint32 order */ 4:
                    message.order = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional int32 origin = 1; */
        if (message.origin !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.origin);
        /* optional uint32 length = 2; */
        if (message.length !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.length);
        /* optional TSD.StrokeArchive stroke = 3; */
        if (message.stroke)
            TSDArchives_2.StrokeArchive.internalBinaryWrite(message.stroke, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 order = 4; */
        if (message.order !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.order);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.StrokeLayerArchive.StrokeRunArchive
 */
exports.StrokeLayerArchive_StrokeRunArchive = new StrokeLayerArchive_StrokeRunArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StrokeSidecarArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.StrokeSidecarArchive", [
            { no: 1, name: "max_order", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "column_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "row_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "left_column_stroke_layers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_10.Reference },
            { no: 5, name: "right_column_stroke_layers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_10.Reference },
            { no: 6, name: "top_row_stroke_layers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_10.Reference },
            { no: 7, name: "bottom_row_stroke_layers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_10.Reference }
        ]);
    }
    create(value) {
        const message = { leftColumnStrokeLayers: [], rightColumnStrokeLayers: [], topRowStrokeLayers: [], bottomRowStrokeLayers: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 max_order */ 1:
                    message.maxOrder = reader.uint32();
                    break;
                case /* optional uint32 column_count */ 2:
                    message.columnCount = reader.uint32();
                    break;
                case /* optional uint32 row_count */ 3:
                    message.rowCount = reader.uint32();
                    break;
                case /* repeated TSP.Reference left_column_stroke_layers */ 4:
                    message.leftColumnStrokeLayers.push(TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference right_column_stroke_layers */ 5:
                    message.rightColumnStrokeLayers.push(TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference top_row_stroke_layers */ 6:
                    message.topRowStrokeLayers.push(TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference bottom_row_stroke_layers */ 7:
                    message.bottomRowStrokeLayers.push(TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional uint32 max_order = 1; */
        if (message.maxOrder !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.maxOrder);
        /* optional uint32 column_count = 2; */
        if (message.columnCount !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.columnCount);
        /* optional uint32 row_count = 3; */
        if (message.rowCount !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.rowCount);
        /* repeated TSP.Reference left_column_stroke_layers = 4; */
        for (let i = 0; i < message.leftColumnStrokeLayers.length; i++)
            TSPMessages_10.Reference.internalBinaryWrite(message.leftColumnStrokeLayers[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference right_column_stroke_layers = 5; */
        for (let i = 0; i < message.rightColumnStrokeLayers.length; i++)
            TSPMessages_10.Reference.internalBinaryWrite(message.rightColumnStrokeLayers[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference top_row_stroke_layers = 6; */
        for (let i = 0; i < message.topRowStrokeLayers.length; i++)
            TSPMessages_10.Reference.internalBinaryWrite(message.topRowStrokeLayers[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference bottom_row_stroke_layers = 7; */
        for (let i = 0; i < message.bottomRowStrokeLayers.length; i++)
            TSPMessages_10.Reference.internalBinaryWrite(message.bottomRowStrokeLayers[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.StrokeSidecarArchive
 */
exports.StrokeSidecarArchive = new StrokeSidecarArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DurationWrapperArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.DurationWrapperArchive", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.DurationWrapperArchive
 */
exports.DurationWrapperArchive = new DurationWrapperArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cell$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.Cell", [
            { no: 2, name: "valueType", kind: "enum", T: () => ["TST.CellValueType", CellValueType] },
            { no: 3, name: "cell_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 4, name: "text_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 5, name: "numberValue", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "stringValue", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "boolValue", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "current_format", kind: "message", T: () => TSKArchives_3.FormatStructArchive },
            { no: 10, name: "formulaError", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 11, name: "number_format", kind: "message", T: () => TSKArchives_3.FormatStructArchive },
            { no: 12, name: "currency_format", kind: "message", T: () => TSKArchives_3.FormatStructArchive },
            { no: 13, name: "duration_format", kind: "message", T: () => TSKArchives_3.FormatStructArchive },
            { no: 14, name: "date_format", kind: "message", T: () => TSKArchives_3.FormatStructArchive },
            { no: 16, name: "custom_format", kind: "message", T: () => TSKArchives_3.FormatStructArchive },
            { no: 17, name: "base_format", kind: "message", T: () => TSKArchives_3.FormatStructArchive },
            { no: 19, name: "explicit_format_flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 20, name: "richText", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 21, name: "conditional_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 23, name: "comment_storage", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 24, name: "conditional_style_applied_rule", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 25, name: "import_warning_set", kind: "message", T: () => exports.ImportWarningSetArchive },
            { no: 26, name: "custom_format_object", kind: "message", T: () => TSKArchives_2.CustomFormatArchive },
            { no: 27, name: "cell_border", kind: "message", T: () => exports.CellBorderArchive },
            { no: 28, name: "cell_spec", kind: "message", T: () => exports.CellSpecArchive },
            { no: 29, name: "cell_format_kind", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 30, name: "text_format", kind: "message", T: () => TSKArchives_3.FormatStructArchive },
            { no: 31, name: "boolean_format", kind: "message", T: () => TSKArchives_3.FormatStructArchive },
            { no: 32, name: "decimal_value_low", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 33, name: "decimal_value_high", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value) {
        const message = { valueType: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.CellValueType valueType */ 2:
                    message.valueType = reader.int32();
                    break;
                case /* optional TSP.Reference cell_style */ 3:
                    message.cellStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.cellStyle);
                    break;
                case /* optional TSP.Reference text_style */ 4:
                    message.textStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.textStyle);
                    break;
                case /* optional double numberValue */ 5:
                    message.numberValue = reader.double();
                    break;
                case /* optional string stringValue */ 6:
                    message.stringValue = reader.string();
                    break;
                case /* optional bool boolValue */ 7:
                    message.boolValue = reader.bool();
                    break;
                case /* optional TSK.FormatStructArchive current_format */ 9:
                    message.currentFormat = TSKArchives_3.FormatStructArchive.internalBinaryRead(reader, reader.uint32(), options, message.currentFormat);
                    break;
                case /* optional TSP.Reference formulaError */ 10:
                    message.formulaError = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.formulaError);
                    break;
                case /* optional TSK.FormatStructArchive number_format */ 11:
                    message.numberFormat = TSKArchives_3.FormatStructArchive.internalBinaryRead(reader, reader.uint32(), options, message.numberFormat);
                    break;
                case /* optional TSK.FormatStructArchive currency_format */ 12:
                    message.currencyFormat = TSKArchives_3.FormatStructArchive.internalBinaryRead(reader, reader.uint32(), options, message.currencyFormat);
                    break;
                case /* optional TSK.FormatStructArchive duration_format */ 13:
                    message.durationFormat = TSKArchives_3.FormatStructArchive.internalBinaryRead(reader, reader.uint32(), options, message.durationFormat);
                    break;
                case /* optional TSK.FormatStructArchive date_format */ 14:
                    message.dateFormat = TSKArchives_3.FormatStructArchive.internalBinaryRead(reader, reader.uint32(), options, message.dateFormat);
                    break;
                case /* optional TSK.FormatStructArchive custom_format */ 16:
                    message.customFormat = TSKArchives_3.FormatStructArchive.internalBinaryRead(reader, reader.uint32(), options, message.customFormat);
                    break;
                case /* optional TSK.FormatStructArchive base_format */ 17:
                    message.baseFormat = TSKArchives_3.FormatStructArchive.internalBinaryRead(reader, reader.uint32(), options, message.baseFormat);
                    break;
                case /* optional uint32 explicit_format_flags */ 19:
                    message.explicitFormatFlags = reader.uint32();
                    break;
                case /* optional TSP.Reference richText */ 20:
                    message.richText = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.richText);
                    break;
                case /* optional TSP.Reference conditional_style */ 21:
                    message.conditionalStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.conditionalStyle);
                    break;
                case /* optional TSP.Reference comment_storage */ 23:
                    message.commentStorage = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.commentStorage);
                    break;
                case /* optional uint32 conditional_style_applied_rule */ 24:
                    message.conditionalStyleAppliedRule = reader.uint32();
                    break;
                case /* optional TST.ImportWarningSetArchive import_warning_set */ 25:
                    message.importWarningSet = exports.ImportWarningSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.importWarningSet);
                    break;
                case /* optional TSK.CustomFormatArchive custom_format_object */ 26:
                    message.customFormatObject = TSKArchives_2.CustomFormatArchive.internalBinaryRead(reader, reader.uint32(), options, message.customFormatObject);
                    break;
                case /* optional TST.CellBorderArchive cell_border */ 27:
                    message.cellBorder = exports.CellBorderArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellBorder);
                    break;
                case /* optional TST.CellSpecArchive cell_spec */ 28:
                    message.cellSpec = exports.CellSpecArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellSpec);
                    break;
                case /* optional uint32 cell_format_kind */ 29:
                    message.cellFormatKind = reader.uint32();
                    break;
                case /* optional TSK.FormatStructArchive text_format */ 30:
                    message.textFormat = TSKArchives_3.FormatStructArchive.internalBinaryRead(reader, reader.uint32(), options, message.textFormat);
                    break;
                case /* optional TSK.FormatStructArchive boolean_format */ 31:
                    message.booleanFormat = TSKArchives_3.FormatStructArchive.internalBinaryRead(reader, reader.uint32(), options, message.booleanFormat);
                    break;
                case /* optional uint64 decimal_value_low */ 32:
                    message.decimalValueLow = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 decimal_value_high */ 33:
                    message.decimalValueHigh = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.CellValueType valueType = 2; */
        if (message.valueType !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.valueType);
        /* optional TSP.Reference cell_style = 3; */
        if (message.cellStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.cellStyle, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference text_style = 4; */
        if (message.textStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.textStyle, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional double numberValue = 5; */
        if (message.numberValue !== undefined)
            writer.tag(5, runtime_1.WireType.Bit64).double(message.numberValue);
        /* optional string stringValue = 6; */
        if (message.stringValue !== undefined)
            writer.tag(6, runtime_1.WireType.LengthDelimited).string(message.stringValue);
        /* optional bool boolValue = 7; */
        if (message.boolValue !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.boolValue);
        /* optional TSK.FormatStructArchive current_format = 9; */
        if (message.currentFormat)
            TSKArchives_3.FormatStructArchive.internalBinaryWrite(message.currentFormat, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference formulaError = 10; */
        if (message.formulaError)
            TSPMessages_10.Reference.internalBinaryWrite(message.formulaError, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.FormatStructArchive number_format = 11; */
        if (message.numberFormat)
            TSKArchives_3.FormatStructArchive.internalBinaryWrite(message.numberFormat, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.FormatStructArchive currency_format = 12; */
        if (message.currencyFormat)
            TSKArchives_3.FormatStructArchive.internalBinaryWrite(message.currencyFormat, writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.FormatStructArchive duration_format = 13; */
        if (message.durationFormat)
            TSKArchives_3.FormatStructArchive.internalBinaryWrite(message.durationFormat, writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.FormatStructArchive date_format = 14; */
        if (message.dateFormat)
            TSKArchives_3.FormatStructArchive.internalBinaryWrite(message.dateFormat, writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.FormatStructArchive custom_format = 16; */
        if (message.customFormat)
            TSKArchives_3.FormatStructArchive.internalBinaryWrite(message.customFormat, writer.tag(16, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.FormatStructArchive base_format = 17; */
        if (message.baseFormat)
            TSKArchives_3.FormatStructArchive.internalBinaryWrite(message.baseFormat, writer.tag(17, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 explicit_format_flags = 19; */
        if (message.explicitFormatFlags !== undefined)
            writer.tag(19, runtime_1.WireType.Varint).uint32(message.explicitFormatFlags);
        /* optional TSP.Reference richText = 20; */
        if (message.richText)
            TSPMessages_10.Reference.internalBinaryWrite(message.richText, writer.tag(20, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference conditional_style = 21; */
        if (message.conditionalStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.conditionalStyle, writer.tag(21, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference comment_storage = 23; */
        if (message.commentStorage)
            TSPMessages_10.Reference.internalBinaryWrite(message.commentStorage, writer.tag(23, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 conditional_style_applied_rule = 24; */
        if (message.conditionalStyleAppliedRule !== undefined)
            writer.tag(24, runtime_1.WireType.Varint).uint32(message.conditionalStyleAppliedRule);
        /* optional TST.ImportWarningSetArchive import_warning_set = 25; */
        if (message.importWarningSet)
            exports.ImportWarningSetArchive.internalBinaryWrite(message.importWarningSet, writer.tag(25, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.CustomFormatArchive custom_format_object = 26; */
        if (message.customFormatObject)
            TSKArchives_2.CustomFormatArchive.internalBinaryWrite(message.customFormatObject, writer.tag(26, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.CellBorderArchive cell_border = 27; */
        if (message.cellBorder)
            exports.CellBorderArchive.internalBinaryWrite(message.cellBorder, writer.tag(27, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.CellSpecArchive cell_spec = 28; */
        if (message.cellSpec)
            exports.CellSpecArchive.internalBinaryWrite(message.cellSpec, writer.tag(28, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 cell_format_kind = 29; */
        if (message.cellFormatKind !== undefined)
            writer.tag(29, runtime_1.WireType.Varint).uint32(message.cellFormatKind);
        /* optional TSK.FormatStructArchive text_format = 30; */
        if (message.textFormat)
            TSKArchives_3.FormatStructArchive.internalBinaryWrite(message.textFormat, writer.tag(30, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.FormatStructArchive boolean_format = 31; */
        if (message.booleanFormat)
            TSKArchives_3.FormatStructArchive.internalBinaryWrite(message.booleanFormat, writer.tag(31, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint64 decimal_value_low = 32; */
        if (message.decimalValueLow !== undefined)
            writer.tag(32, runtime_1.WireType.Varint).uint64(message.decimalValueLow);
        /* optional uint64 decimal_value_high = 33; */
        if (message.decimalValueHigh !== undefined)
            writer.tag(33, runtime_1.WireType.Varint).uint64(message.decimalValueHigh);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.Cell
 */
exports.Cell = new Cell$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MergeRegionMapArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.MergeRegionMapArchive", [
            { no: 1, name: "cell_range", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CellRange }
        ]);
    }
    create(value) {
        const message = { cellRange: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TST.CellRange cell_range */ 1:
                    message.cellRange.push(exports.CellRange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TST.CellRange cell_range = 1; */
        for (let i = 0; i < message.cellRange.length; i++)
            exports.CellRange.internalBinaryWrite(message.cellRange[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.MergeRegionMapArchive
 */
exports.MergeRegionMapArchive = new MergeRegionMapArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellMapArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CellMapArchive", [
            { no: 2, name: "cell_tiles", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_10.Reference },
            { no: 3, name: "uid_based", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "expanded_cell_ids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSCEArchives_20.CellCoordinateArchive },
            { no: 5, name: "cell_uid_list", kind: "message", T: () => exports.CellUIDListArchive },
            { no: 7, name: "merge_uid_ranges", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.UUIDRectArchive },
            { no: 9, name: "unmerge_uid_ranges", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.UUIDRectArchive },
            { no: 13, name: "merge_actions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.MergeOperationArchive },
            { no: 10, name: "may_modify_formulas_in_cells", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "may_modify_values_referenced_by_formulas", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { cellTiles: [], uidBased: false, expandedCellIds: [], mergeUidRanges: [], unmergeUidRanges: [], mergeActions: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.Reference cell_tiles */ 2:
                    message.cellTiles.push(TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool uid_based */ 3:
                    message.uidBased = reader.bool();
                    break;
                case /* repeated TSCE.CellCoordinateArchive expanded_cell_ids */ 14:
                    message.expandedCellIds.push(TSCEArchives_20.CellCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TST.CellUIDListArchive cell_uid_list */ 5:
                    message.cellUidList = exports.CellUIDListArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellUidList);
                    break;
                case /* repeated TSP.UUIDRectArchive merge_uid_ranges */ 7:
                    message.mergeUidRanges.push(TSPMessages_8.UUIDRectArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUIDRectArchive unmerge_uid_ranges */ 9:
                    message.unmergeUidRanges.push(TSPMessages_8.UUIDRectArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TST.MergeOperationArchive merge_actions */ 13:
                    message.mergeActions.push(exports.MergeOperationArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool may_modify_formulas_in_cells */ 10:
                    message.mayModifyFormulasInCells = reader.bool();
                    break;
                case /* optional bool may_modify_values_referenced_by_formulas */ 11:
                    message.mayModifyValuesReferencedByFormulas = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.Reference cell_tiles = 2; */
        for (let i = 0; i < message.cellTiles.length; i++)
            TSPMessages_10.Reference.internalBinaryWrite(message.cellTiles[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool uid_based = 3; */
        if (message.uidBased !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.uidBased);
        /* repeated TSCE.CellCoordinateArchive expanded_cell_ids = 14; */
        for (let i = 0; i < message.expandedCellIds.length; i++)
            TSCEArchives_20.CellCoordinateArchive.internalBinaryWrite(message.expandedCellIds[i], writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.CellUIDListArchive cell_uid_list = 5; */
        if (message.cellUidList)
            exports.CellUIDListArchive.internalBinaryWrite(message.cellUidList, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUIDRectArchive merge_uid_ranges = 7; */
        for (let i = 0; i < message.mergeUidRanges.length; i++)
            TSPMessages_8.UUIDRectArchive.internalBinaryWrite(message.mergeUidRanges[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUIDRectArchive unmerge_uid_ranges = 9; */
        for (let i = 0; i < message.unmergeUidRanges.length; i++)
            TSPMessages_8.UUIDRectArchive.internalBinaryWrite(message.unmergeUidRanges[i], writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TST.MergeOperationArchive merge_actions = 13; */
        for (let i = 0; i < message.mergeActions.length; i++)
            exports.MergeOperationArchive.internalBinaryWrite(message.mergeActions[i], writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool may_modify_formulas_in_cells = 10; */
        if (message.mayModifyFormulasInCells !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).bool(message.mayModifyFormulasInCells);
        /* optional bool may_modify_values_referenced_by_formulas = 11; */
        if (message.mayModifyValuesReferencedByFormulas !== undefined)
            writer.tag(11, runtime_1.WireType.Varint).bool(message.mayModifyValuesReferencedByFormulas);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CellMapArchive
 */
exports.CellMapArchive = new CellMapArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellListArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CellListArchive", [
            { no: 1, name: "cells", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CellListArchive_OptionalCell },
            { no: 2, name: "trailing_empty_cell_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { cells: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TST.CellListArchive.OptionalCell cells */ 1:
                    message.cells.push(exports.CellListArchive_OptionalCell.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 trailing_empty_cell_count */ 2:
                    message.trailingEmptyCellCount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TST.CellListArchive.OptionalCell cells = 1; */
        for (let i = 0; i < message.cells.length; i++)
            exports.CellListArchive_OptionalCell.internalBinaryWrite(message.cells[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 trailing_empty_cell_count = 2; */
        if (message.trailingEmptyCellCount !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.trailingEmptyCellCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CellListArchive
 */
exports.CellListArchive = new CellListArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellListArchive_OptionalCell$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CellListArchive.OptionalCell", [
            { no: 1, name: "cell", kind: "message", T: () => exports.Cell }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TST.Cell cell */ 1:
                    message.cell = exports.Cell.internalBinaryRead(reader, reader.uint32(), options, message.cell);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TST.Cell cell = 1; */
        if (message.cell)
            exports.Cell.internalBinaryWrite(message.cell, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CellListArchive.OptionalCell
 */
exports.CellListArchive_OptionalCell = new CellListArchive_OptionalCell$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConcurrentCellMapArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.ConcurrentCellMapArchive", [
            { no: 1, name: "cell_lists", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_10.Reference },
            { no: 2, name: "uid_based", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "merge_actions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.MergeOperationArchive },
            { no: 4, name: "may_modify_formulas_in_cells", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "may_modify_values_referenced_by_formulas", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "affects_cell_borders", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { cellLists: [], uidBased: false, mergeActions: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.Reference cell_lists */ 1:
                    message.cellLists.push(TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool uid_based */ 2:
                    message.uidBased = reader.bool();
                    break;
                case /* repeated TST.MergeOperationArchive merge_actions */ 3:
                    message.mergeActions.push(exports.MergeOperationArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool may_modify_formulas_in_cells */ 4:
                    message.mayModifyFormulasInCells = reader.bool();
                    break;
                case /* optional bool may_modify_values_referenced_by_formulas */ 5:
                    message.mayModifyValuesReferencedByFormulas = reader.bool();
                    break;
                case /* optional bool affects_cell_borders */ 6:
                    message.affectsCellBorders = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.Reference cell_lists = 1; */
        for (let i = 0; i < message.cellLists.length; i++)
            TSPMessages_10.Reference.internalBinaryWrite(message.cellLists[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool uid_based = 2; */
        if (message.uidBased !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.uidBased);
        /* repeated TST.MergeOperationArchive merge_actions = 3; */
        for (let i = 0; i < message.mergeActions.length; i++)
            exports.MergeOperationArchive.internalBinaryWrite(message.mergeActions[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool may_modify_formulas_in_cells = 4; */
        if (message.mayModifyFormulasInCells !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.mayModifyFormulasInCells);
        /* optional bool may_modify_values_referenced_by_formulas = 5; */
        if (message.mayModifyValuesReferencedByFormulas !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.mayModifyValuesReferencedByFormulas);
        /* optional bool affects_cell_borders = 6; */
        if (message.affectsCellBorders !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.affectsCellBorders);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.ConcurrentCellMapArchive
 */
exports.ConcurrentCellMapArchive = new ConcurrentCellMapArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConcurrentCellListArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.ConcurrentCellListArchive", [
            { no: 1, name: "cells", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ConcurrentCellListArchive_OptionalCell },
            { no: 2, name: "cell_uid_range", kind: "message", T: () => TSPMessages_8.UUIDRectArchive },
            { no: 3, name: "cell_range", kind: "message", T: () => exports.CellRange }
        ]);
    }
    create(value) {
        const message = { cells: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TST.ConcurrentCellListArchive.OptionalCell cells */ 1:
                    message.cells.push(exports.ConcurrentCellListArchive_OptionalCell.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.UUIDRectArchive cell_uid_range */ 2:
                    message.cellUidRange = TSPMessages_8.UUIDRectArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellUidRange);
                    break;
                case /* optional TST.CellRange cell_range */ 3:
                    message.cellRange = exports.CellRange.internalBinaryRead(reader, reader.uint32(), options, message.cellRange);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TST.ConcurrentCellListArchive.OptionalCell cells = 1; */
        for (let i = 0; i < message.cells.length; i++)
            exports.ConcurrentCellListArchive_OptionalCell.internalBinaryWrite(message.cells[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDRectArchive cell_uid_range = 2; */
        if (message.cellUidRange)
            TSPMessages_8.UUIDRectArchive.internalBinaryWrite(message.cellUidRange, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.CellRange cell_range = 3; */
        if (message.cellRange)
            exports.CellRange.internalBinaryWrite(message.cellRange, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.ConcurrentCellListArchive
 */
exports.ConcurrentCellListArchive = new ConcurrentCellListArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConcurrentCellListArchive_OptionalCell$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.ConcurrentCellListArchive.OptionalCell", [
            { no: 1, name: "cell", kind: "message", T: () => exports.Cell }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TST.Cell cell */ 1:
                    message.cell = exports.Cell.internalBinaryRead(reader, reader.uint32(), options, message.cell);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TST.Cell cell = 1; */
        if (message.cell)
            exports.Cell.internalBinaryWrite(message.cell, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.ConcurrentCellListArchive.OptionalCell
 */
exports.ConcurrentCellListArchive_OptionalCell = new ConcurrentCellListArchive_OptionalCell$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellFormatAndValueArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CellFormatAndValueArchive", [
            { no: 1, name: "valueType", kind: "enum", T: () => ["TST.CellValueType", CellValueType] },
            { no: 2, name: "numberValue", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "stringValue", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "boolValue", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "richTextStorage", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 6, name: "use_all_spare_formats", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "explicit_flags", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "cell_format_kind", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "number_format", kind: "message", T: () => TSKArchives_3.FormatStructArchive },
            { no: 11, name: "currency_format", kind: "message", T: () => TSKArchives_3.FormatStructArchive },
            { no: 12, name: "date_format", kind: "message", T: () => TSKArchives_3.FormatStructArchive },
            { no: 13, name: "duration_format", kind: "message", T: () => TSKArchives_3.FormatStructArchive },
            { no: 14, name: "text_format", kind: "message", T: () => TSKArchives_3.FormatStructArchive },
            { no: 15, name: "boolean_format", kind: "message", T: () => TSKArchives_3.FormatStructArchive },
            { no: 16, name: "formatted_value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "formatted_rich_text_value", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 18, name: "apply_spare_format_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "spare_format_type", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 20, name: "decimal_low", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 21, name: "decimal_high", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 22, name: "suppress_apply_value", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { valueType: 0, useAllSpareFormats: false, explicitFlags: 0, cellFormatKind: 0, applySpareFormatOnly: false, spareFormatType: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.CellValueType valueType */ 1:
                    message.valueType = reader.int32();
                    break;
                case /* optional double numberValue */ 2:
                    message.numberValue = reader.double();
                    break;
                case /* optional string stringValue */ 3:
                    message.stringValue = reader.string();
                    break;
                case /* optional bool boolValue */ 4:
                    message.boolValue = reader.bool();
                    break;
                case /* optional TSP.Reference richTextStorage */ 5:
                    message.richTextStorage = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.richTextStorage);
                    break;
                case /* bool use_all_spare_formats */ 6:
                    message.useAllSpareFormats = reader.bool();
                    break;
                case /* uint32 explicit_flags */ 7:
                    message.explicitFlags = reader.uint32();
                    break;
                case /* uint32 cell_format_kind */ 8:
                    message.cellFormatKind = reader.uint32();
                    break;
                case /* optional TSK.FormatStructArchive number_format */ 10:
                    message.numberFormat = TSKArchives_3.FormatStructArchive.internalBinaryRead(reader, reader.uint32(), options, message.numberFormat);
                    break;
                case /* optional TSK.FormatStructArchive currency_format */ 11:
                    message.currencyFormat = TSKArchives_3.FormatStructArchive.internalBinaryRead(reader, reader.uint32(), options, message.currencyFormat);
                    break;
                case /* optional TSK.FormatStructArchive date_format */ 12:
                    message.dateFormat = TSKArchives_3.FormatStructArchive.internalBinaryRead(reader, reader.uint32(), options, message.dateFormat);
                    break;
                case /* optional TSK.FormatStructArchive duration_format */ 13:
                    message.durationFormat = TSKArchives_3.FormatStructArchive.internalBinaryRead(reader, reader.uint32(), options, message.durationFormat);
                    break;
                case /* optional TSK.FormatStructArchive text_format */ 14:
                    message.textFormat = TSKArchives_3.FormatStructArchive.internalBinaryRead(reader, reader.uint32(), options, message.textFormat);
                    break;
                case /* optional TSK.FormatStructArchive boolean_format */ 15:
                    message.booleanFormat = TSKArchives_3.FormatStructArchive.internalBinaryRead(reader, reader.uint32(), options, message.booleanFormat);
                    break;
                case /* optional string formatted_value */ 16:
                    message.formattedValue = reader.string();
                    break;
                case /* optional TSP.Reference formatted_rich_text_value */ 17:
                    message.formattedRichTextValue = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.formattedRichTextValue);
                    break;
                case /* bool apply_spare_format_only */ 18:
                    message.applySpareFormatOnly = reader.bool();
                    break;
                case /* bool spare_format_type */ 19:
                    message.spareFormatType = reader.bool();
                    break;
                case /* optional uint64 decimal_low */ 20:
                    message.decimalLow = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 decimal_high */ 21:
                    message.decimalHigh = reader.uint64().toBigInt();
                    break;
                case /* optional bool suppress_apply_value */ 22:
                    message.suppressApplyValue = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.CellValueType valueType = 1; */
        if (message.valueType !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.valueType);
        /* optional double numberValue = 2; */
        if (message.numberValue !== undefined)
            writer.tag(2, runtime_1.WireType.Bit64).double(message.numberValue);
        /* optional string stringValue = 3; */
        if (message.stringValue !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.stringValue);
        /* optional bool boolValue = 4; */
        if (message.boolValue !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.boolValue);
        /* optional TSP.Reference richTextStorage = 5; */
        if (message.richTextStorage)
            TSPMessages_10.Reference.internalBinaryWrite(message.richTextStorage, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool use_all_spare_formats = 6; */
        if (message.useAllSpareFormats !== false)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.useAllSpareFormats);
        /* uint32 explicit_flags = 7; */
        if (message.explicitFlags !== 0)
            writer.tag(7, runtime_1.WireType.Varint).uint32(message.explicitFlags);
        /* uint32 cell_format_kind = 8; */
        if (message.cellFormatKind !== 0)
            writer.tag(8, runtime_1.WireType.Varint).uint32(message.cellFormatKind);
        /* optional TSK.FormatStructArchive number_format = 10; */
        if (message.numberFormat)
            TSKArchives_3.FormatStructArchive.internalBinaryWrite(message.numberFormat, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.FormatStructArchive currency_format = 11; */
        if (message.currencyFormat)
            TSKArchives_3.FormatStructArchive.internalBinaryWrite(message.currencyFormat, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.FormatStructArchive date_format = 12; */
        if (message.dateFormat)
            TSKArchives_3.FormatStructArchive.internalBinaryWrite(message.dateFormat, writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.FormatStructArchive duration_format = 13; */
        if (message.durationFormat)
            TSKArchives_3.FormatStructArchive.internalBinaryWrite(message.durationFormat, writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.FormatStructArchive text_format = 14; */
        if (message.textFormat)
            TSKArchives_3.FormatStructArchive.internalBinaryWrite(message.textFormat, writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.FormatStructArchive boolean_format = 15; */
        if (message.booleanFormat)
            TSKArchives_3.FormatStructArchive.internalBinaryWrite(message.booleanFormat, writer.tag(15, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string formatted_value = 16; */
        if (message.formattedValue !== undefined)
            writer.tag(16, runtime_1.WireType.LengthDelimited).string(message.formattedValue);
        /* optional TSP.Reference formatted_rich_text_value = 17; */
        if (message.formattedRichTextValue)
            TSPMessages_10.Reference.internalBinaryWrite(message.formattedRichTextValue, writer.tag(17, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool apply_spare_format_only = 18; */
        if (message.applySpareFormatOnly !== false)
            writer.tag(18, runtime_1.WireType.Varint).bool(message.applySpareFormatOnly);
        /* bool spare_format_type = 19; */
        if (message.spareFormatType !== false)
            writer.tag(19, runtime_1.WireType.Varint).bool(message.spareFormatType);
        /* optional uint64 decimal_low = 20; */
        if (message.decimalLow !== undefined)
            writer.tag(20, runtime_1.WireType.Varint).uint64(message.decimalLow);
        /* optional uint64 decimal_high = 21; */
        if (message.decimalHigh !== undefined)
            writer.tag(21, runtime_1.WireType.Varint).uint64(message.decimalHigh);
        /* optional bool suppress_apply_value = 22; */
        if (message.suppressApplyValue !== undefined)
            writer.tag(22, runtime_1.WireType.Varint).bool(message.suppressApplyValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CellFormatAndValueArchive
 */
exports.CellFormatAndValueArchive = new CellFormatAndValueArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellSpecArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CellSpecArchive", [
            { no: 1, name: "interaction_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "formula", kind: "message", T: () => TSCEArchives_12.FormulaArchive },
            { no: 3, name: "range_control_min", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "range_control_max", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "range_control_inc", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "chooser_control_popup_model", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 7, name: "chooser_control_start_w_first", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "category_summary_should_display_label", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { interactionType: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 interaction_type */ 1:
                    message.interactionType = reader.uint32();
                    break;
                case /* optional TSCE.FormulaArchive formula */ 2:
                    message.formula = TSCEArchives_12.FormulaArchive.internalBinaryRead(reader, reader.uint32(), options, message.formula);
                    break;
                case /* optional double range_control_min */ 3:
                    message.rangeControlMin = reader.double();
                    break;
                case /* optional double range_control_max */ 4:
                    message.rangeControlMax = reader.double();
                    break;
                case /* optional double range_control_inc */ 5:
                    message.rangeControlInc = reader.double();
                    break;
                case /* optional TSP.Reference chooser_control_popup_model */ 6:
                    message.chooserControlPopupModel = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.chooserControlPopupModel);
                    break;
                case /* optional bool chooser_control_start_w_first */ 7:
                    message.chooserControlStartWFirst = reader.bool();
                    break;
                case /* optional bool category_summary_should_display_label = 8 [deprecated = true];*/ 8:
                    message.categorySummaryShouldDisplayLabel = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 interaction_type = 1; */
        if (message.interactionType !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.interactionType);
        /* optional TSCE.FormulaArchive formula = 2; */
        if (message.formula)
            TSCEArchives_12.FormulaArchive.internalBinaryWrite(message.formula, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional double range_control_min = 3; */
        if (message.rangeControlMin !== undefined)
            writer.tag(3, runtime_1.WireType.Bit64).double(message.rangeControlMin);
        /* optional double range_control_max = 4; */
        if (message.rangeControlMax !== undefined)
            writer.tag(4, runtime_1.WireType.Bit64).double(message.rangeControlMax);
        /* optional double range_control_inc = 5; */
        if (message.rangeControlInc !== undefined)
            writer.tag(5, runtime_1.WireType.Bit64).double(message.rangeControlInc);
        /* optional TSP.Reference chooser_control_popup_model = 6; */
        if (message.chooserControlPopupModel)
            TSPMessages_10.Reference.internalBinaryWrite(message.chooserControlPopupModel, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool chooser_control_start_w_first = 7; */
        if (message.chooserControlStartWFirst !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.chooserControlStartWFirst);
        /* optional bool category_summary_should_display_label = 8 [deprecated = true]; */
        if (message.categorySummaryShouldDisplayLabel !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.categorySummaryShouldDisplayLabel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CellSpecArchive
 */
exports.CellSpecArchive = new CellSpecArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommentStorageWrapperArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommentStorageWrapperArchive", [
            { no: 1, name: "comment_storage", kind: "message", T: () => TSPMessages_10.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference comment_storage */ 1:
                    message.commentStorage = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.commentStorage);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference comment_storage = 1; */
        if (message.commentStorage)
            TSPMessages_10.Reference.internalBinaryWrite(message.commentStorage, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommentStorageWrapperArchive
 */
exports.CommentStorageWrapperArchive = new CommentStorageWrapperArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellDiffArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CellDiffArchive", [
            { no: 1, name: "property_map_to_set", kind: "message", T: () => TSSArchives_2.CommandPropertyMapArchive },
            { no: 2, name: "property_map_to_reset", kind: "message", T: () => TSSArchives_2.CommandPropertyMapArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSS.CommandPropertyMapArchive property_map_to_set */ 1:
                    message.propertyMapToSet = TSSArchives_2.CommandPropertyMapArchive.internalBinaryRead(reader, reader.uint32(), options, message.propertyMapToSet);
                    break;
                case /* TSS.CommandPropertyMapArchive property_map_to_reset */ 2:
                    message.propertyMapToReset = TSSArchives_2.CommandPropertyMapArchive.internalBinaryRead(reader, reader.uint32(), options, message.propertyMapToReset);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSS.CommandPropertyMapArchive property_map_to_set = 1; */
        if (message.propertyMapToSet)
            TSSArchives_2.CommandPropertyMapArchive.internalBinaryWrite(message.propertyMapToSet, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSS.CommandPropertyMapArchive property_map_to_reset = 2; */
        if (message.propertyMapToReset)
            TSSArchives_2.CommandPropertyMapArchive.internalBinaryWrite(message.propertyMapToReset, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CellDiffArchive
 */
exports.CellDiffArchive = new CellDiffArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellDiffArray$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CellDiffArray", [
            { no: 1, name: "large_array", kind: "message", T: () => TSPMessages_6.LargeArray }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.LargeArray large_array */ 1:
                    message.largeArray = TSPMessages_6.LargeArray.internalBinaryRead(reader, reader.uint32(), options, message.largeArray);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.LargeArray large_array = 1; */
        if (message.largeArray)
            TSPMessages_6.LargeArray.internalBinaryWrite(message.largeArray, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CellDiffArray
 */
exports.CellDiffArray = new CellDiffArray$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellDiffArraySegment$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CellDiffArraySegment", [
            { no: 1, name: "large_array_segment", kind: "message", T: () => TSPMessages_5.LargeArraySegment },
            { no: 2, name: "elements", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CellDiffArchive }
        ]);
    }
    create(value) {
        const message = { elements: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.LargeArraySegment large_array_segment */ 1:
                    message.largeArraySegment = TSPMessages_5.LargeArraySegment.internalBinaryRead(reader, reader.uint32(), options, message.largeArraySegment);
                    break;
                case /* repeated TST.CellDiffArchive elements */ 2:
                    message.elements.push(exports.CellDiffArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.LargeArraySegment large_array_segment = 1; */
        if (message.largeArraySegment)
            TSPMessages_5.LargeArraySegment.internalBinaryWrite(message.largeArraySegment, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TST.CellDiffArchive elements = 2; */
        for (let i = 0; i < message.elements.length; i++)
            exports.CellDiffArchive.internalBinaryWrite(message.elements[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CellDiffArraySegment
 */
exports.CellDiffArraySegment = new CellDiffArraySegment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellDiffMapArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CellDiffMapArchive", [
            { no: 1, name: "uid_based", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "expanded_cell_ids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSCEArchives_20.CellCoordinateArchive },
            { no: 3, name: "cell_uids", kind: "message", T: () => exports.CellUIDListArchive },
            { no: 4, name: "cell_diff_array", kind: "message", T: () => TSPMessages_10.Reference }
        ]);
    }
    create(value) {
        const message = { uidBased: false, expandedCellIds: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool uid_based */ 1:
                    message.uidBased = reader.bool();
                    break;
                case /* repeated TSCE.CellCoordinateArchive expanded_cell_ids */ 2:
                    message.expandedCellIds.push(TSCEArchives_20.CellCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* TST.CellUIDListArchive cell_uids */ 3:
                    message.cellUids = exports.CellUIDListArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellUids);
                    break;
                case /* optional TSP.Reference cell_diff_array */ 4:
                    message.cellDiffArray = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.cellDiffArray);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool uid_based = 1; */
        if (message.uidBased !== false)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.uidBased);
        /* repeated TSCE.CellCoordinateArchive expanded_cell_ids = 2; */
        for (let i = 0; i < message.expandedCellIds.length; i++)
            TSCEArchives_20.CellCoordinateArchive.internalBinaryWrite(message.expandedCellIds[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.CellUIDListArchive cell_uids = 3; */
        if (message.cellUids)
            exports.CellUIDListArchive.internalBinaryWrite(message.cellUids, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference cell_diff_array = 4; */
        if (message.cellDiffArray)
            TSPMessages_10.Reference.internalBinaryWrite(message.cellDiffArray, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CellDiffMapArchive
 */
exports.CellDiffMapArchive = new CellDiffMapArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HierarchicalCellDiffMapArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.HierarchicalCellDiffMapArchive", [
            { no: 1, name: "num_row_rules", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "num_column_rules", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "row_header_uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_11.UUID },
            { no: 4, name: "column_header_uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_11.UUID },
            { no: 5, name: "aggregate_rule_uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_11.UUID },
            { no: 6, name: "active_flattening_dimension", kind: "enum", T: () => ["TST.TableDimensionArchive", TableDimensionArchive] },
            { no: 7, name: "row_value_uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_11.UUID },
            { no: 8, name: "row_level_preorder", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "column_value_uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_11.UUID },
            { no: 10, name: "column_level_preorder", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "cell_diff_storage", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.HierarchicalCellDiffMapArchive_BoxedRow },
            { no: 12, name: "row_sizes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 13, name: "column_sizes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value) {
        const message = { numRowRules: 0, numColumnRules: 0, rowHeaderUids: [], columnHeaderUids: [], aggregateRuleUids: [], activeFlatteningDimension: 0, rowValueUids: [], rowLevelPreorder: [], columnValueUids: [], columnLevelPreorder: [], cellDiffStorage: [], rowSizes: [], columnSizes: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 num_row_rules */ 1:
                    message.numRowRules = reader.int32();
                    break;
                case /* int32 num_column_rules */ 2:
                    message.numColumnRules = reader.int32();
                    break;
                case /* repeated TSP.UUID row_header_uids */ 3:
                    message.rowHeaderUids.push(TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID column_header_uids */ 4:
                    message.columnHeaderUids.push(TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID aggregate_rule_uids */ 5:
                    message.aggregateRuleUids.push(TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* TST.TableDimensionArchive active_flattening_dimension */ 6:
                    message.activeFlatteningDimension = reader.int32();
                    break;
                case /* repeated TSP.UUID row_value_uids */ 7:
                    message.rowValueUids.push(TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 row_level_preorder */ 8:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.rowLevelPreorder.push(reader.uint32());
                    else
                        message.rowLevelPreorder.push(reader.uint32());
                    break;
                case /* repeated TSP.UUID column_value_uids */ 9:
                    message.columnValueUids.push(TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 column_level_preorder */ 10:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.columnLevelPreorder.push(reader.uint32());
                    else
                        message.columnLevelPreorder.push(reader.uint32());
                    break;
                case /* repeated TST.HierarchicalCellDiffMapArchive.BoxedRow cell_diff_storage */ 11:
                    message.cellDiffStorage.push(exports.HierarchicalCellDiffMapArchive_BoxedRow.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated double row_sizes */ 12:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.rowSizes.push(reader.double());
                    else
                        message.rowSizes.push(reader.double());
                    break;
                case /* repeated double column_sizes */ 13:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.columnSizes.push(reader.double());
                    else
                        message.columnSizes.push(reader.double());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int32 num_row_rules = 1; */
        if (message.numRowRules !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.numRowRules);
        /* int32 num_column_rules = 2; */
        if (message.numColumnRules !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.numColumnRules);
        /* repeated TSP.UUID row_header_uids = 3; */
        for (let i = 0; i < message.rowHeaderUids.length; i++)
            TSPMessages_11.UUID.internalBinaryWrite(message.rowHeaderUids[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID column_header_uids = 4; */
        for (let i = 0; i < message.columnHeaderUids.length; i++)
            TSPMessages_11.UUID.internalBinaryWrite(message.columnHeaderUids[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID aggregate_rule_uids = 5; */
        for (let i = 0; i < message.aggregateRuleUids.length; i++)
            TSPMessages_11.UUID.internalBinaryWrite(message.aggregateRuleUids[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.TableDimensionArchive active_flattening_dimension = 6; */
        if (message.activeFlatteningDimension !== 0)
            writer.tag(6, runtime_1.WireType.Varint).int32(message.activeFlatteningDimension);
        /* repeated TSP.UUID row_value_uids = 7; */
        for (let i = 0; i < message.rowValueUids.length; i++)
            TSPMessages_11.UUID.internalBinaryWrite(message.rowValueUids[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 row_level_preorder = 8; */
        for (let i = 0; i < message.rowLevelPreorder.length; i++)
            writer.tag(8, runtime_1.WireType.Varint).uint32(message.rowLevelPreorder[i]);
        /* repeated TSP.UUID column_value_uids = 9; */
        for (let i = 0; i < message.columnValueUids.length; i++)
            TSPMessages_11.UUID.internalBinaryWrite(message.columnValueUids[i], writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 column_level_preorder = 10; */
        for (let i = 0; i < message.columnLevelPreorder.length; i++)
            writer.tag(10, runtime_1.WireType.Varint).uint32(message.columnLevelPreorder[i]);
        /* repeated TST.HierarchicalCellDiffMapArchive.BoxedRow cell_diff_storage = 11; */
        for (let i = 0; i < message.cellDiffStorage.length; i++)
            exports.HierarchicalCellDiffMapArchive_BoxedRow.internalBinaryWrite(message.cellDiffStorage[i], writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated double row_sizes = 12; */
        for (let i = 0; i < message.rowSizes.length; i++)
            writer.tag(12, runtime_1.WireType.Bit64).double(message.rowSizes[i]);
        /* repeated double column_sizes = 13; */
        for (let i = 0; i < message.columnSizes.length; i++)
            writer.tag(13, runtime_1.WireType.Bit64).double(message.columnSizes[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.HierarchicalCellDiffMapArchive
 */
exports.HierarchicalCellDiffMapArchive = new HierarchicalCellDiffMapArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HierarchicalCellDiffMapArchive_BoxedRow$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.HierarchicalCellDiffMapArchive.BoxedRow", [
            { no: 1, name: "column_index_set", kind: "message", T: () => TSPMessages_4.IndexSet },
            { no: 2, name: "cell_diff_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CellDiffArchive }
        ]);
    }
    create(value) {
        const message = { cellDiffList: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.IndexSet column_index_set */ 1:
                    message.columnIndexSet = TSPMessages_4.IndexSet.internalBinaryRead(reader, reader.uint32(), options, message.columnIndexSet);
                    break;
                case /* repeated TST.CellDiffArchive cell_diff_list */ 2:
                    message.cellDiffList.push(exports.CellDiffArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.IndexSet column_index_set = 1; */
        if (message.columnIndexSet)
            TSPMessages_4.IndexSet.internalBinaryWrite(message.columnIndexSet, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TST.CellDiffArchive cell_diff_list = 2; */
        for (let i = 0; i < message.cellDiffList.length; i++)
            exports.CellDiffArchive.internalBinaryWrite(message.cellDiffList[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.HierarchicalCellDiffMapArchive.BoxedRow
 */
exports.HierarchicalCellDiffMapArchive_BoxedRow = new HierarchicalCellDiffMapArchive_BoxedRow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DoubleStyleMapArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.DoubleStyleMapArchive", [
            { no: 1, name: "capacity", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "cell_map_entry", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.DoubleStyleMapArchive_DoubleStyleMapEntryArchive }
        ]);
    }
    create(value) {
        const message = { capacity: 0, count: 0, cellMapEntry: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 capacity */ 1:
                    message.capacity = reader.uint32();
                    break;
                case /* uint32 count */ 2:
                    message.count = reader.uint32();
                    break;
                case /* repeated TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive cell_map_entry */ 3:
                    message.cellMapEntry.push(exports.DoubleStyleMapArchive_DoubleStyleMapEntryArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 capacity = 1; */
        if (message.capacity !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.capacity);
        /* uint32 count = 2; */
        if (message.count !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.count);
        /* repeated TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive cell_map_entry = 3; */
        for (let i = 0; i < message.cellMapEntry.length; i++)
            exports.DoubleStyleMapArchive_DoubleStyleMapEntryArchive.internalBinaryWrite(message.cellMapEntry[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.DoubleStyleMapArchive
 */
exports.DoubleStyleMapArchive = new DoubleStyleMapArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DoubleStyleMapArchive_DoubleStyleMapEntryArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive", [
            { no: 1, name: "cell_id", kind: "message", T: () => exports.CellID },
            { no: 2, name: "old_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 3, name: "new_style", kind: "message", T: () => TSPMessages_10.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.CellID cell_id */ 1:
                    message.cellId = exports.CellID.internalBinaryRead(reader, reader.uint32(), options, message.cellId);
                    break;
                case /* TSP.Reference old_style */ 2:
                    message.oldStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.oldStyle);
                    break;
                case /* TSP.Reference new_style */ 3:
                    message.newStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.newStyle);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.CellID cell_id = 1; */
        if (message.cellId)
            exports.CellID.internalBinaryWrite(message.cellId, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference old_style = 2; */
        if (message.oldStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.oldStyle, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference new_style = 3; */
        if (message.newStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.newStyle, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.DoubleStyleMapArchive.DoubleStyleMapEntryArchive
 */
exports.DoubleStyleMapArchive_DoubleStyleMapEntryArchive = new DoubleStyleMapArchive_DoubleStyleMapEntryArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StyleTableMapArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.StyleTableMapArchive", [
            { no: 1, name: "capacity", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "map_entry", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.StyleTableMapArchive_StyleTableMapEntryArchive }
        ]);
    }
    create(value) {
        const message = { capacity: 0, count: 0, mapEntry: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 capacity */ 1:
                    message.capacity = reader.uint32();
                    break;
                case /* uint32 count */ 2:
                    message.count = reader.uint32();
                    break;
                case /* repeated TST.StyleTableMapArchive.StyleTableMapEntryArchive map_entry */ 3:
                    message.mapEntry.push(exports.StyleTableMapArchive_StyleTableMapEntryArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 capacity = 1; */
        if (message.capacity !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.capacity);
        /* uint32 count = 2; */
        if (message.count !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.count);
        /* repeated TST.StyleTableMapArchive.StyleTableMapEntryArchive map_entry = 3; */
        for (let i = 0; i < message.mapEntry.length; i++)
            exports.StyleTableMapArchive_StyleTableMapEntryArchive.internalBinaryWrite(message.mapEntry[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.StyleTableMapArchive
 */
exports.StyleTableMapArchive = new StyleTableMapArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StyleTableMapArchive_StyleTableMapEntryArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.StyleTableMapArchive.StyleTableMapEntryArchive", [
            { no: 1, name: "key", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "old_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 3, name: "new_style", kind: "message", T: () => TSPMessages_10.Reference }
        ]);
    }
    create(value) {
        const message = { key: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 key */ 1:
                    message.key = reader.uint32();
                    break;
                case /* TSP.Reference old_style */ 2:
                    message.oldStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.oldStyle);
                    break;
                case /* TSP.Reference new_style */ 3:
                    message.newStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.newStyle);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 key = 1; */
        if (message.key !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.key);
        /* TSP.Reference old_style = 2; */
        if (message.oldStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.oldStyle, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference new_style = 3; */
        if (message.newStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.newStyle, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.StyleTableMapArchive.StyleTableMapEntryArchive
 */
exports.StyleTableMapArchive_StyleTableMapEntryArchive = new StyleTableMapArchive_StyleTableMapEntryArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelectionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.SelectionArchive", [
            { no: 1, name: "tableModel", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 4, name: "selection_type", kind: "enum", T: () => ["TST.SelectionTypeArchive", SelectionTypeArchive] },
            { no: 5, name: "anchor_cell", kind: "message", T: () => exports.CellID },
            { no: 6, name: "cell_ranges", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CellRange },
            { no: 7, name: "base_ranges", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CellRange },
            { no: 8, name: "cursor_cell", kind: "message", T: () => exports.CellID },
            { no: 9, name: "table_info", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 10, name: "cell_uid_region", kind: "message", T: () => exports.CellUIDRegionArchive },
            { no: 11, name: "base_uid_region", kind: "message", T: () => exports.CellUIDRegionArchive },
            { no: 12, name: "anchor_cell_uid", kind: "message", T: () => TSPMessages_3.UUIDCoordArchive },
            { no: 13, name: "cursor_cell_uid", kind: "message", T: () => TSPMessages_3.UUIDCoordArchive }
        ]);
    }
    create(value) {
        const message = { selectionType: 0, cellRanges: [], baseRanges: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference tableModel = 1 [deprecated = true];*/ 1:
                    message.tableModel = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.tableModel);
                    break;
                case /* TST.SelectionTypeArchive selection_type */ 4:
                    message.selectionType = reader.int32();
                    break;
                case /* optional TST.CellID anchor_cell */ 5:
                    message.anchorCell = exports.CellID.internalBinaryRead(reader, reader.uint32(), options, message.anchorCell);
                    break;
                case /* repeated TST.CellRange cell_ranges */ 6:
                    message.cellRanges.push(exports.CellRange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TST.CellRange base_ranges */ 7:
                    message.baseRanges.push(exports.CellRange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TST.CellID cursor_cell */ 8:
                    message.cursorCell = exports.CellID.internalBinaryRead(reader, reader.uint32(), options, message.cursorCell);
                    break;
                case /* optional TSP.Reference table_info */ 9:
                    message.tableInfo = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.tableInfo);
                    break;
                case /* optional TST.CellUIDRegionArchive cell_uid_region */ 10:
                    message.cellUidRegion = exports.CellUIDRegionArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellUidRegion);
                    break;
                case /* optional TST.CellUIDRegionArchive base_uid_region */ 11:
                    message.baseUidRegion = exports.CellUIDRegionArchive.internalBinaryRead(reader, reader.uint32(), options, message.baseUidRegion);
                    break;
                case /* optional TSP.UUIDCoordArchive anchor_cell_uid */ 12:
                    message.anchorCellUid = TSPMessages_3.UUIDCoordArchive.internalBinaryRead(reader, reader.uint32(), options, message.anchorCellUid);
                    break;
                case /* optional TSP.UUIDCoordArchive cursor_cell_uid */ 13:
                    message.cursorCellUid = TSPMessages_3.UUIDCoordArchive.internalBinaryRead(reader, reader.uint32(), options, message.cursorCellUid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference tableModel = 1 [deprecated = true]; */
        if (message.tableModel)
            TSPMessages_10.Reference.internalBinaryWrite(message.tableModel, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.SelectionTypeArchive selection_type = 4; */
        if (message.selectionType !== 0)
            writer.tag(4, runtime_1.WireType.Varint).int32(message.selectionType);
        /* optional TST.CellID anchor_cell = 5; */
        if (message.anchorCell)
            exports.CellID.internalBinaryWrite(message.anchorCell, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TST.CellRange cell_ranges = 6; */
        for (let i = 0; i < message.cellRanges.length; i++)
            exports.CellRange.internalBinaryWrite(message.cellRanges[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TST.CellRange base_ranges = 7; */
        for (let i = 0; i < message.baseRanges.length; i++)
            exports.CellRange.internalBinaryWrite(message.baseRanges[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.CellID cursor_cell = 8; */
        if (message.cursorCell)
            exports.CellID.internalBinaryWrite(message.cursorCell, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference table_info = 9; */
        if (message.tableInfo)
            TSPMessages_10.Reference.internalBinaryWrite(message.tableInfo, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.CellUIDRegionArchive cell_uid_region = 10; */
        if (message.cellUidRegion)
            exports.CellUIDRegionArchive.internalBinaryWrite(message.cellUidRegion, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.CellUIDRegionArchive base_uid_region = 11; */
        if (message.baseUidRegion)
            exports.CellUIDRegionArchive.internalBinaryWrite(message.baseUidRegion, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDCoordArchive anchor_cell_uid = 12; */
        if (message.anchorCellUid)
            TSPMessages_3.UUIDCoordArchive.internalBinaryWrite(message.anchorCellUid, writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDCoordArchive cursor_cell_uid = 13; */
        if (message.cursorCellUid)
            TSPMessages_3.UUIDCoordArchive.internalBinaryWrite(message.cursorCellUid, writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.SelectionArchive
 */
exports.SelectionArchive = new SelectionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeathhawkRdar39989167CellSelectionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.DeathhawkRdar39989167CellSelectionArchive", [
            { no: 1, name: "table_info", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 2, name: "selection_type", kind: "enum", opt: true, T: () => ["TST.SelectionTypeArchive", SelectionTypeArchive] },
            { no: 3, name: "cell_uid_region", kind: "message", T: () => exports.CellUIDRegionArchive },
            { no: 4, name: "base_uid_region", kind: "message", T: () => exports.CellUIDRegionArchive },
            { no: 5, name: "anchor_cell_uid", kind: "message", T: () => TSPMessages_3.UUIDCoordArchive },
            { no: 6, name: "cursor_cell_uid", kind: "message", T: () => TSPMessages_3.UUIDCoordArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference table_info */ 1:
                    message.tableInfo = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.tableInfo);
                    break;
                case /* optional TST.SelectionTypeArchive selection_type */ 2:
                    message.selectionType = reader.int32();
                    break;
                case /* optional TST.CellUIDRegionArchive cell_uid_region */ 3:
                    message.cellUidRegion = exports.CellUIDRegionArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellUidRegion);
                    break;
                case /* optional TST.CellUIDRegionArchive base_uid_region */ 4:
                    message.baseUidRegion = exports.CellUIDRegionArchive.internalBinaryRead(reader, reader.uint32(), options, message.baseUidRegion);
                    break;
                case /* optional TSP.UUIDCoordArchive anchor_cell_uid */ 5:
                    message.anchorCellUid = TSPMessages_3.UUIDCoordArchive.internalBinaryRead(reader, reader.uint32(), options, message.anchorCellUid);
                    break;
                case /* optional TSP.UUIDCoordArchive cursor_cell_uid */ 6:
                    message.cursorCellUid = TSPMessages_3.UUIDCoordArchive.internalBinaryRead(reader, reader.uint32(), options, message.cursorCellUid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference table_info = 1; */
        if (message.tableInfo)
            TSPMessages_10.Reference.internalBinaryWrite(message.tableInfo, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.SelectionTypeArchive selection_type = 2; */
        if (message.selectionType !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.selectionType);
        /* optional TST.CellUIDRegionArchive cell_uid_region = 3; */
        if (message.cellUidRegion)
            exports.CellUIDRegionArchive.internalBinaryWrite(message.cellUidRegion, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.CellUIDRegionArchive base_uid_region = 4; */
        if (message.baseUidRegion)
            exports.CellUIDRegionArchive.internalBinaryWrite(message.baseUidRegion, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDCoordArchive anchor_cell_uid = 5; */
        if (message.anchorCellUid)
            TSPMessages_3.UUIDCoordArchive.internalBinaryWrite(message.anchorCellUid, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDCoordArchive cursor_cell_uid = 6; */
        if (message.cursorCellUid)
            TSPMessages_3.UUIDCoordArchive.internalBinaryWrite(message.cursorCellUid, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.DeathhawkRdar39989167CellSelectionArchive
 */
exports.DeathhawkRdar39989167CellSelectionArchive = new DeathhawkRdar39989167CellSelectionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StrokeSelectionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.StrokeSelectionArchive", [
            { no: 1, name: "mask", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 mask */ 1:
                    message.mask = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional int32 mask = 1; */
        if (message.mask !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.mask);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.StrokeSelectionArchive
 */
exports.StrokeSelectionArchive = new StrokeSelectionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ControlCellSelectionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.ControlCellSelectionArchive", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.ControlCellSelectionArchive
 */
exports.ControlCellSelectionArchive = new ControlCellSelectionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StockCellSelectionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.StockCellSelectionArchive", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.StockCellSelectionArchive
 */
exports.StockCellSelectionArchive = new StockCellSelectionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TableNameSelectionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.TableNameSelectionArchive", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.TableNameSelectionArchive
 */
exports.TableNameSelectionArchive = new TableNameSelectionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AutofillSelectionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.AutofillSelectionArchive", [
            { no: 1, name: "source_cell_range", kind: "message", T: () => exports.CellRange },
            { no: 2, name: "target_cell_range", kind: "message", T: () => exports.CellRange }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TST.CellRange source_cell_range */ 1:
                    message.sourceCellRange = exports.CellRange.internalBinaryRead(reader, reader.uint32(), options, message.sourceCellRange);
                    break;
                case /* optional TST.CellRange target_cell_range */ 2:
                    message.targetCellRange = exports.CellRange.internalBinaryRead(reader, reader.uint32(), options, message.targetCellRange);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TST.CellRange source_cell_range = 1; */
        if (message.sourceCellRange)
            exports.CellRange.internalBinaryWrite(message.sourceCellRange, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.CellRange target_cell_range = 2; */
        if (message.targetCellRange)
            exports.CellRange.internalBinaryWrite(message.targetCellRange, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.AutofillSelectionArchive
 */
exports.AutofillSelectionArchive = new AutofillSelectionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FilterRulePrePivotArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.FilterRulePrePivotArchive", [
            { no: 1, name: "predicate", kind: "message", T: () => exports.FormulaPredicatePrePivotArchive },
            { no: 2, name: "disabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.FormulaPredicatePrePivotArchive predicate */ 1:
                    message.predicate = exports.FormulaPredicatePrePivotArchive.internalBinaryRead(reader, reader.uint32(), options, message.predicate);
                    break;
                case /* optional bool disabled */ 2:
                    message.disabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.FormulaPredicatePrePivotArchive predicate = 1; */
        if (message.predicate)
            exports.FormulaPredicatePrePivotArchive.internalBinaryWrite(message.predicate, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool disabled = 2; */
        if (message.disabled !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.disabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.FilterRulePrePivotArchive
 */
exports.FilterRulePrePivotArchive = new FilterRulePrePivotArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FilterRuleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.FilterRuleArchive", [
            { no: 1, name: "predicate", kind: "message", T: () => exports.FormulaPredicateArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.FormulaPredicateArchive predicate */ 1:
                    message.predicate = exports.FormulaPredicateArchive.internalBinaryRead(reader, reader.uint32(), options, message.predicate);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.FormulaPredicateArchive predicate = 1; */
        if (message.predicate)
            exports.FormulaPredicateArchive.internalBinaryWrite(message.predicate, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.FilterRuleArchive
 */
exports.FilterRuleArchive = new FilterRuleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TableStyleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.TableStyleArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSSArchives_1.StyleArchive },
            { no: 10, name: "override_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "table_properties", kind: "message", T: () => TSTStylePropertyArchiving_2.TableStylePropertiesArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSS.StyleArchive super */ 1:
                    message.super = TSSArchives_1.StyleArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional uint32 override_count */ 10:
                    message.overrideCount = reader.uint32();
                    break;
                case /* optional TST.TableStylePropertiesArchive table_properties */ 11:
                    message.tableProperties = TSTStylePropertyArchiving_2.TableStylePropertiesArchive.internalBinaryRead(reader, reader.uint32(), options, message.tableProperties);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSS.StyleArchive super = 1; */
        if (message.super)
            TSSArchives_1.StyleArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 override_count = 10; */
        if (message.overrideCount !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).uint32(message.overrideCount);
        /* optional TST.TableStylePropertiesArchive table_properties = 11; */
        if (message.tableProperties)
            TSTStylePropertyArchiving_2.TableStylePropertiesArchive.internalBinaryWrite(message.tableProperties, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.TableStyleArchive
 */
exports.TableStyleArchive = new TableStyleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellStyleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CellStyleArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSSArchives_1.StyleArchive },
            { no: 10, name: "override_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "cell_properties", kind: "message", T: () => TSTStylePropertyArchiving_1.CellStylePropertiesArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSS.StyleArchive super */ 1:
                    message.super = TSSArchives_1.StyleArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional uint32 override_count */ 10:
                    message.overrideCount = reader.uint32();
                    break;
                case /* optional TST.CellStylePropertiesArchive cell_properties */ 11:
                    message.cellProperties = TSTStylePropertyArchiving_1.CellStylePropertiesArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellProperties);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSS.StyleArchive super = 1; */
        if (message.super)
            TSSArchives_1.StyleArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 override_count = 10; */
        if (message.overrideCount !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).uint32(message.overrideCount);
        /* optional TST.CellStylePropertiesArchive cell_properties = 11; */
        if (message.cellProperties)
            TSTStylePropertyArchiving_1.CellStylePropertiesArchive.internalBinaryWrite(message.cellProperties, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CellStyleArchive
 */
exports.CellStyleArchive = new CellStyleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormulaPredArgDataArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.FormulaPredArgDataArchive", [
            { no: 1, name: "double_value", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "decimal_low", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "decimal_high", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "string_value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "date_value", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "duration_timeinterval", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "duration_units", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "boolean_value", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional double double_value */ 1:
                    message.doubleValue = reader.double();
                    break;
                case /* optional uint64 decimal_low */ 2:
                    message.decimalLow = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 decimal_high */ 3:
                    message.decimalHigh = reader.uint64().toBigInt();
                    break;
                case /* optional string string_value */ 4:
                    message.stringValue = reader.string();
                    break;
                case /* optional double date_value */ 5:
                    message.dateValue = reader.double();
                    break;
                case /* optional double duration_timeinterval */ 6:
                    message.durationTimeinterval = reader.double();
                    break;
                case /* optional int32 duration_units */ 7:
                    message.durationUnits = reader.int32();
                    break;
                case /* optional bool boolean_value */ 8:
                    message.booleanValue = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional double double_value = 1; */
        if (message.doubleValue !== undefined)
            writer.tag(1, runtime_1.WireType.Bit64).double(message.doubleValue);
        /* optional uint64 decimal_low = 2; */
        if (message.decimalLow !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint64(message.decimalLow);
        /* optional uint64 decimal_high = 3; */
        if (message.decimalHigh !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint64(message.decimalHigh);
        /* optional string string_value = 4; */
        if (message.stringValue !== undefined)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.stringValue);
        /* optional double date_value = 5; */
        if (message.dateValue !== undefined)
            writer.tag(5, runtime_1.WireType.Bit64).double(message.dateValue);
        /* optional double duration_timeinterval = 6; */
        if (message.durationTimeinterval !== undefined)
            writer.tag(6, runtime_1.WireType.Bit64).double(message.durationTimeinterval);
        /* optional int32 duration_units = 7; */
        if (message.durationUnits !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).int32(message.durationUnits);
        /* optional bool boolean_value = 8; */
        if (message.booleanValue !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.booleanValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.FormulaPredArgDataArchive
 */
exports.FormulaPredArgDataArchive = new FormulaPredArgDataArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormulaPredArgArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.FormulaPredArgArchive", [
            { no: 1, name: "arg_type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "arg_value", kind: "message", T: () => exports.FormulaPredArgDataArchive },
            { no: 3, name: "base_cell_ref", kind: "message", T: () => TSCEArchives_13.CellReferenceArchive },
            { no: 4, name: "relative_cell_ref", kind: "message", T: () => TSCEArchives_9.RelativeCellRefArchive },
            { no: 5, name: "category_ref", kind: "message", T: () => TSCEArchives_8.CategoryReferenceArchive },
            { no: 6, name: "uid_tract_list", kind: "message", T: () => TSCEArchives_7.ASTNodeArrayArchive_ASTUidTractList },
            { no: 7, name: "host_cell_coord", kind: "message", T: () => TSCEArchives_20.CellCoordinateArchive },
            { no: 8, name: "preserve_row", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "preserve_column", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "list_entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.FormulaPredArgDataArchive },
            { no: 11, name: "view_tract_ref", kind: "message", T: () => TSCEArchives_6.ViewTractRefArchive }
        ]);
    }
    create(value) {
        const message = { argType: 0, listEntries: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 arg_type */ 1:
                    message.argType = reader.int32();
                    break;
                case /* optional TST.FormulaPredArgDataArchive arg_value */ 2:
                    message.argValue = exports.FormulaPredArgDataArchive.internalBinaryRead(reader, reader.uint32(), options, message.argValue);
                    break;
                case /* optional TSCE.CellReferenceArchive base_cell_ref */ 3:
                    message.baseCellRef = TSCEArchives_13.CellReferenceArchive.internalBinaryRead(reader, reader.uint32(), options, message.baseCellRef);
                    break;
                case /* optional TSCE.RelativeCellRefArchive relative_cell_ref */ 4:
                    message.relativeCellRef = TSCEArchives_9.RelativeCellRefArchive.internalBinaryRead(reader, reader.uint32(), options, message.relativeCellRef);
                    break;
                case /* optional TSCE.CategoryReferenceArchive category_ref */ 5:
                    message.categoryRef = TSCEArchives_8.CategoryReferenceArchive.internalBinaryRead(reader, reader.uint32(), options, message.categoryRef);
                    break;
                case /* optional TSCE.ASTNodeArrayArchive.ASTUidTractList uid_tract_list */ 6:
                    message.uidTractList = TSCEArchives_7.ASTNodeArrayArchive_ASTUidTractList.internalBinaryRead(reader, reader.uint32(), options, message.uidTractList);
                    break;
                case /* optional TSCE.CellCoordinateArchive host_cell_coord */ 7:
                    message.hostCellCoord = TSCEArchives_20.CellCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.hostCellCoord);
                    break;
                case /* optional bool preserve_row */ 8:
                    message.preserveRow = reader.bool();
                    break;
                case /* optional bool preserve_column */ 9:
                    message.preserveColumn = reader.bool();
                    break;
                case /* repeated TST.FormulaPredArgDataArchive list_entries */ 10:
                    message.listEntries.push(exports.FormulaPredArgDataArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSCE.ViewTractRefArchive view_tract_ref */ 11:
                    message.viewTractRef = TSCEArchives_6.ViewTractRefArchive.internalBinaryRead(reader, reader.uint32(), options, message.viewTractRef);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int32 arg_type = 1; */
        if (message.argType !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.argType);
        /* optional TST.FormulaPredArgDataArchive arg_value = 2; */
        if (message.argValue)
            exports.FormulaPredArgDataArchive.internalBinaryWrite(message.argValue, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.CellReferenceArchive base_cell_ref = 3; */
        if (message.baseCellRef)
            TSCEArchives_13.CellReferenceArchive.internalBinaryWrite(message.baseCellRef, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.RelativeCellRefArchive relative_cell_ref = 4; */
        if (message.relativeCellRef)
            TSCEArchives_9.RelativeCellRefArchive.internalBinaryWrite(message.relativeCellRef, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.CategoryReferenceArchive category_ref = 5; */
        if (message.categoryRef)
            TSCEArchives_8.CategoryReferenceArchive.internalBinaryWrite(message.categoryRef, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.ASTNodeArrayArchive.ASTUidTractList uid_tract_list = 6; */
        if (message.uidTractList)
            TSCEArchives_7.ASTNodeArrayArchive_ASTUidTractList.internalBinaryWrite(message.uidTractList, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.CellCoordinateArchive host_cell_coord = 7; */
        if (message.hostCellCoord)
            TSCEArchives_20.CellCoordinateArchive.internalBinaryWrite(message.hostCellCoord, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool preserve_row = 8; */
        if (message.preserveRow !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.preserveRow);
        /* optional bool preserve_column = 9; */
        if (message.preserveColumn !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).bool(message.preserveColumn);
        /* repeated TST.FormulaPredArgDataArchive list_entries = 10; */
        for (let i = 0; i < message.listEntries.length; i++)
            exports.FormulaPredArgDataArchive.internalBinaryWrite(message.listEntries[i], writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.ViewTractRefArchive view_tract_ref = 11; */
        if (message.viewTractRef)
            TSCEArchives_6.ViewTractRefArchive.internalBinaryWrite(message.viewTractRef, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.FormulaPredArgArchive
 */
exports.FormulaPredArgArchive = new FormulaPredArgArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormulaPredicatePrePivotArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.FormulaPredicatePrePivotArchive", [
            { no: 1, name: "formula", kind: "message", T: () => TSCEArchives_12.FormulaArchive },
            { no: 2, name: "predicate_type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "qualifier1", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "qualifier2", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "param_index1", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "param_index2", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "param_index0", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = { predicateType: 0, qualifier1: 0, qualifier2: 0, paramIndex1: 0, paramIndex2: 0, paramIndex0: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSCE.FormulaArchive formula */ 1:
                    message.formula = TSCEArchives_12.FormulaArchive.internalBinaryRead(reader, reader.uint32(), options, message.formula);
                    break;
                case /* int32 predicate_type */ 2:
                    message.predicateType = reader.int32();
                    break;
                case /* int32 qualifier1 */ 3:
                    message.qualifier1 = reader.int32();
                    break;
                case /* int32 qualifier2 */ 4:
                    message.qualifier2 = reader.int32();
                    break;
                case /* int32 param_index1 */ 5:
                    message.paramIndex1 = reader.int32();
                    break;
                case /* int32 param_index2 */ 6:
                    message.paramIndex2 = reader.int32();
                    break;
                case /* int32 param_index0 */ 7:
                    message.paramIndex0 = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSCE.FormulaArchive formula = 1; */
        if (message.formula)
            TSCEArchives_12.FormulaArchive.internalBinaryWrite(message.formula, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* int32 predicate_type = 2; */
        if (message.predicateType !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.predicateType);
        /* int32 qualifier1 = 3; */
        if (message.qualifier1 !== 0)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.qualifier1);
        /* int32 qualifier2 = 4; */
        if (message.qualifier2 !== 0)
            writer.tag(4, runtime_1.WireType.Varint).int32(message.qualifier2);
        /* int32 param_index1 = 5; */
        if (message.paramIndex1 !== 0)
            writer.tag(5, runtime_1.WireType.Varint).int32(message.paramIndex1);
        /* int32 param_index2 = 6; */
        if (message.paramIndex2 !== 0)
            writer.tag(6, runtime_1.WireType.Varint).int32(message.paramIndex2);
        /* int32 param_index0 = 7; */
        if (message.paramIndex0 !== 0)
            writer.tag(7, runtime_1.WireType.Varint).int32(message.paramIndex0);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.FormulaPredicatePrePivotArchive
 */
exports.FormulaPredicatePrePivotArchive = new FormulaPredicatePrePivotArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormulaPredicateArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.FormulaPredicateArchive", [
            { no: 1, name: "predicate_type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "qualifier1", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "qualifier2", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "param_value0", kind: "message", T: () => exports.FormulaPredArgArchive },
            { no: 5, name: "param_value1", kind: "message", T: () => exports.FormulaPredArgArchive },
            { no: 6, name: "param_value2", kind: "message", T: () => exports.FormulaPredArgArchive },
            { no: 7, name: "formula", kind: "message", T: () => TSCEArchives_12.FormulaArchive },
            { no: 8, name: "for_conditional_style", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "host_table_uid", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 10, name: "host_column_uid", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 11, name: "host_row_uid", kind: "message", T: () => TSPMessages_11.UUID }
        ]);
    }
    create(value) {
        const message = { predicateType: 0, qualifier1: 0, qualifier2: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 predicate_type */ 1:
                    message.predicateType = reader.int32();
                    break;
                case /* int32 qualifier1 */ 2:
                    message.qualifier1 = reader.int32();
                    break;
                case /* int32 qualifier2 */ 3:
                    message.qualifier2 = reader.int32();
                    break;
                case /* optional TST.FormulaPredArgArchive param_value0 */ 4:
                    message.paramValue0 = exports.FormulaPredArgArchive.internalBinaryRead(reader, reader.uint32(), options, message.paramValue0);
                    break;
                case /* optional TST.FormulaPredArgArchive param_value1 */ 5:
                    message.paramValue1 = exports.FormulaPredArgArchive.internalBinaryRead(reader, reader.uint32(), options, message.paramValue1);
                    break;
                case /* optional TST.FormulaPredArgArchive param_value2 */ 6:
                    message.paramValue2 = exports.FormulaPredArgArchive.internalBinaryRead(reader, reader.uint32(), options, message.paramValue2);
                    break;
                case /* optional TSCE.FormulaArchive formula */ 7:
                    message.formula = TSCEArchives_12.FormulaArchive.internalBinaryRead(reader, reader.uint32(), options, message.formula);
                    break;
                case /* optional bool for_conditional_style */ 8:
                    message.forConditionalStyle = reader.bool();
                    break;
                case /* optional TSP.UUID host_table_uid */ 9:
                    message.hostTableUid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.hostTableUid);
                    break;
                case /* optional TSP.UUID host_column_uid */ 10:
                    message.hostColumnUid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.hostColumnUid);
                    break;
                case /* optional TSP.UUID host_row_uid */ 11:
                    message.hostRowUid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.hostRowUid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int32 predicate_type = 1; */
        if (message.predicateType !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.predicateType);
        /* int32 qualifier1 = 2; */
        if (message.qualifier1 !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.qualifier1);
        /* int32 qualifier2 = 3; */
        if (message.qualifier2 !== 0)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.qualifier2);
        /* optional TST.FormulaPredArgArchive param_value0 = 4; */
        if (message.paramValue0)
            exports.FormulaPredArgArchive.internalBinaryWrite(message.paramValue0, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.FormulaPredArgArchive param_value1 = 5; */
        if (message.paramValue1)
            exports.FormulaPredArgArchive.internalBinaryWrite(message.paramValue1, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.FormulaPredArgArchive param_value2 = 6; */
        if (message.paramValue2)
            exports.FormulaPredArgArchive.internalBinaryWrite(message.paramValue2, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.FormulaArchive formula = 7; */
        if (message.formula)
            TSCEArchives_12.FormulaArchive.internalBinaryWrite(message.formula, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool for_conditional_style = 8; */
        if (message.forConditionalStyle !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.forConditionalStyle);
        /* optional TSP.UUID host_table_uid = 9; */
        if (message.hostTableUid)
            TSPMessages_11.UUID.internalBinaryWrite(message.hostTableUid, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID host_column_uid = 10; */
        if (message.hostColumnUid)
            TSPMessages_11.UUID.internalBinaryWrite(message.hostColumnUid, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID host_row_uid = 11; */
        if (message.hostRowUid)
            TSPMessages_11.UUID.internalBinaryWrite(message.hostRowUid, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.FormulaPredicateArchive
 */
exports.FormulaPredicateArchive = new FormulaPredicateArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConditionalStyleSetArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.ConditionalStyleSetArchive", [
            { no: 1, name: "ruleCount", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "rules_prepivot", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ConditionalStyleSetArchive_ConditionalStyleRulePrePivot },
            { no: 3, name: "rules", kind: "message", T: () => exports.ConditionalStyleSetArchive_ConditionalStyleRules }
        ]);
    }
    create(value) {
        const message = { ruleCount: 0, rulesPrepivot: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 ruleCount */ 1:
                    message.ruleCount = reader.uint32();
                    break;
                case /* repeated TST.ConditionalStyleSetArchive.ConditionalStyleRulePrePivot rules_prepivot */ 2:
                    message.rulesPrepivot.push(exports.ConditionalStyleSetArchive_ConditionalStyleRulePrePivot.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TST.ConditionalStyleSetArchive.ConditionalStyleRules rules */ 3:
                    message.rules = exports.ConditionalStyleSetArchive_ConditionalStyleRules.internalBinaryRead(reader, reader.uint32(), options, message.rules);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 ruleCount = 1; */
        if (message.ruleCount !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.ruleCount);
        /* repeated TST.ConditionalStyleSetArchive.ConditionalStyleRulePrePivot rules_prepivot = 2; */
        for (let i = 0; i < message.rulesPrepivot.length; i++)
            exports.ConditionalStyleSetArchive_ConditionalStyleRulePrePivot.internalBinaryWrite(message.rulesPrepivot[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.ConditionalStyleSetArchive.ConditionalStyleRules rules = 3; */
        if (message.rules)
            exports.ConditionalStyleSetArchive_ConditionalStyleRules.internalBinaryWrite(message.rules, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.ConditionalStyleSetArchive
 */
exports.ConditionalStyleSetArchive = new ConditionalStyleSetArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConditionalStyleSetArchive_ConditionalStyleRulePrePivot$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.ConditionalStyleSetArchive.ConditionalStyleRulePrePivot", [
            { no: 1, name: "predicate", kind: "message", T: () => exports.FormulaPredicatePrePivotArchive },
            { no: 2, name: "cell_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 3, name: "text_style", kind: "message", T: () => TSPMessages_10.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.FormulaPredicatePrePivotArchive predicate */ 1:
                    message.predicate = exports.FormulaPredicatePrePivotArchive.internalBinaryRead(reader, reader.uint32(), options, message.predicate);
                    break;
                case /* TSP.Reference cell_style */ 2:
                    message.cellStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.cellStyle);
                    break;
                case /* TSP.Reference text_style */ 3:
                    message.textStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.textStyle);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.FormulaPredicatePrePivotArchive predicate = 1; */
        if (message.predicate)
            exports.FormulaPredicatePrePivotArchive.internalBinaryWrite(message.predicate, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference cell_style = 2; */
        if (message.cellStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.cellStyle, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference text_style = 3; */
        if (message.textStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.textStyle, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.ConditionalStyleSetArchive.ConditionalStyleRulePrePivot
 */
exports.ConditionalStyleSetArchive_ConditionalStyleRulePrePivot = new ConditionalStyleSetArchive_ConditionalStyleRulePrePivot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConditionalStyleSetArchive_ConditionalStyleRule$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.ConditionalStyleSetArchive.ConditionalStyleRule", [
            { no: 1, name: "predicate", kind: "message", T: () => exports.FormulaPredicateArchive },
            { no: 2, name: "cell_style", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 3, name: "text_style", kind: "message", T: () => TSPMessages_10.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TST.FormulaPredicateArchive predicate */ 1:
                    message.predicate = exports.FormulaPredicateArchive.internalBinaryRead(reader, reader.uint32(), options, message.predicate);
                    break;
                case /* TSP.Reference cell_style */ 2:
                    message.cellStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.cellStyle);
                    break;
                case /* TSP.Reference text_style */ 3:
                    message.textStyle = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.textStyle);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TST.FormulaPredicateArchive predicate = 1; */
        if (message.predicate)
            exports.FormulaPredicateArchive.internalBinaryWrite(message.predicate, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference cell_style = 2; */
        if (message.cellStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.cellStyle, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference text_style = 3; */
        if (message.textStyle)
            TSPMessages_10.Reference.internalBinaryWrite(message.textStyle, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.ConditionalStyleSetArchive.ConditionalStyleRule
 */
exports.ConditionalStyleSetArchive_ConditionalStyleRule = new ConditionalStyleSetArchive_ConditionalStyleRule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConditionalStyleSetArchive_ConditionalStyleRules$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.ConditionalStyleSetArchive.ConditionalStyleRules", [
            { no: 1, name: "rule", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ConditionalStyleSetArchive_ConditionalStyleRule }
        ]);
    }
    create(value) {
        const message = { rule: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TST.ConditionalStyleSetArchive.ConditionalStyleRule rule */ 1:
                    message.rule.push(exports.ConditionalStyleSetArchive_ConditionalStyleRule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TST.ConditionalStyleSetArchive.ConditionalStyleRule rule = 1; */
        for (let i = 0; i < message.rule.length; i++)
            exports.ConditionalStyleSetArchive_ConditionalStyleRule.internalBinaryWrite(message.rule[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.ConditionalStyleSetArchive.ConditionalStyleRules
 */
exports.ConditionalStyleSetArchive_ConditionalStyleRules = new ConditionalStyleSetArchive_ConditionalStyleRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FilterSetArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.FilterSetArchive", [
            { no: 1, name: "type", kind: "enum", opt: true, T: () => ["TST.FilterSetArchive.FilterSetType", FilterSetArchive_FilterSetType] },
            { no: 2, name: "is_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "filter_rules_prepivot", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.FilterRulePrePivotArchive },
            { no: 4, name: "needs_formula_rewrite_for_import", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "filter_offsets", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "filter_enabled", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "filter_rules", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.FilterRuleArchive }
        ]);
    }
    create(value) {
        const message = { filterRulesPrepivot: [], filterOffsets: [], filterEnabled: [], filterRules: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TST.FilterSetArchive.FilterSetType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional bool is_enabled */ 2:
                    message.isEnabled = reader.bool();
                    break;
                case /* repeated TST.FilterRulePrePivotArchive filter_rules_prepivot */ 3:
                    message.filterRulesPrepivot.push(exports.FilterRulePrePivotArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool needs_formula_rewrite_for_import */ 4:
                    message.needsFormulaRewriteForImport = reader.bool();
                    break;
                case /* repeated uint32 filter_offsets */ 5:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.filterOffsets.push(reader.uint32());
                    else
                        message.filterOffsets.push(reader.uint32());
                    break;
                case /* repeated bool filter_enabled */ 6:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.filterEnabled.push(reader.bool());
                    else
                        message.filterEnabled.push(reader.bool());
                    break;
                case /* repeated TST.FilterRuleArchive filter_rules */ 7:
                    message.filterRules.push(exports.FilterRuleArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TST.FilterSetArchive.FilterSetType type = 1; */
        if (message.type !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.type);
        /* optional bool is_enabled = 2; */
        if (message.isEnabled !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.isEnabled);
        /* repeated TST.FilterRulePrePivotArchive filter_rules_prepivot = 3; */
        for (let i = 0; i < message.filterRulesPrepivot.length; i++)
            exports.FilterRulePrePivotArchive.internalBinaryWrite(message.filterRulesPrepivot[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool needs_formula_rewrite_for_import = 4; */
        if (message.needsFormulaRewriteForImport !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.needsFormulaRewriteForImport);
        /* repeated uint32 filter_offsets = 5; */
        for (let i = 0; i < message.filterOffsets.length; i++)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.filterOffsets[i]);
        /* repeated bool filter_enabled = 6; */
        for (let i = 0; i < message.filterEnabled.length; i++)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.filterEnabled[i]);
        /* repeated TST.FilterRuleArchive filter_rules = 7; */
        for (let i = 0; i < message.filterRules.length; i++)
            exports.FilterRuleArchive.internalBinaryWrite(message.filterRules[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.FilterSetArchive
 */
exports.FilterSetArchive = new FilterSetArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UniqueIndexArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.UniqueIndexArchive", [
            { no: 1, name: "column_uid", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 2, name: "unique_entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.UniqueIndexArchive_UniqueIndexEntryArchive }
        ]);
    }
    create(value) {
        const message = { uniqueEntries: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID column_uid */ 1:
                    message.columnUid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.columnUid);
                    break;
                case /* repeated TST.UniqueIndexArchive.UniqueIndexEntryArchive unique_entries */ 2:
                    message.uniqueEntries.push(exports.UniqueIndexArchive_UniqueIndexEntryArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID column_uid = 1; */
        if (message.columnUid)
            TSPMessages_11.UUID.internalBinaryWrite(message.columnUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TST.UniqueIndexArchive.UniqueIndexEntryArchive unique_entries = 2; */
        for (let i = 0; i < message.uniqueEntries.length; i++)
            exports.UniqueIndexArchive_UniqueIndexEntryArchive.internalBinaryWrite(message.uniqueEntries[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.UniqueIndexArchive
 */
exports.UniqueIndexArchive = new UniqueIndexArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UniqueIndexArchive_UniqueIndexEntryArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.UniqueIndexArchive.UniqueIndexEntryArchive", [
            { no: 1, name: "string_value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "row_uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_11.UUID }
        ]);
    }
    create(value) {
        const message = { stringValue: "", rowUids: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string string_value */ 1:
                    message.stringValue = reader.string();
                    break;
                case /* repeated TSP.UUID row_uids */ 2:
                    message.rowUids.push(TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string string_value = 1; */
        if (message.stringValue !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.stringValue);
        /* repeated TSP.UUID row_uids = 2; */
        for (let i = 0; i < message.rowUids.length; i++)
            TSPMessages_11.UUID.internalBinaryWrite(message.rowUids[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.UniqueIndexArchive.UniqueIndexEntryArchive
 */
exports.UniqueIndexArchive_UniqueIndexEntryArchive = new UniqueIndexArchive_UniqueIndexEntryArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HiddenStateExtentArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.HiddenStateExtentArchive", [
            { no: 1, name: "hidden_state_extent_uid", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 2, name: "base_hidden_states", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.HiddenStateExtentArchive_RowOrColumnState },
            { no: 3, name: "row_or_column_direction", kind: "enum", T: () => ["TST.HiddenStateExtentArchive.RowOrColumnDirection", HiddenStateExtentArchive_RowOrColumnDirection] },
            { no: 5, name: "threshold_value", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSCEArchives_18.CellValueArchive },
            { no: 6, name: "needs_to_update_filter_set_for_import", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "collapsed_group_uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_11.UUID },
            { no: 8, name: "filter_set", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 9, name: "summary_pivot_hidden_indexes", kind: "message", T: () => TSCEArchives_5.IndexSetArchive },
            { no: 10, name: "summary_filtered_indexes", kind: "message", T: () => TSCEArchives_5.IndexSetArchive },
            { no: 11, name: "unique_indexes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.UniqueIndexArchive },
            { no: 12, name: "summary_hidden_states", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.HiddenStateExtentArchive_RowOrColumnState }
        ]);
    }
    create(value) {
        const message = { baseHiddenStates: [], rowOrColumnDirection: 0, thresholdValue: [], collapsedGroupUids: [], uniqueIndexes: [], summaryHiddenStates: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID hidden_state_extent_uid */ 1:
                    message.hiddenStateExtentUid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.hiddenStateExtentUid);
                    break;
                case /* repeated TST.HiddenStateExtentArchive.RowOrColumnState base_hidden_states */ 2:
                    message.baseHiddenStates.push(exports.HiddenStateExtentArchive_RowOrColumnState.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* TST.HiddenStateExtentArchive.RowOrColumnDirection row_or_column_direction */ 3:
                    message.rowOrColumnDirection = reader.int32();
                    break;
                case /* repeated TSCE.CellValueArchive threshold_value */ 5:
                    message.thresholdValue.push(TSCEArchives_18.CellValueArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool needs_to_update_filter_set_for_import */ 6:
                    message.needsToUpdateFilterSetForImport = reader.bool();
                    break;
                case /* repeated TSP.UUID collapsed_group_uids */ 7:
                    message.collapsedGroupUids.push(TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Reference filter_set */ 8:
                    message.filterSet = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.filterSet);
                    break;
                case /* optional TSCE.IndexSetArchive summary_pivot_hidden_indexes */ 9:
                    message.summaryPivotHiddenIndexes = TSCEArchives_5.IndexSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.summaryPivotHiddenIndexes);
                    break;
                case /* optional TSCE.IndexSetArchive summary_filtered_indexes */ 10:
                    message.summaryFilteredIndexes = TSCEArchives_5.IndexSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.summaryFilteredIndexes);
                    break;
                case /* repeated TST.UniqueIndexArchive unique_indexes */ 11:
                    message.uniqueIndexes.push(exports.UniqueIndexArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TST.HiddenStateExtentArchive.RowOrColumnState summary_hidden_states */ 12:
                    message.summaryHiddenStates.push(exports.HiddenStateExtentArchive_RowOrColumnState.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID hidden_state_extent_uid = 1; */
        if (message.hiddenStateExtentUid)
            TSPMessages_11.UUID.internalBinaryWrite(message.hiddenStateExtentUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TST.HiddenStateExtentArchive.RowOrColumnState base_hidden_states = 2; */
        for (let i = 0; i < message.baseHiddenStates.length; i++)
            exports.HiddenStateExtentArchive_RowOrColumnState.internalBinaryWrite(message.baseHiddenStates[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.HiddenStateExtentArchive.RowOrColumnDirection row_or_column_direction = 3; */
        if (message.rowOrColumnDirection !== 0)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.rowOrColumnDirection);
        /* repeated TSCE.CellValueArchive threshold_value = 5; */
        for (let i = 0; i < message.thresholdValue.length; i++)
            TSCEArchives_18.CellValueArchive.internalBinaryWrite(message.thresholdValue[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool needs_to_update_filter_set_for_import = 6; */
        if (message.needsToUpdateFilterSetForImport !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.needsToUpdateFilterSetForImport);
        /* repeated TSP.UUID collapsed_group_uids = 7; */
        for (let i = 0; i < message.collapsedGroupUids.length; i++)
            TSPMessages_11.UUID.internalBinaryWrite(message.collapsedGroupUids[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference filter_set = 8; */
        if (message.filterSet)
            TSPMessages_10.Reference.internalBinaryWrite(message.filterSet, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.IndexSetArchive summary_pivot_hidden_indexes = 9; */
        if (message.summaryPivotHiddenIndexes)
            TSCEArchives_5.IndexSetArchive.internalBinaryWrite(message.summaryPivotHiddenIndexes, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.IndexSetArchive summary_filtered_indexes = 10; */
        if (message.summaryFilteredIndexes)
            TSCEArchives_5.IndexSetArchive.internalBinaryWrite(message.summaryFilteredIndexes, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TST.UniqueIndexArchive unique_indexes = 11; */
        for (let i = 0; i < message.uniqueIndexes.length; i++)
            exports.UniqueIndexArchive.internalBinaryWrite(message.uniqueIndexes[i], writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TST.HiddenStateExtentArchive.RowOrColumnState summary_hidden_states = 12; */
        for (let i = 0; i < message.summaryHiddenStates.length; i++)
            exports.HiddenStateExtentArchive_RowOrColumnState.internalBinaryWrite(message.summaryHiddenStates[i], writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.HiddenStateExtentArchive
 */
exports.HiddenStateExtentArchive = new HiddenStateExtentArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HiddenStateExtentArchive_RowOrColumnState$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.HiddenStateExtentArchive.RowOrColumnState", [
            { no: 1, name: "row_or_column_uid", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 2, name: "user_hidden", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "filtered", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "pivot_hidden", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID row_or_column_uid */ 1:
                    message.rowOrColumnUid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.rowOrColumnUid);
                    break;
                case /* optional bool user_hidden */ 2:
                    message.userHidden = reader.bool();
                    break;
                case /* optional bool filtered */ 3:
                    message.filtered = reader.bool();
                    break;
                case /* optional bool pivot_hidden */ 4:
                    message.pivotHidden = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID row_or_column_uid = 1; */
        if (message.rowOrColumnUid)
            TSPMessages_11.UUID.internalBinaryWrite(message.rowOrColumnUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool user_hidden = 2; */
        if (message.userHidden !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.userHidden);
        /* optional bool filtered = 3; */
        if (message.filtered !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.filtered);
        /* optional bool pivot_hidden = 4; */
        if (message.pivotHidden !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.pivotHidden);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.HiddenStateExtentArchive.RowOrColumnState
 */
exports.HiddenStateExtentArchive_RowOrColumnState = new HiddenStateExtentArchive_RowOrColumnState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HiddenStatesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.HiddenStatesArchive", [
            { no: 1, name: "hidden_states_uid", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 2, name: "column_hidden_state_extent", kind: "message", T: () => exports.HiddenStateExtentArchive },
            { no: 3, name: "row_hidden_state_extent", kind: "message", T: () => exports.HiddenStateExtentArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID hidden_states_uid */ 1:
                    message.hiddenStatesUid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.hiddenStatesUid);
                    break;
                case /* TST.HiddenStateExtentArchive column_hidden_state_extent */ 2:
                    message.columnHiddenStateExtent = exports.HiddenStateExtentArchive.internalBinaryRead(reader, reader.uint32(), options, message.columnHiddenStateExtent);
                    break;
                case /* TST.HiddenStateExtentArchive row_hidden_state_extent */ 3:
                    message.rowHiddenStateExtent = exports.HiddenStateExtentArchive.internalBinaryRead(reader, reader.uint32(), options, message.rowHiddenStateExtent);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID hidden_states_uid = 1; */
        if (message.hiddenStatesUid)
            TSPMessages_11.UUID.internalBinaryWrite(message.hiddenStatesUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.HiddenStateExtentArchive column_hidden_state_extent = 2; */
        if (message.columnHiddenStateExtent)
            exports.HiddenStateExtentArchive.internalBinaryWrite(message.columnHiddenStateExtent, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.HiddenStateExtentArchive row_hidden_state_extent = 3; */
        if (message.rowHiddenStateExtent)
            exports.HiddenStateExtentArchive.internalBinaryWrite(message.rowHiddenStateExtent, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.HiddenStatesArchive
 */
exports.HiddenStatesArchive = new HiddenStatesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HiddenStatesOwnerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.HiddenStatesOwnerArchive", [
            { no: 1, name: "owner_uid", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 2, name: "hidden_states", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.HiddenStatesArchive }
        ]);
    }
    create(value) {
        const message = { hiddenStates: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID owner_uid */ 1:
                    message.ownerUid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.ownerUid);
                    break;
                case /* repeated TST.HiddenStatesArchive hidden_states */ 2:
                    message.hiddenStates.push(exports.HiddenStatesArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID owner_uid = 1; */
        if (message.ownerUid)
            TSPMessages_11.UUID.internalBinaryWrite(message.ownerUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TST.HiddenStatesArchive hidden_states = 2; */
        for (let i = 0; i < message.hiddenStates.length; i++)
            exports.HiddenStatesArchive.internalBinaryWrite(message.hiddenStates[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.HiddenStatesOwnerArchive
 */
exports.HiddenStatesOwnerArchive = new HiddenStatesOwnerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpandCollapseStateArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.ExpandCollapseStateArchive", [
            { no: 1, name: "uids_collapsed", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_11.UUID },
            { no: 2, name: "uids_expanded", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_11.UUID },
            { no: 3, name: "dimension", kind: "enum", opt: true, T: () => ["TST.TableDimensionArchive", TableDimensionArchive] }
        ]);
    }
    create(value) {
        const message = { uidsCollapsed: [], uidsExpanded: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.UUID uids_collapsed */ 1:
                    message.uidsCollapsed.push(TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID uids_expanded */ 2:
                    message.uidsExpanded.push(TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TST.TableDimensionArchive dimension */ 3:
                    message.dimension = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.UUID uids_collapsed = 1; */
        for (let i = 0; i < message.uidsCollapsed.length; i++)
            TSPMessages_11.UUID.internalBinaryWrite(message.uidsCollapsed[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID uids_expanded = 2; */
        for (let i = 0; i < message.uidsExpanded.length; i++)
            TSPMessages_11.UUID.internalBinaryWrite(message.uidsExpanded[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.TableDimensionArchive dimension = 3; */
        if (message.dimension !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.dimension);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.ExpandCollapseStateArchive
 */
exports.ExpandCollapseStateArchive = new ExpandCollapseStateArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenAttachmentArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.TokenAttachmentArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSWPArchives_2.UIGraphicalAttachment },
            { no: 2, name: "expressionNode", kind: "message", T: () => TSPMessages_10.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSWP.UIGraphicalAttachment super */ 1:
                    message.super = TSWPArchives_2.UIGraphicalAttachment.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference expressionNode */ 2:
                    message.expressionNode = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.expressionNode);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSWP.UIGraphicalAttachment super = 1; */
        if (message.super)
            TSWPArchives_2.UIGraphicalAttachment.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference expressionNode = 2; */
        if (message.expressionNode)
            TSPMessages_10.Reference.internalBinaryWrite(message.expressionNode, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.TokenAttachmentArchive
 */
exports.TokenAttachmentArchive = new TokenAttachmentArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormulaArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.FormulaArchive", [
            { no: 1, name: "expressionTree", kind: "message", T: () => TSPMessages_10.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference expressionTree */ 1:
                    message.expressionTree = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.expressionTree);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference expressionTree = 1; */
        if (message.expressionTree)
            TSPMessages_10.Reference.internalBinaryWrite(message.expressionTree, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.FormulaArchive
 */
exports.FormulaArchive = new FormulaArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpressionNodeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.ExpressionNodeArchive", [
            { no: 1, name: "children", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_10.Reference },
            { no: 2, name: "first_index", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "last_index", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value) {
        const message = { children: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.Reference children */ 1:
                    message.children.push(TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint64 first_index */ 2:
                    message.firstIndex = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 last_index */ 3:
                    message.lastIndex = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.Reference children = 1; */
        for (let i = 0; i < message.children.length; i++)
            TSPMessages_10.Reference.internalBinaryWrite(message.children[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint64 first_index = 2; */
        if (message.firstIndex !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint64(message.firstIndex);
        /* optional uint64 last_index = 3; */
        if (message.lastIndex !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint64(message.lastIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.ExpressionNodeArchive
 */
exports.ExpressionNodeArchive = new ExpressionNodeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BooleanNodeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.BooleanNodeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.ExpressionNodeArchive },
            { no: 2, name: "value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { value: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.ExpressionNodeArchive super */ 1:
                    message.super = exports.ExpressionNodeArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* bool value */ 2:
                    message.value = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.ExpressionNodeArchive super = 1; */
        if (message.super)
            exports.ExpressionNodeArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool value = 2; */
        if (message.value !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.BooleanNodeArchive
 */
exports.BooleanNodeArchive = new BooleanNodeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NumberNodeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.NumberNodeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.ExpressionNodeArchive },
            { no: 2, name: "number", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "decimal_low", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "decimal_high", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.ExpressionNodeArchive super */ 1:
                    message.super = exports.ExpressionNodeArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional double number */ 2:
                    message.number = reader.double();
                    break;
                case /* optional uint64 decimal_low */ 3:
                    message.decimalLow = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 decimal_high */ 4:
                    message.decimalHigh = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.ExpressionNodeArchive super = 1; */
        if (message.super)
            exports.ExpressionNodeArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional double number = 2; */
        if (message.number !== undefined)
            writer.tag(2, runtime_1.WireType.Bit64).double(message.number);
        /* optional uint64 decimal_low = 3; */
        if (message.decimalLow !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint64(message.decimalLow);
        /* optional uint64 decimal_high = 4; */
        if (message.decimalHigh !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint64(message.decimalHigh);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.NumberNodeArchive
 */
exports.NumberNodeArchive = new NumberNodeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StringNodeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.StringNodeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.ExpressionNodeArchive },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { value: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.ExpressionNodeArchive super */ 1:
                    message.super = exports.ExpressionNodeArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.ExpressionNodeArchive super = 1; */
        if (message.super)
            exports.ExpressionNodeArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.StringNodeArchive
 */
exports.StringNodeArchive = new StringNodeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IdentifierNodeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.IdentifierNodeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.ExpressionNodeArchive },
            { no: 2, name: "identifier", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "symbol", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.ExpressionNodeArchive super */ 1:
                    message.super = exports.ExpressionNodeArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional string identifier */ 2:
                    message.identifier = reader.string();
                    break;
                case /* optional uint32 symbol */ 3:
                    message.symbol = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.ExpressionNodeArchive super = 1; */
        if (message.super)
            exports.ExpressionNodeArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string identifier = 2; */
        if (message.identifier !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.identifier);
        /* optional uint32 symbol = 3; */
        if (message.symbol !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.symbol);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.IdentifierNodeArchive
 */
exports.IdentifierNodeArchive = new IdentifierNodeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ArrayNodeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.ArrayNodeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.ExpressionNodeArchive },
            { no: 2, name: "columns", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "rows", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.ExpressionNodeArchive super */ 1:
                    message.super = exports.ExpressionNodeArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional uint32 columns */ 2:
                    message.columns = reader.uint32();
                    break;
                case /* optional uint32 rows */ 3:
                    message.rows = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.ExpressionNodeArchive super = 1; */
        if (message.super)
            exports.ExpressionNodeArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 columns = 2; */
        if (message.columns !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.columns);
        /* optional uint32 rows = 3; */
        if (message.rows !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.rows);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.ArrayNodeArchive
 */
exports.ArrayNodeArchive = new ArrayNodeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListNodeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.ListNodeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.ExpressionNodeArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.ExpressionNodeArchive super */ 1:
                    message.super = exports.ExpressionNodeArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.ExpressionNodeArchive super = 1; */
        if (message.super)
            exports.ExpressionNodeArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.ListNodeArchive
 */
exports.ListNodeArchive = new ListNodeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OperatorNodeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.OperatorNodeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.ExpressionNodeArchive },
            { no: 2, name: "operatorChar", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { operatorChar: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.ExpressionNodeArchive super */ 1:
                    message.super = exports.ExpressionNodeArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* uint32 operatorChar */ 2:
                    message.operatorChar = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.ExpressionNodeArchive super = 1; */
        if (message.super)
            exports.ExpressionNodeArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 operatorChar = 2; */
        if (message.operatorChar !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.operatorChar);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.OperatorNodeArchive
 */
exports.OperatorNodeArchive = new OperatorNodeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PostfixOperatorNodeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.PostfixOperatorNodeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.OperatorNodeArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.OperatorNodeArchive super */ 1:
                    message.super = exports.OperatorNodeArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.OperatorNodeArchive super = 1; */
        if (message.super)
            exports.OperatorNodeArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.PostfixOperatorNodeArchive
 */
exports.PostfixOperatorNodeArchive = new PostfixOperatorNodeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PrefixOperatorNodeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.PrefixOperatorNodeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.OperatorNodeArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.OperatorNodeArchive super */ 1:
                    message.super = exports.OperatorNodeArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.OperatorNodeArchive super = 1; */
        if (message.super)
            exports.OperatorNodeArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.PrefixOperatorNodeArchive
 */
exports.PrefixOperatorNodeArchive = new PrefixOperatorNodeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FunctionNodeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.FunctionNodeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.ExpressionNodeArchive },
            { no: 2, name: "functionIndex", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "invalidFunctionName", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { functionIndex: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.ExpressionNodeArchive super */ 1:
                    message.super = exports.ExpressionNodeArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* uint32 functionIndex */ 2:
                    message.functionIndex = reader.uint32();
                    break;
                case /* optional string invalidFunctionName */ 3:
                    message.invalidFunctionName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.ExpressionNodeArchive super = 1; */
        if (message.super)
            exports.ExpressionNodeArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 functionIndex = 2; */
        if (message.functionIndex !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.functionIndex);
        /* optional string invalidFunctionName = 3; */
        if (message.invalidFunctionName !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.invalidFunctionName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.FunctionNodeArchive
 */
exports.FunctionNodeArchive = new FunctionNodeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FunctionEndNodeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.FunctionEndNodeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.ExpressionNodeArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.ExpressionNodeArchive super */ 1:
                    message.super = exports.ExpressionNodeArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.ExpressionNodeArchive super = 1; */
        if (message.super)
            exports.ExpressionNodeArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.FunctionEndNodeArchive
 */
exports.FunctionEndNodeArchive = new FunctionEndNodeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DateNodeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.DateNodeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.ExpressionNodeArchive },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "format", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { value: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.ExpressionNodeArchive super */ 1:
                    message.super = exports.ExpressionNodeArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                case /* optional string format */ 3:
                    message.format = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.ExpressionNodeArchive super = 1; */
        if (message.super)
            exports.ExpressionNodeArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.value);
        /* optional string format = 3; */
        if (message.format !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.format);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.DateNodeArchive
 */
exports.DateNodeArchive = new DateNodeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReferenceNodeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.ReferenceNodeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.ExpressionNodeArchive },
            { no: 2, name: "rangeReference", kind: "message", T: () => TSCEArchives_4.RangeReferenceArchive },
            { no: 3, name: "preserve_flags", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "hostTableID", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "host_cell_ref", kind: "message", T: () => TSCEArchives_13.CellReferenceArchive },
            { no: 5, name: "table_uid", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 6, name: "range_top_left", kind: "message", T: () => TSPMessages_3.UUIDCoordArchive },
            { no: 7, name: "range_bottom_right", kind: "message", T: () => TSPMessages_3.UUIDCoordArchive },
            { no: 8, name: "category_ref", kind: "message", T: () => TSCEArchives_8.CategoryReferenceArchive },
            { no: 9, name: "uid_range_rect", kind: "message", T: () => TSPMessages_8.UUIDRectArchive }
        ]);
    }
    create(value) {
        const message = { preserveFlags: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.ExpressionNodeArchive super */ 1:
                    message.super = exports.ExpressionNodeArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSCE.RangeReferenceArchive rangeReference */ 2:
                    message.rangeReference = TSCEArchives_4.RangeReferenceArchive.internalBinaryRead(reader, reader.uint32(), options, message.rangeReference);
                    break;
                case /* uint32 preserve_flags */ 3:
                    message.preserveFlags = reader.uint32();
                    break;
                case /* optional string hostTableID */ 4:
                    message.hostTableID = reader.string();
                    break;
                case /* optional TSCE.CellReferenceArchive host_cell_ref */ 10:
                    message.hostCellRef = TSCEArchives_13.CellReferenceArchive.internalBinaryRead(reader, reader.uint32(), options, message.hostCellRef);
                    break;
                case /* optional TSP.UUID table_uid */ 5:
                    message.tableUid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.tableUid);
                    break;
                case /* optional TSP.UUIDCoordArchive range_top_left */ 6:
                    message.rangeTopLeft = TSPMessages_3.UUIDCoordArchive.internalBinaryRead(reader, reader.uint32(), options, message.rangeTopLeft);
                    break;
                case /* optional TSP.UUIDCoordArchive range_bottom_right */ 7:
                    message.rangeBottomRight = TSPMessages_3.UUIDCoordArchive.internalBinaryRead(reader, reader.uint32(), options, message.rangeBottomRight);
                    break;
                case /* optional TSCE.CategoryReferenceArchive category_ref */ 8:
                    message.categoryRef = TSCEArchives_8.CategoryReferenceArchive.internalBinaryRead(reader, reader.uint32(), options, message.categoryRef);
                    break;
                case /* optional TSP.UUIDRectArchive uid_range_rect */ 9:
                    message.uidRangeRect = TSPMessages_8.UUIDRectArchive.internalBinaryRead(reader, reader.uint32(), options, message.uidRangeRect);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.ExpressionNodeArchive super = 1; */
        if (message.super)
            exports.ExpressionNodeArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.RangeReferenceArchive rangeReference = 2; */
        if (message.rangeReference)
            TSCEArchives_4.RangeReferenceArchive.internalBinaryWrite(message.rangeReference, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 preserve_flags = 3; */
        if (message.preserveFlags !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.preserveFlags);
        /* optional string hostTableID = 4; */
        if (message.hostTableID !== undefined)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.hostTableID);
        /* optional TSCE.CellReferenceArchive host_cell_ref = 10; */
        if (message.hostCellRef)
            TSCEArchives_13.CellReferenceArchive.internalBinaryWrite(message.hostCellRef, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID table_uid = 5; */
        if (message.tableUid)
            TSPMessages_11.UUID.internalBinaryWrite(message.tableUid, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDCoordArchive range_top_left = 6; */
        if (message.rangeTopLeft)
            TSPMessages_3.UUIDCoordArchive.internalBinaryWrite(message.rangeTopLeft, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDCoordArchive range_bottom_right = 7; */
        if (message.rangeBottomRight)
            TSPMessages_3.UUIDCoordArchive.internalBinaryWrite(message.rangeBottomRight, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.CategoryReferenceArchive category_ref = 8; */
        if (message.categoryRef)
            TSCEArchives_8.CategoryReferenceArchive.internalBinaryWrite(message.categoryRef, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDRectArchive uid_range_rect = 9; */
        if (message.uidRangeRect)
            TSPMessages_8.UUIDRectArchive.internalBinaryWrite(message.uidRangeRect, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.ReferenceNodeArchive
 */
exports.ReferenceNodeArchive = new ReferenceNodeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DurationNodeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.DurationNodeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.ExpressionNodeArchive },
            { no: 2, name: "timeinterval", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "smallest", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "largest", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "style", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { timeinterval: 0, smallest: 0, largest: 0, style: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.ExpressionNodeArchive super */ 1:
                    message.super = exports.ExpressionNodeArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* double timeinterval */ 2:
                    message.timeinterval = reader.double();
                    break;
                case /* uint32 smallest */ 3:
                    message.smallest = reader.uint32();
                    break;
                case /* uint32 largest */ 4:
                    message.largest = reader.uint32();
                    break;
                case /* uint32 style */ 5:
                    message.style = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.ExpressionNodeArchive super = 1; */
        if (message.super)
            exports.ExpressionNodeArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* double timeinterval = 2; */
        if (message.timeinterval !== 0)
            writer.tag(2, runtime_1.WireType.Bit64).double(message.timeinterval);
        /* uint32 smallest = 3; */
        if (message.smallest !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.smallest);
        /* uint32 largest = 4; */
        if (message.largest !== 0)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.largest);
        /* uint32 style = 5; */
        if (message.style !== 0)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.style);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.DurationNodeArchive
 */
exports.DurationNodeArchive = new DurationNodeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ArgumentPlaceholderNodeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.ArgumentPlaceholderNodeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.ExpressionNodeArchive },
            { no: 2, name: "functionIndex", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "argumentIndex", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "mode", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.ExpressionNodeArchive super */ 1:
                    message.super = exports.ExpressionNodeArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional uint32 functionIndex */ 2:
                    message.functionIndex = reader.uint32();
                    break;
                case /* optional uint32 argumentIndex */ 3:
                    message.argumentIndex = reader.uint32();
                    break;
                case /* optional uint32 mode */ 4:
                    message.mode = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.ExpressionNodeArchive super = 1; */
        if (message.super)
            exports.ExpressionNodeArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 functionIndex = 2; */
        if (message.functionIndex !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.functionIndex);
        /* optional uint32 argumentIndex = 3; */
        if (message.argumentIndex !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.argumentIndex);
        /* optional uint32 mode = 4; */
        if (message.mode !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.mode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.ArgumentPlaceholderNodeArchive
 */
exports.ArgumentPlaceholderNodeArchive = new ArgumentPlaceholderNodeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EmptyExpressionNodeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.EmptyExpressionNodeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.ExpressionNodeArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.ExpressionNodeArchive super */ 1:
                    message.super = exports.ExpressionNodeArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.ExpressionNodeArchive super = 1; */
        if (message.super)
            exports.ExpressionNodeArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.EmptyExpressionNodeArchive
 */
exports.EmptyExpressionNodeArchive = new EmptyExpressionNodeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LetNodeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.LetNodeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.ExpressionNodeArchive },
            { no: 2, name: "whitespace_after_let", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "whitespace_after_identifier", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "whitespace_after_equals", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "whitespace_after_delimiter", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.ExpressionNodeArchive super */ 1:
                    message.super = exports.ExpressionNodeArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional string whitespace_after_let */ 2:
                    message.whitespaceAfterLet = reader.string();
                    break;
                case /* optional string whitespace_after_identifier */ 3:
                    message.whitespaceAfterIdentifier = reader.string();
                    break;
                case /* optional string whitespace_after_equals */ 4:
                    message.whitespaceAfterEquals = reader.string();
                    break;
                case /* optional string whitespace_after_delimiter */ 5:
                    message.whitespaceAfterDelimiter = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.ExpressionNodeArchive super = 1; */
        if (message.super)
            exports.ExpressionNodeArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string whitespace_after_let = 2; */
        if (message.whitespaceAfterLet !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.whitespaceAfterLet);
        /* optional string whitespace_after_identifier = 3; */
        if (message.whitespaceAfterIdentifier !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.whitespaceAfterIdentifier);
        /* optional string whitespace_after_equals = 4; */
        if (message.whitespaceAfterEquals !== undefined)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.whitespaceAfterEquals);
        /* optional string whitespace_after_delimiter = 5; */
        if (message.whitespaceAfterDelimiter !== undefined)
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.whitespaceAfterDelimiter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.LetNodeArchive
 */
exports.LetNodeArchive = new LetNodeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InNodeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.InNodeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.ExpressionNodeArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.ExpressionNodeArchive super */ 1:
                    message.super = exports.ExpressionNodeArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.ExpressionNodeArchive super = 1; */
        if (message.super)
            exports.ExpressionNodeArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.InNodeArchive
 */
exports.InNodeArchive = new InNodeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VariableNodeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.VariableNodeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.ExpressionNodeArchive },
            { no: 2, name: "identifier", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "symbol", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { identifier: "", symbol: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.ExpressionNodeArchive super */ 1:
                    message.super = exports.ExpressionNodeArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* string identifier */ 2:
                    message.identifier = reader.string();
                    break;
                case /* uint32 symbol */ 3:
                    message.symbol = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.ExpressionNodeArchive super = 1; */
        if (message.super)
            exports.ExpressionNodeArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string identifier = 2; */
        if (message.identifier !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.identifier);
        /* uint32 symbol = 3; */
        if (message.symbol !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.symbol);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.VariableNodeArchive
 */
exports.VariableNodeArchive = new VariableNodeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LayoutHintArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.LayoutHintArchive", [
            { no: 1, name: "isValid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "cellRange", kind: "message", T: () => exports.CellRange },
            { no: 3, name: "hintID", kind: "message", T: () => exports.CellID },
            { no: 4, name: "maximumSize", kind: "message", T: () => TSPMessages_2.Size },
            { no: 5, name: "partitionPosition", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "horizontal", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "effectiveSize", kind: "message", T: () => TSPMessages_2.Size },
            { no: 8, name: "partitioningPass", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { isValid: false, partitionPosition: 0, horizontal: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool isValid */ 1:
                    message.isValid = reader.bool();
                    break;
                case /* optional TST.CellRange cellRange */ 2:
                    message.cellRange = exports.CellRange.internalBinaryRead(reader, reader.uint32(), options, message.cellRange);
                    break;
                case /* optional TST.CellID hintID */ 3:
                    message.hintID = exports.CellID.internalBinaryRead(reader, reader.uint32(), options, message.hintID);
                    break;
                case /* TSP.Size maximumSize */ 4:
                    message.maximumSize = TSPMessages_2.Size.internalBinaryRead(reader, reader.uint32(), options, message.maximumSize);
                    break;
                case /* uint32 partitionPosition */ 5:
                    message.partitionPosition = reader.uint32();
                    break;
                case /* bool horizontal */ 6:
                    message.horizontal = reader.bool();
                    break;
                case /* optional TSP.Size effectiveSize */ 7:
                    message.effectiveSize = TSPMessages_2.Size.internalBinaryRead(reader, reader.uint32(), options, message.effectiveSize);
                    break;
                case /* optional uint32 partitioningPass */ 8:
                    message.partitioningPass = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool isValid = 1; */
        if (message.isValid !== false)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.isValid);
        /* optional TST.CellRange cellRange = 2; */
        if (message.cellRange)
            exports.CellRange.internalBinaryWrite(message.cellRange, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.CellID hintID = 3; */
        if (message.hintID)
            exports.CellID.internalBinaryWrite(message.hintID, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Size maximumSize = 4; */
        if (message.maximumSize)
            TSPMessages_2.Size.internalBinaryWrite(message.maximumSize, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 partitionPosition = 5; */
        if (message.partitionPosition !== 0)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.partitionPosition);
        /* bool horizontal = 6; */
        if (message.horizontal !== false)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.horizontal);
        /* optional TSP.Size effectiveSize = 7; */
        if (message.effectiveSize)
            TSPMessages_2.Size.internalBinaryWrite(message.effectiveSize, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 partitioningPass = 8; */
        if (message.partitioningPass !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).uint32(message.partitioningPass);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.LayoutHintArchive
 */
exports.LayoutHintArchive = new LayoutHintArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CompletionTokenAttachmentArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CompletionTokenAttachmentArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TokenAttachmentArchive },
            { no: 2, name: "completionText", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "caretPosition", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "prefixStart", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TokenAttachmentArchive super */ 1:
                    message.super = exports.TokenAttachmentArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional string completionText */ 2:
                    message.completionText = reader.string();
                    break;
                case /* optional uint32 caretPosition */ 3:
                    message.caretPosition = reader.uint32();
                    break;
                case /* optional uint32 prefixStart */ 4:
                    message.prefixStart = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TokenAttachmentArchive super = 1; */
        if (message.super)
            exports.TokenAttachmentArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string completionText = 2; */
        if (message.completionText !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.completionText);
        /* optional uint32 caretPosition = 3; */
        if (message.caretPosition !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.caretPosition);
        /* optional uint32 prefixStart = 4; */
        if (message.prefixStart !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.prefixStart);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CompletionTokenAttachmentArchive
 */
exports.CompletionTokenAttachmentArchive = new CompletionTokenAttachmentArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HiddenStateFormulaOwnerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.HiddenStateFormulaOwnerArchive", [
            { no: 1, name: "owner_id", kind: "message", T: () => TSPMessages_7.CFUUIDArchive },
            { no: 2, name: "threshold_value", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSCEArchives_18.CellValueArchive },
            { no: 3, name: "needs_to_update_filter_set_for_import", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { thresholdValue: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.CFUUIDArchive owner_id */ 1:
                    message.ownerId = TSPMessages_7.CFUUIDArchive.internalBinaryRead(reader, reader.uint32(), options, message.ownerId);
                    break;
                case /* repeated TSCE.CellValueArchive threshold_value */ 2:
                    message.thresholdValue.push(TSCEArchives_18.CellValueArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool needs_to_update_filter_set_for_import */ 3:
                    message.needsToUpdateFilterSetForImport = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.CFUUIDArchive owner_id = 1; */
        if (message.ownerId)
            TSPMessages_7.CFUUIDArchive.internalBinaryWrite(message.ownerId, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.CellValueArchive threshold_value = 2; */
        for (let i = 0; i < message.thresholdValue.length; i++)
            TSCEArchives_18.CellValueArchive.internalBinaryWrite(message.thresholdValue[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool needs_to_update_filter_set_for_import = 3; */
        if (message.needsToUpdateFilterSetForImport !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.needsToUpdateFilterSetForImport);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.HiddenStateFormulaOwnerArchive
 */
exports.HiddenStateFormulaOwnerArchive = new HiddenStateFormulaOwnerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormulaStoreArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.FormulaStoreArchive", [
            { no: 2, name: "next_formula_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "formulas", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.FormulaStoreArchive_FormulaStorePair }
        ]);
    }
    create(value) {
        const message = { nextFormulaIndex: 0, formulas: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 next_formula_index */ 2:
                    message.nextFormulaIndex = reader.uint32();
                    break;
                case /* repeated TST.FormulaStoreArchive.FormulaStorePair formulas */ 3:
                    message.formulas.push(exports.FormulaStoreArchive_FormulaStorePair.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 next_formula_index = 2; */
        if (message.nextFormulaIndex !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.nextFormulaIndex);
        /* repeated TST.FormulaStoreArchive.FormulaStorePair formulas = 3; */
        for (let i = 0; i < message.formulas.length; i++)
            exports.FormulaStoreArchive_FormulaStorePair.internalBinaryWrite(message.formulas[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.FormulaStoreArchive
 */
exports.FormulaStoreArchive = new FormulaStoreArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormulaStoreArchive_FormulaStorePair$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.FormulaStoreArchive.FormulaStorePair", [
            { no: 1, name: "formula_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "formula", kind: "message", T: () => TSCEArchives_12.FormulaArchive }
        ]);
    }
    create(value) {
        const message = { formulaIndex: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 formula_index */ 1:
                    message.formulaIndex = reader.uint32();
                    break;
                case /* TSCE.FormulaArchive formula */ 2:
                    message.formula = TSCEArchives_12.FormulaArchive.internalBinaryRead(reader, reader.uint32(), options, message.formula);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 formula_index = 1; */
        if (message.formulaIndex !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.formulaIndex);
        /* TSCE.FormulaArchive formula = 2; */
        if (message.formula)
            TSCEArchives_12.FormulaArchive.internalBinaryWrite(message.formula, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.FormulaStoreArchive.FormulaStorePair
 */
exports.FormulaStoreArchive_FormulaStorePair = new FormulaStoreArchive_FormulaStorePair$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MergeOperationArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.MergeOperationArchive", [
            { no: 1, name: "merge_type", kind: "enum", T: () => ["TST.MergeActionArchive", MergeActionArchive] },
            { no: 2, name: "merge_ranges", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_8.UUIDRectArchive },
            { no: 3, name: "merge_formulas", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSCEArchives_12.FormulaArchive },
            { no: 4, name: "merge_formula_indexes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { mergeType: 0, mergeRanges: [], mergeFormulas: [], mergeFormulaIndexes: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.MergeActionArchive merge_type */ 1:
                    message.mergeType = reader.int32();
                    break;
                case /* repeated TSP.UUIDRectArchive merge_ranges */ 2:
                    message.mergeRanges.push(TSPMessages_8.UUIDRectArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSCE.FormulaArchive merge_formulas */ 3:
                    message.mergeFormulas.push(TSCEArchives_12.FormulaArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 merge_formula_indexes */ 4:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.mergeFormulaIndexes.push(reader.uint32());
                    else
                        message.mergeFormulaIndexes.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.MergeActionArchive merge_type = 1; */
        if (message.mergeType !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.mergeType);
        /* repeated TSP.UUIDRectArchive merge_ranges = 2; */
        for (let i = 0; i < message.mergeRanges.length; i++)
            TSPMessages_8.UUIDRectArchive.internalBinaryWrite(message.mergeRanges[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.FormulaArchive merge_formulas = 3; */
        for (let i = 0; i < message.mergeFormulas.length; i++)
            TSCEArchives_12.FormulaArchive.internalBinaryWrite(message.mergeFormulas[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 merge_formula_indexes = 4; */
        for (let i = 0; i < message.mergeFormulaIndexes.length; i++)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.mergeFormulaIndexes[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.MergeOperationArchive
 */
exports.MergeOperationArchive = new MergeOperationArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MergeOwnerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.MergeOwnerArchive", [
            { no: 1, name: "owner_id", kind: "message", T: () => TSPMessages_7.CFUUIDArchive },
            { no: 2, name: "formula_store", kind: "message", T: () => exports.FormulaStoreArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.CFUUIDArchive owner_id */ 1:
                    message.ownerId = TSPMessages_7.CFUUIDArchive.internalBinaryRead(reader, reader.uint32(), options, message.ownerId);
                    break;
                case /* optional TST.FormulaStoreArchive formula_store */ 2:
                    message.formulaStore = exports.FormulaStoreArchive.internalBinaryRead(reader, reader.uint32(), options, message.formulaStore);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.CFUUIDArchive owner_id = 1; */
        if (message.ownerId)
            TSPMessages_7.CFUUIDArchive.internalBinaryWrite(message.ownerId, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.FormulaStoreArchive formula_store = 2; */
        if (message.formulaStore)
            exports.FormulaStoreArchive.internalBinaryWrite(message.formulaStore, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.MergeOwnerArchive
 */
exports.MergeOwnerArchive = new MergeOwnerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PencilAnnotationArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.PencilAnnotationArchive", [
            { no: 1, name: "table_info", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 2, name: "pencil_annotation_storage", kind: "message", T: () => TSPMessages_10.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference table_info */ 1:
                    message.tableInfo = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.tableInfo);
                    break;
                case /* optional TSP.Reference pencil_annotation_storage */ 2:
                    message.pencilAnnotationStorage = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.pencilAnnotationStorage);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference table_info = 1; */
        if (message.tableInfo)
            TSPMessages_10.Reference.internalBinaryWrite(message.tableInfo, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference pencil_annotation_storage = 2; */
        if (message.pencilAnnotationStorage)
            TSPMessages_10.Reference.internalBinaryWrite(message.pencilAnnotationStorage, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.PencilAnnotationArchive
 */
exports.PencilAnnotationArchive = new PencilAnnotationArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PencilAnnotationOwnerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.PencilAnnotationOwnerArchive", [
            { no: 1, name: "owner_id", kind: "message", T: () => TSPMessages_7.CFUUIDArchive },
            { no: 2, name: "formula_store", kind: "message", T: () => exports.FormulaStoreArchive },
            { no: 3, name: "annotations", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_10.Reference }
        ]);
    }
    create(value) {
        const message = { annotations: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.CFUUIDArchive owner_id */ 1:
                    message.ownerId = TSPMessages_7.CFUUIDArchive.internalBinaryRead(reader, reader.uint32(), options, message.ownerId);
                    break;
                case /* optional TST.FormulaStoreArchive formula_store */ 2:
                    message.formulaStore = exports.FormulaStoreArchive.internalBinaryRead(reader, reader.uint32(), options, message.formulaStore);
                    break;
                case /* repeated TSP.Reference annotations */ 3:
                    message.annotations.push(TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.CFUUIDArchive owner_id = 1; */
        if (message.ownerId)
            TSPMessages_7.CFUUIDArchive.internalBinaryWrite(message.ownerId, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.FormulaStoreArchive formula_store = 2; */
        if (message.formulaStore)
            exports.FormulaStoreArchive.internalBinaryWrite(message.formulaStore, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference annotations = 3; */
        for (let i = 0; i < message.annotations.length; i++)
            TSPMessages_10.Reference.internalBinaryWrite(message.annotations[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.PencilAnnotationOwnerArchive
 */
exports.PencilAnnotationOwnerArchive = new PencilAnnotationOwnerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccumulatorArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.AccumulatorArchive", [
            { no: 1, name: "bool_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "number_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "date_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "duration_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "string_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "min_value", kind: "message", T: () => TSCEArchives_18.CellValueArchive },
            { no: 7, name: "max_value", kind: "message", T: () => TSCEArchives_18.CellValueArchive },
            { no: 8, name: "number_total_value", kind: "message", T: () => TSCEArchives_18.CellValueArchive },
            { no: 9, name: "first_date_seen", kind: "message", T: () => TSCEArchives_18.CellValueArchive },
            { no: 10, name: "total_secs_since_ref_date", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 11, name: "secs_to_add", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 12, name: "bool_true_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "error_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "is_circular_ref", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "product_value", kind: "message", T: () => TSCEArchives_18.CellValueArchive },
            { no: 16, name: "no_content_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 bool_count */ 1:
                    message.boolCount = reader.uint32();
                    break;
                case /* optional uint32 number_count */ 2:
                    message.numberCount = reader.uint32();
                    break;
                case /* optional uint32 date_count */ 3:
                    message.dateCount = reader.uint32();
                    break;
                case /* optional uint32 duration_count */ 4:
                    message.durationCount = reader.uint32();
                    break;
                case /* optional uint32 string_count */ 5:
                    message.stringCount = reader.uint32();
                    break;
                case /* TSCE.CellValueArchive min_value */ 6:
                    message.minValue = TSCEArchives_18.CellValueArchive.internalBinaryRead(reader, reader.uint32(), options, message.minValue);
                    break;
                case /* TSCE.CellValueArchive max_value */ 7:
                    message.maxValue = TSCEArchives_18.CellValueArchive.internalBinaryRead(reader, reader.uint32(), options, message.maxValue);
                    break;
                case /* TSCE.CellValueArchive number_total_value */ 8:
                    message.numberTotalValue = TSCEArchives_18.CellValueArchive.internalBinaryRead(reader, reader.uint32(), options, message.numberTotalValue);
                    break;
                case /* optional TSCE.CellValueArchive first_date_seen */ 9:
                    message.firstDateSeen = TSCEArchives_18.CellValueArchive.internalBinaryRead(reader, reader.uint32(), options, message.firstDateSeen);
                    break;
                case /* optional double total_secs_since_ref_date */ 10:
                    message.totalSecsSinceRefDate = reader.double();
                    break;
                case /* optional double secs_to_add */ 11:
                    message.secsToAdd = reader.double();
                    break;
                case /* optional uint32 bool_true_count */ 12:
                    message.boolTrueCount = reader.uint32();
                    break;
                case /* optional uint32 error_count */ 13:
                    message.errorCount = reader.uint32();
                    break;
                case /* optional bool is_circular_ref */ 14:
                    message.isCircularRef = reader.bool();
                    break;
                case /* optional TSCE.CellValueArchive product_value */ 15:
                    message.productValue = TSCEArchives_18.CellValueArchive.internalBinaryRead(reader, reader.uint32(), options, message.productValue);
                    break;
                case /* optional uint32 no_content_count */ 16:
                    message.noContentCount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional uint32 bool_count = 1; */
        if (message.boolCount !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.boolCount);
        /* optional uint32 number_count = 2; */
        if (message.numberCount !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.numberCount);
        /* optional uint32 date_count = 3; */
        if (message.dateCount !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.dateCount);
        /* optional uint32 duration_count = 4; */
        if (message.durationCount !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.durationCount);
        /* optional uint32 string_count = 5; */
        if (message.stringCount !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.stringCount);
        /* TSCE.CellValueArchive min_value = 6; */
        if (message.minValue)
            TSCEArchives_18.CellValueArchive.internalBinaryWrite(message.minValue, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSCE.CellValueArchive max_value = 7; */
        if (message.maxValue)
            TSCEArchives_18.CellValueArchive.internalBinaryWrite(message.maxValue, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSCE.CellValueArchive number_total_value = 8; */
        if (message.numberTotalValue)
            TSCEArchives_18.CellValueArchive.internalBinaryWrite(message.numberTotalValue, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.CellValueArchive first_date_seen = 9; */
        if (message.firstDateSeen)
            TSCEArchives_18.CellValueArchive.internalBinaryWrite(message.firstDateSeen, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional double total_secs_since_ref_date = 10; */
        if (message.totalSecsSinceRefDate !== undefined)
            writer.tag(10, runtime_1.WireType.Bit64).double(message.totalSecsSinceRefDate);
        /* optional double secs_to_add = 11; */
        if (message.secsToAdd !== undefined)
            writer.tag(11, runtime_1.WireType.Bit64).double(message.secsToAdd);
        /* optional uint32 bool_true_count = 12; */
        if (message.boolTrueCount !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).uint32(message.boolTrueCount);
        /* optional uint32 error_count = 13; */
        if (message.errorCount !== undefined)
            writer.tag(13, runtime_1.WireType.Varint).uint32(message.errorCount);
        /* optional bool is_circular_ref = 14; */
        if (message.isCircularRef !== undefined)
            writer.tag(14, runtime_1.WireType.Varint).bool(message.isCircularRef);
        /* optional TSCE.CellValueArchive product_value = 15; */
        if (message.productValue)
            TSCEArchives_18.CellValueArchive.internalBinaryWrite(message.productValue, writer.tag(15, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 no_content_count = 16; */
        if (message.noContentCount !== undefined)
            writer.tag(16, runtime_1.WireType.Varint).uint32(message.noContentCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.AccumulatorArchive
 */
exports.AccumulatorArchive = new AccumulatorArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupColumnArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.GroupColumnArchive", [
            { no: 1, name: "column_uid", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 2, name: "grouping_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "grouping_functor", kind: "message", T: () => TSCEArchives_3.FunctorArchive },
            { no: 4, name: "grouping_column_uid", kind: "message", T: () => TSPMessages_11.UUID }
        ]);
    }
    create(value) {
        const message = { groupingType: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID column_uid */ 1:
                    message.columnUid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.columnUid);
                    break;
                case /* uint32 grouping_type */ 2:
                    message.groupingType = reader.uint32();
                    break;
                case /* optional TSCE.FunctorArchive grouping_functor */ 3:
                    message.groupingFunctor = TSCEArchives_3.FunctorArchive.internalBinaryRead(reader, reader.uint32(), options, message.groupingFunctor);
                    break;
                case /* optional TSP.UUID grouping_column_uid */ 4:
                    message.groupingColumnUid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.groupingColumnUid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID column_uid = 1; */
        if (message.columnUid)
            TSPMessages_11.UUID.internalBinaryWrite(message.columnUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 grouping_type = 2; */
        if (message.groupingType !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.groupingType);
        /* optional TSCE.FunctorArchive grouping_functor = 3; */
        if (message.groupingFunctor)
            TSCEArchives_3.FunctorArchive.internalBinaryWrite(message.groupingFunctor, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID grouping_column_uid = 4; */
        if (message.groupingColumnUid)
            TSPMessages_11.UUID.internalBinaryWrite(message.groupingColumnUid, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.GroupColumnArchive
 */
exports.GroupColumnArchive = new GroupColumnArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupColumnListArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.GroupColumnListArchive", [
            { no: 1, name: "group_column", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.GroupColumnArchive }
        ]);
    }
    create(value) {
        const message = { groupColumn: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TST.GroupColumnArchive group_column */ 1:
                    message.groupColumn.push(exports.GroupColumnArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TST.GroupColumnArchive group_column = 1; */
        for (let i = 0; i < message.groupColumn.length; i++)
            exports.GroupColumnArchive.internalBinaryWrite(message.groupColumn[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.GroupColumnListArchive
 */
exports.GroupColumnListArchive = new GroupColumnListArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ColumnAggregateArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.ColumnAggregateArchive", [
            { no: 1, name: "column_uid", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 2, name: "level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "agg_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "show_as_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "column_aggregate_uid", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 6, name: "running_total_group_column_uid", kind: "message", T: () => TSPMessages_11.UUID }
        ]);
    }
    create(value) {
        const message = { level: 0, aggType: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID column_uid */ 1:
                    message.columnUid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.columnUid);
                    break;
                case /* uint32 level */ 2:
                    message.level = reader.uint32();
                    break;
                case /* uint32 agg_type */ 3:
                    message.aggType = reader.uint32();
                    break;
                case /* optional uint32 show_as_type */ 4:
                    message.showAsType = reader.uint32();
                    break;
                case /* optional TSP.UUID column_aggregate_uid */ 5:
                    message.columnAggregateUid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.columnAggregateUid);
                    break;
                case /* optional TSP.UUID running_total_group_column_uid */ 6:
                    message.runningTotalGroupColumnUid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.runningTotalGroupColumnUid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID column_uid = 1; */
        if (message.columnUid)
            TSPMessages_11.UUID.internalBinaryWrite(message.columnUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 level = 2; */
        if (message.level !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.level);
        /* uint32 agg_type = 3; */
        if (message.aggType !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.aggType);
        /* optional uint32 show_as_type = 4; */
        if (message.showAsType !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.showAsType);
        /* optional TSP.UUID column_aggregate_uid = 5; */
        if (message.columnAggregateUid)
            TSPMessages_11.UUID.internalBinaryWrite(message.columnAggregateUid, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID running_total_group_column_uid = 6; */
        if (message.runningTotalGroupColumnUid)
            TSPMessages_11.UUID.internalBinaryWrite(message.runningTotalGroupColumnUid, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.ColumnAggregateArchive
 */
exports.ColumnAggregateArchive = new ColumnAggregateArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ColumnAggregateListArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.ColumnAggregateListArchive", [
            { no: 1, name: "aggregates", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ColumnAggregateArchive }
        ]);
    }
    create(value) {
        const message = { aggregates: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TST.ColumnAggregateArchive aggregates */ 1:
                    message.aggregates.push(exports.ColumnAggregateArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TST.ColumnAggregateArchive aggregates = 1; */
        for (let i = 0; i < message.aggregates.length; i++)
            exports.ColumnAggregateArchive.internalBinaryWrite(message.aggregates[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.ColumnAggregateListArchive
 */
exports.ColumnAggregateListArchive = new ColumnAggregateListArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupByArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.GroupByArchive", [
            { no: 1, name: "group_by_uid", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 2, name: "group_column", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.GroupColumnArchive },
            { no: 3, name: "group_node_root", kind: "message", T: () => exports.GroupByArchive_GroupNodeArchive },
            { no: 4, name: "aggregator", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.GroupByArchive_AggregatorArchive },
            { no: 5, name: "column_agg_type", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ColumnAggregateArchive },
            { no: 6, name: "is_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "indirect_agg_type_change_formula", kind: "message", T: () => TSCEArchives_20.CellCoordinateArchive },
            { no: 8, name: "grouping_columns_formula", kind: "message", T: () => TSCEArchives_20.CellCoordinateArchive },
            { no: 9, name: "aggs_in_group_root_formula", kind: "message", T: () => TSCEArchives_20.CellCoordinateArchive },
            { no: 10, name: "grouping_column_headers_formula", kind: "message", T: () => TSCEArchives_20.CellCoordinateArchive },
            { no: 11, name: "column_order_changed_formula", kind: "message", T: () => TSCEArchives_20.CellCoordinateArchive },
            { no: 12, name: "row_order_changed_formula", kind: "message", T: () => TSCEArchives_20.CellCoordinateArchive },
            { no: 13, name: "row_order_changed_ignoring_recalc_formula", kind: "message", T: () => TSCEArchives_20.CellCoordinateArchive },
            { no: 14, name: "owner_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "row_uid_lookup", kind: "message", T: () => TSCEArchives_19.UidLookupListArchive },
            { no: 16, name: "hidden_states_changed_formula", kind: "message", T: () => TSCEArchives_20.CellCoordinateArchive },
            { no: 17, name: "aggregator_ref", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_10.Reference },
            { no: 18, name: "group_node_root_ref", kind: "message", T: () => TSPMessages_10.Reference }
        ]);
    }
    create(value) {
        const message = { groupColumn: [], aggregator: [], columnAggType: [], isEnabled: false, aggregatorRef: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID group_by_uid */ 1:
                    message.groupByUid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.groupByUid);
                    break;
                case /* repeated TST.GroupColumnArchive group_column */ 2:
                    message.groupColumn.push(exports.GroupColumnArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TST.GroupByArchive.GroupNodeArchive group_node_root */ 3:
                    message.groupNodeRoot = exports.GroupByArchive_GroupNodeArchive.internalBinaryRead(reader, reader.uint32(), options, message.groupNodeRoot);
                    break;
                case /* repeated TST.GroupByArchive.AggregatorArchive aggregator */ 4:
                    message.aggregator.push(exports.GroupByArchive_AggregatorArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TST.ColumnAggregateArchive column_agg_type */ 5:
                    message.columnAggType.push(exports.ColumnAggregateArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool is_enabled */ 6:
                    message.isEnabled = reader.bool();
                    break;
                case /* optional TSCE.CellCoordinateArchive indirect_agg_type_change_formula */ 7:
                    message.indirectAggTypeChangeFormula = TSCEArchives_20.CellCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.indirectAggTypeChangeFormula);
                    break;
                case /* optional TSCE.CellCoordinateArchive grouping_columns_formula */ 8:
                    message.groupingColumnsFormula = TSCEArchives_20.CellCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.groupingColumnsFormula);
                    break;
                case /* optional TSCE.CellCoordinateArchive aggs_in_group_root_formula */ 9:
                    message.aggsInGroupRootFormula = TSCEArchives_20.CellCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.aggsInGroupRootFormula);
                    break;
                case /* optional TSCE.CellCoordinateArchive grouping_column_headers_formula */ 10:
                    message.groupingColumnHeadersFormula = TSCEArchives_20.CellCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.groupingColumnHeadersFormula);
                    break;
                case /* optional TSCE.CellCoordinateArchive column_order_changed_formula */ 11:
                    message.columnOrderChangedFormula = TSCEArchives_20.CellCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.columnOrderChangedFormula);
                    break;
                case /* optional TSCE.CellCoordinateArchive row_order_changed_formula */ 12:
                    message.rowOrderChangedFormula = TSCEArchives_20.CellCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.rowOrderChangedFormula);
                    break;
                case /* optional TSCE.CellCoordinateArchive row_order_changed_ignoring_recalc_formula */ 13:
                    message.rowOrderChangedIgnoringRecalcFormula = TSCEArchives_20.CellCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.rowOrderChangedIgnoringRecalcFormula);
                    break;
                case /* optional int32 owner_index */ 14:
                    message.ownerIndex = reader.int32();
                    break;
                case /* optional TSCE.UidLookupListArchive row_uid_lookup */ 15:
                    message.rowUidLookup = TSCEArchives_19.UidLookupListArchive.internalBinaryRead(reader, reader.uint32(), options, message.rowUidLookup);
                    break;
                case /* optional TSCE.CellCoordinateArchive hidden_states_changed_formula */ 16:
                    message.hiddenStatesChangedFormula = TSCEArchives_20.CellCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.hiddenStatesChangedFormula);
                    break;
                case /* repeated TSP.Reference aggregator_ref */ 17:
                    message.aggregatorRef.push(TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Reference group_node_root_ref */ 18:
                    message.groupNodeRootRef = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.groupNodeRootRef);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID group_by_uid = 1; */
        if (message.groupByUid)
            TSPMessages_11.UUID.internalBinaryWrite(message.groupByUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TST.GroupColumnArchive group_column = 2; */
        for (let i = 0; i < message.groupColumn.length; i++)
            exports.GroupColumnArchive.internalBinaryWrite(message.groupColumn[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.GroupByArchive.GroupNodeArchive group_node_root = 3; */
        if (message.groupNodeRoot)
            exports.GroupByArchive_GroupNodeArchive.internalBinaryWrite(message.groupNodeRoot, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TST.GroupByArchive.AggregatorArchive aggregator = 4; */
        for (let i = 0; i < message.aggregator.length; i++)
            exports.GroupByArchive_AggregatorArchive.internalBinaryWrite(message.aggregator[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TST.ColumnAggregateArchive column_agg_type = 5; */
        for (let i = 0; i < message.columnAggType.length; i++)
            exports.ColumnAggregateArchive.internalBinaryWrite(message.columnAggType[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool is_enabled = 6; */
        if (message.isEnabled !== false)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.isEnabled);
        /* optional TSCE.CellCoordinateArchive indirect_agg_type_change_formula = 7; */
        if (message.indirectAggTypeChangeFormula)
            TSCEArchives_20.CellCoordinateArchive.internalBinaryWrite(message.indirectAggTypeChangeFormula, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.CellCoordinateArchive grouping_columns_formula = 8; */
        if (message.groupingColumnsFormula)
            TSCEArchives_20.CellCoordinateArchive.internalBinaryWrite(message.groupingColumnsFormula, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.CellCoordinateArchive aggs_in_group_root_formula = 9; */
        if (message.aggsInGroupRootFormula)
            TSCEArchives_20.CellCoordinateArchive.internalBinaryWrite(message.aggsInGroupRootFormula, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.CellCoordinateArchive grouping_column_headers_formula = 10; */
        if (message.groupingColumnHeadersFormula)
            TSCEArchives_20.CellCoordinateArchive.internalBinaryWrite(message.groupingColumnHeadersFormula, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.CellCoordinateArchive column_order_changed_formula = 11; */
        if (message.columnOrderChangedFormula)
            TSCEArchives_20.CellCoordinateArchive.internalBinaryWrite(message.columnOrderChangedFormula, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.CellCoordinateArchive row_order_changed_formula = 12; */
        if (message.rowOrderChangedFormula)
            TSCEArchives_20.CellCoordinateArchive.internalBinaryWrite(message.rowOrderChangedFormula, writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.CellCoordinateArchive row_order_changed_ignoring_recalc_formula = 13; */
        if (message.rowOrderChangedIgnoringRecalcFormula)
            TSCEArchives_20.CellCoordinateArchive.internalBinaryWrite(message.rowOrderChangedIgnoringRecalcFormula, writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional int32 owner_index = 14; */
        if (message.ownerIndex !== undefined)
            writer.tag(14, runtime_1.WireType.Varint).int32(message.ownerIndex);
        /* optional TSCE.UidLookupListArchive row_uid_lookup = 15; */
        if (message.rowUidLookup)
            TSCEArchives_19.UidLookupListArchive.internalBinaryWrite(message.rowUidLookup, writer.tag(15, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.CellCoordinateArchive hidden_states_changed_formula = 16; */
        if (message.hiddenStatesChangedFormula)
            TSCEArchives_20.CellCoordinateArchive.internalBinaryWrite(message.hiddenStatesChangedFormula, writer.tag(16, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference aggregator_ref = 17; */
        for (let i = 0; i < message.aggregatorRef.length; i++)
            TSPMessages_10.Reference.internalBinaryWrite(message.aggregatorRef[i], writer.tag(17, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference group_node_root_ref = 18; */
        if (message.groupNodeRootRef)
            TSPMessages_10.Reference.internalBinaryWrite(message.groupNodeRootRef, writer.tag(18, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.GroupByArchive
 */
exports.GroupByArchive = new GroupByArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupByArchive_AggNodeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.GroupByArchive.AggNodeArchive", [
            { no: 1, name: "formula_coord", kind: "message", T: () => TSCEArchives_20.CellCoordinateArchive },
            { no: 2, name: "accum", kind: "message", T: () => exports.AccumulatorArchive },
            { no: 3, name: "child", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.GroupByArchive_AggNodeArchive }
        ]);
    }
    create(value) {
        const message = { child: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSCE.CellCoordinateArchive formula_coord */ 1:
                    message.formulaCoord = TSCEArchives_20.CellCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.formulaCoord);
                    break;
                case /* optional TST.AccumulatorArchive accum */ 2:
                    message.accum = exports.AccumulatorArchive.internalBinaryRead(reader, reader.uint32(), options, message.accum);
                    break;
                case /* repeated TST.GroupByArchive.AggNodeArchive child */ 3:
                    message.child.push(exports.GroupByArchive_AggNodeArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSCE.CellCoordinateArchive formula_coord = 1; */
        if (message.formulaCoord)
            TSCEArchives_20.CellCoordinateArchive.internalBinaryWrite(message.formulaCoord, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.AccumulatorArchive accum = 2; */
        if (message.accum)
            exports.AccumulatorArchive.internalBinaryWrite(message.accum, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TST.GroupByArchive.AggNodeArchive child = 3; */
        for (let i = 0; i < message.child.length; i++)
            exports.GroupByArchive_AggNodeArchive.internalBinaryWrite(message.child[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.GroupByArchive.AggNodeArchive
 */
exports.GroupByArchive_AggNodeArchive = new GroupByArchive_AggNodeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupByArchive_AggregatorArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.GroupByArchive.AggregatorArchive", [
            { no: 1, name: "column_uid", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 2, name: "agg_node", kind: "message", T: () => exports.GroupByArchive_AggNodeArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID column_uid */ 1:
                    message.columnUid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.columnUid);
                    break;
                case /* optional TST.GroupByArchive.AggNodeArchive agg_node */ 2:
                    message.aggNode = exports.GroupByArchive_AggNodeArchive.internalBinaryRead(reader, reader.uint32(), options, message.aggNode);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID column_uid = 1; */
        if (message.columnUid)
            TSPMessages_11.UUID.internalBinaryWrite(message.columnUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.GroupByArchive.AggNodeArchive agg_node = 2; */
        if (message.aggNode)
            exports.GroupByArchive_AggNodeArchive.internalBinaryWrite(message.aggNode, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.GroupByArchive.AggregatorArchive
 */
exports.GroupByArchive_AggregatorArchive = new GroupByArchive_AggregatorArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupByArchive_GroupNodeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.GroupByArchive.GroupNodeArchive", [
            { no: 1, name: "group_uid", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 3, name: "child", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.GroupByArchive_GroupNodeArchive },
            { no: 4, name: "row_uid", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_11.UUID },
            { no: 5, name: "agg_formula_coords", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSCEArchives_20.CellCoordinateArchive },
            { no: 6, name: "format_manager", kind: "message", T: () => exports.GroupByArchive_GroupNodeArchive_FormatManagerArchive },
            { no: 7, name: "group_cell_value", kind: "message", T: () => TSCEArchives_18.CellValueArchive },
            { no: 8, name: "row_indexes", kind: "message", T: () => TSCEArchives_5.IndexSetArchive },
            { no: 9, name: "row_lookup_uids", kind: "message", T: () => TSCEArchives_5.IndexSetArchive },
            { no: 10, name: "child_ref", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_10.Reference }
        ]);
    }
    create(value) {
        const message = { child: [], rowUid: [], aggFormulaCoords: [], childRef: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID group_uid */ 1:
                    message.groupUid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.groupUid);
                    break;
                case /* repeated TST.GroupByArchive.GroupNodeArchive child */ 3:
                    message.child.push(exports.GroupByArchive_GroupNodeArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID row_uid */ 4:
                    message.rowUid.push(TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSCE.CellCoordinateArchive agg_formula_coords */ 5:
                    message.aggFormulaCoords.push(TSCEArchives_20.CellCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TST.GroupByArchive.GroupNodeArchive.FormatManagerArchive format_manager */ 6:
                    message.formatManager = exports.GroupByArchive_GroupNodeArchive_FormatManagerArchive.internalBinaryRead(reader, reader.uint32(), options, message.formatManager);
                    break;
                case /* optional TSCE.CellValueArchive group_cell_value */ 7:
                    message.groupCellValue = TSCEArchives_18.CellValueArchive.internalBinaryRead(reader, reader.uint32(), options, message.groupCellValue);
                    break;
                case /* optional TSCE.IndexSetArchive row_indexes */ 8:
                    message.rowIndexes = TSCEArchives_5.IndexSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.rowIndexes);
                    break;
                case /* optional TSCE.IndexSetArchive row_lookup_uids */ 9:
                    message.rowLookupUids = TSCEArchives_5.IndexSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.rowLookupUids);
                    break;
                case /* repeated TSP.Reference child_ref */ 10:
                    message.childRef.push(TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID group_uid = 1; */
        if (message.groupUid)
            TSPMessages_11.UUID.internalBinaryWrite(message.groupUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TST.GroupByArchive.GroupNodeArchive child = 3; */
        for (let i = 0; i < message.child.length; i++)
            exports.GroupByArchive_GroupNodeArchive.internalBinaryWrite(message.child[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID row_uid = 4; */
        for (let i = 0; i < message.rowUid.length; i++)
            TSPMessages_11.UUID.internalBinaryWrite(message.rowUid[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.CellCoordinateArchive agg_formula_coords = 5; */
        for (let i = 0; i < message.aggFormulaCoords.length; i++)
            TSCEArchives_20.CellCoordinateArchive.internalBinaryWrite(message.aggFormulaCoords[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.GroupByArchive.GroupNodeArchive.FormatManagerArchive format_manager = 6; */
        if (message.formatManager)
            exports.GroupByArchive_GroupNodeArchive_FormatManagerArchive.internalBinaryWrite(message.formatManager, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.CellValueArchive group_cell_value = 7; */
        if (message.groupCellValue)
            TSCEArchives_18.CellValueArchive.internalBinaryWrite(message.groupCellValue, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.IndexSetArchive row_indexes = 8; */
        if (message.rowIndexes)
            TSCEArchives_5.IndexSetArchive.internalBinaryWrite(message.rowIndexes, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.IndexSetArchive row_lookup_uids = 9; */
        if (message.rowLookupUids)
            TSCEArchives_5.IndexSetArchive.internalBinaryWrite(message.rowLookupUids, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference child_ref = 10; */
        for (let i = 0; i < message.childRef.length; i++)
            TSPMessages_10.Reference.internalBinaryWrite(message.childRef[i], writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.GroupByArchive.GroupNodeArchive
 */
exports.GroupByArchive_GroupNodeArchive = new GroupByArchive_GroupNodeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupByArchive_GroupNodeArchive_FormatManagerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.GroupByArchive.GroupNodeArchive.FormatManagerArchive", [
            { no: 1, name: "cell_value", kind: "message", T: () => TSCEArchives_18.CellValueArchive },
            { no: 2, name: "formats", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSKArchives_3.FormatStructArchive },
            { no: 3, name: "row_sets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.GroupByArchive_GroupNodeArchive_FormatManagerArchive_RowSetArchive },
            { no: 4, name: "row_uid_lookup_sets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSCEArchives_5.IndexSetArchive }
        ]);
    }
    create(value) {
        const message = { formats: [], rowSets: [], rowUidLookupSets: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSCE.CellValueArchive cell_value */ 1:
                    message.cellValue = TSCEArchives_18.CellValueArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellValue);
                    break;
                case /* repeated TSK.FormatStructArchive formats */ 2:
                    message.formats.push(TSKArchives_3.FormatStructArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TST.GroupByArchive.GroupNodeArchive.FormatManagerArchive.RowSetArchive row_sets */ 3:
                    message.rowSets.push(exports.GroupByArchive_GroupNodeArchive_FormatManagerArchive_RowSetArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSCE.IndexSetArchive row_uid_lookup_sets */ 4:
                    message.rowUidLookupSets.push(TSCEArchives_5.IndexSetArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSCE.CellValueArchive cell_value = 1; */
        if (message.cellValue)
            TSCEArchives_18.CellValueArchive.internalBinaryWrite(message.cellValue, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSK.FormatStructArchive formats = 2; */
        for (let i = 0; i < message.formats.length; i++)
            TSKArchives_3.FormatStructArchive.internalBinaryWrite(message.formats[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TST.GroupByArchive.GroupNodeArchive.FormatManagerArchive.RowSetArchive row_sets = 3; */
        for (let i = 0; i < message.rowSets.length; i++)
            exports.GroupByArchive_GroupNodeArchive_FormatManagerArchive_RowSetArchive.internalBinaryWrite(message.rowSets[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.IndexSetArchive row_uid_lookup_sets = 4; */
        for (let i = 0; i < message.rowUidLookupSets.length; i++)
            TSCEArchives_5.IndexSetArchive.internalBinaryWrite(message.rowUidLookupSets[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.GroupByArchive.GroupNodeArchive.FormatManagerArchive
 */
exports.GroupByArchive_GroupNodeArchive_FormatManagerArchive = new GroupByArchive_GroupNodeArchive_FormatManagerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupByArchive_GroupNodeArchive_FormatManagerArchive_RowSetArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.GroupByArchive.GroupNodeArchive.FormatManagerArchive.RowSetArchive", [
            { no: 1, name: "row_uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_11.UUID }
        ]);
    }
    create(value) {
        const message = { rowUids: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.UUID row_uids */ 1:
                    message.rowUids.push(TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.UUID row_uids = 1; */
        for (let i = 0; i < message.rowUids.length; i++)
            TSPMessages_11.UUID.internalBinaryWrite(message.rowUids[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.GroupByArchive.GroupNodeArchive.FormatManagerArchive.RowSetArchive
 */
exports.GroupByArchive_GroupNodeArchive_FormatManagerArchive_RowSetArchive = new GroupByArchive_GroupNodeArchive_FormatManagerArchive_RowSetArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CategoryOwnerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CategoryOwnerArchive", [
            { no: 1, name: "owner_uid", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 2, name: "group_by", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.GroupByArchive }
        ]);
    }
    create(value) {
        const message = { groupBy: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID owner_uid */ 1:
                    message.ownerUid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.ownerUid);
                    break;
                case /* repeated TST.GroupByArchive group_by */ 2:
                    message.groupBy.push(exports.GroupByArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID owner_uid = 1; */
        if (message.ownerUid)
            TSPMessages_11.UUID.internalBinaryWrite(message.ownerUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TST.GroupByArchive group_by = 2; */
        for (let i = 0; i < message.groupBy.length; i++)
            exports.GroupByArchive.internalBinaryWrite(message.groupBy[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CategoryOwnerArchive
 */
exports.CategoryOwnerArchive = new CategoryOwnerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CategoryOwnerRefArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CategoryOwnerRefArchive", [
            { no: 1, name: "group_by", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_10.Reference }
        ]);
    }
    create(value) {
        const message = { groupBy: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.Reference group_by */ 1:
                    message.groupBy.push(TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.Reference group_by = 1; */
        for (let i = 0; i < message.groupBy.length; i++)
            TSPMessages_10.Reference.internalBinaryWrite(message.groupBy[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CategoryOwnerRefArchive
 */
exports.CategoryOwnerRefArchive = new CategoryOwnerRefArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PivotGroupingColumnOptionsMapArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.PivotGroupingColumnOptionsMapArchive", [
            { no: 1, name: "uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_11.UUID },
            { no: 2, name: "flags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "aggregate_rule_uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_11.UUID }
        ]);
    }
    create(value) {
        const message = { uids: [], flags: [], aggregateRuleUids: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.UUID uids */ 1:
                    message.uids.push(TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 flags */ 2:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.flags.push(reader.uint32());
                    else
                        message.flags.push(reader.uint32());
                    break;
                case /* repeated TSP.UUID aggregate_rule_uids */ 4:
                    message.aggregateRuleUids.push(TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.UUID uids = 1; */
        for (let i = 0; i < message.uids.length; i++)
            TSPMessages_11.UUID.internalBinaryWrite(message.uids[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 flags = 2; */
        for (let i = 0; i < message.flags.length; i++)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.flags[i]);
        /* repeated TSP.UUID aggregate_rule_uids = 4; */
        for (let i = 0; i < message.aggregateRuleUids.length; i++)
            TSPMessages_11.UUID.internalBinaryWrite(message.aggregateRuleUids[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.PivotGroupingColumnOptionsMapArchive
 */
exports.PivotGroupingColumnOptionsMapArchive = new PivotGroupingColumnOptionsMapArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PivotOwnerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.PivotOwnerArchive", [
            { no: 2, name: "pivot_owner_uid", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 3, name: "grouping_columns_for_rows", kind: "message", T: () => exports.GroupColumnListArchive },
            { no: 4, name: "grouping_columns_for_columns", kind: "message", T: () => exports.GroupColumnListArchive },
            { no: 5, name: "aggregate_columns", kind: "message", T: () => exports.ColumnAggregateListArchive },
            { no: 6, name: "flattening_dimension", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "is_empty_pivot", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "source_table_uid", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 9, name: "refresh_timestamp", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 10, name: "grpg_col_options_map", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 11, name: "hide_grand_total_rows", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "source_table_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "hide_grand_total_columns", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "formula_store", kind: "message", T: () => exports.FormulaStoreArchive },
            { no: 18, name: "refresh_uid", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 19, name: "row_column_rule_change_uid", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 20, name: "aggregate_rule_change_uid", kind: "message", T: () => TSPMessages_11.UUID }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.UUID pivot_owner_uid */ 2:
                    message.pivotOwnerUid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.pivotOwnerUid);
                    break;
                case /* optional TST.GroupColumnListArchive grouping_columns_for_rows */ 3:
                    message.groupingColumnsForRows = exports.GroupColumnListArchive.internalBinaryRead(reader, reader.uint32(), options, message.groupingColumnsForRows);
                    break;
                case /* optional TST.GroupColumnListArchive grouping_columns_for_columns */ 4:
                    message.groupingColumnsForColumns = exports.GroupColumnListArchive.internalBinaryRead(reader, reader.uint32(), options, message.groupingColumnsForColumns);
                    break;
                case /* optional TST.ColumnAggregateListArchive aggregate_columns */ 5:
                    message.aggregateColumns = exports.ColumnAggregateListArchive.internalBinaryRead(reader, reader.uint32(), options, message.aggregateColumns);
                    break;
                case /* optional int32 flattening_dimension */ 6:
                    message.flatteningDimension = reader.int32();
                    break;
                case /* optional bool is_empty_pivot */ 7:
                    message.isEmptyPivot = reader.bool();
                    break;
                case /* optional TSP.UUID source_table_uid */ 8:
                    message.sourceTableUid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.sourceTableUid);
                    break;
                case /* optional double refresh_timestamp */ 9:
                    message.refreshTimestamp = reader.double();
                    break;
                case /* optional TSP.Reference grpg_col_options_map */ 10:
                    message.grpgColOptionsMap = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.grpgColOptionsMap);
                    break;
                case /* optional bool hide_grand_total_rows */ 11:
                    message.hideGrandTotalRows = reader.bool();
                    break;
                case /* optional string source_table_name */ 12:
                    message.sourceTableName = reader.string();
                    break;
                case /* optional bool hide_grand_total_columns */ 13:
                    message.hideGrandTotalColumns = reader.bool();
                    break;
                case /* optional TST.FormulaStoreArchive formula_store */ 17:
                    message.formulaStore = exports.FormulaStoreArchive.internalBinaryRead(reader, reader.uint32(), options, message.formulaStore);
                    break;
                case /* optional TSP.UUID refresh_uid */ 18:
                    message.refreshUid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.refreshUid);
                    break;
                case /* optional TSP.UUID row_column_rule_change_uid */ 19:
                    message.rowColumnRuleChangeUid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.rowColumnRuleChangeUid);
                    break;
                case /* optional TSP.UUID aggregate_rule_change_uid */ 20:
                    message.aggregateRuleChangeUid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.aggregateRuleChangeUid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.UUID pivot_owner_uid = 2; */
        if (message.pivotOwnerUid)
            TSPMessages_11.UUID.internalBinaryWrite(message.pivotOwnerUid, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.GroupColumnListArchive grouping_columns_for_rows = 3; */
        if (message.groupingColumnsForRows)
            exports.GroupColumnListArchive.internalBinaryWrite(message.groupingColumnsForRows, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.GroupColumnListArchive grouping_columns_for_columns = 4; */
        if (message.groupingColumnsForColumns)
            exports.GroupColumnListArchive.internalBinaryWrite(message.groupingColumnsForColumns, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.ColumnAggregateListArchive aggregate_columns = 5; */
        if (message.aggregateColumns)
            exports.ColumnAggregateListArchive.internalBinaryWrite(message.aggregateColumns, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional int32 flattening_dimension = 6; */
        if (message.flatteningDimension !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).int32(message.flatteningDimension);
        /* optional bool is_empty_pivot = 7; */
        if (message.isEmptyPivot !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.isEmptyPivot);
        /* optional TSP.UUID source_table_uid = 8; */
        if (message.sourceTableUid)
            TSPMessages_11.UUID.internalBinaryWrite(message.sourceTableUid, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional double refresh_timestamp = 9; */
        if (message.refreshTimestamp !== undefined)
            writer.tag(9, runtime_1.WireType.Bit64).double(message.refreshTimestamp);
        /* optional TSP.Reference grpg_col_options_map = 10; */
        if (message.grpgColOptionsMap)
            TSPMessages_10.Reference.internalBinaryWrite(message.grpgColOptionsMap, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool hide_grand_total_rows = 11; */
        if (message.hideGrandTotalRows !== undefined)
            writer.tag(11, runtime_1.WireType.Varint).bool(message.hideGrandTotalRows);
        /* optional string source_table_name = 12; */
        if (message.sourceTableName !== undefined)
            writer.tag(12, runtime_1.WireType.LengthDelimited).string(message.sourceTableName);
        /* optional bool hide_grand_total_columns = 13; */
        if (message.hideGrandTotalColumns !== undefined)
            writer.tag(13, runtime_1.WireType.Varint).bool(message.hideGrandTotalColumns);
        /* optional TST.FormulaStoreArchive formula_store = 17; */
        if (message.formulaStore)
            exports.FormulaStoreArchive.internalBinaryWrite(message.formulaStore, writer.tag(17, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID refresh_uid = 18; */
        if (message.refreshUid)
            TSPMessages_11.UUID.internalBinaryWrite(message.refreshUid, writer.tag(18, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID row_column_rule_change_uid = 19; */
        if (message.rowColumnRuleChangeUid)
            TSPMessages_11.UUID.internalBinaryWrite(message.rowColumnRuleChangeUid, writer.tag(19, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID aggregate_rule_change_uid = 20; */
        if (message.aggregateRuleChangeUid)
            TSPMessages_11.UUID.internalBinaryWrite(message.aggregateRuleChangeUid, writer.tag(20, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.PivotOwnerArchive
 */
exports.PivotOwnerArchive = new PivotOwnerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RichTextPayloadArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.RichTextPayloadArchive", [
            { no: 1, name: "storage", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 2, name: "range", kind: "message", T: () => TSPMessages_9.Range },
            { no: 3, name: "cellid", kind: "message", T: () => exports.CellID }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.Reference storage */ 1:
                    message.storage = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.storage);
                    break;
                case /* optional TSP.Range range */ 2:
                    message.range = TSPMessages_9.Range.internalBinaryRead(reader, reader.uint32(), options, message.range);
                    break;
                case /* TST.CellID cellid */ 3:
                    message.cellid = exports.CellID.internalBinaryRead(reader, reader.uint32(), options, message.cellid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.Reference storage = 1; */
        if (message.storage)
            TSPMessages_10.Reference.internalBinaryWrite(message.storage, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Range range = 2; */
        if (message.range)
            TSPMessages_9.Range.internalBinaryWrite(message.range, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.CellID cellid = 3; */
        if (message.cellid)
            exports.CellID.internalBinaryWrite(message.cellid, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.RichTextPayloadArchive
 */
exports.RichTextPayloadArchive = new RichTextPayloadArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormulaEqualsTokenAttachmentArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.FormulaEqualsTokenAttachmentArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSWPArchives_2.UIGraphicalAttachment }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSWP.UIGraphicalAttachment super */ 1:
                    message.super = TSWPArchives_2.UIGraphicalAttachment.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSWP.UIGraphicalAttachment super = 1; */
        if (message.super)
            TSWPArchives_2.UIGraphicalAttachment.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.FormulaEqualsTokenAttachmentArchive
 */
exports.FormulaEqualsTokenAttachmentArchive = new FormulaEqualsTokenAttachmentArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellFillStandIn$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CellFillStandIn", [
            { no: 1, name: "fill", kind: "message", T: () => TSDArchives_1.FillArchive },
            { no: 2, name: "type_is_mixed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "color_has_been_modified", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "color_is_mixed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "first_color_has_been_modified", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "first_color_is_mixed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "last_color_has_been_modified", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "last_color_is_mixed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "gradient_type_has_been_modified", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "gradient_type_is_mixed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "gradient_angle_has_been_modified", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "gradient_angle_is_mixed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "image_data_has_been_modified", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "image_data_is_mixed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "tint_color_has_been_modified", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "tint_color_is_mixed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "scale_has_been_modified", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "scale_is_mixed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "technique_has_been_modified", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 20, name: "technique_is_mixed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.FillArchive fill */ 1:
                    message.fill = TSDArchives_1.FillArchive.internalBinaryRead(reader, reader.uint32(), options, message.fill);
                    break;
                case /* optional bool type_is_mixed */ 2:
                    message.typeIsMixed = reader.bool();
                    break;
                case /* optional bool color_has_been_modified */ 3:
                    message.colorHasBeenModified = reader.bool();
                    break;
                case /* optional bool color_is_mixed */ 4:
                    message.colorIsMixed = reader.bool();
                    break;
                case /* optional bool first_color_has_been_modified */ 5:
                    message.firstColorHasBeenModified = reader.bool();
                    break;
                case /* optional bool first_color_is_mixed */ 6:
                    message.firstColorIsMixed = reader.bool();
                    break;
                case /* optional bool last_color_has_been_modified */ 7:
                    message.lastColorHasBeenModified = reader.bool();
                    break;
                case /* optional bool last_color_is_mixed */ 8:
                    message.lastColorIsMixed = reader.bool();
                    break;
                case /* optional bool gradient_type_has_been_modified */ 9:
                    message.gradientTypeHasBeenModified = reader.bool();
                    break;
                case /* optional bool gradient_type_is_mixed */ 10:
                    message.gradientTypeIsMixed = reader.bool();
                    break;
                case /* optional bool gradient_angle_has_been_modified */ 11:
                    message.gradientAngleHasBeenModified = reader.bool();
                    break;
                case /* optional bool gradient_angle_is_mixed */ 12:
                    message.gradientAngleIsMixed = reader.bool();
                    break;
                case /* optional bool image_data_has_been_modified */ 13:
                    message.imageDataHasBeenModified = reader.bool();
                    break;
                case /* optional bool image_data_is_mixed */ 14:
                    message.imageDataIsMixed = reader.bool();
                    break;
                case /* optional bool tint_color_has_been_modified */ 15:
                    message.tintColorHasBeenModified = reader.bool();
                    break;
                case /* optional bool tint_color_is_mixed */ 16:
                    message.tintColorIsMixed = reader.bool();
                    break;
                case /* optional bool scale_has_been_modified */ 17:
                    message.scaleHasBeenModified = reader.bool();
                    break;
                case /* optional bool scale_is_mixed */ 18:
                    message.scaleIsMixed = reader.bool();
                    break;
                case /* optional bool technique_has_been_modified */ 19:
                    message.techniqueHasBeenModified = reader.bool();
                    break;
                case /* optional bool technique_is_mixed */ 20:
                    message.techniqueIsMixed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.FillArchive fill = 1; */
        if (message.fill)
            TSDArchives_1.FillArchive.internalBinaryWrite(message.fill, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool type_is_mixed = 2; */
        if (message.typeIsMixed !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.typeIsMixed);
        /* optional bool color_has_been_modified = 3; */
        if (message.colorHasBeenModified !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.colorHasBeenModified);
        /* optional bool color_is_mixed = 4; */
        if (message.colorIsMixed !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.colorIsMixed);
        /* optional bool first_color_has_been_modified = 5; */
        if (message.firstColorHasBeenModified !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.firstColorHasBeenModified);
        /* optional bool first_color_is_mixed = 6; */
        if (message.firstColorIsMixed !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.firstColorIsMixed);
        /* optional bool last_color_has_been_modified = 7; */
        if (message.lastColorHasBeenModified !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.lastColorHasBeenModified);
        /* optional bool last_color_is_mixed = 8; */
        if (message.lastColorIsMixed !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.lastColorIsMixed);
        /* optional bool gradient_type_has_been_modified = 9; */
        if (message.gradientTypeHasBeenModified !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).bool(message.gradientTypeHasBeenModified);
        /* optional bool gradient_type_is_mixed = 10; */
        if (message.gradientTypeIsMixed !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).bool(message.gradientTypeIsMixed);
        /* optional bool gradient_angle_has_been_modified = 11; */
        if (message.gradientAngleHasBeenModified !== undefined)
            writer.tag(11, runtime_1.WireType.Varint).bool(message.gradientAngleHasBeenModified);
        /* optional bool gradient_angle_is_mixed = 12; */
        if (message.gradientAngleIsMixed !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).bool(message.gradientAngleIsMixed);
        /* optional bool image_data_has_been_modified = 13; */
        if (message.imageDataHasBeenModified !== undefined)
            writer.tag(13, runtime_1.WireType.Varint).bool(message.imageDataHasBeenModified);
        /* optional bool image_data_is_mixed = 14; */
        if (message.imageDataIsMixed !== undefined)
            writer.tag(14, runtime_1.WireType.Varint).bool(message.imageDataIsMixed);
        /* optional bool tint_color_has_been_modified = 15; */
        if (message.tintColorHasBeenModified !== undefined)
            writer.tag(15, runtime_1.WireType.Varint).bool(message.tintColorHasBeenModified);
        /* optional bool tint_color_is_mixed = 16; */
        if (message.tintColorIsMixed !== undefined)
            writer.tag(16, runtime_1.WireType.Varint).bool(message.tintColorIsMixed);
        /* optional bool scale_has_been_modified = 17; */
        if (message.scaleHasBeenModified !== undefined)
            writer.tag(17, runtime_1.WireType.Varint).bool(message.scaleHasBeenModified);
        /* optional bool scale_is_mixed = 18; */
        if (message.scaleIsMixed !== undefined)
            writer.tag(18, runtime_1.WireType.Varint).bool(message.scaleIsMixed);
        /* optional bool technique_has_been_modified = 19; */
        if (message.techniqueHasBeenModified !== undefined)
            writer.tag(19, runtime_1.WireType.Varint).bool(message.techniqueHasBeenModified);
        /* optional bool technique_is_mixed = 20; */
        if (message.techniqueIsMixed !== undefined)
            writer.tag(20, runtime_1.WireType.Varint).bool(message.techniqueIsMixed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CellFillStandIn
 */
exports.CellFillStandIn = new CellFillStandIn$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormulaSelectionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.FormulaSelectionArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSWPArchives_1.SelectionArchive },
            { no: 2, name: "activeTokenCharIndex", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSWP.SelectionArchive super */ 1:
                    message.super = TSWPArchives_1.SelectionArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional uint32 activeTokenCharIndex */ 2:
                    message.activeTokenCharIndex = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSWP.SelectionArchive super = 1; */
        if (message.super)
            TSWPArchives_1.SelectionArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 activeTokenCharIndex = 2; */
        if (message.activeTokenCharIndex !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.activeTokenCharIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.FormulaSelectionArchive
 */
exports.FormulaSelectionArchive = new FormulaSelectionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CellBorderArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CellBorderArchive", [
            { no: 1, name: "top_stroke", kind: "message", T: () => TSDArchives_2.StrokeArchive },
            { no: 2, name: "top_stroke_order", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "right_stroke", kind: "message", T: () => TSDArchives_2.StrokeArchive },
            { no: 4, name: "right_stroke_order", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "bottom_stroke", kind: "message", T: () => TSDArchives_2.StrokeArchive },
            { no: 6, name: "bottom_stroke_order", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "left_stroke", kind: "message", T: () => TSDArchives_2.StrokeArchive },
            { no: 8, name: "left_stroke_order", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSD.StrokeArchive top_stroke */ 1:
                    message.topStroke = TSDArchives_2.StrokeArchive.internalBinaryRead(reader, reader.uint32(), options, message.topStroke);
                    break;
                case /* optional int32 top_stroke_order */ 2:
                    message.topStrokeOrder = reader.int32();
                    break;
                case /* optional TSD.StrokeArchive right_stroke */ 3:
                    message.rightStroke = TSDArchives_2.StrokeArchive.internalBinaryRead(reader, reader.uint32(), options, message.rightStroke);
                    break;
                case /* optional int32 right_stroke_order */ 4:
                    message.rightStrokeOrder = reader.int32();
                    break;
                case /* optional TSD.StrokeArchive bottom_stroke */ 5:
                    message.bottomStroke = TSDArchives_2.StrokeArchive.internalBinaryRead(reader, reader.uint32(), options, message.bottomStroke);
                    break;
                case /* optional int32 bottom_stroke_order */ 6:
                    message.bottomStrokeOrder = reader.int32();
                    break;
                case /* optional TSD.StrokeArchive left_stroke */ 7:
                    message.leftStroke = TSDArchives_2.StrokeArchive.internalBinaryRead(reader, reader.uint32(), options, message.leftStroke);
                    break;
                case /* optional int32 left_stroke_order */ 8:
                    message.leftStrokeOrder = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSD.StrokeArchive top_stroke = 1; */
        if (message.topStroke)
            TSDArchives_2.StrokeArchive.internalBinaryWrite(message.topStroke, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional int32 top_stroke_order = 2; */
        if (message.topStrokeOrder !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.topStrokeOrder);
        /* optional TSD.StrokeArchive right_stroke = 3; */
        if (message.rightStroke)
            TSDArchives_2.StrokeArchive.internalBinaryWrite(message.rightStroke, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional int32 right_stroke_order = 4; */
        if (message.rightStrokeOrder !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).int32(message.rightStrokeOrder);
        /* optional TSD.StrokeArchive bottom_stroke = 5; */
        if (message.bottomStroke)
            TSDArchives_2.StrokeArchive.internalBinaryWrite(message.bottomStroke, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional int32 bottom_stroke_order = 6; */
        if (message.bottomStrokeOrder !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).int32(message.bottomStrokeOrder);
        /* optional TSD.StrokeArchive left_stroke = 7; */
        if (message.leftStroke)
            TSDArchives_2.StrokeArchive.internalBinaryWrite(message.leftStroke, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional int32 left_stroke_order = 8; */
        if (message.leftStrokeOrder !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).int32(message.leftStrokeOrder);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CellBorderArchive
 */
exports.CellBorderArchive = new CellBorderArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DefaultCellStylesContainerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.DefaultCellStylesContainerArchive", [
            { no: 1, name: "table_style_network", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 2, name: "row_uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_11.UUID },
            { no: 3, name: "column_uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_11.UUID },
            { no: 4, name: "row_types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "column_types", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "is_a_pivot_table", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { rowUids: [], columnUids: [], rowTypes: [], columnTypes: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.Reference table_style_network */ 1:
                    message.tableStyleNetwork = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.tableStyleNetwork);
                    break;
                case /* repeated TSP.UUID row_uids */ 2:
                    message.rowUids.push(TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID column_uids */ 3:
                    message.columnUids.push(TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 row_types */ 4:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.rowTypes.push(reader.uint32());
                    else
                        message.rowTypes.push(reader.uint32());
                    break;
                case /* repeated uint32 column_types */ 5:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.columnTypes.push(reader.uint32());
                    else
                        message.columnTypes.push(reader.uint32());
                    break;
                case /* optional bool is_a_pivot_table */ 6:
                    message.isAPivotTable = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.Reference table_style_network = 1; */
        if (message.tableStyleNetwork)
            TSPMessages_10.Reference.internalBinaryWrite(message.tableStyleNetwork, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID row_uids = 2; */
        for (let i = 0; i < message.rowUids.length; i++)
            TSPMessages_11.UUID.internalBinaryWrite(message.rowUids[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID column_uids = 3; */
        for (let i = 0; i < message.columnUids.length; i++)
            TSPMessages_11.UUID.internalBinaryWrite(message.columnUids[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 row_types = 4; */
        for (let i = 0; i < message.rowTypes.length; i++)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.rowTypes[i]);
        /* repeated uint32 column_types = 5; */
        for (let i = 0; i < message.columnTypes.length; i++)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.columnTypes[i]);
        /* optional bool is_a_pivot_table = 6; */
        if (message.isAPivotTable !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.isAPivotTable);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.DefaultCellStylesContainerArchive
 */
exports.DefaultCellStylesContainerArchive = new DefaultCellStylesContainerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MultiTableRemapperArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.MultiTableRemapperArchive", [
            { no: 1, name: "mapping_purpose", kind: "enum", T: () => ["TST.MultiTableRemapperArchive.Purpose", MultiTableRemapperArchive_Purpose] },
            { no: 2, name: "should_steal_references", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "can_reuse_table_names", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "owner_uid_mapper", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSCEArchives_2.OwnerUIDMapperArchive },
            { no: 5, name: "backing_tables_for_charts", kind: "message", T: () => TSPMessages_1.UUIDMapArchive },
            { no: 6, name: "cross_document_paste", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "nested_inner_mapper", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { mappingPurpose: 0, shouldStealReferences: false, canReuseTableNames: false, ownerUidMapper: [], crossDocumentPaste: false, nestedInnerMapper: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.MultiTableRemapperArchive.Purpose mapping_purpose */ 1:
                    message.mappingPurpose = reader.int32();
                    break;
                case /* bool should_steal_references */ 2:
                    message.shouldStealReferences = reader.bool();
                    break;
                case /* bool can_reuse_table_names */ 3:
                    message.canReuseTableNames = reader.bool();
                    break;
                case /* repeated TSCE.OwnerUIDMapperArchive owner_uid_mapper */ 4:
                    message.ownerUidMapper.push(TSCEArchives_2.OwnerUIDMapperArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* TSP.UUIDMapArchive backing_tables_for_charts */ 5:
                    message.backingTablesForCharts = TSPMessages_1.UUIDMapArchive.internalBinaryRead(reader, reader.uint32(), options, message.backingTablesForCharts);
                    break;
                case /* bool cross_document_paste */ 6:
                    message.crossDocumentPaste = reader.bool();
                    break;
                case /* bool nested_inner_mapper */ 7:
                    message.nestedInnerMapper = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.MultiTableRemapperArchive.Purpose mapping_purpose = 1; */
        if (message.mappingPurpose !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.mappingPurpose);
        /* bool should_steal_references = 2; */
        if (message.shouldStealReferences !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.shouldStealReferences);
        /* bool can_reuse_table_names = 3; */
        if (message.canReuseTableNames !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.canReuseTableNames);
        /* repeated TSCE.OwnerUIDMapperArchive owner_uid_mapper = 4; */
        for (let i = 0; i < message.ownerUidMapper.length; i++)
            TSCEArchives_2.OwnerUIDMapperArchive.internalBinaryWrite(message.ownerUidMapper[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUIDMapArchive backing_tables_for_charts = 5; */
        if (message.backingTablesForCharts)
            TSPMessages_1.UUIDMapArchive.internalBinaryWrite(message.backingTablesForCharts, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool cross_document_paste = 6; */
        if (message.crossDocumentPaste !== false)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.crossDocumentPaste);
        /* bool nested_inner_mapper = 7; */
        if (message.nestedInnerMapper !== false)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.nestedInnerMapper);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.MultiTableRemapperArchive
 */
exports.MultiTableRemapperArchive = new MultiTableRemapperArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangePropagationMapWrapper$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.ChangePropagationMapWrapper", [
            { no: 1, name: "replacement_behavior", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "style_replace_prototypes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_10.Reference },
            { no: 3, name: "style_replace_replacements", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_10.Reference },
            { no: 4, name: "style_modify_styles", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_10.Reference },
            { no: 5, name: "style_modify_old_prop_maps", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_10.Reference },
            { no: 6, name: "style_modify_new_prop_maps", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_10.Reference },
            { no: 7, name: "style_delete_prototypes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_10.Reference },
            { no: 8, name: "style_delete_replacements", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_10.Reference },
            { no: 9, name: "table_preset_replace_prototype", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 10, name: "table_preset_replace_replacement", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 11, name: "table_preset_delete_prototype", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 12, name: "table_preset_delete_replacement", kind: "message", T: () => TSPMessages_10.Reference }
        ]);
    }
    create(value) {
        const message = { replacementBehavior: 0, styleReplacePrototypes: [], styleReplaceReplacements: [], styleModifyStyles: [], styleModifyOldPropMaps: [], styleModifyNewPropMaps: [], styleDeletePrototypes: [], styleDeleteReplacements: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 replacement_behavior */ 1:
                    message.replacementBehavior = reader.int32();
                    break;
                case /* repeated TSP.Reference style_replace_prototypes */ 2:
                    message.styleReplacePrototypes.push(TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference style_replace_replacements */ 3:
                    message.styleReplaceReplacements.push(TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference style_modify_styles */ 4:
                    message.styleModifyStyles.push(TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference style_modify_old_prop_maps */ 5:
                    message.styleModifyOldPropMaps.push(TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference style_modify_new_prop_maps */ 6:
                    message.styleModifyNewPropMaps.push(TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference style_delete_prototypes */ 7:
                    message.styleDeletePrototypes.push(TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference style_delete_replacements */ 8:
                    message.styleDeleteReplacements.push(TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Reference table_preset_replace_prototype */ 9:
                    message.tablePresetReplacePrototype = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.tablePresetReplacePrototype);
                    break;
                case /* optional TSP.Reference table_preset_replace_replacement */ 10:
                    message.tablePresetReplaceReplacement = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.tablePresetReplaceReplacement);
                    break;
                case /* optional TSP.Reference table_preset_delete_prototype */ 11:
                    message.tablePresetDeletePrototype = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.tablePresetDeletePrototype);
                    break;
                case /* optional TSP.Reference table_preset_delete_replacement */ 12:
                    message.tablePresetDeleteReplacement = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.tablePresetDeleteReplacement);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int32 replacement_behavior = 1; */
        if (message.replacementBehavior !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.replacementBehavior);
        /* repeated TSP.Reference style_replace_prototypes = 2; */
        for (let i = 0; i < message.styleReplacePrototypes.length; i++)
            TSPMessages_10.Reference.internalBinaryWrite(message.styleReplacePrototypes[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference style_replace_replacements = 3; */
        for (let i = 0; i < message.styleReplaceReplacements.length; i++)
            TSPMessages_10.Reference.internalBinaryWrite(message.styleReplaceReplacements[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference style_modify_styles = 4; */
        for (let i = 0; i < message.styleModifyStyles.length; i++)
            TSPMessages_10.Reference.internalBinaryWrite(message.styleModifyStyles[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference style_modify_old_prop_maps = 5; */
        for (let i = 0; i < message.styleModifyOldPropMaps.length; i++)
            TSPMessages_10.Reference.internalBinaryWrite(message.styleModifyOldPropMaps[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference style_modify_new_prop_maps = 6; */
        for (let i = 0; i < message.styleModifyNewPropMaps.length; i++)
            TSPMessages_10.Reference.internalBinaryWrite(message.styleModifyNewPropMaps[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference style_delete_prototypes = 7; */
        for (let i = 0; i < message.styleDeletePrototypes.length; i++)
            TSPMessages_10.Reference.internalBinaryWrite(message.styleDeletePrototypes[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference style_delete_replacements = 8; */
        for (let i = 0; i < message.styleDeleteReplacements.length; i++)
            TSPMessages_10.Reference.internalBinaryWrite(message.styleDeleteReplacements[i], writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference table_preset_replace_prototype = 9; */
        if (message.tablePresetReplacePrototype)
            TSPMessages_10.Reference.internalBinaryWrite(message.tablePresetReplacePrototype, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference table_preset_replace_replacement = 10; */
        if (message.tablePresetReplaceReplacement)
            TSPMessages_10.Reference.internalBinaryWrite(message.tablePresetReplaceReplacement, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference table_preset_delete_prototype = 11; */
        if (message.tablePresetDeletePrototype)
            TSPMessages_10.Reference.internalBinaryWrite(message.tablePresetDeletePrototype, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference table_preset_delete_replacement = 12; */
        if (message.tablePresetDeleteReplacement)
            TSPMessages_10.Reference.internalBinaryWrite(message.tablePresetDeleteReplacement, writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.ChangePropagationMapWrapper
 */
exports.ChangePropagationMapWrapper = new ChangePropagationMapWrapper$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SummaryCellVendorArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.SummaryCellVendorArchive", [
            { no: 1, name: "table_info", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 2, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.SummaryCellVendorArchive_SummaryCellEntry }
        ]);
    }
    create(value) {
        const message = { entries: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.Reference table_info */ 1:
                    message.tableInfo = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.tableInfo);
                    break;
                case /* repeated TST.SummaryCellVendorArchive.SummaryCellEntry entries */ 2:
                    message.entries.push(exports.SummaryCellVendorArchive_SummaryCellEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.Reference table_info = 1; */
        if (message.tableInfo)
            TSPMessages_10.Reference.internalBinaryWrite(message.tableInfo, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TST.SummaryCellVendorArchive.SummaryCellEntry entries = 2; */
        for (let i = 0; i < message.entries.length; i++)
            exports.SummaryCellVendorArchive_SummaryCellEntry.internalBinaryWrite(message.entries[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.SummaryCellVendorArchive
 */
exports.SummaryCellVendorArchive = new SummaryCellVendorArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SummaryCellVendorArchive_SummaryCellEntry$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.SummaryCellVendorArchive.SummaryCellEntry", [
            { no: 1, name: "wildcardUID", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 2, name: "columnUID", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 3, name: "cell", kind: "message", T: () => exports.Cell }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID wildcardUID */ 1:
                    message.wildcardUID = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.wildcardUID);
                    break;
                case /* TSP.UUID columnUID */ 2:
                    message.columnUID = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.columnUID);
                    break;
                case /* TST.Cell cell */ 3:
                    message.cell = exports.Cell.internalBinaryRead(reader, reader.uint32(), options, message.cell);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID wildcardUID = 1; */
        if (message.wildcardUID)
            TSPMessages_11.UUID.internalBinaryWrite(message.wildcardUID, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID columnUID = 2; */
        if (message.columnUID)
            TSPMessages_11.UUID.internalBinaryWrite(message.columnUID, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.Cell cell = 3; */
        if (message.cell)
            exports.Cell.internalBinaryWrite(message.cell, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.SummaryCellVendorArchive.SummaryCellEntry
 */
exports.SummaryCellVendorArchive_SummaryCellEntry = new SummaryCellVendorArchive_SummaryCellEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CategoryOrderArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CategoryOrderArchive", [
            { no: 1, name: "table_info", kind: "message", T: () => TSPMessages_10.Reference },
            { no: 2, name: "uid_map", kind: "message", T: () => TSPMessages_10.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.Reference table_info */ 1:
                    message.tableInfo = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.tableInfo);
                    break;
                case /* TSP.Reference uid_map */ 2:
                    message.uidMap = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.uidMap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.Reference table_info = 1; */
        if (message.tableInfo)
            TSPMessages_10.Reference.internalBinaryWrite(message.tableInfo, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference uid_map = 2; */
        if (message.uidMap)
            TSPMessages_10.Reference.internalBinaryWrite(message.uidMap, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CategoryOrderArchive
 */
exports.CategoryOrderArchive = new CategoryOrderArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PivotOrderArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.PivotOrderArchive", [
            { no: 1, name: "uid_map", kind: "message", T: () => TSPMessages_10.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference uid_map */ 1:
                    message.uidMap = TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options, message.uidMap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference uid_map = 1; */
        if (message.uidMap)
            TSPMessages_10.Reference.internalBinaryWrite(message.uidMap, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.PivotOrderArchive
 */
exports.PivotOrderArchive = new PivotOrderArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeaderNameMgrTileArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.HeaderNameMgrTileArchive", [
            { no: 1, name: "first_fragment", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "last_fragment", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name_frag_entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.HeaderNameMgrTileArchive_NameFragmentArchive }
        ]);
    }
    create(value) {
        const message = { firstFragment: "", lastFragment: "", nameFragEntries: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string first_fragment */ 1:
                    message.firstFragment = reader.string();
                    break;
                case /* string last_fragment */ 2:
                    message.lastFragment = reader.string();
                    break;
                case /* repeated TST.HeaderNameMgrTileArchive.NameFragmentArchive name_frag_entries */ 3:
                    message.nameFragEntries.push(exports.HeaderNameMgrTileArchive_NameFragmentArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string first_fragment = 1; */
        if (message.firstFragment !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.firstFragment);
        /* string last_fragment = 2; */
        if (message.lastFragment !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.lastFragment);
        /* repeated TST.HeaderNameMgrTileArchive.NameFragmentArchive name_frag_entries = 3; */
        for (let i = 0; i < message.nameFragEntries.length; i++)
            exports.HeaderNameMgrTileArchive_NameFragmentArchive.internalBinaryWrite(message.nameFragEntries[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.HeaderNameMgrTileArchive
 */
exports.HeaderNameMgrTileArchive = new HeaderNameMgrTileArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeaderNameMgrTileArchive_NameFragmentArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.HeaderNameMgrTileArchive.NameFragmentArchive", [
            { no: 1, name: "name_fragment", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name_precedent", kind: "message", T: () => TSCEArchives_20.CellCoordinateArchive },
            { no: 3, name: "uses_of_name_fragment", kind: "message", T: () => TSCEArchives_1.UidCellRefSetArchive }
        ]);
    }
    create(value) {
        const message = { nameFragment: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name_fragment */ 1:
                    message.nameFragment = reader.string();
                    break;
                case /* TSCE.CellCoordinateArchive name_precedent */ 2:
                    message.namePrecedent = TSCEArchives_20.CellCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.namePrecedent);
                    break;
                case /* optional TSCE.UidCellRefSetArchive uses_of_name_fragment */ 3:
                    message.usesOfNameFragment = TSCEArchives_1.UidCellRefSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.usesOfNameFragment);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name_fragment = 1; */
        if (message.nameFragment !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.nameFragment);
        /* TSCE.CellCoordinateArchive name_precedent = 2; */
        if (message.namePrecedent)
            TSCEArchives_20.CellCoordinateArchive.internalBinaryWrite(message.namePrecedent, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.UidCellRefSetArchive uses_of_name_fragment = 3; */
        if (message.usesOfNameFragment)
            TSCEArchives_1.UidCellRefSetArchive.internalBinaryWrite(message.usesOfNameFragment, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.HeaderNameMgrTileArchive.NameFragmentArchive
 */
exports.HeaderNameMgrTileArchive_NameFragmentArchive = new HeaderNameMgrTileArchive_NameFragmentArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeaderNameMgrArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.HeaderNameMgrArchive", [
            { no: 1, name: "owner_uid", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 2, name: "nrm_owner_uid", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 3, name: "per_tables", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.HeaderNameMgrArchive_PerTableArchive },
            { no: 4, name: "name_frag_tiles", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_10.Reference }
        ]);
    }
    create(value) {
        const message = { perTables: [], nameFragTiles: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID owner_uid */ 1:
                    message.ownerUid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.ownerUid);
                    break;
                case /* optional TSP.UUID nrm_owner_uid */ 2:
                    message.nrmOwnerUid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.nrmOwnerUid);
                    break;
                case /* repeated TST.HeaderNameMgrArchive.PerTableArchive per_tables */ 3:
                    message.perTables.push(exports.HeaderNameMgrArchive_PerTableArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference name_frag_tiles */ 4:
                    message.nameFragTiles.push(TSPMessages_10.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID owner_uid = 1; */
        if (message.ownerUid)
            TSPMessages_11.UUID.internalBinaryWrite(message.ownerUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID nrm_owner_uid = 2; */
        if (message.nrmOwnerUid)
            TSPMessages_11.UUID.internalBinaryWrite(message.nrmOwnerUid, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TST.HeaderNameMgrArchive.PerTableArchive per_tables = 3; */
        for (let i = 0; i < message.perTables.length; i++)
            exports.HeaderNameMgrArchive_PerTableArchive.internalBinaryWrite(message.perTables[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference name_frag_tiles = 4; */
        for (let i = 0; i < message.nameFragTiles.length; i++)
            TSPMessages_10.Reference.internalBinaryWrite(message.nameFragTiles[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.HeaderNameMgrArchive
 */
exports.HeaderNameMgrArchive = new HeaderNameMgrArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeaderNameMgrArchive_PerTableArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.HeaderNameMgrArchive.PerTableArchive", [
            { no: 1, name: "table_uid", kind: "message", T: () => TSPMessages_11.UUID },
            { no: 2, name: "per_table_precedent", kind: "message", T: () => TSCEArchives_20.CellCoordinateArchive },
            { no: 3, name: "is_deleted", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "header_row_uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_11.UUID },
            { no: 6, name: "header_column_uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_11.UUID },
            { no: 7, name: "update_header_row_uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_11.UUID },
            { no: 8, name: "update_header_column_uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_11.UUID }
        ]);
    }
    create(value) {
        const message = { headerRowUids: [], headerColumnUids: [], updateHeaderRowUids: [], updateHeaderColumnUids: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUID table_uid */ 1:
                    message.tableUid = TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options, message.tableUid);
                    break;
                case /* TSCE.CellCoordinateArchive per_table_precedent */ 2:
                    message.perTablePrecedent = TSCEArchives_20.CellCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.perTablePrecedent);
                    break;
                case /* optional bool is_deleted */ 3:
                    message.isDeleted = reader.bool();
                    break;
                case /* repeated TSP.UUID header_row_uids */ 5:
                    message.headerRowUids.push(TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID header_column_uids */ 6:
                    message.headerColumnUids.push(TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID update_header_row_uids */ 7:
                    message.updateHeaderRowUids.push(TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID update_header_column_uids */ 8:
                    message.updateHeaderColumnUids.push(TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUID table_uid = 1; */
        if (message.tableUid)
            TSPMessages_11.UUID.internalBinaryWrite(message.tableUid, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSCE.CellCoordinateArchive per_table_precedent = 2; */
        if (message.perTablePrecedent)
            TSCEArchives_20.CellCoordinateArchive.internalBinaryWrite(message.perTablePrecedent, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_deleted = 3; */
        if (message.isDeleted !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.isDeleted);
        /* repeated TSP.UUID header_row_uids = 5; */
        for (let i = 0; i < message.headerRowUids.length; i++)
            TSPMessages_11.UUID.internalBinaryWrite(message.headerRowUids[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID header_column_uids = 6; */
        for (let i = 0; i < message.headerColumnUids.length; i++)
            TSPMessages_11.UUID.internalBinaryWrite(message.headerColumnUids[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID update_header_row_uids = 7; */
        for (let i = 0; i < message.updateHeaderRowUids.length; i++)
            TSPMessages_11.UUID.internalBinaryWrite(message.updateHeaderRowUids[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID update_header_column_uids = 8; */
        for (let i = 0; i < message.updateHeaderColumnUids.length; i++)
            TSPMessages_11.UUID.internalBinaryWrite(message.updateHeaderColumnUids[i], writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.HeaderNameMgrArchive.PerTableArchive
 */
exports.HeaderNameMgrArchive_PerTableArchive = new HeaderNameMgrArchive_PerTableArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WidthHeightCacheFittingEntry$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.WidthHeightCacheFittingEntry", [
            { no: 1, name: "fitting_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "fitting_size", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 fitting_index */ 1:
                    message.fittingIndex = reader.uint32();
                    break;
                case /* optional float fitting_size */ 2:
                    message.fittingSize = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional uint32 fitting_index = 1; */
        if (message.fittingIndex !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.fittingIndex);
        /* optional float fitting_size = 2; */
        if (message.fittingSize !== undefined)
            writer.tag(2, runtime_1.WireType.Bit32).float(message.fittingSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.WidthHeightCacheFittingEntry
 */
exports.WidthHeightCacheFittingEntry = new WidthHeightCacheFittingEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WidthHeightCache$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.WidthHeightCache", [
            { no: 1, name: "rows_fitting_entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.WidthHeightCacheFittingEntry },
            { no: 3, name: "columns_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { rowsFittingEntries: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TST.WidthHeightCacheFittingEntry rows_fitting_entries */ 1:
                    message.rowsFittingEntries.push(exports.WidthHeightCacheFittingEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 columns_count */ 3:
                    message.columnsCount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TST.WidthHeightCacheFittingEntry rows_fitting_entries = 1; */
        for (let i = 0; i < message.rowsFittingEntries.length; i++)
            exports.WidthHeightCacheFittingEntry.internalBinaryWrite(message.rowsFittingEntries[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 columns_count = 3; */
        if (message.columnsCount !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.columnsCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.WidthHeightCache
 */
exports.WidthHeightCache = new WidthHeightCache$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LayoutEngineArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.LayoutEngineArchive", [
            { no: 1, name: "width_height_cache", kind: "message", T: () => exports.WidthHeightCache }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TST.WidthHeightCache width_height_cache */ 1:
                    message.widthHeightCache = exports.WidthHeightCache.internalBinaryRead(reader, reader.uint32(), options, message.widthHeightCache);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TST.WidthHeightCache width_height_cache = 1; */
        if (message.widthHeightCache)
            exports.WidthHeightCache.internalBinaryWrite(message.widthHeightCache, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.LayoutEngineArchive
 */
exports.LayoutEngineArchive = new LayoutEngineArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CollaboratorTableCursorSubselectionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CollaboratorTableCursorSubselectionArchive", [
            { no: 1, name: "cell_uid_list", kind: "message", T: () => exports.CellUIDListArchive },
            { no: 3, name: "selection_type", kind: "enum", opt: true, T: () => ["TST.SelectionTypeArchive", SelectionTypeArchive] },
            { no: 4, name: "row_column_uid_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_11.UUID }
        ]);
    }
    create(value) {
        const message = { rowColumnUidList: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TST.CellUIDListArchive cell_uid_list */ 1:
                    message.cellUidList = exports.CellUIDListArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellUidList);
                    break;
                case /* optional TST.SelectionTypeArchive selection_type */ 3:
                    message.selectionType = reader.int32();
                    break;
                case /* repeated TSP.UUID row_column_uid_list */ 4:
                    message.rowColumnUidList.push(TSPMessages_11.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TST.CellUIDListArchive cell_uid_list = 1; */
        if (message.cellUidList)
            exports.CellUIDListArchive.internalBinaryWrite(message.cellUidList, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.SelectionTypeArchive selection_type = 3; */
        if (message.selectionType !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.selectionType);
        /* repeated TSP.UUID row_column_uid_list = 4; */
        for (let i = 0; i < message.rowColumnUidList.length; i++)
            TSPMessages_11.UUID.internalBinaryWrite(message.rowColumnUidList[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CollaboratorTableCursorSubselectionArchive
 */
exports.CollaboratorTableCursorSubselectionArchive = new CollaboratorTableCursorSubselectionArchive$Type();
//# sourceMappingURL=TSTArchives.js.map