"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandSetNegativeNumberStyleArchive = exports.CommandSetFractionAccuracyArchive = exports.CommandSetCurrencyCodeArchive = exports.CommandSetBaseUseMinusSignArchive = exports.CommandSetBasePlacesArchive = exports.CommandSetBaseArchive = exports.CommandApplyTableStylePresetArchive = exports.CommandReplaceTableStylePresetArchive = exports.CommandRemoveTableStylePresetArchive = exports.CommandAddTableStylePresetArchive = exports.CommandSetFiltersEnabledArchive = exports.CommandSetRepeatingHeaderEnabledArchive = exports.CommandStyleTableArchive = exports.CommandStyleCellsArchive = exports.CommandSetWasCutArchive = exports.CommandSetNowArchive = exports.CommandSetTableNameHeightArchive = exports.CommandSetTableFontNameArchive = exports.CommandSetTableFontSizeArchive = exports.CommandSetTableNameEnabledArchive = exports.CommandSetTableNameArchive = exports.CommandSetPencilAnnotationsArchive = exports.CommandChangeTableAreaForColumnOrRowArchive = exports.CommandPostflightSetCellArchive = exports.CommandTextPreflightInsertCellArchive = exports.CommandHideShowArchive = exports.CommandCategoryResizeColumnOrRowArchive = exports.CommandResizeColumnOrRowArchive = exports.CommandRowColumnRangeArchive = exports.CommandRemoveColumnsOrRowsArchive = exports.ColumnRowBundleArchive = exports.CommandInsertColumnsOrRowsArchive = exports.ColumnRowMetadataArchive = exports.CommandMoveCellsArchive = exports.CommandReplaceCustomFormatArchive = exports.CommandSetDurationUnitSmallestLargestArchive = exports.CommandSetDurationStyleArchive = exports.CommandSetAutomaticDurationUnitsArchive = exports.CommandMutateCellFormatArchive = exports.CommandDeleteCellContentsArchive = exports.CommandDeleteCellsArchive = exports.CommandChangeFreezeHeaderStateArchive = exports.CommandApplyConcurrentCellMapArchive = exports.CommandApplyCellMapArchive = exports.CommandApplyCellDiffMapArchive = exports.CommandApplyCellContentsArchive = exports.TableCommandArchive = exports.ColumnRowBundleItemTypeEnum = exports.TableAreaTransition = exports.TableArea = void 0;
exports.RegionSelectionTransformerArchive = exports.StockCellSelectionTransformerArchive = exports.ControlCellSelectionTransformerArchive = exports.TableNameSelectionTransformerArchive = exports.TableSubSelectionTransformerBaseArchive = exports.WPSelectionTransformerArchive = exports.IdempotentSelectionTransformerArchive = exports.CommandCategoryWillChangeGroupValue = exports.CommandCategorySetLabelRowVisibility = exports.CommandCategoryChangeSummaryAggregateType = exports.CommandCategoryCollapseExpandGroupArchive = exports.CommandSetStructuredTextImportRecordArchive = exports.CommandTransposeTableArchive = exports.ColumnRowRestoreDataArchive = exports.CommandSetFilterSetArchive = exports.CommandRewriteSortOrderForRewriteSpecArchive = exports.CommandRewriteSortOrderForTableResizeArchive = exports.CommandSetGroupSortOrderArchive = exports.CommandSetSortOrderArchive = exports.CommandSetStorageLanguageArchive = exports.CommandJustForNotifyingArchive = exports.CommandSetTextStylePropertiesArchive = exports.CommandSetTextStyleArchive = exports.CommandSetFilterSetTypeArchive = exports.CommandSetFormulaTokenizationArchive = exports.CommandApplyCellCommentArchive = exports.TableCommandSelectionBehaviorArchive = exports.FormulaEditingCommandSelectionBehaviorArchive = exports.FormulaEditingCommandGroupArchive = exports.CommandCategorySetGroupingColumnsArchive = exports.CommandChooseTableIdRemapperArchive = exports.CommandUnmergeArchive = exports.CommandInverseMergeArchive = exports.CommandMergeArchive = exports.CommandRewritePivotOwnerFormulasArchive = exports.CommandRewriteConditionalStylesForRewriteSpecArchive = exports.CommandRewriteFilterFormulasForRewriteSpecArchive = exports.CommandRewriteFilterFormulasForTableResizeArchive = exports.CommandRewriteCategoryFormulasArchive = exports.CommandRewriteMergeFormulasArchive = exports.CommandRewriteTableFormulasForRewriteSpecArchive = exports.CommandRewriteFormulasForTransposeArchive = exports.FormulaRewriteSpecArchive = exports.CommandSortArchive = exports.CommandMoveColumnsOrRowsArchive = exports.CommandSetRangeControlMinMaxIncArchive = exports.CommandSetUseAccountingStyleArchive = exports.CommandSetShowThousandsSeparatorArchive = exports.CommandSetDateTimeFormatArchive = exports.CommandSetNumberOfDecimalPlacesArchive = void 0;
exports.CommandExtendTableIDHistoryArchive = exports.CommandRewriteTrackedReferencesArchive = exports.CommandPivotSortArchive = exports.CommandPivotHideShowGrandTotalsArchive = exports.CommandPivotSetGroupingColumnOptionsArchive = exports.CommandPivotSetPivotRulesArchive = exports.CommandRewritePencilAnnotationFormulasArchive_AnnotationPair = exports.CommandRewritePencilAnnotationFormulasArchive = exports.CommandRewriteHiddenStatesForGroupByChangeArchive = exports.CommandCategoryMoveRowsArchive = exports.RowColumnSelectionTransformerArchive = exports.StrokeSelectionTransformerArchive = void 0;
const runtime_1 = require("@protobuf-ts/runtime");
const runtime_2 = require("@protobuf-ts/runtime");
const runtime_3 = require("@protobuf-ts/runtime");
const runtime_4 = require("@protobuf-ts/runtime");
const runtime_5 = require("@protobuf-ts/runtime");
const TSTArchives_1 = require("./TSTArchives");
const TSTArchives_2 = require("./TSTArchives");
const TSCEArchives_1 = require("./TSCEArchives");
const TSCEArchives_2 = require("./TSCEArchives");
const TSTArchives_3 = require("./TSTArchives");
const TSTArchives_4 = require("./TSTArchives");
const TSTArchives_5 = require("./TSTArchives");
const TSTArchives_6 = require("./TSTArchives");
const TSTArchives_7 = require("./TSTArchives");
const TSWPArchives_1 = require("./TSWPArchives");
const TSTArchives_8 = require("./TSTArchives");
const TSDCommandArchives_1 = require("./TSDCommandArchives");
const TSKArchives_1 = require("./TSKArchives");
const TSKArchives_2 = require("./TSKArchives");
const TSTArchives_9 = require("./TSTArchives");
const TSTArchives_10 = require("./TSTArchives");
const TSTArchives_11 = require("./TSTArchives");
const TSTArchives_12 = require("./TSTArchives");
const TSCEArchives_3 = require("./TSCEArchives");
const TSTArchives_13 = require("./TSTArchives");
const TSCEArchives_4 = require("./TSCEArchives");
const TSCEArchives_5 = require("./TSCEArchives");
const TSCEArchives_6 = require("./TSCEArchives");
const TSCEArchives_7 = require("./TSCEArchives");
const TSCEArchives_8 = require("./TSCEArchives");
const TSCEArchives_9 = require("./TSCEArchives");
const TSCEArchives_10 = require("./TSCEArchives");
const TSCEArchives_11 = require("./TSCEArchives");
const TSCEArchives_12 = require("./TSCEArchives");
const TSCEArchives_13 = require("./TSCEArchives");
const TSTArchives_sos_1 = require("./TSTArchives_sos");
const TSTArchives_14 = require("./TSTArchives");
const TSPMessages_1 = require("./TSPMessages");
const TSCEArchives_14 = require("./TSCEArchives");
const TSKArchives_3 = require("./TSKArchives");
const TSPMessages_2 = require("./TSPMessages");
const TSTArchives_15 = require("./TSTArchives");
const TSTArchives_16 = require("./TSTArchives");
const TSTArchives_17 = require("./TSTArchives");
const TSTArchives_18 = require("./TSTArchives");
const TSTArchives_19 = require("./TSTArchives");
const TSPMessages_3 = require("./TSPMessages");
const TSTArchives_20 = require("./TSTArchives");
const TSTArchives_21 = require("./TSTArchives");
const TSTArchives_22 = require("./TSTArchives");
const TSPMessages_4 = require("./TSPMessages");
const TSPMessages_5 = require("./TSPMessages");
const TSPMessages_6 = require("./TSPMessages");
const TSKArchives_4 = require("./TSKArchives");
/**
 * @generated from protobuf enum TST.TableArea
 */
var TableArea;
(function (TableArea) {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    TableArea[TableArea["UNSPECIFIED$"] = 0] = "UNSPECIFIED$";
    /**
     * @generated from protobuf enum value: TableAreaBody = 1;
     */
    TableArea[TableArea["TableAreaBody"] = 1] = "TableAreaBody";
    /**
     * @generated from protobuf enum value: TableAreaHeaderRow = 2;
     */
    TableArea[TableArea["TableAreaHeaderRow"] = 2] = "TableAreaHeaderRow";
    /**
     * @generated from protobuf enum value: TableAreaHeaderColumn = 3;
     */
    TableArea[TableArea["TableAreaHeaderColumn"] = 3] = "TableAreaHeaderColumn";
    /**
     * @generated from protobuf enum value: TableAreaFooterRow = 4;
     */
    TableArea[TableArea["TableAreaFooterRow"] = 4] = "TableAreaFooterRow";
})(TableArea = exports.TableArea || (exports.TableArea = {}));
/**
 * @generated from protobuf enum TST.TableAreaTransition
 */
var TableAreaTransition;
(function (TableAreaTransition) {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    TableAreaTransition[TableAreaTransition["UNSPECIFIED$"] = 0] = "UNSPECIFIED$";
    /**
     * @generated from protobuf enum value: TableAreaTransitionHeaderRowToBody = 1;
     */
    TableAreaTransition[TableAreaTransition["TableAreaTransitionHeaderRowToBody"] = 1] = "TableAreaTransitionHeaderRowToBody";
    /**
     * @generated from protobuf enum value: TableAreaTransitionBodyToHeaderRow = 2;
     */
    TableAreaTransition[TableAreaTransition["TableAreaTransitionBodyToHeaderRow"] = 2] = "TableAreaTransitionBodyToHeaderRow";
    /**
     * @generated from protobuf enum value: TableAreaTransitionFooterRowToBody = 3;
     */
    TableAreaTransition[TableAreaTransition["TableAreaTransitionFooterRowToBody"] = 3] = "TableAreaTransitionFooterRowToBody";
    /**
     * @generated from protobuf enum value: TableAreaTransitionBodyToFooterRow = 4;
     */
    TableAreaTransition[TableAreaTransition["TableAreaTransitionBodyToFooterRow"] = 4] = "TableAreaTransitionBodyToFooterRow";
    /**
     * @generated from protobuf enum value: TableAreaTransitionHeaderColumnToBody = 5;
     */
    TableAreaTransition[TableAreaTransition["TableAreaTransitionHeaderColumnToBody"] = 5] = "TableAreaTransitionHeaderColumnToBody";
    /**
     * @generated from protobuf enum value: TableAreaTransitionBodyToHeaderColumn = 6;
     */
    TableAreaTransition[TableAreaTransition["TableAreaTransitionBodyToHeaderColumn"] = 6] = "TableAreaTransitionBodyToHeaderColumn";
})(TableAreaTransition = exports.TableAreaTransition || (exports.TableAreaTransition = {}));
/**
 * @generated from protobuf enum TST.ColumnRowBundleItemTypeEnum
 */
var ColumnRowBundleItemTypeEnum;
(function (ColumnRowBundleItemTypeEnum) {
    /**
     * @generated from protobuf enum value: ColumnRowTypeAnchor = 0;
     */
    ColumnRowBundleItemTypeEnum[ColumnRowBundleItemTypeEnum["ColumnRowTypeAnchor"] = 0] = "ColumnRowTypeAnchor";
    /**
     * @generated from protobuf enum value: ColumnRowTypeHeaderRow = 1;
     */
    ColumnRowBundleItemTypeEnum[ColumnRowBundleItemTypeEnum["ColumnRowTypeHeaderRow"] = 1] = "ColumnRowTypeHeaderRow";
    /**
     * @generated from protobuf enum value: ColumnRowTypeBodyRow = 2;
     */
    ColumnRowBundleItemTypeEnum[ColumnRowBundleItemTypeEnum["ColumnRowTypeBodyRow"] = 2] = "ColumnRowTypeBodyRow";
    /**
     * @generated from protobuf enum value: ColumnRowTypeFooterRow = 3;
     */
    ColumnRowBundleItemTypeEnum[ColumnRowBundleItemTypeEnum["ColumnRowTypeFooterRow"] = 3] = "ColumnRowTypeFooterRow";
    /**
     * @generated from protobuf enum value: ColumnRowTypeHeaderColumn = 4;
     */
    ColumnRowBundleItemTypeEnum[ColumnRowBundleItemTypeEnum["ColumnRowTypeHeaderColumn"] = 4] = "ColumnRowTypeHeaderColumn";
    /**
     * @generated from protobuf enum value: ColumnRowTypeBodyColumn = 5;
     */
    ColumnRowBundleItemTypeEnum[ColumnRowBundleItemTypeEnum["ColumnRowTypeBodyColumn"] = 5] = "ColumnRowTypeBodyColumn";
})(ColumnRowBundleItemTypeEnum = exports.ColumnRowBundleItemTypeEnum || (exports.ColumnRowBundleItemTypeEnum = {}));
// @generated message type with reflection information, may provide speed optimized methods
class TableCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.TableCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_4.CommandArchive },
            { no: 2, name: "table_info_id_path", kind: "message", T: () => TSPMessages_6.UUIDPath },
            { no: 3, name: "commandname", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "default_cell_styles_container", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 5, name: "timestamp", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "random_seed_lo", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "random_seed_hi", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "is_inverse", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "old_timestamp", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 10, name: "old_random_seed", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_4.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUIDPath table_info_id_path */ 2:
                    message.tableInfoIdPath = TSPMessages_6.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.tableInfoIdPath);
                    break;
                case /* optional string commandname */ 3:
                    message.commandname = reader.string();
                    break;
                case /* optional TSP.Reference default_cell_styles_container */ 4:
                    message.defaultCellStylesContainer = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.defaultCellStylesContainer);
                    break;
                case /* optional double timestamp */ 5:
                    message.timestamp = reader.double();
                    break;
                case /* optional uint32 random_seed_lo */ 6:
                    message.randomSeedLo = reader.uint32();
                    break;
                case /* optional uint32 random_seed_hi */ 7:
                    message.randomSeedHi = reader.uint32();
                    break;
                case /* optional bool is_inverse */ 8:
                    message.isInverse = reader.bool();
                    break;
                case /* optional double old_timestamp */ 9:
                    message.oldTimestamp = reader.double();
                    break;
                case /* optional uint64 old_random_seed */ 10:
                    message.oldRandomSeed = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_4.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUIDPath table_info_id_path = 2; */
        if (message.tableInfoIdPath)
            TSPMessages_6.UUIDPath.internalBinaryWrite(message.tableInfoIdPath, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string commandname = 3; */
        if (message.commandname !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.commandname);
        /* optional TSP.Reference default_cell_styles_container = 4; */
        if (message.defaultCellStylesContainer)
            TSPMessages_5.Reference.internalBinaryWrite(message.defaultCellStylesContainer, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional double timestamp = 5; */
        if (message.timestamp !== undefined)
            writer.tag(5, runtime_1.WireType.Bit64).double(message.timestamp);
        /* optional uint32 random_seed_lo = 6; */
        if (message.randomSeedLo !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).uint32(message.randomSeedLo);
        /* optional uint32 random_seed_hi = 7; */
        if (message.randomSeedHi !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).uint32(message.randomSeedHi);
        /* optional bool is_inverse = 8; */
        if (message.isInverse !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.isInverse);
        /* optional double old_timestamp = 9; */
        if (message.oldTimestamp !== undefined)
            writer.tag(9, runtime_1.WireType.Bit64).double(message.oldTimestamp);
        /* optional uint64 old_random_seed = 10; */
        if (message.oldRandomSeed !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).uint64(message.oldRandomSeed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.TableCommandArchive
 */
exports.TableCommandArchive = new TableCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandApplyCellContentsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandApplyCellContentsArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "cell_diff_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 3, name: "rollback_cell_diff_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 4, name: "custom_format_keys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 5, name: "action_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { customFormatKeys: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Reference cell_diff_map */ 2:
                    message.cellDiffMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.cellDiffMap);
                    break;
                case /* optional TSP.Reference rollback_cell_diff_map */ 3:
                    message.rollbackCellDiffMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.rollbackCellDiffMap);
                    break;
                case /* repeated TSP.UUID custom_format_keys */ 4:
                    message.customFormatKeys.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string action_string */ 5:
                    message.actionString = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference cell_diff_map = 2; */
        if (message.cellDiffMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.cellDiffMap, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference rollback_cell_diff_map = 3; */
        if (message.rollbackCellDiffMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.rollbackCellDiffMap, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID custom_format_keys = 4; */
        for (let i = 0; i < message.customFormatKeys.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.customFormatKeys[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string action_string = 5; */
        if (message.actionString !== undefined)
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.actionString);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandApplyCellContentsArchive
 */
exports.CommandApplyCellContentsArchive = new CommandApplyCellContentsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandApplyCellDiffMapArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandApplyCellDiffMapArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "cell_diff_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 3, name: "should_allow_merge_fragments", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "inverse_cell_diff_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 5, name: "custom_format_keys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID }
        ]);
    }
    create(value) {
        const message = { shouldAllowMergeFragments: false, customFormatKeys: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Reference cell_diff_map */ 2:
                    message.cellDiffMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.cellDiffMap);
                    break;
                case /* bool should_allow_merge_fragments */ 3:
                    message.shouldAllowMergeFragments = reader.bool();
                    break;
                case /* optional TSP.Reference inverse_cell_diff_map */ 4:
                    message.inverseCellDiffMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.inverseCellDiffMap);
                    break;
                case /* repeated TSP.UUID custom_format_keys */ 5:
                    message.customFormatKeys.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference cell_diff_map = 2; */
        if (message.cellDiffMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.cellDiffMap, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool should_allow_merge_fragments = 3; */
        if (message.shouldAllowMergeFragments !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.shouldAllowMergeFragments);
        /* optional TSP.Reference inverse_cell_diff_map = 4; */
        if (message.inverseCellDiffMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.inverseCellDiffMap, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID custom_format_keys = 5; */
        for (let i = 0; i < message.customFormatKeys.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.customFormatKeys[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandApplyCellDiffMapArchive
 */
exports.CommandApplyCellDiffMapArchive = new CommandApplyCellDiffMapArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandApplyCellMapArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandApplyCellMapArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "redo_cell_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 3, name: "undo_cell_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 4, name: "undo_formula_rewrite_command", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 5, name: "custom_format_keys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 6, name: "merge_owner_rollback_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "is_from_paste", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "formula_rewrite_commands", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = { customFormatKeys: [], isFromPaste: false, formulaRewriteCommands: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Reference redo_cell_map */ 2:
                    message.redoCellMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.redoCellMap);
                    break;
                case /* optional TSP.Reference undo_cell_map */ 3:
                    message.undoCellMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoCellMap);
                    break;
                case /* optional TSP.Reference undo_formula_rewrite_command */ 4:
                    message.undoFormulaRewriteCommand = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoFormulaRewriteCommand);
                    break;
                case /* repeated TSP.UUID custom_format_keys */ 5:
                    message.customFormatKeys.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 merge_owner_rollback_index */ 6:
                    message.mergeOwnerRollbackIndex = reader.uint32();
                    break;
                case /* bool is_from_paste */ 7:
                    message.isFromPaste = reader.bool();
                    break;
                case /* repeated TSP.Reference formula_rewrite_commands */ 8:
                    message.formulaRewriteCommands.push(TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference redo_cell_map = 2; */
        if (message.redoCellMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.redoCellMap, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_cell_map = 3; */
        if (message.undoCellMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.undoCellMap, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_formula_rewrite_command = 4; */
        if (message.undoFormulaRewriteCommand)
            TSPMessages_5.Reference.internalBinaryWrite(message.undoFormulaRewriteCommand, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID custom_format_keys = 5; */
        for (let i = 0; i < message.customFormatKeys.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.customFormatKeys[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 merge_owner_rollback_index = 6; */
        if (message.mergeOwnerRollbackIndex !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).uint32(message.mergeOwnerRollbackIndex);
        /* bool is_from_paste = 7; */
        if (message.isFromPaste !== false)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.isFromPaste);
        /* repeated TSP.Reference formula_rewrite_commands = 8; */
        for (let i = 0; i < message.formulaRewriteCommands.length; i++)
            TSPMessages_5.Reference.internalBinaryWrite(message.formulaRewriteCommands[i], writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandApplyCellMapArchive
 */
exports.CommandApplyCellMapArchive = new CommandApplyCellMapArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandApplyConcurrentCellMapArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandApplyConcurrentCellMapArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "redo_concurrent_cell_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 3, name: "undo_concurrent_cell_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 4, name: "undo_formula_rewrite_command", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 5, name: "custom_format_keys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 6, name: "merge_owner_rollback_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "is_from_paste", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "formula_rewrite_commands", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = { customFormatKeys: [], isFromPaste: false, formulaRewriteCommands: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Reference redo_concurrent_cell_map */ 2:
                    message.redoConcurrentCellMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.redoConcurrentCellMap);
                    break;
                case /* optional TSP.Reference undo_concurrent_cell_map */ 3:
                    message.undoConcurrentCellMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoConcurrentCellMap);
                    break;
                case /* optional TSP.Reference undo_formula_rewrite_command */ 4:
                    message.undoFormulaRewriteCommand = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoFormulaRewriteCommand);
                    break;
                case /* repeated TSP.UUID custom_format_keys */ 5:
                    message.customFormatKeys.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 merge_owner_rollback_index */ 6:
                    message.mergeOwnerRollbackIndex = reader.uint32();
                    break;
                case /* bool is_from_paste */ 7:
                    message.isFromPaste = reader.bool();
                    break;
                case /* repeated TSP.Reference formula_rewrite_commands */ 8:
                    message.formulaRewriteCommands.push(TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference redo_concurrent_cell_map = 2; */
        if (message.redoConcurrentCellMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.redoConcurrentCellMap, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_concurrent_cell_map = 3; */
        if (message.undoConcurrentCellMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.undoConcurrentCellMap, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_formula_rewrite_command = 4; */
        if (message.undoFormulaRewriteCommand)
            TSPMessages_5.Reference.internalBinaryWrite(message.undoFormulaRewriteCommand, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID custom_format_keys = 5; */
        for (let i = 0; i < message.customFormatKeys.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.customFormatKeys[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 merge_owner_rollback_index = 6; */
        if (message.mergeOwnerRollbackIndex !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).uint32(message.mergeOwnerRollbackIndex);
        /* bool is_from_paste = 7; */
        if (message.isFromPaste !== false)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.isFromPaste);
        /* repeated TSP.Reference formula_rewrite_commands = 8; */
        for (let i = 0; i < message.formulaRewriteCommands.length; i++)
            TSPMessages_5.Reference.internalBinaryWrite(message.formulaRewriteCommands[i], writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandApplyConcurrentCellMapArchive
 */
exports.CommandApplyConcurrentCellMapArchive = new CommandApplyConcurrentCellMapArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandChangeFreezeHeaderStateArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandChangeFreezeHeaderStateArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "direction", kind: "enum", T: () => ["TST.TableDimensionArchive", TSTArchives_22.TableDimensionArchive] },
            { no: 3, name: "new_freeze_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "prev_freeze_state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { direction: 0, newFreezeState: false, prevFreezeState: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TST.TableDimensionArchive direction */ 2:
                    message.direction = reader.int32();
                    break;
                case /* bool new_freeze_state */ 3:
                    message.newFreezeState = reader.bool();
                    break;
                case /* bool prev_freeze_state */ 4:
                    message.prevFreezeState = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.TableDimensionArchive direction = 2; */
        if (message.direction !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.direction);
        /* bool new_freeze_state = 3; */
        if (message.newFreezeState !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.newFreezeState);
        /* bool prev_freeze_state = 4; */
        if (message.prevFreezeState !== false)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.prevFreezeState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandChangeFreezeHeaderStateArchive
 */
exports.CommandChangeFreezeHeaderStateArchive = new CommandChangeFreezeHeaderStateArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandDeleteCellsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandDeleteCellsArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 5, name: "invalidate_comments", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "invalidate_comments_valid", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "cell_uid_region", kind: "message", T: () => TSTArchives_21.CellUIDRegionArchive },
            { no: 8, name: "summary_cell_uid_list", kind: "message", T: () => TSTArchives_20.CellUIDListArchive },
            { no: 9, name: "inverse_concurrent_cell_map", kind: "message", T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional bool invalidate_comments */ 5:
                    message.invalidateComments = reader.bool();
                    break;
                case /* optional bool invalidate_comments_valid */ 6:
                    message.invalidateCommentsValid = reader.bool();
                    break;
                case /* optional TST.CellUIDRegionArchive cell_uid_region */ 7:
                    message.cellUidRegion = TSTArchives_21.CellUIDRegionArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellUidRegion);
                    break;
                case /* optional TST.CellUIDListArchive summary_cell_uid_list */ 8:
                    message.summaryCellUidList = TSTArchives_20.CellUIDListArchive.internalBinaryRead(reader, reader.uint32(), options, message.summaryCellUidList);
                    break;
                case /* optional TSP.Reference inverse_concurrent_cell_map */ 9:
                    message.inverseConcurrentCellMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.inverseConcurrentCellMap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool invalidate_comments = 5; */
        if (message.invalidateComments !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.invalidateComments);
        /* optional bool invalidate_comments_valid = 6; */
        if (message.invalidateCommentsValid !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.invalidateCommentsValid);
        /* optional TST.CellUIDRegionArchive cell_uid_region = 7; */
        if (message.cellUidRegion)
            TSTArchives_21.CellUIDRegionArchive.internalBinaryWrite(message.cellUidRegion, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.CellUIDListArchive summary_cell_uid_list = 8; */
        if (message.summaryCellUidList)
            TSTArchives_20.CellUIDListArchive.internalBinaryWrite(message.summaryCellUidList, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference inverse_concurrent_cell_map = 9; */
        if (message.inverseConcurrentCellMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.inverseConcurrentCellMap, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandDeleteCellsArchive
 */
exports.CommandDeleteCellsArchive = new CommandDeleteCellsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandDeleteCellContentsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandDeleteCellContentsArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "cell_uid_list", kind: "message", T: () => TSTArchives_20.CellUIDListArchive },
            { no: 3, name: "inverse_cell_diff_map", kind: "message", T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TST.CellUIDListArchive cell_uid_list */ 2:
                    message.cellUidList = TSTArchives_20.CellUIDListArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellUidList);
                    break;
                case /* optional TSP.Reference inverse_cell_diff_map */ 3:
                    message.inverseCellDiffMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.inverseCellDiffMap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.CellUIDListArchive cell_uid_list = 2; */
        if (message.cellUidList)
            TSTArchives_20.CellUIDListArchive.internalBinaryWrite(message.cellUidList, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference inverse_cell_diff_map = 3; */
        if (message.inverseCellDiffMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.inverseCellDiffMap, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandDeleteCellContentsArchive
 */
exports.CommandDeleteCellContentsArchive = new CommandDeleteCellContentsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandMutateCellFormatArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandMutateCellFormatArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "cell_uid_list", kind: "message", T: () => TSTArchives_20.CellUIDListArchive },
            { no: 3, name: "inverse_cell_diff_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 4, name: "whole_format_diff_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 5, name: "intended_format_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { intendedFormatType: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TST.CellUIDListArchive cell_uid_list */ 2:
                    message.cellUidList = TSTArchives_20.CellUIDListArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellUidList);
                    break;
                case /* optional TSP.Reference inverse_cell_diff_map */ 3:
                    message.inverseCellDiffMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.inverseCellDiffMap);
                    break;
                case /* optional TSP.Reference whole_format_diff_map */ 4:
                    message.wholeFormatDiffMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.wholeFormatDiffMap);
                    break;
                case /* uint32 intended_format_type */ 5:
                    message.intendedFormatType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.CellUIDListArchive cell_uid_list = 2; */
        if (message.cellUidList)
            TSTArchives_20.CellUIDListArchive.internalBinaryWrite(message.cellUidList, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference inverse_cell_diff_map = 3; */
        if (message.inverseCellDiffMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.inverseCellDiffMap, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference whole_format_diff_map = 4; */
        if (message.wholeFormatDiffMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.wholeFormatDiffMap, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 intended_format_type = 5; */
        if (message.intendedFormatType !== 0)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.intendedFormatType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandMutateCellFormatArchive
 */
exports.CommandMutateCellFormatArchive = new CommandMutateCellFormatArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetAutomaticDurationUnitsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetAutomaticDurationUnitsArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandMutateCellFormatArchive },
            { no: 4, name: "automatic_units", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.CommandMutateCellFormatArchive super */ 1:
                    message.super = exports.CommandMutateCellFormatArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional bool automatic_units */ 4:
                    message.automaticUnits = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.CommandMutateCellFormatArchive super = 1; */
        if (message.super)
            exports.CommandMutateCellFormatArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool automatic_units = 4; */
        if (message.automaticUnits !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.automaticUnits);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetAutomaticDurationUnitsArchive
 */
exports.CommandSetAutomaticDurationUnitsArchive = new CommandSetAutomaticDurationUnitsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetDurationStyleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetDurationStyleArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandMutateCellFormatArchive },
            { no: 2, name: "duration_style", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.CommandMutateCellFormatArchive super */ 1:
                    message.super = exports.CommandMutateCellFormatArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional uint32 duration_style */ 2:
                    message.durationStyle = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.CommandMutateCellFormatArchive super = 1; */
        if (message.super)
            exports.CommandMutateCellFormatArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 duration_style = 2; */
        if (message.durationStyle !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.durationStyle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetDurationStyleArchive
 */
exports.CommandSetDurationStyleArchive = new CommandSetDurationStyleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetDurationUnitSmallestLargestArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetDurationUnitSmallestLargestArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandMutateCellFormatArchive },
            { no: 2, name: "smallest_unit", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "largest_unit", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.CommandMutateCellFormatArchive super */ 1:
                    message.super = exports.CommandMutateCellFormatArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional uint32 smallest_unit */ 2:
                    message.smallestUnit = reader.uint32();
                    break;
                case /* optional uint32 largest_unit */ 3:
                    message.largestUnit = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.CommandMutateCellFormatArchive super = 1; */
        if (message.super)
            exports.CommandMutateCellFormatArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 smallest_unit = 2; */
        if (message.smallestUnit !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.smallestUnit);
        /* optional uint32 largest_unit = 3; */
        if (message.largestUnit !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.largestUnit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetDurationUnitSmallestLargestArchive
 */
exports.CommandSetDurationUnitSmallestLargestArchive = new CommandSetDurationUnitSmallestLargestArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandReplaceCustomFormatArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandReplaceCustomFormatArchive", [
            { no: 1, name: "undo_diff_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 2, name: "commit_diff_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 6, name: "super", kind: "message", T: () => exports.TableCommandArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference undo_diff_map */ 1:
                    message.undoDiffMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoDiffMap);
                    break;
                case /* optional TSP.Reference commit_diff_map */ 2:
                    message.commitDiffMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.commitDiffMap);
                    break;
                case /* TST.TableCommandArchive super */ 6:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference undo_diff_map = 1; */
        if (message.undoDiffMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.undoDiffMap, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference commit_diff_map = 2; */
        if (message.commitDiffMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.commitDiffMap, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.TableCommandArchive super = 6; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandReplaceCustomFormatArchive
 */
exports.CommandReplaceCustomFormatArchive = new CommandReplaceCustomFormatArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandMoveCellsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandMoveCellsArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "dst_table_info_id_path", kind: "message", T: () => TSPMessages_6.UUIDPath },
            { no: 3, name: "src_uid_range", kind: "message", T: () => TSPMessages_3.UUIDRectArchive },
            { no: 4, name: "dst_uid_range", kind: "message", T: () => TSPMessages_3.UUIDRectArchive },
            { no: 5, name: "table_dimension", kind: "enum", opt: true, T: () => ["TST.TableDimensionArchive", TSTArchives_22.TableDimensionArchive] },
            { no: 6, name: "src_cell_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 7, name: "dst_cell_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 8, name: "dst_cell_styles_container", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 9, name: "src_undo_cell_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 10, name: "dst_undo_cell_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 11, name: "dst_merge_owner_rollback_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "formula_rewrite_commands", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.Reference },
            { no: 13, name: "merge_action_to_restore", kind: "message", T: () => TSTArchives_19.MergeOperationArchive },
            { no: 14, name: "comment_cell_uids_to_restore", kind: "message", T: () => TSTArchives_20.CellUIDListArchive },
            { no: 15, name: "comment_storages_to_restore", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = { dstMergeOwnerRollbackIndex: 0, formulaRewriteCommands: [], commentStoragesToRestore: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUIDPath dst_table_info_id_path */ 2:
                    message.dstTableInfoIdPath = TSPMessages_6.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.dstTableInfoIdPath);
                    break;
                case /* TSP.UUIDRectArchive src_uid_range */ 3:
                    message.srcUidRange = TSPMessages_3.UUIDRectArchive.internalBinaryRead(reader, reader.uint32(), options, message.srcUidRange);
                    break;
                case /* TSP.UUIDRectArchive dst_uid_range */ 4:
                    message.dstUidRange = TSPMessages_3.UUIDRectArchive.internalBinaryRead(reader, reader.uint32(), options, message.dstUidRange);
                    break;
                case /* optional TST.TableDimensionArchive table_dimension */ 5:
                    message.tableDimension = reader.int32();
                    break;
                case /* TSP.Reference src_cell_map */ 6:
                    message.srcCellMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.srcCellMap);
                    break;
                case /* optional TSP.Reference dst_cell_map */ 7:
                    message.dstCellMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.dstCellMap);
                    break;
                case /* optional TSP.Reference dst_cell_styles_container */ 8:
                    message.dstCellStylesContainer = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.dstCellStylesContainer);
                    break;
                case /* optional TSP.Reference src_undo_cell_map */ 9:
                    message.srcUndoCellMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.srcUndoCellMap);
                    break;
                case /* optional TSP.Reference dst_undo_cell_map */ 10:
                    message.dstUndoCellMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.dstUndoCellMap);
                    break;
                case /* uint32 dst_merge_owner_rollback_index */ 11:
                    message.dstMergeOwnerRollbackIndex = reader.uint32();
                    break;
                case /* repeated TSP.Reference formula_rewrite_commands */ 12:
                    message.formulaRewriteCommands.push(TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TST.MergeOperationArchive merge_action_to_restore */ 13:
                    message.mergeActionToRestore = TSTArchives_19.MergeOperationArchive.internalBinaryRead(reader, reader.uint32(), options, message.mergeActionToRestore);
                    break;
                case /* optional TST.CellUIDListArchive comment_cell_uids_to_restore */ 14:
                    message.commentCellUidsToRestore = TSTArchives_20.CellUIDListArchive.internalBinaryRead(reader, reader.uint32(), options, message.commentCellUidsToRestore);
                    break;
                case /* repeated TSP.Reference comment_storages_to_restore */ 15:
                    message.commentStoragesToRestore.push(TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUIDPath dst_table_info_id_path = 2; */
        if (message.dstTableInfoIdPath)
            TSPMessages_6.UUIDPath.internalBinaryWrite(message.dstTableInfoIdPath, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUIDRectArchive src_uid_range = 3; */
        if (message.srcUidRange)
            TSPMessages_3.UUIDRectArchive.internalBinaryWrite(message.srcUidRange, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUIDRectArchive dst_uid_range = 4; */
        if (message.dstUidRange)
            TSPMessages_3.UUIDRectArchive.internalBinaryWrite(message.dstUidRange, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.TableDimensionArchive table_dimension = 5; */
        if (message.tableDimension !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).int32(message.tableDimension);
        /* TSP.Reference src_cell_map = 6; */
        if (message.srcCellMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.srcCellMap, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference dst_cell_map = 7; */
        if (message.dstCellMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.dstCellMap, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference dst_cell_styles_container = 8; */
        if (message.dstCellStylesContainer)
            TSPMessages_5.Reference.internalBinaryWrite(message.dstCellStylesContainer, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference src_undo_cell_map = 9; */
        if (message.srcUndoCellMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.srcUndoCellMap, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference dst_undo_cell_map = 10; */
        if (message.dstUndoCellMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.dstUndoCellMap, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 dst_merge_owner_rollback_index = 11; */
        if (message.dstMergeOwnerRollbackIndex !== 0)
            writer.tag(11, runtime_1.WireType.Varint).uint32(message.dstMergeOwnerRollbackIndex);
        /* repeated TSP.Reference formula_rewrite_commands = 12; */
        for (let i = 0; i < message.formulaRewriteCommands.length; i++)
            TSPMessages_5.Reference.internalBinaryWrite(message.formulaRewriteCommands[i], writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.MergeOperationArchive merge_action_to_restore = 13; */
        if (message.mergeActionToRestore)
            TSTArchives_19.MergeOperationArchive.internalBinaryWrite(message.mergeActionToRestore, writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.CellUIDListArchive comment_cell_uids_to_restore = 14; */
        if (message.commentCellUidsToRestore)
            TSTArchives_20.CellUIDListArchive.internalBinaryWrite(message.commentCellUidsToRestore, writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference comment_storages_to_restore = 15; */
        for (let i = 0; i < message.commentStoragesToRestore.length; i++)
            TSPMessages_5.Reference.internalBinaryWrite(message.commentStoragesToRestore[i], writer.tag(15, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandMoveCellsArchive
 */
exports.CommandMoveCellsArchive = new CommandMoveCellsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ColumnRowMetadataArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.ColumnRowMetadataArchive", [
            { no: 1, name: "size", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "hiding_action", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "cell_style", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 4, name: "text_style", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 5, name: "uuid", kind: "message", T: () => TSPMessages_4.UUID }
        ]);
    }
    create(value) {
        const message = { size: 0, hidingAction: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double size */ 1:
                    message.size = reader.double();
                    break;
                case /* uint32 hiding_action */ 2:
                    message.hidingAction = reader.uint32();
                    break;
                case /* optional TSP.Reference cell_style */ 3:
                    message.cellStyle = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.cellStyle);
                    break;
                case /* optional TSP.Reference text_style */ 4:
                    message.textStyle = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.textStyle);
                    break;
                case /* optional TSP.UUID uuid */ 5:
                    message.uuid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.uuid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* double size = 1; */
        if (message.size !== 0)
            writer.tag(1, runtime_1.WireType.Bit64).double(message.size);
        /* uint32 hiding_action = 2; */
        if (message.hidingAction !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.hidingAction);
        /* optional TSP.Reference cell_style = 3; */
        if (message.cellStyle)
            TSPMessages_5.Reference.internalBinaryWrite(message.cellStyle, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference text_style = 4; */
        if (message.textStyle)
            TSPMessages_5.Reference.internalBinaryWrite(message.textStyle, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID uuid = 5; */
        if (message.uuid)
            TSPMessages_4.UUID.internalBinaryWrite(message.uuid, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.ColumnRowMetadataArchive
 */
exports.ColumnRowMetadataArchive = new ColumnRowMetadataArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandInsertColumnsOrRowsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandInsertColumnsOrRowsArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "bundle", kind: "message", T: () => exports.ColumnRowBundleArchive },
            { no: 15, name: "concurrent_cell_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 16, name: "categories_cell_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 4, name: "undo_commands", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 17, name: "undo_concurrent_cell_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 18, name: "undo_categories_cell_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 6, name: "sort_order", kind: "message", T: () => TSTArchives_18.TableSortOrderUIDArchive },
            { no: 14, name: "group_sort_order", kind: "message", T: () => TSTArchives_17.TableGroupSortOrderUIDArchive },
            { no: 7, name: "filter_set", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 8, name: "should_edge_expand_formula_ranges", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "was_categorized", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "undo_order", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 11, name: "src_row_column_uid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 12, name: "opp_row_column_uid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 13, name: "undo_bundle", kind: "message", T: () => exports.ColumnRowBundleArchive }
        ]);
    }
    create(value) {
        const message = { undoOrder: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TST.ColumnRowBundleArchive bundle */ 2:
                    message.bundle = exports.ColumnRowBundleArchive.internalBinaryRead(reader, reader.uint32(), options, message.bundle);
                    break;
                case /* TSP.Reference concurrent_cell_map */ 15:
                    message.concurrentCellMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.concurrentCellMap);
                    break;
                case /* TSP.Reference categories_cell_map */ 16:
                    message.categoriesCellMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.categoriesCellMap);
                    break;
                case /* optional TSP.Reference undo_commands */ 4:
                    message.undoCommands = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoCommands);
                    break;
                case /* optional TSP.Reference undo_concurrent_cell_map */ 17:
                    message.undoConcurrentCellMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoConcurrentCellMap);
                    break;
                case /* optional TSP.Reference undo_categories_cell_map */ 18:
                    message.undoCategoriesCellMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoCategoriesCellMap);
                    break;
                case /* optional TST.TableSortOrderUIDArchive sort_order */ 6:
                    message.sortOrder = TSTArchives_18.TableSortOrderUIDArchive.internalBinaryRead(reader, reader.uint32(), options, message.sortOrder);
                    break;
                case /* optional TST.TableGroupSortOrderUIDArchive group_sort_order */ 14:
                    message.groupSortOrder = TSTArchives_17.TableGroupSortOrderUIDArchive.internalBinaryRead(reader, reader.uint32(), options, message.groupSortOrder);
                    break;
                case /* optional TSP.Reference filter_set */ 7:
                    message.filterSet = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.filterSet);
                    break;
                case /* optional bool should_edge_expand_formula_ranges */ 8:
                    message.shouldEdgeExpandFormulaRanges = reader.bool();
                    break;
                case /* optional bool was_categorized */ 9:
                    message.wasCategorized = reader.bool();
                    break;
                case /* repeated TSP.UUID undo_order */ 10:
                    message.undoOrder.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* TSP.UUID src_row_column_uid */ 11:
                    message.srcRowColumnUid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.srcRowColumnUid);
                    break;
                case /* TSP.UUID opp_row_column_uid */ 12:
                    message.oppRowColumnUid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.oppRowColumnUid);
                    break;
                case /* optional TST.ColumnRowBundleArchive undo_bundle */ 13:
                    message.undoBundle = exports.ColumnRowBundleArchive.internalBinaryRead(reader, reader.uint32(), options, message.undoBundle);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.ColumnRowBundleArchive bundle = 2; */
        if (message.bundle)
            exports.ColumnRowBundleArchive.internalBinaryWrite(message.bundle, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference concurrent_cell_map = 15; */
        if (message.concurrentCellMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.concurrentCellMap, writer.tag(15, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference categories_cell_map = 16; */
        if (message.categoriesCellMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.categoriesCellMap, writer.tag(16, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_commands = 4; */
        if (message.undoCommands)
            TSPMessages_5.Reference.internalBinaryWrite(message.undoCommands, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_concurrent_cell_map = 17; */
        if (message.undoConcurrentCellMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.undoConcurrentCellMap, writer.tag(17, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_categories_cell_map = 18; */
        if (message.undoCategoriesCellMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.undoCategoriesCellMap, writer.tag(18, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.TableSortOrderUIDArchive sort_order = 6; */
        if (message.sortOrder)
            TSTArchives_18.TableSortOrderUIDArchive.internalBinaryWrite(message.sortOrder, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.TableGroupSortOrderUIDArchive group_sort_order = 14; */
        if (message.groupSortOrder)
            TSTArchives_17.TableGroupSortOrderUIDArchive.internalBinaryWrite(message.groupSortOrder, writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference filter_set = 7; */
        if (message.filterSet)
            TSPMessages_5.Reference.internalBinaryWrite(message.filterSet, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool should_edge_expand_formula_ranges = 8; */
        if (message.shouldEdgeExpandFormulaRanges !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.shouldEdgeExpandFormulaRanges);
        /* optional bool was_categorized = 9; */
        if (message.wasCategorized !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).bool(message.wasCategorized);
        /* repeated TSP.UUID undo_order = 10; */
        for (let i = 0; i < message.undoOrder.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.undoOrder[i], writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID src_row_column_uid = 11; */
        if (message.srcRowColumnUid)
            TSPMessages_4.UUID.internalBinaryWrite(message.srcRowColumnUid, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID opp_row_column_uid = 12; */
        if (message.oppRowColumnUid)
            TSPMessages_4.UUID.internalBinaryWrite(message.oppRowColumnUid, writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.ColumnRowBundleArchive undo_bundle = 13; */
        if (message.undoBundle)
            exports.ColumnRowBundleArchive.internalBinaryWrite(message.undoBundle, writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandInsertColumnsOrRowsArchive
 */
exports.CommandInsertColumnsOrRowsArchive = new CommandInsertColumnsOrRowsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ColumnRowBundleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.ColumnRowBundleArchive", [
            { no: 1, name: "is_row", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "view_uid_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 3, name: "view_type_list", kind: "enum", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ["TST.ColumnRowBundleItemTypeEnum", ColumnRowBundleItemTypeEnum] },
            { no: 4, name: "base_uid_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 5, name: "base_type_list", kind: "enum", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ["TST.ColumnRowBundleItemTypeEnum", ColumnRowBundleItemTypeEnum] },
            { no: 6, name: "category_order_uid_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 7, name: "category_order_type_list", kind: "enum", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ["TST.ColumnRowBundleItemTypeEnum", ColumnRowBundleItemTypeEnum] },
            { no: 8, name: "metadata_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ColumnRowMetadataArchive }
        ]);
    }
    create(value) {
        const message = { isRow: false, viewUidList: [], viewTypeList: [], baseUidList: [], baseTypeList: [], categoryOrderUidList: [], categoryOrderTypeList: [], metadataList: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_row */ 1:
                    message.isRow = reader.bool();
                    break;
                case /* repeated TSP.UUID view_uid_list */ 2:
                    message.viewUidList.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TST.ColumnRowBundleItemTypeEnum view_type_list */ 3:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.viewTypeList.push(reader.int32());
                    else
                        message.viewTypeList.push(reader.int32());
                    break;
                case /* repeated TSP.UUID base_uid_list */ 4:
                    message.baseUidList.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TST.ColumnRowBundleItemTypeEnum base_type_list */ 5:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.baseTypeList.push(reader.int32());
                    else
                        message.baseTypeList.push(reader.int32());
                    break;
                case /* repeated TSP.UUID category_order_uid_list */ 6:
                    message.categoryOrderUidList.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TST.ColumnRowBundleItemTypeEnum category_order_type_list */ 7:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.categoryOrderTypeList.push(reader.int32());
                    else
                        message.categoryOrderTypeList.push(reader.int32());
                    break;
                case /* repeated TST.ColumnRowMetadataArchive metadata_list */ 8:
                    message.metadataList.push(exports.ColumnRowMetadataArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool is_row = 1; */
        if (message.isRow !== false)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.isRow);
        /* repeated TSP.UUID view_uid_list = 2; */
        for (let i = 0; i < message.viewUidList.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.viewUidList[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TST.ColumnRowBundleItemTypeEnum view_type_list = 3; */
        for (let i = 0; i < message.viewTypeList.length; i++)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.viewTypeList[i]);
        /* repeated TSP.UUID base_uid_list = 4; */
        for (let i = 0; i < message.baseUidList.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.baseUidList[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TST.ColumnRowBundleItemTypeEnum base_type_list = 5; */
        for (let i = 0; i < message.baseTypeList.length; i++)
            writer.tag(5, runtime_1.WireType.Varint).int32(message.baseTypeList[i]);
        /* repeated TSP.UUID category_order_uid_list = 6; */
        for (let i = 0; i < message.categoryOrderUidList.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.categoryOrderUidList[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TST.ColumnRowBundleItemTypeEnum category_order_type_list = 7; */
        for (let i = 0; i < message.categoryOrderTypeList.length; i++)
            writer.tag(7, runtime_1.WireType.Varint).int32(message.categoryOrderTypeList[i]);
        /* repeated TST.ColumnRowMetadataArchive metadata_list = 8; */
        for (let i = 0; i < message.metadataList.length; i++)
            exports.ColumnRowMetadataArchive.internalBinaryWrite(message.metadataList[i], writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.ColumnRowBundleArchive
 */
exports.ColumnRowBundleArchive = new ColumnRowBundleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandRemoveColumnsOrRowsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandRemoveColumnsOrRowsArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "bundle", kind: "message", T: () => exports.ColumnRowBundleArchive },
            { no: 11, name: "concurrent_cell_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 12, name: "categories_cell_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 13, name: "undo_concurrent_cell_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 14, name: "undo_categories_cell_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 5, name: "undo_filter_set", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 6, name: "undo_sort_order", kind: "message", T: () => TSTArchives_18.TableSortOrderUIDArchive },
            { no: 10, name: "undo_group_sort_order", kind: "message", T: () => TSTArchives_17.TableGroupSortOrderUIDArchive },
            { no: 7, name: "formula_rewrite_command_for_undo", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 8, name: "inverse_should_edge_expand_formula_ranges", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "undo_order", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID }
        ]);
    }
    create(value) {
        const message = { undoOrder: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TST.ColumnRowBundleArchive bundle */ 2:
                    message.bundle = exports.ColumnRowBundleArchive.internalBinaryRead(reader, reader.uint32(), options, message.bundle);
                    break;
                case /* optional TSP.Reference concurrent_cell_map */ 11:
                    message.concurrentCellMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.concurrentCellMap);
                    break;
                case /* optional TSP.Reference categories_cell_map */ 12:
                    message.categoriesCellMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.categoriesCellMap);
                    break;
                case /* optional TSP.Reference undo_concurrent_cell_map */ 13:
                    message.undoConcurrentCellMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoConcurrentCellMap);
                    break;
                case /* optional TSP.Reference undo_categories_cell_map */ 14:
                    message.undoCategoriesCellMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoCategoriesCellMap);
                    break;
                case /* optional TSP.Reference undo_filter_set */ 5:
                    message.undoFilterSet = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoFilterSet);
                    break;
                case /* optional TST.TableSortOrderUIDArchive undo_sort_order */ 6:
                    message.undoSortOrder = TSTArchives_18.TableSortOrderUIDArchive.internalBinaryRead(reader, reader.uint32(), options, message.undoSortOrder);
                    break;
                case /* optional TST.TableGroupSortOrderUIDArchive undo_group_sort_order */ 10:
                    message.undoGroupSortOrder = TSTArchives_17.TableGroupSortOrderUIDArchive.internalBinaryRead(reader, reader.uint32(), options, message.undoGroupSortOrder);
                    break;
                case /* optional TSP.Reference formula_rewrite_command_for_undo */ 7:
                    message.formulaRewriteCommandForUndo = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.formulaRewriteCommandForUndo);
                    break;
                case /* optional bool inverse_should_edge_expand_formula_ranges */ 8:
                    message.inverseShouldEdgeExpandFormulaRanges = reader.bool();
                    break;
                case /* repeated TSP.UUID undo_order */ 9:
                    message.undoOrder.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.ColumnRowBundleArchive bundle = 2; */
        if (message.bundle)
            exports.ColumnRowBundleArchive.internalBinaryWrite(message.bundle, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference concurrent_cell_map = 11; */
        if (message.concurrentCellMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.concurrentCellMap, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference categories_cell_map = 12; */
        if (message.categoriesCellMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.categoriesCellMap, writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_concurrent_cell_map = 13; */
        if (message.undoConcurrentCellMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.undoConcurrentCellMap, writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_categories_cell_map = 14; */
        if (message.undoCategoriesCellMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.undoCategoriesCellMap, writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_filter_set = 5; */
        if (message.undoFilterSet)
            TSPMessages_5.Reference.internalBinaryWrite(message.undoFilterSet, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.TableSortOrderUIDArchive undo_sort_order = 6; */
        if (message.undoSortOrder)
            TSTArchives_18.TableSortOrderUIDArchive.internalBinaryWrite(message.undoSortOrder, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.TableGroupSortOrderUIDArchive undo_group_sort_order = 10; */
        if (message.undoGroupSortOrder)
            TSTArchives_17.TableGroupSortOrderUIDArchive.internalBinaryWrite(message.undoGroupSortOrder, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference formula_rewrite_command_for_undo = 7; */
        if (message.formulaRewriteCommandForUndo)
            TSPMessages_5.Reference.internalBinaryWrite(message.formulaRewriteCommandForUndo, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool inverse_should_edge_expand_formula_ranges = 8; */
        if (message.inverseShouldEdgeExpandFormulaRanges !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.inverseShouldEdgeExpandFormulaRanges);
        /* repeated TSP.UUID undo_order = 9; */
        for (let i = 0; i < message.undoOrder.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.undoOrder[i], writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandRemoveColumnsOrRowsArchive
 */
exports.CommandRemoveColumnsOrRowsArchive = new CommandRemoveColumnsOrRowsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandRowColumnRangeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandRowColumnRangeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 3, name: "is_row", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { uids: [], isRow: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSP.UUID uids */ 2:
                    message.uids.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool is_row */ 3:
                    message.isRow = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID uids = 2; */
        for (let i = 0; i < message.uids.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.uids[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool is_row = 3; */
        if (message.isRow !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.isRow);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandRowColumnRangeArchive
 */
exports.CommandRowColumnRangeArchive = new CommandRowColumnRangeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandResizeColumnOrRowArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandResizeColumnOrRowArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandRowColumnRangeArchive },
            { no: 2, name: "sizes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "sizes_for_undo", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value) {
        const message = { sizes: [], sizesForUndo: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.CommandRowColumnRangeArchive super */ 1:
                    message.super = exports.CommandRowColumnRangeArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated float sizes */ 2:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.sizes.push(reader.float());
                    else
                        message.sizes.push(reader.float());
                    break;
                case /* repeated float sizes_for_undo */ 3:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.sizesForUndo.push(reader.float());
                    else
                        message.sizesForUndo.push(reader.float());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.CommandRowColumnRangeArchive super = 1; */
        if (message.super)
            exports.CommandRowColumnRangeArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated float sizes = 2; */
        for (let i = 0; i < message.sizes.length; i++)
            writer.tag(2, runtime_1.WireType.Bit32).float(message.sizes[i]);
        /* repeated float sizes_for_undo = 3; */
        for (let i = 0; i < message.sizesForUndo.length; i++)
            writer.tag(3, runtime_1.WireType.Bit32).float(message.sizesForUndo[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandResizeColumnOrRowArchive
 */
exports.CommandResizeColumnOrRowArchive = new CommandResizeColumnOrRowArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandCategoryResizeColumnOrRowArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandCategoryResizeColumnOrRowArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "category_row_sizes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "category_row_sizes_for_undo", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "category_label_row_sizes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "category_label_row_sizes_for_undo", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "category_column_size", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "category_column_size_for_undo", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value) {
        const message = { categoryRowSizes: [], categoryRowSizesForUndo: [], categoryLabelRowSizes: [], categoryLabelRowSizesForUndo: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated float category_row_sizes */ 2:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.categoryRowSizes.push(reader.float());
                    else
                        message.categoryRowSizes.push(reader.float());
                    break;
                case /* repeated float category_row_sizes_for_undo */ 3:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.categoryRowSizesForUndo.push(reader.float());
                    else
                        message.categoryRowSizesForUndo.push(reader.float());
                    break;
                case /* repeated float category_label_row_sizes */ 4:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.categoryLabelRowSizes.push(reader.float());
                    else
                        message.categoryLabelRowSizes.push(reader.float());
                    break;
                case /* repeated float category_label_row_sizes_for_undo */ 5:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.categoryLabelRowSizesForUndo.push(reader.float());
                    else
                        message.categoryLabelRowSizesForUndo.push(reader.float());
                    break;
                case /* optional double category_column_size */ 6:
                    message.categoryColumnSize = reader.double();
                    break;
                case /* optional double category_column_size_for_undo */ 7:
                    message.categoryColumnSizeForUndo = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated float category_row_sizes = 2; */
        for (let i = 0; i < message.categoryRowSizes.length; i++)
            writer.tag(2, runtime_1.WireType.Bit32).float(message.categoryRowSizes[i]);
        /* repeated float category_row_sizes_for_undo = 3; */
        for (let i = 0; i < message.categoryRowSizesForUndo.length; i++)
            writer.tag(3, runtime_1.WireType.Bit32).float(message.categoryRowSizesForUndo[i]);
        /* repeated float category_label_row_sizes = 4; */
        for (let i = 0; i < message.categoryLabelRowSizes.length; i++)
            writer.tag(4, runtime_1.WireType.Bit32).float(message.categoryLabelRowSizes[i]);
        /* repeated float category_label_row_sizes_for_undo = 5; */
        for (let i = 0; i < message.categoryLabelRowSizesForUndo.length; i++)
            writer.tag(5, runtime_1.WireType.Bit32).float(message.categoryLabelRowSizesForUndo[i]);
        /* optional double category_column_size = 6; */
        if (message.categoryColumnSize !== undefined)
            writer.tag(6, runtime_1.WireType.Bit64).double(message.categoryColumnSize);
        /* optional double category_column_size_for_undo = 7; */
        if (message.categoryColumnSizeForUndo !== undefined)
            writer.tag(7, runtime_1.WireType.Bit64).double(message.categoryColumnSizeForUndo);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandCategoryResizeColumnOrRowArchive
 */
exports.CommandCategoryResizeColumnOrRowArchive = new CommandCategoryResizeColumnOrRowArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandHideShowArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandHideShowArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandRowColumnRangeArchive },
            { no: 2, name: "hide_show_action", kind: "enum", T: () => ["TST.HideShowActionArchive", TSTArchives_16.HideShowActionArchive] },
            { no: 3, name: "hiding_action", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "hide_show_action_for_undo", kind: "enum", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ["TST.HideShowActionArchive", TSTArchives_16.HideShowActionArchive] }
        ]);
    }
    create(value) {
        const message = { hideShowAction: 0, hidingAction: 0, hideShowActionForUndo: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.CommandRowColumnRangeArchive super */ 1:
                    message.super = exports.CommandRowColumnRangeArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TST.HideShowActionArchive hide_show_action */ 2:
                    message.hideShowAction = reader.int32();
                    break;
                case /* uint32 hiding_action */ 3:
                    message.hidingAction = reader.uint32();
                    break;
                case /* repeated TST.HideShowActionArchive hide_show_action_for_undo */ 4:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.hideShowActionForUndo.push(reader.int32());
                    else
                        message.hideShowActionForUndo.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.CommandRowColumnRangeArchive super = 1; */
        if (message.super)
            exports.CommandRowColumnRangeArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.HideShowActionArchive hide_show_action = 2; */
        if (message.hideShowAction !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.hideShowAction);
        /* uint32 hiding_action = 3; */
        if (message.hidingAction !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.hidingAction);
        /* repeated TST.HideShowActionArchive hide_show_action_for_undo = 4; */
        for (let i = 0; i < message.hideShowActionForUndo.length; i++)
            writer.tag(4, runtime_1.WireType.Varint).int32(message.hideShowActionForUndo[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandHideShowArchive
 */
exports.CommandHideShowArchive = new CommandHideShowArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandTextPreflightInsertCellArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandTextPreflightInsertCellArchive", [
            { no: 3, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 6, name: "coalesced_textcommand", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 8, name: "postflightcommand", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 9, name: "grouped_with_postflight", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "editing_cell", kind: "message", T: () => TSTArchives_15.Cell },
            { no: 11, name: "editing_storage", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 12, name: "last_column_hit_by_tap", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "cell_uid", kind: "message", T: () => TSPMessages_2.UUIDCoordArchive },
            { no: 14, name: "archived_initial_selection_path", kind: "message", T: () => TSKArchives_3.SelectionPathArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 3:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference coalesced_textcommand */ 6:
                    message.coalescedTextcommand = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.coalescedTextcommand);
                    break;
                case /* optional TSP.Reference postflightcommand */ 8:
                    message.postflightcommand = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.postflightcommand);
                    break;
                case /* optional bool grouped_with_postflight */ 9:
                    message.groupedWithPostflight = reader.bool();
                    break;
                case /* TST.Cell editing_cell */ 10:
                    message.editingCell = TSTArchives_15.Cell.internalBinaryRead(reader, reader.uint32(), options, message.editingCell);
                    break;
                case /* TSP.Reference editing_storage */ 11:
                    message.editingStorage = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.editingStorage);
                    break;
                case /* optional uint32 last_column_hit_by_tap */ 12:
                    message.lastColumnHitByTap = reader.uint32();
                    break;
                case /* TSP.UUIDCoordArchive cell_uid */ 13:
                    message.cellUid = TSPMessages_2.UUIDCoordArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellUid);
                    break;
                case /* optional TSK.SelectionPathArchive archived_initial_selection_path */ 14:
                    message.archivedInitialSelectionPath = TSKArchives_3.SelectionPathArchive.internalBinaryRead(reader, reader.uint32(), options, message.archivedInitialSelectionPath);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 3; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference coalesced_textcommand = 6; */
        if (message.coalescedTextcommand)
            TSPMessages_5.Reference.internalBinaryWrite(message.coalescedTextcommand, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference postflightcommand = 8; */
        if (message.postflightcommand)
            TSPMessages_5.Reference.internalBinaryWrite(message.postflightcommand, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool grouped_with_postflight = 9; */
        if (message.groupedWithPostflight !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).bool(message.groupedWithPostflight);
        /* TST.Cell editing_cell = 10; */
        if (message.editingCell)
            TSTArchives_15.Cell.internalBinaryWrite(message.editingCell, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference editing_storage = 11; */
        if (message.editingStorage)
            TSPMessages_5.Reference.internalBinaryWrite(message.editingStorage, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 last_column_hit_by_tap = 12; */
        if (message.lastColumnHitByTap !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).uint32(message.lastColumnHitByTap);
        /* TSP.UUIDCoordArchive cell_uid = 13; */
        if (message.cellUid)
            TSPMessages_2.UUIDCoordArchive.internalBinaryWrite(message.cellUid, writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSK.SelectionPathArchive archived_initial_selection_path = 14; */
        if (message.archivedInitialSelectionPath)
            TSKArchives_3.SelectionPathArchive.internalBinaryWrite(message.archivedInitialSelectionPath, writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandTextPreflightInsertCellArchive
 */
exports.CommandTextPreflightInsertCellArchive = new CommandTextPreflightInsertCellArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandPostflightSetCellArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandPostflightSetCellArchive", [
            { no: 3, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 4, name: "childcommandundo", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 6, name: "editing_cell", kind: "message", T: () => TSTArchives_15.Cell },
            { no: 7, name: "new_cell", kind: "message", T: () => TSTArchives_15.Cell },
            { no: 8, name: "editing_storage", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 9, name: "last_column_hit_by_tap", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "cell_uid", kind: "message", T: () => TSPMessages_2.UUIDCoordArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 3:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference childcommandundo */ 4:
                    message.childcommandundo = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.childcommandundo);
                    break;
                case /* TST.Cell editing_cell */ 6:
                    message.editingCell = TSTArchives_15.Cell.internalBinaryRead(reader, reader.uint32(), options, message.editingCell);
                    break;
                case /* TST.Cell new_cell */ 7:
                    message.newCell = TSTArchives_15.Cell.internalBinaryRead(reader, reader.uint32(), options, message.newCell);
                    break;
                case /* TSP.Reference editing_storage */ 8:
                    message.editingStorage = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.editingStorage);
                    break;
                case /* optional uint32 last_column_hit_by_tap */ 9:
                    message.lastColumnHitByTap = reader.uint32();
                    break;
                case /* TSP.UUIDCoordArchive cell_uid */ 10:
                    message.cellUid = TSPMessages_2.UUIDCoordArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellUid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 3; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference childcommandundo = 4; */
        if (message.childcommandundo)
            TSPMessages_5.Reference.internalBinaryWrite(message.childcommandundo, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.Cell editing_cell = 6; */
        if (message.editingCell)
            TSTArchives_15.Cell.internalBinaryWrite(message.editingCell, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.Cell new_cell = 7; */
        if (message.newCell)
            TSTArchives_15.Cell.internalBinaryWrite(message.newCell, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference editing_storage = 8; */
        if (message.editingStorage)
            TSPMessages_5.Reference.internalBinaryWrite(message.editingStorage, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 last_column_hit_by_tap = 9; */
        if (message.lastColumnHitByTap !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).uint32(message.lastColumnHitByTap);
        /* TSP.UUIDCoordArchive cell_uid = 10; */
        if (message.cellUid)
            TSPMessages_2.UUIDCoordArchive.internalBinaryWrite(message.cellUid, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandPostflightSetCellArchive
 */
exports.CommandPostflightSetCellArchive = new CommandPostflightSetCellArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandChangeTableAreaForColumnOrRowArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandChangeTableAreaForColumnOrRowArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandRowColumnRangeArchive },
            { no: 2, name: "table_area_transition", kind: "enum", T: () => ["TST.TableAreaTransition", TableAreaTransition] },
            { no: 3, name: "cell_diff_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 4, name: "undo_cell_diff_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 5, name: "undo_commands", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 6, name: "action_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { tableAreaTransition: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.CommandRowColumnRangeArchive super */ 1:
                    message.super = exports.CommandRowColumnRangeArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TST.TableAreaTransition table_area_transition */ 2:
                    message.tableAreaTransition = reader.int32();
                    break;
                case /* optional TSP.Reference cell_diff_map */ 3:
                    message.cellDiffMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.cellDiffMap);
                    break;
                case /* optional TSP.Reference undo_cell_diff_map */ 4:
                    message.undoCellDiffMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoCellDiffMap);
                    break;
                case /* optional TSP.Reference undo_commands */ 5:
                    message.undoCommands = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoCommands);
                    break;
                case /* optional string action_string */ 6:
                    message.actionString = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.CommandRowColumnRangeArchive super = 1; */
        if (message.super)
            exports.CommandRowColumnRangeArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.TableAreaTransition table_area_transition = 2; */
        if (message.tableAreaTransition !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.tableAreaTransition);
        /* optional TSP.Reference cell_diff_map = 3; */
        if (message.cellDiffMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.cellDiffMap, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_cell_diff_map = 4; */
        if (message.undoCellDiffMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.undoCellDiffMap, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_commands = 5; */
        if (message.undoCommands)
            TSPMessages_5.Reference.internalBinaryWrite(message.undoCommands, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string action_string = 6; */
        if (message.actionString !== undefined)
            writer.tag(6, runtime_1.WireType.LengthDelimited).string(message.actionString);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandChangeTableAreaForColumnOrRowArchive
 */
exports.CommandChangeTableAreaForColumnOrRowArchive = new CommandChangeTableAreaForColumnOrRowArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetPencilAnnotationsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetPencilAnnotationsArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "annotations", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.Reference },
            { no: 3, name: "formulas", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSCEArchives_14.FormulaArchive },
            { no: 4, name: "formula_indexes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "inverse_formulas", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSCEArchives_14.FormulaArchive },
            { no: 6, name: "inverse_formula_indexes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "rollback_index", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value) {
        const message = { annotations: [], formulas: [], formulaIndexes: [], inverseFormulas: [], inverseFormulaIndexes: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSP.Reference annotations */ 2:
                    message.annotations.push(TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSCE.FormulaArchive formulas */ 3:
                    message.formulas.push(TSCEArchives_14.FormulaArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint64 formula_indexes */ 4:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.formulaIndexes.push(reader.uint64().toBigInt());
                    else
                        message.formulaIndexes.push(reader.uint64().toBigInt());
                    break;
                case /* repeated TSCE.FormulaArchive inverse_formulas */ 5:
                    message.inverseFormulas.push(TSCEArchives_14.FormulaArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint64 inverse_formula_indexes */ 6:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.inverseFormulaIndexes.push(reader.uint64().toBigInt());
                    else
                        message.inverseFormulaIndexes.push(reader.uint64().toBigInt());
                    break;
                case /* optional uint64 rollback_index */ 7:
                    message.rollbackIndex = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference annotations = 2; */
        for (let i = 0; i < message.annotations.length; i++)
            TSPMessages_5.Reference.internalBinaryWrite(message.annotations[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSCE.FormulaArchive formulas = 3; */
        for (let i = 0; i < message.formulas.length; i++)
            TSCEArchives_14.FormulaArchive.internalBinaryWrite(message.formulas[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint64 formula_indexes = 4; */
        for (let i = 0; i < message.formulaIndexes.length; i++)
            writer.tag(4, runtime_1.WireType.Varint).uint64(message.formulaIndexes[i]);
        /* repeated TSCE.FormulaArchive inverse_formulas = 5; */
        for (let i = 0; i < message.inverseFormulas.length; i++)
            TSCEArchives_14.FormulaArchive.internalBinaryWrite(message.inverseFormulas[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated uint64 inverse_formula_indexes = 6; */
        for (let i = 0; i < message.inverseFormulaIndexes.length; i++)
            writer.tag(6, runtime_1.WireType.Varint).uint64(message.inverseFormulaIndexes[i]);
        /* optional uint64 rollback_index = 7; */
        if (message.rollbackIndex !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).uint64(message.rollbackIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetPencilAnnotationsArchive
 */
exports.CommandSetPencilAnnotationsArchive = new CommandSetPencilAnnotationsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetTableNameArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetTableNameArchive", [
            { no: 1, name: "newtablename", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "oldtablename", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "newstyle", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 4, name: "oldstyle", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 5, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 6, name: "old_shape_style", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 7, name: "new_shape_style", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 8, name: "old_table_name_border_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "new_table_name_border_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { newtablename: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string newtablename */ 1:
                    message.newtablename = reader.string();
                    break;
                case /* optional string oldtablename */ 2:
                    message.oldtablename = reader.string();
                    break;
                case /* optional TSP.Reference newstyle */ 3:
                    message.newstyle = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.newstyle);
                    break;
                case /* optional TSP.Reference oldstyle */ 4:
                    message.oldstyle = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.oldstyle);
                    break;
                case /* TST.TableCommandArchive super */ 5:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference old_shape_style */ 6:
                    message.oldShapeStyle = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.oldShapeStyle);
                    break;
                case /* optional TSP.Reference new_shape_style */ 7:
                    message.newShapeStyle = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.newShapeStyle);
                    break;
                case /* optional bool old_table_name_border_enabled */ 8:
                    message.oldTableNameBorderEnabled = reader.bool();
                    break;
                case /* optional bool new_table_name_border_enabled */ 9:
                    message.newTableNameBorderEnabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string newtablename = 1; */
        if (message.newtablename !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.newtablename);
        /* optional string oldtablename = 2; */
        if (message.oldtablename !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.oldtablename);
        /* optional TSP.Reference newstyle = 3; */
        if (message.newstyle)
            TSPMessages_5.Reference.internalBinaryWrite(message.newstyle, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference oldstyle = 4; */
        if (message.oldstyle)
            TSPMessages_5.Reference.internalBinaryWrite(message.oldstyle, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.TableCommandArchive super = 5; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference old_shape_style = 6; */
        if (message.oldShapeStyle)
            TSPMessages_5.Reference.internalBinaryWrite(message.oldShapeStyle, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference new_shape_style = 7; */
        if (message.newShapeStyle)
            TSPMessages_5.Reference.internalBinaryWrite(message.newShapeStyle, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool old_table_name_border_enabled = 8; */
        if (message.oldTableNameBorderEnabled !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.oldTableNameBorderEnabled);
        /* optional bool new_table_name_border_enabled = 9; */
        if (message.newTableNameBorderEnabled !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).bool(message.newTableNameBorderEnabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetTableNameArchive
 */
exports.CommandSetTableNameArchive = new CommandSetTableNameArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetTableNameEnabledArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetTableNameEnabledArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "table_name_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "prev_table_name_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { tableNameEnabled: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* bool table_name_enabled */ 2:
                    message.tableNameEnabled = reader.bool();
                    break;
                case /* optional bool prev_table_name_enabled */ 3:
                    message.prevTableNameEnabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool table_name_enabled = 2; */
        if (message.tableNameEnabled !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.tableNameEnabled);
        /* optional bool prev_table_name_enabled = 3; */
        if (message.prevTableNameEnabled !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.prevTableNameEnabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetTableNameEnabledArchive
 */
exports.CommandSetTableNameEnabledArchive = new CommandSetTableNameEnabledArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetTableFontSizeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetTableFontSizeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "is_increase", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "font_size_diff", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "font_size_list", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "inverse_font_size_list", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "cell_diff_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 7, name: "inverse_cell_diff_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 8, name: "styles_container_refresh_done", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { isIncrease: false, fontSizeDiff: 0, fontSizeList: [], inverseFontSizeList: [], stylesContainerRefreshDone: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* bool is_increase */ 2:
                    message.isIncrease = reader.bool();
                    break;
                case /* int32 font_size_diff */ 3:
                    message.fontSizeDiff = reader.int32();
                    break;
                case /* repeated double font_size_list */ 4:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.fontSizeList.push(reader.double());
                    else
                        message.fontSizeList.push(reader.double());
                    break;
                case /* repeated double inverse_font_size_list */ 5:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.inverseFontSizeList.push(reader.double());
                    else
                        message.inverseFontSizeList.push(reader.double());
                    break;
                case /* optional TSP.Reference cell_diff_map */ 6:
                    message.cellDiffMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.cellDiffMap);
                    break;
                case /* optional TSP.Reference inverse_cell_diff_map */ 7:
                    message.inverseCellDiffMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.inverseCellDiffMap);
                    break;
                case /* bool styles_container_refresh_done */ 8:
                    message.stylesContainerRefreshDone = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool is_increase = 2; */
        if (message.isIncrease !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.isIncrease);
        /* int32 font_size_diff = 3; */
        if (message.fontSizeDiff !== 0)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.fontSizeDiff);
        /* repeated double font_size_list = 4; */
        for (let i = 0; i < message.fontSizeList.length; i++)
            writer.tag(4, runtime_1.WireType.Bit64).double(message.fontSizeList[i]);
        /* repeated double inverse_font_size_list = 5; */
        for (let i = 0; i < message.inverseFontSizeList.length; i++)
            writer.tag(5, runtime_1.WireType.Bit64).double(message.inverseFontSizeList[i]);
        /* optional TSP.Reference cell_diff_map = 6; */
        if (message.cellDiffMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.cellDiffMap, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference inverse_cell_diff_map = 7; */
        if (message.inverseCellDiffMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.inverseCellDiffMap, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool styles_container_refresh_done = 8; */
        if (message.stylesContainerRefreshDone !== false)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.stylesContainerRefreshDone);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetTableFontSizeArchive
 */
exports.CommandSetTableFontSizeArchive = new CommandSetTableFontSizeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetTableFontNameArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetTableFontNameArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "font_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "preserve_face", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "previous_font_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "previous_table_style", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 6, name: "previous_text_styles", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.Reference },
            { no: 7, name: "cell_diff_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 8, name: "inverse_cell_diff_map", kind: "message", T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = { fontName: "", preserveFace: false, previousTextStyles: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* string font_name */ 2:
                    message.fontName = reader.string();
                    break;
                case /* bool preserve_face */ 3:
                    message.preserveFace = reader.bool();
                    break;
                case /* optional string previous_font_name */ 4:
                    message.previousFontName = reader.string();
                    break;
                case /* optional TSP.Reference previous_table_style */ 5:
                    message.previousTableStyle = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.previousTableStyle);
                    break;
                case /* repeated TSP.Reference previous_text_styles */ 6:
                    message.previousTextStyles.push(TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* TSP.Reference cell_diff_map */ 7:
                    message.cellDiffMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.cellDiffMap);
                    break;
                case /* optional TSP.Reference inverse_cell_diff_map */ 8:
                    message.inverseCellDiffMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.inverseCellDiffMap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string font_name = 2; */
        if (message.fontName !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.fontName);
        /* bool preserve_face = 3; */
        if (message.preserveFace !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.preserveFace);
        /* optional string previous_font_name = 4; */
        if (message.previousFontName !== undefined)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.previousFontName);
        /* optional TSP.Reference previous_table_style = 5; */
        if (message.previousTableStyle)
            TSPMessages_5.Reference.internalBinaryWrite(message.previousTableStyle, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference previous_text_styles = 6; */
        for (let i = 0; i < message.previousTextStyles.length; i++)
            TSPMessages_5.Reference.internalBinaryWrite(message.previousTextStyles[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference cell_diff_map = 7; */
        if (message.cellDiffMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.cellDiffMap, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference inverse_cell_diff_map = 8; */
        if (message.inverseCellDiffMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.inverseCellDiffMap, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetTableFontNameArchive
 */
exports.CommandSetTableFontNameArchive = new CommandSetTableFontNameArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetTableNameHeightArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetTableNameHeightArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "old_table_name_height", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "new_table_name_height", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value) {
        const message = { oldTableNameHeight: 0, newTableNameHeight: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* double old_table_name_height */ 2:
                    message.oldTableNameHeight = reader.double();
                    break;
                case /* double new_table_name_height */ 3:
                    message.newTableNameHeight = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* double old_table_name_height = 2; */
        if (message.oldTableNameHeight !== 0)
            writer.tag(2, runtime_1.WireType.Bit64).double(message.oldTableNameHeight);
        /* double new_table_name_height = 3; */
        if (message.newTableNameHeight !== 0)
            writer.tag(3, runtime_1.WireType.Bit64).double(message.newTableNameHeight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetTableNameHeightArchive
 */
exports.CommandSetTableNameHeightArchive = new CommandSetTableNameHeightArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetNowArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetNowArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetNowArchive
 */
exports.CommandSetNowArchive = new CommandSetNowArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetWasCutArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetWasCutArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "from_table_uid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 3, name: "prev_from_table_uid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 4, name: "was_cut", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "prev_was_cut", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "from_group_by_uid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 7, name: "prev_from_group_by_uid", kind: "message", T: () => TSPMessages_4.UUID }
        ]);
    }
    create(value) {
        const message = { wasCut: false, prevWasCut: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUID from_table_uid */ 2:
                    message.fromTableUid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.fromTableUid);
                    break;
                case /* TSP.UUID prev_from_table_uid */ 3:
                    message.prevFromTableUid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.prevFromTableUid);
                    break;
                case /* bool was_cut */ 4:
                    message.wasCut = reader.bool();
                    break;
                case /* bool prev_was_cut */ 5:
                    message.prevWasCut = reader.bool();
                    break;
                case /* TSP.UUID from_group_by_uid */ 6:
                    message.fromGroupByUid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.fromGroupByUid);
                    break;
                case /* TSP.UUID prev_from_group_by_uid */ 7:
                    message.prevFromGroupByUid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.prevFromGroupByUid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID from_table_uid = 2; */
        if (message.fromTableUid)
            TSPMessages_4.UUID.internalBinaryWrite(message.fromTableUid, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID prev_from_table_uid = 3; */
        if (message.prevFromTableUid)
            TSPMessages_4.UUID.internalBinaryWrite(message.prevFromTableUid, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool was_cut = 4; */
        if (message.wasCut !== false)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.wasCut);
        /* bool prev_was_cut = 5; */
        if (message.prevWasCut !== false)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.prevWasCut);
        /* TSP.UUID from_group_by_uid = 6; */
        if (message.fromGroupByUid)
            TSPMessages_4.UUID.internalBinaryWrite(message.fromGroupByUid, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID prev_from_group_by_uid = 7; */
        if (message.prevFromGroupByUid)
            TSPMessages_4.UUID.internalBinaryWrite(message.prevFromGroupByUid, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetWasCutArchive
 */
exports.CommandSetWasCutArchive = new CommandSetWasCutArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandStyleCellsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandStyleCellsArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "format_properties", kind: "message", T: () => TSPMessages_1.ReferenceDictionary },
            { no: 3, name: "selection", kind: "message", T: () => TSTArchives_14.SelectionArchive },
            { no: 4, name: "undo_cell_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 5, name: "redo_cell_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 6, name: "text_undo", kind: "message", T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.ReferenceDictionary format_properties */ 2:
                    message.formatProperties = TSPMessages_1.ReferenceDictionary.internalBinaryRead(reader, reader.uint32(), options, message.formatProperties);
                    break;
                case /* TST.SelectionArchive selection */ 3:
                    message.selection = TSTArchives_14.SelectionArchive.internalBinaryRead(reader, reader.uint32(), options, message.selection);
                    break;
                case /* TSP.Reference undo_cell_map */ 4:
                    message.undoCellMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoCellMap);
                    break;
                case /* TSP.Reference redo_cell_map */ 5:
                    message.redoCellMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.redoCellMap);
                    break;
                case /* optional TSP.Reference text_undo */ 6:
                    message.textUndo = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.textUndo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.ReferenceDictionary format_properties = 2; */
        if (message.formatProperties)
            TSPMessages_1.ReferenceDictionary.internalBinaryWrite(message.formatProperties, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.SelectionArchive selection = 3; */
        if (message.selection)
            TSTArchives_14.SelectionArchive.internalBinaryWrite(message.selection, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference undo_cell_map = 4; */
        if (message.undoCellMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.undoCellMap, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference redo_cell_map = 5; */
        if (message.redoCellMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.redoCellMap, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference text_undo = 6; */
        if (message.textUndo)
            TSPMessages_5.Reference.internalBinaryWrite(message.textUndo, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandStyleCellsArchive
 */
exports.CommandStyleCellsArchive = new CommandStyleCellsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandStyleTableArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandStyleTableArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "format_properties", kind: "message", T: () => TSPMessages_1.ReferenceDictionary },
            { no: 3, name: "old_style", kind: "message", T: () => TSTArchives_sos_1.TableStylePropertyChangeSetArchive },
            { no: 4, name: "new_style", kind: "message", T: () => TSTArchives_sos_1.TableStylePropertyChangeSetArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.ReferenceDictionary format_properties */ 2:
                    message.formatProperties = TSPMessages_1.ReferenceDictionary.internalBinaryRead(reader, reader.uint32(), options, message.formatProperties);
                    break;
                case /* optional TSTSOS.TableStylePropertyChangeSetArchive old_style */ 3:
                    message.oldStyle = TSTArchives_sos_1.TableStylePropertyChangeSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldStyle);
                    break;
                case /* optional TSTSOS.TableStylePropertyChangeSetArchive new_style */ 4:
                    message.newStyle = TSTArchives_sos_1.TableStylePropertyChangeSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.newStyle);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.ReferenceDictionary format_properties = 2; */
        if (message.formatProperties)
            TSPMessages_1.ReferenceDictionary.internalBinaryWrite(message.formatProperties, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSTSOS.TableStylePropertyChangeSetArchive old_style = 3; */
        if (message.oldStyle)
            TSTArchives_sos_1.TableStylePropertyChangeSetArchive.internalBinaryWrite(message.oldStyle, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSTSOS.TableStylePropertyChangeSetArchive new_style = 4; */
        if (message.newStyle)
            TSTArchives_sos_1.TableStylePropertyChangeSetArchive.internalBinaryWrite(message.newStyle, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandStyleTableArchive
 */
exports.CommandStyleTableArchive = new CommandStyleTableArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetRepeatingHeaderEnabledArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetRepeatingHeaderEnabledArchive", [
            { no: 1, name: "repeating_header_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "direction", kind: "enum", T: () => ["TST.TableDimensionArchive", TSTArchives_22.TableDimensionArchive] },
            { no: 3, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 4, name: "prev_repeating_header_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { repeatingHeaderEnabled: false, direction: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool repeating_header_enabled */ 1:
                    message.repeatingHeaderEnabled = reader.bool();
                    break;
                case /* TST.TableDimensionArchive direction */ 2:
                    message.direction = reader.int32();
                    break;
                case /* TST.TableCommandArchive super */ 3:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional bool prev_repeating_header_enabled */ 4:
                    message.prevRepeatingHeaderEnabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool repeating_header_enabled = 1; */
        if (message.repeatingHeaderEnabled !== false)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.repeatingHeaderEnabled);
        /* TST.TableDimensionArchive direction = 2; */
        if (message.direction !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.direction);
        /* TST.TableCommandArchive super = 3; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool prev_repeating_header_enabled = 4; */
        if (message.prevRepeatingHeaderEnabled !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.prevRepeatingHeaderEnabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetRepeatingHeaderEnabledArchive
 */
exports.CommandSetRepeatingHeaderEnabledArchive = new CommandSetRepeatingHeaderEnabledArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetFiltersEnabledArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetFiltersEnabledArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "new_filters_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "old_filters_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "rollback_uid_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID }
        ]);
    }
    create(value) {
        const message = { newFiltersEnabled: false, rollbackUidList: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* bool new_filters_enabled */ 2:
                    message.newFiltersEnabled = reader.bool();
                    break;
                case /* optional bool old_filters_enabled */ 3:
                    message.oldFiltersEnabled = reader.bool();
                    break;
                case /* repeated TSP.UUID rollback_uid_list */ 4:
                    message.rollbackUidList.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool new_filters_enabled = 2; */
        if (message.newFiltersEnabled !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.newFiltersEnabled);
        /* optional bool old_filters_enabled = 3; */
        if (message.oldFiltersEnabled !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.oldFiltersEnabled);
        /* repeated TSP.UUID rollback_uid_list = 4; */
        for (let i = 0; i < message.rollbackUidList.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.rollbackUidList[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetFiltersEnabledArchive
 */
exports.CommandSetFiltersEnabledArchive = new CommandSetFiltersEnabledArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandAddTableStylePresetArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandAddTableStylePresetArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "preset_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "table_styles", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 4, name: "send_notification", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { presetIndex: 0, sendNotification: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* int32 preset_index */ 2:
                    message.presetIndex = reader.int32();
                    break;
                case /* TSP.Reference table_styles */ 3:
                    message.tableStyles = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.tableStyles);
                    break;
                case /* bool send_notification */ 4:
                    message.sendNotification = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* int32 preset_index = 2; */
        if (message.presetIndex !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.presetIndex);
        /* TSP.Reference table_styles = 3; */
        if (message.tableStyles)
            TSPMessages_5.Reference.internalBinaryWrite(message.tableStyles, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool send_notification = 4; */
        if (message.sendNotification !== false)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.sendNotification);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandAddTableStylePresetArchive
 */
exports.CommandAddTableStylePresetArchive = new CommandAddTableStylePresetArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandRemoveTableStylePresetArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandRemoveTableStylePresetArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_4.CommandArchive },
            { no: 2, name: "theme", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 3, name: "removed_table_styles", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 4, name: "preset_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "preset_index_in_theme", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = { presetId: 0, presetIndexInTheme: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_4.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Reference theme */ 2:
                    message.theme = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.theme);
                    break;
                case /* TSP.Reference removed_table_styles */ 3:
                    message.removedTableStyles = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.removedTableStyles);
                    break;
                case /* int32 preset_id */ 4:
                    message.presetId = reader.int32();
                    break;
                case /* int32 preset_index_in_theme */ 5:
                    message.presetIndexInTheme = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_4.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference theme = 2; */
        if (message.theme)
            TSPMessages_5.Reference.internalBinaryWrite(message.theme, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference removed_table_styles = 3; */
        if (message.removedTableStyles)
            TSPMessages_5.Reference.internalBinaryWrite(message.removedTableStyles, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* int32 preset_id = 4; */
        if (message.presetId !== 0)
            writer.tag(4, runtime_1.WireType.Varint).int32(message.presetId);
        /* int32 preset_index_in_theme = 5; */
        if (message.presetIndexInTheme !== 0)
            writer.tag(5, runtime_1.WireType.Varint).int32(message.presetIndexInTheme);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandRemoveTableStylePresetArchive
 */
exports.CommandRemoveTableStylePresetArchive = new CommandRemoveTableStylePresetArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandReplaceTableStylePresetArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandReplaceTableStylePresetArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_4.CommandArchive },
            { no: 2, name: "theme", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 3, name: "old_table_styles", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 4, name: "new_table_styles", kind: "message", T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_4.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Reference theme */ 2:
                    message.theme = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.theme);
                    break;
                case /* TSP.Reference old_table_styles */ 3:
                    message.oldTableStyles = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.oldTableStyles);
                    break;
                case /* TSP.Reference new_table_styles */ 4:
                    message.newTableStyles = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.newTableStyles);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_4.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference theme = 2; */
        if (message.theme)
            TSPMessages_5.Reference.internalBinaryWrite(message.theme, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference old_table_styles = 3; */
        if (message.oldTableStyles)
            TSPMessages_5.Reference.internalBinaryWrite(message.oldTableStyles, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference new_table_styles = 4; */
        if (message.newTableStyles)
            TSPMessages_5.Reference.internalBinaryWrite(message.newTableStyles, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandReplaceTableStylePresetArchive
 */
exports.CommandReplaceTableStylePresetArchive = new CommandReplaceTableStylePresetArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandApplyTableStylePresetArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandApplyTableStylePresetArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "preset", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 3, name: "styles", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 4, name: "undo_preset", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 5, name: "undo_styles", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 6, name: "cell_diff_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 7, name: "undo_cell_diff_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 8, name: "apply_preset_option", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "table_clears_all_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "undo_table_clears_all_flag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "row_col_styles", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ColumnRowMetadataArchive },
            { no: 14, name: "undo_row_col_styles", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ColumnRowMetadataArchive },
            { no: 15, name: "change_prop_map_wrapper", kind: "message", T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = { applyPresetOption: 0, tableClearsAllFlag: false, undoTableClearsAllFlag: false, rowColStyles: [], undoRowColStyles: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference preset */ 2:
                    message.preset = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.preset);
                    break;
                case /* optional TSP.Reference styles */ 3:
                    message.styles = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.styles);
                    break;
                case /* optional TSP.Reference undo_preset */ 4:
                    message.undoPreset = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoPreset);
                    break;
                case /* optional TSP.Reference undo_styles */ 5:
                    message.undoStyles = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoStyles);
                    break;
                case /* optional TSP.Reference cell_diff_map */ 6:
                    message.cellDiffMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.cellDiffMap);
                    break;
                case /* optional TSP.Reference undo_cell_diff_map */ 7:
                    message.undoCellDiffMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoCellDiffMap);
                    break;
                case /* int32 apply_preset_option */ 8:
                    message.applyPresetOption = reader.int32();
                    break;
                case /* bool table_clears_all_flag */ 11:
                    message.tableClearsAllFlag = reader.bool();
                    break;
                case /* bool undo_table_clears_all_flag */ 12:
                    message.undoTableClearsAllFlag = reader.bool();
                    break;
                case /* repeated TST.ColumnRowMetadataArchive row_col_styles */ 13:
                    message.rowColStyles.push(exports.ColumnRowMetadataArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TST.ColumnRowMetadataArchive undo_row_col_styles */ 14:
                    message.undoRowColStyles.push(exports.ColumnRowMetadataArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Reference change_prop_map_wrapper */ 15:
                    message.changePropMapWrapper = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.changePropMapWrapper);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference preset = 2; */
        if (message.preset)
            TSPMessages_5.Reference.internalBinaryWrite(message.preset, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference styles = 3; */
        if (message.styles)
            TSPMessages_5.Reference.internalBinaryWrite(message.styles, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_preset = 4; */
        if (message.undoPreset)
            TSPMessages_5.Reference.internalBinaryWrite(message.undoPreset, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_styles = 5; */
        if (message.undoStyles)
            TSPMessages_5.Reference.internalBinaryWrite(message.undoStyles, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference cell_diff_map = 6; */
        if (message.cellDiffMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.cellDiffMap, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_cell_diff_map = 7; */
        if (message.undoCellDiffMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.undoCellDiffMap, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* int32 apply_preset_option = 8; */
        if (message.applyPresetOption !== 0)
            writer.tag(8, runtime_1.WireType.Varint).int32(message.applyPresetOption);
        /* bool table_clears_all_flag = 11; */
        if (message.tableClearsAllFlag !== false)
            writer.tag(11, runtime_1.WireType.Varint).bool(message.tableClearsAllFlag);
        /* bool undo_table_clears_all_flag = 12; */
        if (message.undoTableClearsAllFlag !== false)
            writer.tag(12, runtime_1.WireType.Varint).bool(message.undoTableClearsAllFlag);
        /* repeated TST.ColumnRowMetadataArchive row_col_styles = 13; */
        for (let i = 0; i < message.rowColStyles.length; i++)
            exports.ColumnRowMetadataArchive.internalBinaryWrite(message.rowColStyles[i], writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TST.ColumnRowMetadataArchive undo_row_col_styles = 14; */
        for (let i = 0; i < message.undoRowColStyles.length; i++)
            exports.ColumnRowMetadataArchive.internalBinaryWrite(message.undoRowColStyles[i], writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference change_prop_map_wrapper = 15; */
        if (message.changePropMapWrapper)
            TSPMessages_5.Reference.internalBinaryWrite(message.changePropMapWrapper, writer.tag(15, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandApplyTableStylePresetArchive
 */
exports.CommandApplyTableStylePresetArchive = new CommandApplyTableStylePresetArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetBaseArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetBaseArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandMutateCellFormatArchive },
            { no: 2, name: "base", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { base: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.CommandMutateCellFormatArchive super */ 1:
                    message.super = exports.CommandMutateCellFormatArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* uint32 base */ 2:
                    message.base = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.CommandMutateCellFormatArchive super = 1; */
        if (message.super)
            exports.CommandMutateCellFormatArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 base = 2; */
        if (message.base !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.base);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetBaseArchive
 */
exports.CommandSetBaseArchive = new CommandSetBaseArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetBasePlacesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetBasePlacesArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandMutateCellFormatArchive },
            { no: 2, name: "base_places", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { basePlaces: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.CommandMutateCellFormatArchive super */ 1:
                    message.super = exports.CommandMutateCellFormatArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* uint32 base_places */ 2:
                    message.basePlaces = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.CommandMutateCellFormatArchive super = 1; */
        if (message.super)
            exports.CommandMutateCellFormatArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 base_places = 2; */
        if (message.basePlaces !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.basePlaces);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetBasePlacesArchive
 */
exports.CommandSetBasePlacesArchive = new CommandSetBasePlacesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetBaseUseMinusSignArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetBaseUseMinusSignArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandMutateCellFormatArchive },
            { no: 2, name: "base_use_minus_sign", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { baseUseMinusSign: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.CommandMutateCellFormatArchive super */ 1:
                    message.super = exports.CommandMutateCellFormatArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* bool base_use_minus_sign */ 2:
                    message.baseUseMinusSign = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.CommandMutateCellFormatArchive super = 1; */
        if (message.super)
            exports.CommandMutateCellFormatArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool base_use_minus_sign = 2; */
        if (message.baseUseMinusSign !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.baseUseMinusSign);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetBaseUseMinusSignArchive
 */
exports.CommandSetBaseUseMinusSignArchive = new CommandSetBaseUseMinusSignArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetCurrencyCodeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetCurrencyCodeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandMutateCellFormatArchive },
            { no: 2, name: "currency_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { currencyCode: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.CommandMutateCellFormatArchive super */ 1:
                    message.super = exports.CommandMutateCellFormatArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* string currency_code */ 2:
                    message.currencyCode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.CommandMutateCellFormatArchive super = 1; */
        if (message.super)
            exports.CommandMutateCellFormatArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string currency_code = 2; */
        if (message.currencyCode !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.currencyCode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetCurrencyCodeArchive
 */
exports.CommandSetCurrencyCodeArchive = new CommandSetCurrencyCodeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetFractionAccuracyArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetFractionAccuracyArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandMutateCellFormatArchive },
            { no: 2, name: "fraction_accuracy", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { fractionAccuracy: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.CommandMutateCellFormatArchive super */ 1:
                    message.super = exports.CommandMutateCellFormatArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* uint32 fraction_accuracy */ 2:
                    message.fractionAccuracy = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.CommandMutateCellFormatArchive super = 1; */
        if (message.super)
            exports.CommandMutateCellFormatArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 fraction_accuracy = 2; */
        if (message.fractionAccuracy !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.fractionAccuracy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetFractionAccuracyArchive
 */
exports.CommandSetFractionAccuracyArchive = new CommandSetFractionAccuracyArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetNegativeNumberStyleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetNegativeNumberStyleArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandMutateCellFormatArchive },
            { no: 2, name: "negative_number_style", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { negativeNumberStyle: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.CommandMutateCellFormatArchive super */ 1:
                    message.super = exports.CommandMutateCellFormatArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* uint32 negative_number_style */ 2:
                    message.negativeNumberStyle = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.CommandMutateCellFormatArchive super = 1; */
        if (message.super)
            exports.CommandMutateCellFormatArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 negative_number_style = 2; */
        if (message.negativeNumberStyle !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.negativeNumberStyle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetNegativeNumberStyleArchive
 */
exports.CommandSetNegativeNumberStyleArchive = new CommandSetNegativeNumberStyleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetNumberOfDecimalPlacesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetNumberOfDecimalPlacesArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandMutateCellFormatArchive },
            { no: 2, name: "decimal_places", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { decimalPlaces: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.CommandMutateCellFormatArchive super */ 1:
                    message.super = exports.CommandMutateCellFormatArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* uint32 decimal_places */ 2:
                    message.decimalPlaces = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.CommandMutateCellFormatArchive super = 1; */
        if (message.super)
            exports.CommandMutateCellFormatArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 decimal_places = 2; */
        if (message.decimalPlaces !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.decimalPlaces);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetNumberOfDecimalPlacesArchive
 */
exports.CommandSetNumberOfDecimalPlacesArchive = new CommandSetNumberOfDecimalPlacesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetDateTimeFormatArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetDateTimeFormatArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandMutateCellFormatArchive },
            { no: 2, name: "date_format_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "time_format_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.CommandMutateCellFormatArchive super */ 1:
                    message.super = exports.CommandMutateCellFormatArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional string date_format_string */ 2:
                    message.dateFormatString = reader.string();
                    break;
                case /* optional string time_format_string */ 3:
                    message.timeFormatString = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.CommandMutateCellFormatArchive super = 1; */
        if (message.super)
            exports.CommandMutateCellFormatArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string date_format_string = 2; */
        if (message.dateFormatString !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.dateFormatString);
        /* optional string time_format_string = 3; */
        if (message.timeFormatString !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.timeFormatString);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetDateTimeFormatArchive
 */
exports.CommandSetDateTimeFormatArchive = new CommandSetDateTimeFormatArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetShowThousandsSeparatorArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetShowThousandsSeparatorArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandMutateCellFormatArchive },
            { no: 2, name: "show_thousands_separator", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { showThousandsSeparator: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.CommandMutateCellFormatArchive super */ 1:
                    message.super = exports.CommandMutateCellFormatArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* bool show_thousands_separator */ 2:
                    message.showThousandsSeparator = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.CommandMutateCellFormatArchive super = 1; */
        if (message.super)
            exports.CommandMutateCellFormatArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool show_thousands_separator = 2; */
        if (message.showThousandsSeparator !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.showThousandsSeparator);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetShowThousandsSeparatorArchive
 */
exports.CommandSetShowThousandsSeparatorArchive = new CommandSetShowThousandsSeparatorArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetUseAccountingStyleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetUseAccountingStyleArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandMutateCellFormatArchive },
            { no: 2, name: "use_accounting_style", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { useAccountingStyle: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.CommandMutateCellFormatArchive super */ 1:
                    message.super = exports.CommandMutateCellFormatArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* bool use_accounting_style */ 2:
                    message.useAccountingStyle = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.CommandMutateCellFormatArchive super = 1; */
        if (message.super)
            exports.CommandMutateCellFormatArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool use_accounting_style = 2; */
        if (message.useAccountingStyle !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.useAccountingStyle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetUseAccountingStyleArchive
 */
exports.CommandSetUseAccountingStyleArchive = new CommandSetUseAccountingStyleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetRangeControlMinMaxIncArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetRangeControlMinMaxIncArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "minimum", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "maximum", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "increment", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "cell_diff_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 6, name: "cell_uid_list", kind: "message", T: () => TSTArchives_20.CellUIDListArchive },
            { no: 7, name: "inverse_cell_diff_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 8, name: "is_first_commit", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { isFirstCommit: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional double minimum */ 2:
                    message.minimum = reader.double();
                    break;
                case /* optional double maximum */ 3:
                    message.maximum = reader.double();
                    break;
                case /* optional double increment */ 4:
                    message.increment = reader.double();
                    break;
                case /* optional TSP.Reference cell_diff_map */ 5:
                    message.cellDiffMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.cellDiffMap);
                    break;
                case /* optional TST.CellUIDListArchive cell_uid_list */ 6:
                    message.cellUidList = TSTArchives_20.CellUIDListArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellUidList);
                    break;
                case /* optional TSP.Reference inverse_cell_diff_map */ 7:
                    message.inverseCellDiffMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.inverseCellDiffMap);
                    break;
                case /* bool is_first_commit */ 8:
                    message.isFirstCommit = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional double minimum = 2; */
        if (message.minimum !== undefined)
            writer.tag(2, runtime_1.WireType.Bit64).double(message.minimum);
        /* optional double maximum = 3; */
        if (message.maximum !== undefined)
            writer.tag(3, runtime_1.WireType.Bit64).double(message.maximum);
        /* optional double increment = 4; */
        if (message.increment !== undefined)
            writer.tag(4, runtime_1.WireType.Bit64).double(message.increment);
        /* optional TSP.Reference cell_diff_map = 5; */
        if (message.cellDiffMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.cellDiffMap, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.CellUIDListArchive cell_uid_list = 6; */
        if (message.cellUidList)
            TSTArchives_20.CellUIDListArchive.internalBinaryWrite(message.cellUidList, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference inverse_cell_diff_map = 7; */
        if (message.inverseCellDiffMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.inverseCellDiffMap, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool is_first_commit = 8; */
        if (message.isFirstCommit !== false)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.isFirstCommit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetRangeControlMinMaxIncArchive
 */
exports.CommandSetRangeControlMinMaxIncArchive = new CommandSetRangeControlMinMaxIncArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandMoveColumnsOrRowsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandMoveColumnsOrRowsArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "dest_uid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 3, name: "before", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "undo_dest_uid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 5, name: "undo_before", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 7, name: "direction", kind: "enum", T: () => ["TST.TableDimensionArchive", TSTArchives_22.TableDimensionArchive] },
            { no: 8, name: "formula_rewrite_command", kind: "message", T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = { before: false, undoBefore: false, uids: [], direction: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUID dest_uid */ 2:
                    message.destUid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.destUid);
                    break;
                case /* bool before */ 3:
                    message.before = reader.bool();
                    break;
                case /* TSP.UUID undo_dest_uid */ 4:
                    message.undoDestUid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.undoDestUid);
                    break;
                case /* bool undo_before */ 5:
                    message.undoBefore = reader.bool();
                    break;
                case /* repeated TSP.UUID uids */ 6:
                    message.uids.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* TST.TableDimensionArchive direction */ 7:
                    message.direction = reader.int32();
                    break;
                case /* optional TSP.Reference formula_rewrite_command */ 8:
                    message.formulaRewriteCommand = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.formulaRewriteCommand);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID dest_uid = 2; */
        if (message.destUid)
            TSPMessages_4.UUID.internalBinaryWrite(message.destUid, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool before = 3; */
        if (message.before !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.before);
        /* TSP.UUID undo_dest_uid = 4; */
        if (message.undoDestUid)
            TSPMessages_4.UUID.internalBinaryWrite(message.undoDestUid, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool undo_before = 5; */
        if (message.undoBefore !== false)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.undoBefore);
        /* repeated TSP.UUID uids = 6; */
        for (let i = 0; i < message.uids.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.uids[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.TableDimensionArchive direction = 7; */
        if (message.direction !== 0)
            writer.tag(7, runtime_1.WireType.Varint).int32(message.direction);
        /* optional TSP.Reference formula_rewrite_command = 8; */
        if (message.formulaRewriteCommand)
            TSPMessages_5.Reference.internalBinaryWrite(message.formulaRewriteCommand, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandMoveColumnsOrRowsArchive
 */
exports.CommandMoveColumnsOrRowsArchive = new CommandMoveColumnsOrRowsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSortArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSortArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "from_row_uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 3, name: "to_row_uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 4, name: "formula_rewrite_command", kind: "message", T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = { fromRowUids: [], toRowUids: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSP.UUID from_row_uids */ 2:
                    message.fromRowUids.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID to_row_uids */ 3:
                    message.toRowUids.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Reference formula_rewrite_command */ 4:
                    message.formulaRewriteCommand = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.formulaRewriteCommand);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID from_row_uids = 2; */
        for (let i = 0; i < message.fromRowUids.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.fromRowUids[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID to_row_uids = 3; */
        for (let i = 0; i < message.toRowUids.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.toRowUids[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference formula_rewrite_command = 4; */
        if (message.formulaRewriteCommand)
            TSPMessages_5.Reference.internalBinaryWrite(message.formulaRewriteCommand, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSortArchive
 */
exports.CommandSortArchive = new CommandSortArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormulaRewriteSpecArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.FormulaRewriteSpecArchive", [
            { no: 1, name: "rewrite_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "table_uid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 3, name: "cond_style_owner_uid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 4, name: "group_by_uid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 5, name: "is_inverse", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "column_or_row_uuids_info", kind: "message", T: () => TSCEArchives_13.ColumnOrRowUuidsInfoArchive },
            { no: 7, name: "aux_column_or_row_uuids_info", kind: "message", T: () => TSCEArchives_13.ColumnOrRowUuidsInfoArchive },
            { no: 8, name: "region_moved_info", kind: "message", T: () => TSCEArchives_12.RegionMovedInfoArchive },
            { no: 9, name: "region_info", kind: "message", T: () => TSCEArchives_11.RegionInfoArchive },
            { no: 10, name: "rewrite_table_id_info", kind: "message", T: () => TSCEArchives_10.RewriteTableUIDInfoArchive },
            { no: 11, name: "transposed_table_info", kind: "message", T: () => TSCEArchives_9.TableTransposeInfoArchive },
            { no: 12, name: "merge_origin_moved_info", kind: "message", T: () => TSCEArchives_8.MergeOriginMovedArchive },
            { no: 13, name: "merge_source", kind: "message", T: () => TSCEArchives_7.MergeSourceArchive },
            { no: 14, name: "group_node_info", kind: "message", T: () => TSCEArchives_6.RewriteGroupNodeUIDInfoArchive },
            { no: 15, name: "groupby_change", kind: "message", T: () => TSCEArchives_5.GroupByChangeArchive }
        ]);
    }
    create(value) {
        const message = { rewriteType: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 rewrite_type */ 1:
                    message.rewriteType = reader.uint32();
                    break;
                case /* optional TSP.UUID table_uid */ 2:
                    message.tableUid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.tableUid);
                    break;
                case /* optional TSP.UUID cond_style_owner_uid */ 3:
                    message.condStyleOwnerUid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.condStyleOwnerUid);
                    break;
                case /* optional TSP.UUID group_by_uid */ 4:
                    message.groupByUid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.groupByUid);
                    break;
                case /* optional bool is_inverse */ 5:
                    message.isInverse = reader.bool();
                    break;
                case /* optional TSCE.ColumnOrRowUuidsInfoArchive column_or_row_uuids_info */ 6:
                    message.columnOrRowUuidsInfo = TSCEArchives_13.ColumnOrRowUuidsInfoArchive.internalBinaryRead(reader, reader.uint32(), options, message.columnOrRowUuidsInfo);
                    break;
                case /* optional TSCE.ColumnOrRowUuidsInfoArchive aux_column_or_row_uuids_info */ 7:
                    message.auxColumnOrRowUuidsInfo = TSCEArchives_13.ColumnOrRowUuidsInfoArchive.internalBinaryRead(reader, reader.uint32(), options, message.auxColumnOrRowUuidsInfo);
                    break;
                case /* optional TSCE.RegionMovedInfoArchive region_moved_info */ 8:
                    message.regionMovedInfo = TSCEArchives_12.RegionMovedInfoArchive.internalBinaryRead(reader, reader.uint32(), options, message.regionMovedInfo);
                    break;
                case /* optional TSCE.RegionInfoArchive region_info */ 9:
                    message.regionInfo = TSCEArchives_11.RegionInfoArchive.internalBinaryRead(reader, reader.uint32(), options, message.regionInfo);
                    break;
                case /* optional TSCE.RewriteTableUIDInfoArchive rewrite_table_id_info */ 10:
                    message.rewriteTableIdInfo = TSCEArchives_10.RewriteTableUIDInfoArchive.internalBinaryRead(reader, reader.uint32(), options, message.rewriteTableIdInfo);
                    break;
                case /* optional TSCE.TableTransposeInfoArchive transposed_table_info */ 11:
                    message.transposedTableInfo = TSCEArchives_9.TableTransposeInfoArchive.internalBinaryRead(reader, reader.uint32(), options, message.transposedTableInfo);
                    break;
                case /* optional TSCE.MergeOriginMovedArchive merge_origin_moved_info */ 12:
                    message.mergeOriginMovedInfo = TSCEArchives_8.MergeOriginMovedArchive.internalBinaryRead(reader, reader.uint32(), options, message.mergeOriginMovedInfo);
                    break;
                case /* optional TSCE.MergeSourceArchive merge_source */ 13:
                    message.mergeSource = TSCEArchives_7.MergeSourceArchive.internalBinaryRead(reader, reader.uint32(), options, message.mergeSource);
                    break;
                case /* optional TSCE.RewriteGroupNodeUIDInfoArchive group_node_info */ 14:
                    message.groupNodeInfo = TSCEArchives_6.RewriteGroupNodeUIDInfoArchive.internalBinaryRead(reader, reader.uint32(), options, message.groupNodeInfo);
                    break;
                case /* optional TSCE.GroupByChangeArchive groupby_change */ 15:
                    message.groupbyChange = TSCEArchives_5.GroupByChangeArchive.internalBinaryRead(reader, reader.uint32(), options, message.groupbyChange);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 rewrite_type = 1; */
        if (message.rewriteType !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.rewriteType);
        /* optional TSP.UUID table_uid = 2; */
        if (message.tableUid)
            TSPMessages_4.UUID.internalBinaryWrite(message.tableUid, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID cond_style_owner_uid = 3; */
        if (message.condStyleOwnerUid)
            TSPMessages_4.UUID.internalBinaryWrite(message.condStyleOwnerUid, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID group_by_uid = 4; */
        if (message.groupByUid)
            TSPMessages_4.UUID.internalBinaryWrite(message.groupByUid, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_inverse = 5; */
        if (message.isInverse !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.isInverse);
        /* optional TSCE.ColumnOrRowUuidsInfoArchive column_or_row_uuids_info = 6; */
        if (message.columnOrRowUuidsInfo)
            TSCEArchives_13.ColumnOrRowUuidsInfoArchive.internalBinaryWrite(message.columnOrRowUuidsInfo, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.ColumnOrRowUuidsInfoArchive aux_column_or_row_uuids_info = 7; */
        if (message.auxColumnOrRowUuidsInfo)
            TSCEArchives_13.ColumnOrRowUuidsInfoArchive.internalBinaryWrite(message.auxColumnOrRowUuidsInfo, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.RegionMovedInfoArchive region_moved_info = 8; */
        if (message.regionMovedInfo)
            TSCEArchives_12.RegionMovedInfoArchive.internalBinaryWrite(message.regionMovedInfo, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.RegionInfoArchive region_info = 9; */
        if (message.regionInfo)
            TSCEArchives_11.RegionInfoArchive.internalBinaryWrite(message.regionInfo, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.RewriteTableUIDInfoArchive rewrite_table_id_info = 10; */
        if (message.rewriteTableIdInfo)
            TSCEArchives_10.RewriteTableUIDInfoArchive.internalBinaryWrite(message.rewriteTableIdInfo, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.TableTransposeInfoArchive transposed_table_info = 11; */
        if (message.transposedTableInfo)
            TSCEArchives_9.TableTransposeInfoArchive.internalBinaryWrite(message.transposedTableInfo, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.MergeOriginMovedArchive merge_origin_moved_info = 12; */
        if (message.mergeOriginMovedInfo)
            TSCEArchives_8.MergeOriginMovedArchive.internalBinaryWrite(message.mergeOriginMovedInfo, writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.MergeSourceArchive merge_source = 13; */
        if (message.mergeSource)
            TSCEArchives_7.MergeSourceArchive.internalBinaryWrite(message.mergeSource, writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.RewriteGroupNodeUIDInfoArchive group_node_info = 14; */
        if (message.groupNodeInfo)
            TSCEArchives_6.RewriteGroupNodeUIDInfoArchive.internalBinaryWrite(message.groupNodeInfo, writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.GroupByChangeArchive groupby_change = 15; */
        if (message.groupbyChange)
            TSCEArchives_5.GroupByChangeArchive.internalBinaryWrite(message.groupbyChange, writer.tag(15, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.FormulaRewriteSpecArchive
 */
exports.FormulaRewriteSpecArchive = new FormulaRewriteSpecArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandRewriteFormulasForTransposeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandRewriteFormulasForTransposeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "rewrite_spec", kind: "message", T: () => exports.FormulaRewriteSpecArchive },
            { no: 3, name: "formulas_to_rewrite", kind: "message", T: () => TSCEArchives_4.FormulasForUndoArchive },
            { no: 4, name: "warningset_map", kind: "message", T: () => TSTArchives_13.ImportWarningSetByCellRefArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TST.FormulaRewriteSpecArchive rewrite_spec */ 2:
                    message.rewriteSpec = exports.FormulaRewriteSpecArchive.internalBinaryRead(reader, reader.uint32(), options, message.rewriteSpec);
                    break;
                case /* TSCE.FormulasForUndoArchive formulas_to_rewrite */ 3:
                    message.formulasToRewrite = TSCEArchives_4.FormulasForUndoArchive.internalBinaryRead(reader, reader.uint32(), options, message.formulasToRewrite);
                    break;
                case /* optional TST.ImportWarningSetByCellRefArchive warningset_map */ 4:
                    message.warningsetMap = TSTArchives_13.ImportWarningSetByCellRefArchive.internalBinaryRead(reader, reader.uint32(), options, message.warningsetMap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.FormulaRewriteSpecArchive rewrite_spec = 2; */
        if (message.rewriteSpec)
            exports.FormulaRewriteSpecArchive.internalBinaryWrite(message.rewriteSpec, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSCE.FormulasForUndoArchive formulas_to_rewrite = 3; */
        if (message.formulasToRewrite)
            TSCEArchives_4.FormulasForUndoArchive.internalBinaryWrite(message.formulasToRewrite, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.ImportWarningSetByCellRefArchive warningset_map = 4; */
        if (message.warningsetMap)
            TSTArchives_13.ImportWarningSetByCellRefArchive.internalBinaryWrite(message.warningsetMap, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandRewriteFormulasForTransposeArchive
 */
exports.CommandRewriteFormulasForTransposeArchive = new CommandRewriteFormulasForTransposeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandRewriteTableFormulasForRewriteSpecArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandRewriteTableFormulasForRewriteSpecArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "rewrite_spec", kind: "message", T: () => exports.FormulaRewriteSpecArchive },
            { no: 3, name: "formulas_to_rewrite", kind: "message", T: () => TSCEArchives_4.FormulasForUndoArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TST.FormulaRewriteSpecArchive rewrite_spec */ 2:
                    message.rewriteSpec = exports.FormulaRewriteSpecArchive.internalBinaryRead(reader, reader.uint32(), options, message.rewriteSpec);
                    break;
                case /* TSCE.FormulasForUndoArchive formulas_to_rewrite */ 3:
                    message.formulasToRewrite = TSCEArchives_4.FormulasForUndoArchive.internalBinaryRead(reader, reader.uint32(), options, message.formulasToRewrite);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.FormulaRewriteSpecArchive rewrite_spec = 2; */
        if (message.rewriteSpec)
            exports.FormulaRewriteSpecArchive.internalBinaryWrite(message.rewriteSpec, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSCE.FormulasForUndoArchive formulas_to_rewrite = 3; */
        if (message.formulasToRewrite)
            TSCEArchives_4.FormulasForUndoArchive.internalBinaryWrite(message.formulasToRewrite, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandRewriteTableFormulasForRewriteSpecArchive
 */
exports.CommandRewriteTableFormulasForRewriteSpecArchive = new CommandRewriteTableFormulasForRewriteSpecArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandRewriteMergeFormulasArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandRewriteMergeFormulasArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "rewrite_spec", kind: "message", T: () => exports.FormulaRewriteSpecArchive },
            { no: 3, name: "formulas_to_rewrite", kind: "message", T: () => TSCEArchives_4.FormulasForUndoArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TST.FormulaRewriteSpecArchive rewrite_spec */ 2:
                    message.rewriteSpec = exports.FormulaRewriteSpecArchive.internalBinaryRead(reader, reader.uint32(), options, message.rewriteSpec);
                    break;
                case /* TSCE.FormulasForUndoArchive formulas_to_rewrite */ 3:
                    message.formulasToRewrite = TSCEArchives_4.FormulasForUndoArchive.internalBinaryRead(reader, reader.uint32(), options, message.formulasToRewrite);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.FormulaRewriteSpecArchive rewrite_spec = 2; */
        if (message.rewriteSpec)
            exports.FormulaRewriteSpecArchive.internalBinaryWrite(message.rewriteSpec, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSCE.FormulasForUndoArchive formulas_to_rewrite = 3; */
        if (message.formulasToRewrite)
            TSCEArchives_4.FormulasForUndoArchive.internalBinaryWrite(message.formulasToRewrite, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandRewriteMergeFormulasArchive
 */
exports.CommandRewriteMergeFormulasArchive = new CommandRewriteMergeFormulasArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandRewriteCategoryFormulasArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandRewriteCategoryFormulasArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "rewrite_spec", kind: "message", T: () => exports.FormulaRewriteSpecArchive },
            { no: 3, name: "formulas_to_rewrite", kind: "message", T: () => TSCEArchives_4.FormulasForUndoArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TST.FormulaRewriteSpecArchive rewrite_spec */ 2:
                    message.rewriteSpec = exports.FormulaRewriteSpecArchive.internalBinaryRead(reader, reader.uint32(), options, message.rewriteSpec);
                    break;
                case /* TSCE.FormulasForUndoArchive formulas_to_rewrite */ 3:
                    message.formulasToRewrite = TSCEArchives_4.FormulasForUndoArchive.internalBinaryRead(reader, reader.uint32(), options, message.formulasToRewrite);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.FormulaRewriteSpecArchive rewrite_spec = 2; */
        if (message.rewriteSpec)
            exports.FormulaRewriteSpecArchive.internalBinaryWrite(message.rewriteSpec, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSCE.FormulasForUndoArchive formulas_to_rewrite = 3; */
        if (message.formulasToRewrite)
            TSCEArchives_4.FormulasForUndoArchive.internalBinaryWrite(message.formulasToRewrite, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandRewriteCategoryFormulasArchive
 */
exports.CommandRewriteCategoryFormulasArchive = new CommandRewriteCategoryFormulasArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandRewriteFilterFormulasForTableResizeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandRewriteFilterFormulasForTableResizeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandRewriteFilterFormulasForTableResizeArchive
 */
exports.CommandRewriteFilterFormulasForTableResizeArchive = new CommandRewriteFilterFormulasForTableResizeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandRewriteFilterFormulasForRewriteSpecArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandRewriteFilterFormulasForRewriteSpecArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "filter_set", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 3, name: "rewrite_spec", kind: "message", T: () => exports.FormulaRewriteSpecArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Reference filter_set */ 2:
                    message.filterSet = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.filterSet);
                    break;
                case /* TST.FormulaRewriteSpecArchive rewrite_spec */ 3:
                    message.rewriteSpec = exports.FormulaRewriteSpecArchive.internalBinaryRead(reader, reader.uint32(), options, message.rewriteSpec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference filter_set = 2; */
        if (message.filterSet)
            TSPMessages_5.Reference.internalBinaryWrite(message.filterSet, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.FormulaRewriteSpecArchive rewrite_spec = 3; */
        if (message.rewriteSpec)
            exports.FormulaRewriteSpecArchive.internalBinaryWrite(message.rewriteSpec, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandRewriteFilterFormulasForRewriteSpecArchive
 */
exports.CommandRewriteFilterFormulasForRewriteSpecArchive = new CommandRewriteFilterFormulasForRewriteSpecArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandRewriteConditionalStylesForRewriteSpecArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandRewriteConditionalStylesForRewriteSpecArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "rewrite_spec", kind: "message", T: () => exports.FormulaRewriteSpecArchive },
            { no: 3, name: "formulas_to_rewrite", kind: "message", T: () => TSCEArchives_4.FormulasForUndoArchive },
            { no: 4, name: "conditional_style_sets", kind: "message", T: () => TSCEArchives_3.ExpandedCellRefObjectMapArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TST.FormulaRewriteSpecArchive rewrite_spec */ 2:
                    message.rewriteSpec = exports.FormulaRewriteSpecArchive.internalBinaryRead(reader, reader.uint32(), options, message.rewriteSpec);
                    break;
                case /* optional TSCE.FormulasForUndoArchive formulas_to_rewrite */ 3:
                    message.formulasToRewrite = TSCEArchives_4.FormulasForUndoArchive.internalBinaryRead(reader, reader.uint32(), options, message.formulasToRewrite);
                    break;
                case /* optional TSCE.ExpandedCellRefObjectMapArchive conditional_style_sets */ 4:
                    message.conditionalStyleSets = TSCEArchives_3.ExpandedCellRefObjectMapArchive.internalBinaryRead(reader, reader.uint32(), options, message.conditionalStyleSets);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.FormulaRewriteSpecArchive rewrite_spec = 2; */
        if (message.rewriteSpec)
            exports.FormulaRewriteSpecArchive.internalBinaryWrite(message.rewriteSpec, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.FormulasForUndoArchive formulas_to_rewrite = 3; */
        if (message.formulasToRewrite)
            TSCEArchives_4.FormulasForUndoArchive.internalBinaryWrite(message.formulasToRewrite, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.ExpandedCellRefObjectMapArchive conditional_style_sets = 4; */
        if (message.conditionalStyleSets)
            TSCEArchives_3.ExpandedCellRefObjectMapArchive.internalBinaryWrite(message.conditionalStyleSets, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandRewriteConditionalStylesForRewriteSpecArchive
 */
exports.CommandRewriteConditionalStylesForRewriteSpecArchive = new CommandRewriteConditionalStylesForRewriteSpecArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandRewritePivotOwnerFormulasArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandRewritePivotOwnerFormulasArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "rewrite_spec", kind: "message", T: () => exports.FormulaRewriteSpecArchive },
            { no: 3, name: "formulas_to_rewrite", kind: "message", T: () => TSCEArchives_4.FormulasForUndoArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TST.FormulaRewriteSpecArchive rewrite_spec */ 2:
                    message.rewriteSpec = exports.FormulaRewriteSpecArchive.internalBinaryRead(reader, reader.uint32(), options, message.rewriteSpec);
                    break;
                case /* TSCE.FormulasForUndoArchive formulas_to_rewrite */ 3:
                    message.formulasToRewrite = TSCEArchives_4.FormulasForUndoArchive.internalBinaryRead(reader, reader.uint32(), options, message.formulasToRewrite);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.FormulaRewriteSpecArchive rewrite_spec = 2; */
        if (message.rewriteSpec)
            exports.FormulaRewriteSpecArchive.internalBinaryWrite(message.rewriteSpec, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSCE.FormulasForUndoArchive formulas_to_rewrite = 3; */
        if (message.formulasToRewrite)
            TSCEArchives_4.FormulasForUndoArchive.internalBinaryWrite(message.formulasToRewrite, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandRewritePivotOwnerFormulasArchive
 */
exports.CommandRewritePivotOwnerFormulasArchive = new CommandRewritePivotOwnerFormulasArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandMergeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandMergeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "cell_uid_list", kind: "message", T: () => TSTArchives_20.CellUIDListArchive },
            { no: 3, name: "undo_cell_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 4, name: "undo_formula_rewrite_command", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 5, name: "merge_owner_rollback", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "commit_cell_map", kind: "message", T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TST.CellUIDListArchive cell_uid_list */ 2:
                    message.cellUidList = TSTArchives_20.CellUIDListArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellUidList);
                    break;
                case /* optional TSP.Reference undo_cell_map */ 3:
                    message.undoCellMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoCellMap);
                    break;
                case /* optional TSP.Reference undo_formula_rewrite_command */ 4:
                    message.undoFormulaRewriteCommand = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoFormulaRewriteCommand);
                    break;
                case /* optional uint32 merge_owner_rollback */ 5:
                    message.mergeOwnerRollback = reader.uint32();
                    break;
                case /* optional TSP.Reference commit_cell_map */ 6:
                    message.commitCellMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.commitCellMap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.CellUIDListArchive cell_uid_list = 2; */
        if (message.cellUidList)
            TSTArchives_20.CellUIDListArchive.internalBinaryWrite(message.cellUidList, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_cell_map = 3; */
        if (message.undoCellMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.undoCellMap, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_formula_rewrite_command = 4; */
        if (message.undoFormulaRewriteCommand)
            TSPMessages_5.Reference.internalBinaryWrite(message.undoFormulaRewriteCommand, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 merge_owner_rollback = 5; */
        if (message.mergeOwnerRollback !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.mergeOwnerRollback);
        /* optional TSP.Reference commit_cell_map = 6; */
        if (message.commitCellMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.commitCellMap, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandMergeArchive
 */
exports.CommandMergeArchive = new CommandMergeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandInverseMergeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandInverseMergeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.CommandApplyCellMapArchive },
            { no: 2, name: "merge_source_cell_uid", kind: "message", T: () => TSPMessages_2.UUIDCoordArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.CommandApplyCellMapArchive super */ 1:
                    message.super = exports.CommandApplyCellMapArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUIDCoordArchive merge_source_cell_uid */ 2:
                    message.mergeSourceCellUid = TSPMessages_2.UUIDCoordArchive.internalBinaryRead(reader, reader.uint32(), options, message.mergeSourceCellUid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.CommandApplyCellMapArchive super = 1; */
        if (message.super)
            exports.CommandApplyCellMapArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUIDCoordArchive merge_source_cell_uid = 2; */
        if (message.mergeSourceCellUid)
            TSPMessages_2.UUIDCoordArchive.internalBinaryWrite(message.mergeSourceCellUid, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandInverseMergeArchive
 */
exports.CommandInverseMergeArchive = new CommandInverseMergeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandUnmergeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandUnmergeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "unmerge_uid_ranges", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_3.UUIDRectArchive },
            { no: 3, name: "undo_cell_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 4, name: "undo_formula_rewrite_command", kind: "message", T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = { unmergeUidRanges: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSP.UUIDRectArchive unmerge_uid_ranges */ 2:
                    message.unmergeUidRanges.push(TSPMessages_3.UUIDRectArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Reference undo_cell_map */ 3:
                    message.undoCellMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoCellMap);
                    break;
                case /* optional TSP.Reference undo_formula_rewrite_command */ 4:
                    message.undoFormulaRewriteCommand = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoFormulaRewriteCommand);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUIDRectArchive unmerge_uid_ranges = 2; */
        for (let i = 0; i < message.unmergeUidRanges.length; i++)
            TSPMessages_3.UUIDRectArchive.internalBinaryWrite(message.unmergeUidRanges[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_cell_map = 3; */
        if (message.undoCellMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.undoCellMap, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_formula_rewrite_command = 4; */
        if (message.undoFormulaRewriteCommand)
            TSPMessages_5.Reference.internalBinaryWrite(message.undoFormulaRewriteCommand, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandUnmergeArchive
 */
exports.CommandUnmergeArchive = new CommandUnmergeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandChooseTableIdRemapperArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandChooseTableIdRemapperArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_4.CommandArchive },
            { no: 2, name: "table_id_mapper", kind: "message", T: () => TSTArchives_12.MultiTableRemapperArchive },
            { no: 3, name: "formula_rewrite_command_for_undo", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 4, name: "apply_and_clear", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { applyAndClear: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_4.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TST.MultiTableRemapperArchive table_id_mapper */ 2:
                    message.tableIdMapper = TSTArchives_12.MultiTableRemapperArchive.internalBinaryRead(reader, reader.uint32(), options, message.tableIdMapper);
                    break;
                case /* optional TSP.Reference formula_rewrite_command_for_undo */ 3:
                    message.formulaRewriteCommandForUndo = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.formulaRewriteCommandForUndo);
                    break;
                case /* bool apply_and_clear */ 4:
                    message.applyAndClear = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_4.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.MultiTableRemapperArchive table_id_mapper = 2; */
        if (message.tableIdMapper)
            TSTArchives_12.MultiTableRemapperArchive.internalBinaryWrite(message.tableIdMapper, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference formula_rewrite_command_for_undo = 3; */
        if (message.formulaRewriteCommandForUndo)
            TSPMessages_5.Reference.internalBinaryWrite(message.formulaRewriteCommandForUndo, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool apply_and_clear = 4; */
        if (message.applyAndClear !== false)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.applyAndClear);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandChooseTableIdRemapperArchive
 */
exports.CommandChooseTableIdRemapperArchive = new CommandChooseTableIdRemapperArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandCategorySetGroupingColumnsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandCategorySetGroupingColumnsArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "new_enabled_changing", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "old_enabled_changing", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "new_grouping_columns", kind: "message", T: () => TSTArchives_11.GroupColumnListArchive },
            { no: 5, name: "old_grouping_columns", kind: "message", T: () => TSTArchives_11.GroupColumnListArchive },
            { no: 6, name: "restore_base_order", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "base_row_order", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 8, name: "undo_restore_base_order", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "undo_base_row_order", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 10, name: "restore_view_order", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "view_row_order", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 12, name: "undo_restore_view_order", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "undo_view_row_order", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 14, name: "collapse_state", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 15, name: "undo_collapse_state", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 16, name: "summary_change_state", kind: "message", T: () => TSTArchives_10.SummaryModelGroupByChangeStateArchive },
            { no: 17, name: "undo_summary_change_state", kind: "message", T: () => TSTArchives_10.SummaryModelGroupByChangeStateArchive },
            { no: 18, name: "new_column_aggregates", kind: "message", T: () => TSTArchives_9.ColumnAggregateListArchive },
            { no: 19, name: "old_column_aggregates", kind: "message", T: () => TSTArchives_9.ColumnAggregateListArchive },
            { no: 20, name: "undo_set_enabled_rewrite_command", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 21, name: "undo_set_columns_rewrite_command", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 22, name: "force_restore_all_states", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 23, name: "cell_diff_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 24, name: "undo_cell_diff_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 25, name: "undo_set_group_sort_order_command", kind: "message", T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = { newEnabledChanging: 0, oldEnabledChanging: 0, restoreBaseOrder: false, baseRowOrder: [], undoRestoreBaseOrder: false, undoBaseRowOrder: [], restoreViewOrder: false, viewRowOrder: [], undoRestoreViewOrder: false, undoViewRowOrder: [], collapseState: [], undoCollapseState: [], forceRestoreAllStates: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* int32 new_enabled_changing */ 2:
                    message.newEnabledChanging = reader.int32();
                    break;
                case /* int32 old_enabled_changing */ 3:
                    message.oldEnabledChanging = reader.int32();
                    break;
                case /* TST.GroupColumnListArchive new_grouping_columns */ 4:
                    message.newGroupingColumns = TSTArchives_11.GroupColumnListArchive.internalBinaryRead(reader, reader.uint32(), options, message.newGroupingColumns);
                    break;
                case /* optional TST.GroupColumnListArchive old_grouping_columns */ 5:
                    message.oldGroupingColumns = TSTArchives_11.GroupColumnListArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldGroupingColumns);
                    break;
                case /* bool restore_base_order */ 6:
                    message.restoreBaseOrder = reader.bool();
                    break;
                case /* repeated TSP.UUID base_row_order */ 7:
                    message.baseRowOrder.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool undo_restore_base_order */ 8:
                    message.undoRestoreBaseOrder = reader.bool();
                    break;
                case /* repeated TSP.UUID undo_base_row_order */ 9:
                    message.undoBaseRowOrder.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool restore_view_order */ 10:
                    message.restoreViewOrder = reader.bool();
                    break;
                case /* repeated TSP.UUID view_row_order */ 11:
                    message.viewRowOrder.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool undo_restore_view_order */ 12:
                    message.undoRestoreViewOrder = reader.bool();
                    break;
                case /* repeated TSP.UUID undo_view_row_order */ 13:
                    message.undoViewRowOrder.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID collapse_state */ 14:
                    message.collapseState.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID undo_collapse_state */ 15:
                    message.undoCollapseState.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TST.SummaryModelGroupByChangeStateArchive summary_change_state */ 16:
                    message.summaryChangeState = TSTArchives_10.SummaryModelGroupByChangeStateArchive.internalBinaryRead(reader, reader.uint32(), options, message.summaryChangeState);
                    break;
                case /* optional TST.SummaryModelGroupByChangeStateArchive undo_summary_change_state */ 17:
                    message.undoSummaryChangeState = TSTArchives_10.SummaryModelGroupByChangeStateArchive.internalBinaryRead(reader, reader.uint32(), options, message.undoSummaryChangeState);
                    break;
                case /* optional TST.ColumnAggregateListArchive new_column_aggregates */ 18:
                    message.newColumnAggregates = TSTArchives_9.ColumnAggregateListArchive.internalBinaryRead(reader, reader.uint32(), options, message.newColumnAggregates);
                    break;
                case /* optional TST.ColumnAggregateListArchive old_column_aggregates */ 19:
                    message.oldColumnAggregates = TSTArchives_9.ColumnAggregateListArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldColumnAggregates);
                    break;
                case /* optional TSP.Reference undo_set_enabled_rewrite_command */ 20:
                    message.undoSetEnabledRewriteCommand = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoSetEnabledRewriteCommand);
                    break;
                case /* optional TSP.Reference undo_set_columns_rewrite_command */ 21:
                    message.undoSetColumnsRewriteCommand = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoSetColumnsRewriteCommand);
                    break;
                case /* bool force_restore_all_states */ 22:
                    message.forceRestoreAllStates = reader.bool();
                    break;
                case /* optional TSP.Reference cell_diff_map */ 23:
                    message.cellDiffMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.cellDiffMap);
                    break;
                case /* optional TSP.Reference undo_cell_diff_map */ 24:
                    message.undoCellDiffMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoCellDiffMap);
                    break;
                case /* optional TSP.Reference undo_set_group_sort_order_command */ 25:
                    message.undoSetGroupSortOrderCommand = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoSetGroupSortOrderCommand);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* int32 new_enabled_changing = 2; */
        if (message.newEnabledChanging !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.newEnabledChanging);
        /* int32 old_enabled_changing = 3; */
        if (message.oldEnabledChanging !== 0)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.oldEnabledChanging);
        /* TST.GroupColumnListArchive new_grouping_columns = 4; */
        if (message.newGroupingColumns)
            TSTArchives_11.GroupColumnListArchive.internalBinaryWrite(message.newGroupingColumns, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.GroupColumnListArchive old_grouping_columns = 5; */
        if (message.oldGroupingColumns)
            TSTArchives_11.GroupColumnListArchive.internalBinaryWrite(message.oldGroupingColumns, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool restore_base_order = 6; */
        if (message.restoreBaseOrder !== false)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.restoreBaseOrder);
        /* repeated TSP.UUID base_row_order = 7; */
        for (let i = 0; i < message.baseRowOrder.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.baseRowOrder[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool undo_restore_base_order = 8; */
        if (message.undoRestoreBaseOrder !== false)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.undoRestoreBaseOrder);
        /* repeated TSP.UUID undo_base_row_order = 9; */
        for (let i = 0; i < message.undoBaseRowOrder.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.undoBaseRowOrder[i], writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool restore_view_order = 10; */
        if (message.restoreViewOrder !== false)
            writer.tag(10, runtime_1.WireType.Varint).bool(message.restoreViewOrder);
        /* repeated TSP.UUID view_row_order = 11; */
        for (let i = 0; i < message.viewRowOrder.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.viewRowOrder[i], writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool undo_restore_view_order = 12; */
        if (message.undoRestoreViewOrder !== false)
            writer.tag(12, runtime_1.WireType.Varint).bool(message.undoRestoreViewOrder);
        /* repeated TSP.UUID undo_view_row_order = 13; */
        for (let i = 0; i < message.undoViewRowOrder.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.undoViewRowOrder[i], writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID collapse_state = 14; */
        for (let i = 0; i < message.collapseState.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.collapseState[i], writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID undo_collapse_state = 15; */
        for (let i = 0; i < message.undoCollapseState.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.undoCollapseState[i], writer.tag(15, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.SummaryModelGroupByChangeStateArchive summary_change_state = 16; */
        if (message.summaryChangeState)
            TSTArchives_10.SummaryModelGroupByChangeStateArchive.internalBinaryWrite(message.summaryChangeState, writer.tag(16, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.SummaryModelGroupByChangeStateArchive undo_summary_change_state = 17; */
        if (message.undoSummaryChangeState)
            TSTArchives_10.SummaryModelGroupByChangeStateArchive.internalBinaryWrite(message.undoSummaryChangeState, writer.tag(17, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.ColumnAggregateListArchive new_column_aggregates = 18; */
        if (message.newColumnAggregates)
            TSTArchives_9.ColumnAggregateListArchive.internalBinaryWrite(message.newColumnAggregates, writer.tag(18, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.ColumnAggregateListArchive old_column_aggregates = 19; */
        if (message.oldColumnAggregates)
            TSTArchives_9.ColumnAggregateListArchive.internalBinaryWrite(message.oldColumnAggregates, writer.tag(19, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_set_enabled_rewrite_command = 20; */
        if (message.undoSetEnabledRewriteCommand)
            TSPMessages_5.Reference.internalBinaryWrite(message.undoSetEnabledRewriteCommand, writer.tag(20, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_set_columns_rewrite_command = 21; */
        if (message.undoSetColumnsRewriteCommand)
            TSPMessages_5.Reference.internalBinaryWrite(message.undoSetColumnsRewriteCommand, writer.tag(21, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool force_restore_all_states = 22; */
        if (message.forceRestoreAllStates !== false)
            writer.tag(22, runtime_1.WireType.Varint).bool(message.forceRestoreAllStates);
        /* optional TSP.Reference cell_diff_map = 23; */
        if (message.cellDiffMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.cellDiffMap, writer.tag(23, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_cell_diff_map = 24; */
        if (message.undoCellDiffMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.undoCellDiffMap, writer.tag(24, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_set_group_sort_order_command = 25; */
        if (message.undoSetGroupSortOrderCommand)
            TSPMessages_5.Reference.internalBinaryWrite(message.undoSetGroupSortOrderCommand, writer.tag(25, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandCategorySetGroupingColumnsArchive
 */
exports.CommandCategorySetGroupingColumnsArchive = new CommandCategorySetGroupingColumnsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormulaEditingCommandGroupArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.FormulaEditingCommandGroupArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_2.ProgressiveCommandGroupArchive },
            { no: 2, name: "undoSelectionValid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "undoSelectionStart", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "undoSelectionLength", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "undoActiveToken", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "redoSelectionValid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "redoSelectionStart", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "redoSelectionLength", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "redoActiveToken", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { undoSelectionValid: false, undoSelectionStart: 0, undoSelectionLength: 0, undoActiveToken: 0, redoSelectionValid: false, redoSelectionStart: 0, redoSelectionLength: 0, redoActiveToken: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.ProgressiveCommandGroupArchive super */ 1:
                    message.super = TSKArchives_2.ProgressiveCommandGroupArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* bool undoSelectionValid */ 2:
                    message.undoSelectionValid = reader.bool();
                    break;
                case /* uint32 undoSelectionStart */ 3:
                    message.undoSelectionStart = reader.uint32();
                    break;
                case /* uint32 undoSelectionLength */ 4:
                    message.undoSelectionLength = reader.uint32();
                    break;
                case /* uint32 undoActiveToken */ 5:
                    message.undoActiveToken = reader.uint32();
                    break;
                case /* bool redoSelectionValid */ 6:
                    message.redoSelectionValid = reader.bool();
                    break;
                case /* uint32 redoSelectionStart */ 7:
                    message.redoSelectionStart = reader.uint32();
                    break;
                case /* uint32 redoSelectionLength */ 8:
                    message.redoSelectionLength = reader.uint32();
                    break;
                case /* uint32 redoActiveToken */ 9:
                    message.redoActiveToken = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.ProgressiveCommandGroupArchive super = 1; */
        if (message.super)
            TSKArchives_2.ProgressiveCommandGroupArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool undoSelectionValid = 2; */
        if (message.undoSelectionValid !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.undoSelectionValid);
        /* uint32 undoSelectionStart = 3; */
        if (message.undoSelectionStart !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.undoSelectionStart);
        /* uint32 undoSelectionLength = 4; */
        if (message.undoSelectionLength !== 0)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.undoSelectionLength);
        /* uint32 undoActiveToken = 5; */
        if (message.undoActiveToken !== 0)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.undoActiveToken);
        /* bool redoSelectionValid = 6; */
        if (message.redoSelectionValid !== false)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.redoSelectionValid);
        /* uint32 redoSelectionStart = 7; */
        if (message.redoSelectionStart !== 0)
            writer.tag(7, runtime_1.WireType.Varint).uint32(message.redoSelectionStart);
        /* uint32 redoSelectionLength = 8; */
        if (message.redoSelectionLength !== 0)
            writer.tag(8, runtime_1.WireType.Varint).uint32(message.redoSelectionLength);
        /* uint32 redoActiveToken = 9; */
        if (message.redoActiveToken !== 0)
            writer.tag(9, runtime_1.WireType.Varint).uint32(message.redoActiveToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.FormulaEditingCommandGroupArchive
 */
exports.FormulaEditingCommandGroupArchive = new FormulaEditingCommandGroupArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormulaEditingCommandSelectionBehaviorArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.FormulaEditingCommandSelectionBehaviorArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_1.CommandSelectionBehaviorArchive },
            { no: 2, name: "undoActiveToken", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "redoActiveToken", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandSelectionBehaviorArchive super */ 1:
                    message.super = TSKArchives_1.CommandSelectionBehaviorArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional uint32 undoActiveToken */ 2:
                    message.undoActiveToken = reader.uint32();
                    break;
                case /* optional uint32 redoActiveToken */ 3:
                    message.redoActiveToken = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandSelectionBehaviorArchive super = 1; */
        if (message.super)
            TSKArchives_1.CommandSelectionBehaviorArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 undoActiveToken = 2; */
        if (message.undoActiveToken !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.undoActiveToken);
        /* optional uint32 redoActiveToken = 3; */
        if (message.redoActiveToken !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.redoActiveToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.FormulaEditingCommandSelectionBehaviorArchive
 */
exports.FormulaEditingCommandSelectionBehaviorArchive = new FormulaEditingCommandSelectionBehaviorArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TableCommandSelectionBehaviorArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.TableCommandSelectionBehaviorArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_1.CommandSelectionBehaviorArchive },
            { no: 2, name: "table_info", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 3, name: "last_column_uid_hit_by_tap", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 4, name: "invalidate_comments", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandSelectionBehaviorArchive super */ 1:
                    message.super = TSKArchives_1.CommandSelectionBehaviorArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference table_info */ 2:
                    message.tableInfo = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.tableInfo);
                    break;
                case /* optional TSP.UUID last_column_uid_hit_by_tap */ 3:
                    message.lastColumnUidHitByTap = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.lastColumnUidHitByTap);
                    break;
                case /* optional uint32 invalidate_comments */ 4:
                    message.invalidateComments = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandSelectionBehaviorArchive super = 1; */
        if (message.super)
            TSKArchives_1.CommandSelectionBehaviorArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference table_info = 2; */
        if (message.tableInfo)
            TSPMessages_5.Reference.internalBinaryWrite(message.tableInfo, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID last_column_uid_hit_by_tap = 3; */
        if (message.lastColumnUidHitByTap)
            TSPMessages_4.UUID.internalBinaryWrite(message.lastColumnUidHitByTap, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 invalidate_comments = 4; */
        if (message.invalidateComments !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.invalidateComments);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.TableCommandSelectionBehaviorArchive
 */
exports.TableCommandSelectionBehaviorArchive = new TableCommandSelectionBehaviorArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandApplyCellCommentArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandApplyCellCommentArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "cell_uid", kind: "message", T: () => TSPMessages_2.UUIDCoordArchive },
            { no: 3, name: "old_comment_storage", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 4, name: "new_comment_storage", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 5, name: "forward_variant", kind: "enum", opt: true, T: () => ["TSD.CommentCommandVariant", TSDCommandArchives_1.CommentCommandVariant] },
            { no: 6, name: "inverse_variant", kind: "enum", opt: true, T: () => ["TSD.CommentCommandVariant", TSDCommandArchives_1.CommentCommandVariant] }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUIDCoordArchive cell_uid */ 2:
                    message.cellUid = TSPMessages_2.UUIDCoordArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellUid);
                    break;
                case /* optional TSP.Reference old_comment_storage */ 3:
                    message.oldCommentStorage = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.oldCommentStorage);
                    break;
                case /* optional TSP.Reference new_comment_storage */ 4:
                    message.newCommentStorage = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.newCommentStorage);
                    break;
                case /* optional TSD.CommentCommandVariant forward_variant */ 5:
                    message.forwardVariant = reader.int32();
                    break;
                case /* optional TSD.CommentCommandVariant inverse_variant */ 6:
                    message.inverseVariant = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUIDCoordArchive cell_uid = 2; */
        if (message.cellUid)
            TSPMessages_2.UUIDCoordArchive.internalBinaryWrite(message.cellUid, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference old_comment_storage = 3; */
        if (message.oldCommentStorage)
            TSPMessages_5.Reference.internalBinaryWrite(message.oldCommentStorage, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference new_comment_storage = 4; */
        if (message.newCommentStorage)
            TSPMessages_5.Reference.internalBinaryWrite(message.newCommentStorage, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.CommentCommandVariant forward_variant = 5; */
        if (message.forwardVariant !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).int32(message.forwardVariant);
        /* optional TSD.CommentCommandVariant inverse_variant = 6; */
        if (message.inverseVariant !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).int32(message.inverseVariant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandApplyCellCommentArchive
 */
exports.CommandApplyCellCommentArchive = new CommandApplyCellCommentArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetFormulaTokenizationArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetFormulaTokenizationArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_4.CommandArchive },
            { no: 2, name: "tokenization", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { tokenization: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_4.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* bool tokenization */ 2:
                    message.tokenization = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_4.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool tokenization = 2; */
        if (message.tokenization !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.tokenization);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetFormulaTokenizationArchive
 */
exports.CommandSetFormulaTokenizationArchive = new CommandSetFormulaTokenizationArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetFilterSetTypeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetFilterSetTypeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "old_filter_set_type", kind: "enum", opt: true, T: () => ["TST.FilterSetArchive.FilterSetType", TSTArchives_8.FilterSetArchive_FilterSetType] },
            { no: 3, name: "new_filter_set_type", kind: "enum", T: () => ["TST.FilterSetArchive.FilterSetType", TSTArchives_8.FilterSetArchive_FilterSetType] },
            { no: 4, name: "rollback_uid_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID }
        ]);
    }
    create(value) {
        const message = { newFilterSetType: 0, rollbackUidList: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TST.FilterSetArchive.FilterSetType old_filter_set_type */ 2:
                    message.oldFilterSetType = reader.int32();
                    break;
                case /* TST.FilterSetArchive.FilterSetType new_filter_set_type */ 3:
                    message.newFilterSetType = reader.int32();
                    break;
                case /* repeated TSP.UUID rollback_uid_list */ 4:
                    message.rollbackUidList.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.FilterSetArchive.FilterSetType old_filter_set_type = 2; */
        if (message.oldFilterSetType !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.oldFilterSetType);
        /* TST.FilterSetArchive.FilterSetType new_filter_set_type = 3; */
        if (message.newFilterSetType !== 0)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.newFilterSetType);
        /* repeated TSP.UUID rollback_uid_list = 4; */
        for (let i = 0; i < message.rollbackUidList.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.rollbackUidList[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetFilterSetTypeArchive
 */
exports.CommandSetFilterSetTypeArchive = new CommandSetFilterSetTypeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetTextStyleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetTextStyleArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "cell_diff_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 3, name: "inverse_cell_diff_map", kind: "message", T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Reference cell_diff_map */ 2:
                    message.cellDiffMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.cellDiffMap);
                    break;
                case /* optional TSP.Reference inverse_cell_diff_map */ 3:
                    message.inverseCellDiffMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.inverseCellDiffMap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference cell_diff_map = 2; */
        if (message.cellDiffMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.cellDiffMap, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference inverse_cell_diff_map = 3; */
        if (message.inverseCellDiffMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.inverseCellDiffMap, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetTextStyleArchive
 */
exports.CommandSetTextStyleArchive = new CommandSetTextStyleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetTextStylePropertiesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetTextStylePropertiesArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "cell_diff_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 3, name: "cell_was_rich_text", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "inverse_cell_diff_map", kind: "message", T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = { cellWasRichText: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Reference cell_diff_map */ 2:
                    message.cellDiffMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.cellDiffMap);
                    break;
                case /* repeated bool cell_was_rich_text */ 3:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.cellWasRichText.push(reader.bool());
                    else
                        message.cellWasRichText.push(reader.bool());
                    break;
                case /* optional TSP.Reference inverse_cell_diff_map */ 4:
                    message.inverseCellDiffMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.inverseCellDiffMap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference cell_diff_map = 2; */
        if (message.cellDiffMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.cellDiffMap, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated bool cell_was_rich_text = 3; */
        for (let i = 0; i < message.cellWasRichText.length; i++)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.cellWasRichText[i]);
        /* optional TSP.Reference inverse_cell_diff_map = 4; */
        if (message.inverseCellDiffMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.inverseCellDiffMap, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetTextStylePropertiesArchive
 */
exports.CommandSetTextStylePropertiesArchive = new CommandSetTextStylePropertiesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandJustForNotifyingArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandJustForNotifyingArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "change_descriptor_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { changeDescriptorType: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* uint32 change_descriptor_type */ 2:
                    message.changeDescriptorType = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 change_descriptor_type = 2; */
        if (message.changeDescriptorType !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.changeDescriptorType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandJustForNotifyingArchive
 */
exports.CommandJustForNotifyingArchive = new CommandJustForNotifyingArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetStorageLanguageArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetStorageLanguageArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_4.CommandArchive },
            { no: 2, name: "storage", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 3, name: "language", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "range_location", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "range_length", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "undo_transaction", kind: "message", T: () => TSWPArchives_1.UndoTransaction }
        ]);
    }
    create(value) {
        const message = { language: "", rangeLocation: 0, rangeLength: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_4.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Reference storage */ 2:
                    message.storage = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.storage);
                    break;
                case /* string language */ 3:
                    message.language = reader.string();
                    break;
                case /* uint32 range_location */ 4:
                    message.rangeLocation = reader.uint32();
                    break;
                case /* uint32 range_length */ 5:
                    message.rangeLength = reader.uint32();
                    break;
                case /* optional TSWP.UndoTransaction undo_transaction */ 6:
                    message.undoTransaction = TSWPArchives_1.UndoTransaction.internalBinaryRead(reader, reader.uint32(), options, message.undoTransaction);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_4.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference storage = 2; */
        if (message.storage)
            TSPMessages_5.Reference.internalBinaryWrite(message.storage, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string language = 3; */
        if (message.language !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.language);
        /* uint32 range_location = 4; */
        if (message.rangeLocation !== 0)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.rangeLocation);
        /* uint32 range_length = 5; */
        if (message.rangeLength !== 0)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.rangeLength);
        /* optional TSWP.UndoTransaction undo_transaction = 6; */
        if (message.undoTransaction)
            TSWPArchives_1.UndoTransaction.internalBinaryWrite(message.undoTransaction, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetStorageLanguageArchive
 */
exports.CommandSetStorageLanguageArchive = new CommandSetStorageLanguageArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetSortOrderArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetSortOrderArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "old_sort_order", kind: "message", T: () => TSTArchives_7.TableSortOrderArchive },
            { no: 3, name: "new_sort_order", kind: "message", T: () => TSTArchives_7.TableSortOrderArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TST.TableSortOrderArchive old_sort_order */ 2:
                    message.oldSortOrder = TSTArchives_7.TableSortOrderArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldSortOrder);
                    break;
                case /* optional TST.TableSortOrderArchive new_sort_order */ 3:
                    message.newSortOrder = TSTArchives_7.TableSortOrderArchive.internalBinaryRead(reader, reader.uint32(), options, message.newSortOrder);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.TableSortOrderArchive old_sort_order = 2; */
        if (message.oldSortOrder)
            TSTArchives_7.TableSortOrderArchive.internalBinaryWrite(message.oldSortOrder, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.TableSortOrderArchive new_sort_order = 3; */
        if (message.newSortOrder)
            TSTArchives_7.TableSortOrderArchive.internalBinaryWrite(message.newSortOrder, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetSortOrderArchive
 */
exports.CommandSetSortOrderArchive = new CommandSetSortOrderArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetGroupSortOrderArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetGroupSortOrderArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "old_group_sort_order", kind: "message", T: () => TSTArchives_17.TableGroupSortOrderUIDArchive },
            { no: 3, name: "new_group_sort_order", kind: "message", T: () => TSTArchives_17.TableGroupSortOrderUIDArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TST.TableGroupSortOrderUIDArchive old_group_sort_order */ 2:
                    message.oldGroupSortOrder = TSTArchives_17.TableGroupSortOrderUIDArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldGroupSortOrder);
                    break;
                case /* optional TST.TableGroupSortOrderUIDArchive new_group_sort_order */ 3:
                    message.newGroupSortOrder = TSTArchives_17.TableGroupSortOrderUIDArchive.internalBinaryRead(reader, reader.uint32(), options, message.newGroupSortOrder);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.TableGroupSortOrderUIDArchive old_group_sort_order = 2; */
        if (message.oldGroupSortOrder)
            TSTArchives_17.TableGroupSortOrderUIDArchive.internalBinaryWrite(message.oldGroupSortOrder, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.TableGroupSortOrderUIDArchive new_group_sort_order = 3; */
        if (message.newGroupSortOrder)
            TSTArchives_17.TableGroupSortOrderUIDArchive.internalBinaryWrite(message.newGroupSortOrder, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetGroupSortOrderArchive
 */
exports.CommandSetGroupSortOrderArchive = new CommandSetGroupSortOrderArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandRewriteSortOrderForTableResizeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandRewriteSortOrderForTableResizeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "old_sort_order", kind: "message", T: () => TSTArchives_7.TableSortOrderArchive },
            { no: 3, name: "new_sort_order", kind: "message", T: () => TSTArchives_7.TableSortOrderArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TST.TableSortOrderArchive old_sort_order */ 2:
                    message.oldSortOrder = TSTArchives_7.TableSortOrderArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldSortOrder);
                    break;
                case /* optional TST.TableSortOrderArchive new_sort_order */ 3:
                    message.newSortOrder = TSTArchives_7.TableSortOrderArchive.internalBinaryRead(reader, reader.uint32(), options, message.newSortOrder);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.TableSortOrderArchive old_sort_order = 2; */
        if (message.oldSortOrder)
            TSTArchives_7.TableSortOrderArchive.internalBinaryWrite(message.oldSortOrder, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.TableSortOrderArchive new_sort_order = 3; */
        if (message.newSortOrder)
            TSTArchives_7.TableSortOrderArchive.internalBinaryWrite(message.newSortOrder, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandRewriteSortOrderForTableResizeArchive
 */
exports.CommandRewriteSortOrderForTableResizeArchive = new CommandRewriteSortOrderForTableResizeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandRewriteSortOrderForRewriteSpecArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandRewriteSortOrderForRewriteSpecArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "rewrite_spec", kind: "message", T: () => exports.FormulaRewriteSpecArchive },
            { no: 3, name: "old_sort_order", kind: "message", T: () => TSTArchives_7.TableSortOrderArchive },
            { no: 4, name: "new_sort_order", kind: "message", T: () => TSTArchives_7.TableSortOrderArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TST.FormulaRewriteSpecArchive rewrite_spec */ 2:
                    message.rewriteSpec = exports.FormulaRewriteSpecArchive.internalBinaryRead(reader, reader.uint32(), options, message.rewriteSpec);
                    break;
                case /* optional TST.TableSortOrderArchive old_sort_order */ 3:
                    message.oldSortOrder = TSTArchives_7.TableSortOrderArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldSortOrder);
                    break;
                case /* optional TST.TableSortOrderArchive new_sort_order */ 4:
                    message.newSortOrder = TSTArchives_7.TableSortOrderArchive.internalBinaryRead(reader, reader.uint32(), options, message.newSortOrder);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.FormulaRewriteSpecArchive rewrite_spec = 2; */
        if (message.rewriteSpec)
            exports.FormulaRewriteSpecArchive.internalBinaryWrite(message.rewriteSpec, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.TableSortOrderArchive old_sort_order = 3; */
        if (message.oldSortOrder)
            TSTArchives_7.TableSortOrderArchive.internalBinaryWrite(message.oldSortOrder, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.TableSortOrderArchive new_sort_order = 4; */
        if (message.newSortOrder)
            TSTArchives_7.TableSortOrderArchive.internalBinaryWrite(message.newSortOrder, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandRewriteSortOrderForRewriteSpecArchive
 */
exports.CommandRewriteSortOrderForRewriteSpecArchive = new CommandRewriteSortOrderForRewriteSpecArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetFilterSetArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetFilterSetArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "new_filter_set", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 3, name: "old_filter_set", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 4, name: "rollback_uid_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID }
        ]);
    }
    create(value) {
        const message = { rollbackUidList: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Reference new_filter_set */ 2:
                    message.newFilterSet = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.newFilterSet);
                    break;
                case /* optional TSP.Reference old_filter_set */ 3:
                    message.oldFilterSet = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.oldFilterSet);
                    break;
                case /* repeated TSP.UUID rollback_uid_list */ 4:
                    message.rollbackUidList.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference new_filter_set = 2; */
        if (message.newFilterSet)
            TSPMessages_5.Reference.internalBinaryWrite(message.newFilterSet, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference old_filter_set = 3; */
        if (message.oldFilterSet)
            TSPMessages_5.Reference.internalBinaryWrite(message.oldFilterSet, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID rollback_uid_list = 4; */
        for (let i = 0; i < message.rollbackUidList.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.rollbackUidList[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetFilterSetArchive
 */
exports.CommandSetFilterSetArchive = new CommandSetFilterSetArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ColumnRowRestoreDataArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.ColumnRowRestoreDataArchive", [
            { no: 1, name: "uid_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 2, name: "metadatas", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ColumnRowMetadataArchive }
        ]);
    }
    create(value) {
        const message = { uidList: [], metadatas: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.UUID uid_list */ 1:
                    message.uidList.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TST.ColumnRowMetadataArchive metadatas */ 2:
                    message.metadatas.push(exports.ColumnRowMetadataArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.UUID uid_list = 1; */
        for (let i = 0; i < message.uidList.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.uidList[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TST.ColumnRowMetadataArchive metadatas = 2; */
        for (let i = 0; i < message.metadatas.length; i++)
            exports.ColumnRowMetadataArchive.internalBinaryWrite(message.metadatas[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.ColumnRowRestoreDataArchive
 */
exports.ColumnRowRestoreDataArchive = new ColumnRowRestoreDataArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandTransposeTableArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandTransposeTableArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "original_table_range", kind: "message", T: () => TSTArchives_6.ExpandedCellRange },
            { no: 3, name: "original_cell_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 4, name: "original_footer_row_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "original_column_widths", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "original_row_heights", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "ineligible_merge_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSTArchives_5.CellRange },
            { no: 8, name: "transposed_cell_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 9, name: "undo_formula_rewrite_command", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 10, name: "rich_text_subcommands", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 11, name: "column_restore_data", kind: "message", T: () => exports.ColumnRowRestoreDataArchive },
            { no: 12, name: "row_restore_data", kind: "message", T: () => exports.ColumnRowRestoreDataArchive }
        ]);
    }
    create(value) {
        const message = { originalFooterRowCount: 0, originalColumnWidths: [], originalRowHeights: [], ineligibleMergeList: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TST.ExpandedCellRange original_table_range */ 2:
                    message.originalTableRange = TSTArchives_6.ExpandedCellRange.internalBinaryRead(reader, reader.uint32(), options, message.originalTableRange);
                    break;
                case /* TSP.Reference original_cell_map */ 3:
                    message.originalCellMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.originalCellMap);
                    break;
                case /* uint32 original_footer_row_count */ 4:
                    message.originalFooterRowCount = reader.uint32();
                    break;
                case /* repeated float original_column_widths */ 5:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.originalColumnWidths.push(reader.float());
                    else
                        message.originalColumnWidths.push(reader.float());
                    break;
                case /* repeated float original_row_heights */ 6:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.originalRowHeights.push(reader.float());
                    else
                        message.originalRowHeights.push(reader.float());
                    break;
                case /* repeated TST.CellRange ineligible_merge_list */ 7:
                    message.ineligibleMergeList.push(TSTArchives_5.CellRange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* TSP.Reference transposed_cell_map */ 8:
                    message.transposedCellMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.transposedCellMap);
                    break;
                case /* optional TSP.Reference undo_formula_rewrite_command */ 9:
                    message.undoFormulaRewriteCommand = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoFormulaRewriteCommand);
                    break;
                case /* optional TSP.Reference rich_text_subcommands */ 10:
                    message.richTextSubcommands = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.richTextSubcommands);
                    break;
                case /* optional TST.ColumnRowRestoreDataArchive column_restore_data */ 11:
                    message.columnRestoreData = exports.ColumnRowRestoreDataArchive.internalBinaryRead(reader, reader.uint32(), options, message.columnRestoreData);
                    break;
                case /* optional TST.ColumnRowRestoreDataArchive row_restore_data */ 12:
                    message.rowRestoreData = exports.ColumnRowRestoreDataArchive.internalBinaryRead(reader, reader.uint32(), options, message.rowRestoreData);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.ExpandedCellRange original_table_range = 2; */
        if (message.originalTableRange)
            TSTArchives_6.ExpandedCellRange.internalBinaryWrite(message.originalTableRange, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference original_cell_map = 3; */
        if (message.originalCellMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.originalCellMap, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 original_footer_row_count = 4; */
        if (message.originalFooterRowCount !== 0)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.originalFooterRowCount);
        /* repeated float original_column_widths = 5; */
        for (let i = 0; i < message.originalColumnWidths.length; i++)
            writer.tag(5, runtime_1.WireType.Bit32).float(message.originalColumnWidths[i]);
        /* repeated float original_row_heights = 6; */
        for (let i = 0; i < message.originalRowHeights.length; i++)
            writer.tag(6, runtime_1.WireType.Bit32).float(message.originalRowHeights[i]);
        /* repeated TST.CellRange ineligible_merge_list = 7; */
        for (let i = 0; i < message.ineligibleMergeList.length; i++)
            TSTArchives_5.CellRange.internalBinaryWrite(message.ineligibleMergeList[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference transposed_cell_map = 8; */
        if (message.transposedCellMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.transposedCellMap, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_formula_rewrite_command = 9; */
        if (message.undoFormulaRewriteCommand)
            TSPMessages_5.Reference.internalBinaryWrite(message.undoFormulaRewriteCommand, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference rich_text_subcommands = 10; */
        if (message.richTextSubcommands)
            TSPMessages_5.Reference.internalBinaryWrite(message.richTextSubcommands, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.ColumnRowRestoreDataArchive column_restore_data = 11; */
        if (message.columnRestoreData)
            exports.ColumnRowRestoreDataArchive.internalBinaryWrite(message.columnRestoreData, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.ColumnRowRestoreDataArchive row_restore_data = 12; */
        if (message.rowRestoreData)
            exports.ColumnRowRestoreDataArchive.internalBinaryWrite(message.rowRestoreData, writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandTransposeTableArchive
 */
exports.CommandTransposeTableArchive = new CommandTransposeTableArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandSetStructuredTextImportRecordArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandSetStructuredTextImportRecordArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "new_import_record", kind: "message", T: () => TSTArchives_4.StructuredTextImportRecord },
            { no: 3, name: "old_import_record", kind: "message", T: () => TSTArchives_4.StructuredTextImportRecord }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TST.StructuredTextImportRecord new_import_record */ 2:
                    message.newImportRecord = TSTArchives_4.StructuredTextImportRecord.internalBinaryRead(reader, reader.uint32(), options, message.newImportRecord);
                    break;
                case /* optional TST.StructuredTextImportRecord old_import_record */ 3:
                    message.oldImportRecord = TSTArchives_4.StructuredTextImportRecord.internalBinaryRead(reader, reader.uint32(), options, message.oldImportRecord);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.StructuredTextImportRecord new_import_record = 2; */
        if (message.newImportRecord)
            TSTArchives_4.StructuredTextImportRecord.internalBinaryWrite(message.newImportRecord, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.StructuredTextImportRecord old_import_record = 3; */
        if (message.oldImportRecord)
            TSTArchives_4.StructuredTextImportRecord.internalBinaryWrite(message.oldImportRecord, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandSetStructuredTextImportRecordArchive
 */
exports.CommandSetStructuredTextImportRecordArchive = new CommandSetStructuredTextImportRecordArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandCategoryCollapseExpandGroupArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandCategoryCollapseExpandGroupArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "is_collapsing", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "grouping_columns", kind: "message", T: () => TSTArchives_11.GroupColumnListArchive },
            { no: 4, name: "collapse_state", kind: "message", T: () => TSTArchives_3.ExpandCollapseStateArchive },
            { no: 5, name: "undo_collapse_state", kind: "message", T: () => TSTArchives_3.ExpandCollapseStateArchive }
        ]);
    }
    create(value) {
        const message = { isCollapsing: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* bool is_collapsing */ 2:
                    message.isCollapsing = reader.bool();
                    break;
                case /* TST.GroupColumnListArchive grouping_columns */ 3:
                    message.groupingColumns = TSTArchives_11.GroupColumnListArchive.internalBinaryRead(reader, reader.uint32(), options, message.groupingColumns);
                    break;
                case /* TST.ExpandCollapseStateArchive collapse_state */ 4:
                    message.collapseState = TSTArchives_3.ExpandCollapseStateArchive.internalBinaryRead(reader, reader.uint32(), options, message.collapseState);
                    break;
                case /* optional TST.ExpandCollapseStateArchive undo_collapse_state */ 5:
                    message.undoCollapseState = TSTArchives_3.ExpandCollapseStateArchive.internalBinaryRead(reader, reader.uint32(), options, message.undoCollapseState);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool is_collapsing = 2; */
        if (message.isCollapsing !== false)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.isCollapsing);
        /* TST.GroupColumnListArchive grouping_columns = 3; */
        if (message.groupingColumns)
            TSTArchives_11.GroupColumnListArchive.internalBinaryWrite(message.groupingColumns, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.ExpandCollapseStateArchive collapse_state = 4; */
        if (message.collapseState)
            TSTArchives_3.ExpandCollapseStateArchive.internalBinaryWrite(message.collapseState, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.ExpandCollapseStateArchive undo_collapse_state = 5; */
        if (message.undoCollapseState)
            TSTArchives_3.ExpandCollapseStateArchive.internalBinaryWrite(message.undoCollapseState, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandCategoryCollapseExpandGroupArchive
 */
exports.CommandCategoryCollapseExpandGroupArchive = new CommandCategoryCollapseExpandGroupArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandCategoryChangeSummaryAggregateType$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandCategoryChangeSummaryAggregateType", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "aggregate_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "undo_aggregate_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "column_uid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 5, name: "group_level", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value) {
        const message = { aggregateType: 0, undoAggregateType: 0, groupLevel: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* uint32 aggregate_type */ 2:
                    message.aggregateType = reader.uint32();
                    break;
                case /* uint32 undo_aggregate_type */ 3:
                    message.undoAggregateType = reader.uint32();
                    break;
                case /* TSP.UUID column_uid */ 4:
                    message.columnUid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.columnUid);
                    break;
                case /* sint32 group_level */ 5:
                    message.groupLevel = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 aggregate_type = 2; */
        if (message.aggregateType !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.aggregateType);
        /* uint32 undo_aggregate_type = 3; */
        if (message.undoAggregateType !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.undoAggregateType);
        /* TSP.UUID column_uid = 4; */
        if (message.columnUid)
            TSPMessages_4.UUID.internalBinaryWrite(message.columnUid, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* sint32 group_level = 5; */
        if (message.groupLevel !== 0)
            writer.tag(5, runtime_1.WireType.Varint).sint32(message.groupLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandCategoryChangeSummaryAggregateType
 */
exports.CommandCategoryChangeSummaryAggregateType = new CommandCategoryChangeSummaryAggregateType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandCategorySetLabelRowVisibility$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandCategorySetLabelRowVisibility", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "group_level", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "label_row_visibility", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "undo_label_row_visibility", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { groupLevel: 0, labelRowVisibility: 0, undoLabelRowVisibility: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* uint32 group_level */ 2:
                    message.groupLevel = reader.uint32();
                    break;
                case /* uint32 label_row_visibility */ 3:
                    message.labelRowVisibility = reader.uint32();
                    break;
                case /* uint32 undo_label_row_visibility */ 4:
                    message.undoLabelRowVisibility = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 group_level = 2; */
        if (message.groupLevel !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.groupLevel);
        /* uint32 label_row_visibility = 3; */
        if (message.labelRowVisibility !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.labelRowVisibility);
        /* uint32 undo_label_row_visibility = 4; */
        if (message.undoLabelRowVisibility !== 0)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.undoLabelRowVisibility);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandCategorySetLabelRowVisibility
 */
exports.CommandCategorySetLabelRowVisibility = new CommandCategorySetLabelRowVisibility$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandCategoryWillChangeGroupValue$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandCategoryWillChangeGroupValue", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "group_node_uid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 3, name: "undo_group_node_uid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 4, name: "group_value", kind: "message", T: () => TSCEArchives_2.CellValueArchive },
            { no: 5, name: "undo_group_value", kind: "message", T: () => TSCEArchives_2.CellValueArchive },
            { no: 6, name: "rewrite_command_for_undo", kind: "message", T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUID group_node_uid */ 2:
                    message.groupNodeUid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.groupNodeUid);
                    break;
                case /* optional TSP.UUID undo_group_node_uid */ 3:
                    message.undoGroupNodeUid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.undoGroupNodeUid);
                    break;
                case /* optional TSCE.CellValueArchive group_value */ 4:
                    message.groupValue = TSCEArchives_2.CellValueArchive.internalBinaryRead(reader, reader.uint32(), options, message.groupValue);
                    break;
                case /* optional TSCE.CellValueArchive undo_group_value */ 5:
                    message.undoGroupValue = TSCEArchives_2.CellValueArchive.internalBinaryRead(reader, reader.uint32(), options, message.undoGroupValue);
                    break;
                case /* optional TSP.Reference rewrite_command_for_undo */ 6:
                    message.rewriteCommandForUndo = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.rewriteCommandForUndo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID group_node_uid = 2; */
        if (message.groupNodeUid)
            TSPMessages_4.UUID.internalBinaryWrite(message.groupNodeUid, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID undo_group_node_uid = 3; */
        if (message.undoGroupNodeUid)
            TSPMessages_4.UUID.internalBinaryWrite(message.undoGroupNodeUid, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.CellValueArchive group_value = 4; */
        if (message.groupValue)
            TSCEArchives_2.CellValueArchive.internalBinaryWrite(message.groupValue, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.CellValueArchive undo_group_value = 5; */
        if (message.undoGroupValue)
            TSCEArchives_2.CellValueArchive.internalBinaryWrite(message.undoGroupValue, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference rewrite_command_for_undo = 6; */
        if (message.rewriteCommandForUndo)
            TSPMessages_5.Reference.internalBinaryWrite(message.rewriteCommandForUndo, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandCategoryWillChangeGroupValue
 */
exports.CommandCategoryWillChangeGroupValue = new CommandCategoryWillChangeGroupValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IdempotentSelectionTransformerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.IdempotentSelectionTransformerArchive", [
            { no: 1, name: "archived_selection", kind: "message", T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.Reference archived_selection */ 1:
                    message.archivedSelection = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.archivedSelection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.Reference archived_selection = 1; */
        if (message.archivedSelection)
            TSPMessages_5.Reference.internalBinaryWrite(message.archivedSelection, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.IdempotentSelectionTransformerArchive
 */
exports.IdempotentSelectionTransformerArchive = new IdempotentSelectionTransformerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WPSelectionTransformerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.WPSelectionTransformerArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableSubSelectionTransformerBaseArchive },
            { no: 2, name: "archived_selection", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 3, name: "origin_cell_uid", kind: "message", T: () => TSPMessages_2.UUIDCoordArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableSubSelectionTransformerBaseArchive super */ 1:
                    message.super = exports.TableSubSelectionTransformerBaseArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Reference archived_selection */ 2:
                    message.archivedSelection = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.archivedSelection);
                    break;
                case /* optional TSP.UUIDCoordArchive origin_cell_uid */ 3:
                    message.originCellUid = TSPMessages_2.UUIDCoordArchive.internalBinaryRead(reader, reader.uint32(), options, message.originCellUid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableSubSelectionTransformerBaseArchive super = 1; */
        if (message.super)
            exports.TableSubSelectionTransformerBaseArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference archived_selection = 2; */
        if (message.archivedSelection)
            TSPMessages_5.Reference.internalBinaryWrite(message.archivedSelection, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDCoordArchive origin_cell_uid = 3; */
        if (message.originCellUid)
            TSPMessages_2.UUIDCoordArchive.internalBinaryWrite(message.originCellUid, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.WPSelectionTransformerArchive
 */
exports.WPSelectionTransformerArchive = new WPSelectionTransformerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TableSubSelectionTransformerBaseArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.TableSubSelectionTransformerBaseArchive", [
            { no: 1, name: "table_info_id_path", kind: "message", T: () => TSPMessages_6.UUIDPath }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUIDPath table_info_id_path */ 1:
                    message.tableInfoIdPath = TSPMessages_6.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.tableInfoIdPath);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUIDPath table_info_id_path = 1; */
        if (message.tableInfoIdPath)
            TSPMessages_6.UUIDPath.internalBinaryWrite(message.tableInfoIdPath, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.TableSubSelectionTransformerBaseArchive
 */
exports.TableSubSelectionTransformerBaseArchive = new TableSubSelectionTransformerBaseArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TableNameSelectionTransformerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.TableNameSelectionTransformerArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableSubSelectionTransformerBaseArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableSubSelectionTransformerBaseArchive super */ 1:
                    message.super = exports.TableSubSelectionTransformerBaseArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableSubSelectionTransformerBaseArchive super = 1; */
        if (message.super)
            exports.TableSubSelectionTransformerBaseArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.TableNameSelectionTransformerArchive
 */
exports.TableNameSelectionTransformerArchive = new TableNameSelectionTransformerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ControlCellSelectionTransformerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.ControlCellSelectionTransformerArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableSubSelectionTransformerBaseArchive },
            { no: 2, name: "cell_uids", kind: "message", T: () => TSTArchives_20.CellUIDListArchive },
            { no: 3, name: "origin_cell_uid", kind: "message", T: () => TSPMessages_2.UUIDCoordArchive },
            { no: 4, name: "origin_cell_id", kind: "message", T: () => TSCEArchives_1.CellCoordinateArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableSubSelectionTransformerBaseArchive super */ 1:
                    message.super = exports.TableSubSelectionTransformerBaseArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TST.CellUIDListArchive cell_uids */ 2:
                    message.cellUids = TSTArchives_20.CellUIDListArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellUids);
                    break;
                case /* optional TSP.UUIDCoordArchive origin_cell_uid */ 3:
                    message.originCellUid = TSPMessages_2.UUIDCoordArchive.internalBinaryRead(reader, reader.uint32(), options, message.originCellUid);
                    break;
                case /* TSCE.CellCoordinateArchive origin_cell_id */ 4:
                    message.originCellId = TSCEArchives_1.CellCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.originCellId);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableSubSelectionTransformerBaseArchive super = 1; */
        if (message.super)
            exports.TableSubSelectionTransformerBaseArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.CellUIDListArchive cell_uids = 2; */
        if (message.cellUids)
            TSTArchives_20.CellUIDListArchive.internalBinaryWrite(message.cellUids, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDCoordArchive origin_cell_uid = 3; */
        if (message.originCellUid)
            TSPMessages_2.UUIDCoordArchive.internalBinaryWrite(message.originCellUid, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSCE.CellCoordinateArchive origin_cell_id = 4; */
        if (message.originCellId)
            TSCEArchives_1.CellCoordinateArchive.internalBinaryWrite(message.originCellId, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.ControlCellSelectionTransformerArchive
 */
exports.ControlCellSelectionTransformerArchive = new ControlCellSelectionTransformerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StockCellSelectionTransformerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.StockCellSelectionTransformerArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableSubSelectionTransformerBaseArchive },
            { no: 2, name: "cell_uids", kind: "message", T: () => TSTArchives_20.CellUIDListArchive },
            { no: 3, name: "origin_cell_uid", kind: "message", T: () => TSPMessages_2.UUIDCoordArchive },
            { no: 4, name: "origin_cell_id", kind: "message", T: () => TSCEArchives_1.CellCoordinateArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableSubSelectionTransformerBaseArchive super */ 1:
                    message.super = exports.TableSubSelectionTransformerBaseArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TST.CellUIDListArchive cell_uids */ 2:
                    message.cellUids = TSTArchives_20.CellUIDListArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellUids);
                    break;
                case /* optional TSP.UUIDCoordArchive origin_cell_uid */ 3:
                    message.originCellUid = TSPMessages_2.UUIDCoordArchive.internalBinaryRead(reader, reader.uint32(), options, message.originCellUid);
                    break;
                case /* TSCE.CellCoordinateArchive origin_cell_id */ 4:
                    message.originCellId = TSCEArchives_1.CellCoordinateArchive.internalBinaryRead(reader, reader.uint32(), options, message.originCellId);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableSubSelectionTransformerBaseArchive super = 1; */
        if (message.super)
            exports.TableSubSelectionTransformerBaseArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.CellUIDListArchive cell_uids = 2; */
        if (message.cellUids)
            TSTArchives_20.CellUIDListArchive.internalBinaryWrite(message.cellUids, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDCoordArchive origin_cell_uid = 3; */
        if (message.originCellUid)
            TSPMessages_2.UUIDCoordArchive.internalBinaryWrite(message.originCellUid, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSCE.CellCoordinateArchive origin_cell_id = 4; */
        if (message.originCellId)
            TSCEArchives_1.CellCoordinateArchive.internalBinaryWrite(message.originCellId, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.StockCellSelectionTransformerArchive
 */
exports.StockCellSelectionTransformerArchive = new StockCellSelectionTransformerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegionSelectionTransformerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.RegionSelectionTransformerArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableSubSelectionTransformerBaseArchive },
            { no: 2, name: "cell_uids", kind: "message", T: () => TSTArchives_20.CellUIDListArchive },
            { no: 3, name: "origin_cell_uid", kind: "message", T: () => TSPMessages_2.UUIDCoordArchive },
            { no: 4, name: "anchor_cell_uid", kind: "message", T: () => TSPMessages_2.UUIDCoordArchive },
            { no: 5, name: "cursor_cell_uid", kind: "message", T: () => TSPMessages_2.UUIDCoordArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableSubSelectionTransformerBaseArchive super */ 1:
                    message.super = exports.TableSubSelectionTransformerBaseArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TST.CellUIDListArchive cell_uids */ 2:
                    message.cellUids = TSTArchives_20.CellUIDListArchive.internalBinaryRead(reader, reader.uint32(), options, message.cellUids);
                    break;
                case /* optional TSP.UUIDCoordArchive origin_cell_uid */ 3:
                    message.originCellUid = TSPMessages_2.UUIDCoordArchive.internalBinaryRead(reader, reader.uint32(), options, message.originCellUid);
                    break;
                case /* TSP.UUIDCoordArchive anchor_cell_uid */ 4:
                    message.anchorCellUid = TSPMessages_2.UUIDCoordArchive.internalBinaryRead(reader, reader.uint32(), options, message.anchorCellUid);
                    break;
                case /* TSP.UUIDCoordArchive cursor_cell_uid */ 5:
                    message.cursorCellUid = TSPMessages_2.UUIDCoordArchive.internalBinaryRead(reader, reader.uint32(), options, message.cursorCellUid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableSubSelectionTransformerBaseArchive super = 1; */
        if (message.super)
            exports.TableSubSelectionTransformerBaseArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.CellUIDListArchive cell_uids = 2; */
        if (message.cellUids)
            TSTArchives_20.CellUIDListArchive.internalBinaryWrite(message.cellUids, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDCoordArchive origin_cell_uid = 3; */
        if (message.originCellUid)
            TSPMessages_2.UUIDCoordArchive.internalBinaryWrite(message.originCellUid, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUIDCoordArchive anchor_cell_uid = 4; */
        if (message.anchorCellUid)
            TSPMessages_2.UUIDCoordArchive.internalBinaryWrite(message.anchorCellUid, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUIDCoordArchive cursor_cell_uid = 5; */
        if (message.cursorCellUid)
            TSPMessages_2.UUIDCoordArchive.internalBinaryWrite(message.cursorCellUid, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.RegionSelectionTransformerArchive
 */
exports.RegionSelectionTransformerArchive = new RegionSelectionTransformerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StrokeSelectionTransformerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.StrokeSelectionTransformerArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableSubSelectionTransformerBaseArchive },
            { no: 2, name: "archived_selection", kind: "message", T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableSubSelectionTransformerBaseArchive super */ 1:
                    message.super = exports.TableSubSelectionTransformerBaseArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Reference archived_selection */ 2:
                    message.archivedSelection = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.archivedSelection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableSubSelectionTransformerBaseArchive super = 1; */
        if (message.super)
            exports.TableSubSelectionTransformerBaseArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference archived_selection = 2; */
        if (message.archivedSelection)
            TSPMessages_5.Reference.internalBinaryWrite(message.archivedSelection, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.StrokeSelectionTransformerArchive
 */
exports.StrokeSelectionTransformerArchive = new StrokeSelectionTransformerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RowColumnSelectionTransformerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.RowColumnSelectionTransformerArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableSubSelectionTransformerBaseArchive },
            { no: 2, name: "selection_type", kind: "enum", T: () => ["TST.SelectionTypeArchive", TSTArchives_2.SelectionTypeArchive] },
            { no: 3, name: "row_col_uids", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID }
        ]);
    }
    create(value) {
        const message = { selectionType: 0, rowColUids: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableSubSelectionTransformerBaseArchive super */ 1:
                    message.super = exports.TableSubSelectionTransformerBaseArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TST.SelectionTypeArchive selection_type */ 2:
                    message.selectionType = reader.int32();
                    break;
                case /* repeated TSP.UUID row_col_uids */ 3:
                    message.rowColUids.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableSubSelectionTransformerBaseArchive super = 1; */
        if (message.super)
            exports.TableSubSelectionTransformerBaseArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.SelectionTypeArchive selection_type = 2; */
        if (message.selectionType !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.selectionType);
        /* repeated TSP.UUID row_col_uids = 3; */
        for (let i = 0; i < message.rowColUids.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.rowColUids[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.RowColumnSelectionTransformerArchive
 */
exports.RowColumnSelectionTransformerArchive = new RowColumnSelectionTransformerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandCategoryMoveRowsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandCategoryMoveRowsArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "action_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "category_row_order", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 4, name: "undo_category_row_order", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 5, name: "cell_diff_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 6, name: "undo_cell_diff_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 7, name: "grouping_columns", kind: "message", T: () => TSTArchives_11.GroupColumnListArchive }
        ]);
    }
    create(value) {
        const message = { actionType: 0, categoryRowOrder: [], undoCategoryRowOrder: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* uint32 action_type */ 2:
                    message.actionType = reader.uint32();
                    break;
                case /* repeated TSP.UUID category_row_order */ 3:
                    message.categoryRowOrder.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID undo_category_row_order */ 4:
                    message.undoCategoryRowOrder.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* TSP.Reference cell_diff_map */ 5:
                    message.cellDiffMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.cellDiffMap);
                    break;
                case /* optional TSP.Reference undo_cell_diff_map */ 6:
                    message.undoCellDiffMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoCellDiffMap);
                    break;
                case /* optional TST.GroupColumnListArchive grouping_columns */ 7:
                    message.groupingColumns = TSTArchives_11.GroupColumnListArchive.internalBinaryRead(reader, reader.uint32(), options, message.groupingColumns);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* uint32 action_type = 2; */
        if (message.actionType !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.actionType);
        /* repeated TSP.UUID category_row_order = 3; */
        for (let i = 0; i < message.categoryRowOrder.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.categoryRowOrder[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID undo_category_row_order = 4; */
        for (let i = 0; i < message.undoCategoryRowOrder.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.undoCategoryRowOrder[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference cell_diff_map = 5; */
        if (message.cellDiffMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.cellDiffMap, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_cell_diff_map = 6; */
        if (message.undoCellDiffMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.undoCellDiffMap, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.GroupColumnListArchive grouping_columns = 7; */
        if (message.groupingColumns)
            TSTArchives_11.GroupColumnListArchive.internalBinaryWrite(message.groupingColumns, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandCategoryMoveRowsArchive
 */
exports.CommandCategoryMoveRowsArchive = new CommandCategoryMoveRowsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandRewriteHiddenStatesForGroupByChangeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandRewriteHiddenStatesForGroupByChangeArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "group_by_change", kind: "message", T: () => TSCEArchives_5.GroupByChangeArchive },
            { no: 3, name: "collapsed_state", kind: "message", T: () => TSTArchives_3.ExpandCollapseStateArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSCE.GroupByChangeArchive group_by_change */ 2:
                    message.groupByChange = TSCEArchives_5.GroupByChangeArchive.internalBinaryRead(reader, reader.uint32(), options, message.groupByChange);
                    break;
                case /* optional TST.ExpandCollapseStateArchive collapsed_state */ 3:
                    message.collapsedState = TSTArchives_3.ExpandCollapseStateArchive.internalBinaryRead(reader, reader.uint32(), options, message.collapsedState);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSCE.GroupByChangeArchive group_by_change = 2; */
        if (message.groupByChange)
            TSCEArchives_5.GroupByChangeArchive.internalBinaryWrite(message.groupByChange, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.ExpandCollapseStateArchive collapsed_state = 3; */
        if (message.collapsedState)
            TSTArchives_3.ExpandCollapseStateArchive.internalBinaryWrite(message.collapsedState, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandRewriteHiddenStatesForGroupByChangeArchive
 */
exports.CommandRewriteHiddenStatesForGroupByChangeArchive = new CommandRewriteHiddenStatesForGroupByChangeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandRewritePencilAnnotationFormulasArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandRewritePencilAnnotationFormulasArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "rewrite_spec", kind: "message", T: () => exports.FormulaRewriteSpecArchive },
            { no: 3, name: "formulas_to_rewrite", kind: "message", T: () => TSCEArchives_4.FormulasForUndoArchive },
            { no: 4, name: "annotations_for_undo", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.CommandRewritePencilAnnotationFormulasArchive_AnnotationPair }
        ]);
    }
    create(value) {
        const message = { annotationsForUndo: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TST.FormulaRewriteSpecArchive rewrite_spec */ 2:
                    message.rewriteSpec = exports.FormulaRewriteSpecArchive.internalBinaryRead(reader, reader.uint32(), options, message.rewriteSpec);
                    break;
                case /* TSCE.FormulasForUndoArchive formulas_to_rewrite */ 3:
                    message.formulasToRewrite = TSCEArchives_4.FormulasForUndoArchive.internalBinaryRead(reader, reader.uint32(), options, message.formulasToRewrite);
                    break;
                case /* repeated TST.CommandRewritePencilAnnotationFormulasArchive.AnnotationPair annotations_for_undo */ 4:
                    message.annotationsForUndo.push(exports.CommandRewritePencilAnnotationFormulasArchive_AnnotationPair.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.FormulaRewriteSpecArchive rewrite_spec = 2; */
        if (message.rewriteSpec)
            exports.FormulaRewriteSpecArchive.internalBinaryWrite(message.rewriteSpec, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSCE.FormulasForUndoArchive formulas_to_rewrite = 3; */
        if (message.formulasToRewrite)
            TSCEArchives_4.FormulasForUndoArchive.internalBinaryWrite(message.formulasToRewrite, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TST.CommandRewritePencilAnnotationFormulasArchive.AnnotationPair annotations_for_undo = 4; */
        for (let i = 0; i < message.annotationsForUndo.length; i++)
            exports.CommandRewritePencilAnnotationFormulasArchive_AnnotationPair.internalBinaryWrite(message.annotationsForUndo[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandRewritePencilAnnotationFormulasArchive
 */
exports.CommandRewritePencilAnnotationFormulasArchive = new CommandRewritePencilAnnotationFormulasArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandRewritePencilAnnotationFormulasArchive_AnnotationPair$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandRewritePencilAnnotationFormulasArchive.AnnotationPair", [
            { no: 1, name: "index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "annotation", kind: "message", T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = { index: 0n };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 index */ 1:
                    message.index = reader.uint64().toBigInt();
                    break;
                case /* TSP.Reference annotation */ 2:
                    message.annotation = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.annotation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 index = 1; */
        if (message.index !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).uint64(message.index);
        /* TSP.Reference annotation = 2; */
        if (message.annotation)
            TSPMessages_5.Reference.internalBinaryWrite(message.annotation, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandRewritePencilAnnotationFormulasArchive.AnnotationPair
 */
exports.CommandRewritePencilAnnotationFormulasArchive_AnnotationPair = new CommandRewritePencilAnnotationFormulasArchive_AnnotationPair$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandPivotSetPivotRulesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandPivotSetPivotRulesArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "new_target_pivot_refresh_uid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 3, name: "new_row_groupings", kind: "message", T: () => TSTArchives_11.GroupColumnListArchive },
            { no: 4, name: "old_row_groupings", kind: "message", T: () => TSTArchives_11.GroupColumnListArchive },
            { no: 5, name: "new_column_groupings", kind: "message", T: () => TSTArchives_11.GroupColumnListArchive },
            { no: 6, name: "old_column_groupings", kind: "message", T: () => TSTArchives_11.GroupColumnListArchive },
            { no: 7, name: "new_aggregates", kind: "message", T: () => TSTArchives_9.ColumnAggregateListArchive },
            { no: 8, name: "old_aggregates", kind: "message", T: () => TSTArchives_9.ColumnAggregateListArchive },
            { no: 9, name: "new_flattening_dimension", kind: "enum", opt: true, T: () => ["TST.TableDimensionArchive", TSTArchives_22.TableDimensionArchive] },
            { no: 10, name: "old_flattening_dimension", kind: "enum", opt: true, T: () => ["TST.TableDimensionArchive", TSTArchives_22.TableDimensionArchive] },
            { no: 11, name: "new_pivot_data_model", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 12, name: "old_pivot_data_model", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 13, name: "new_pivot_refresh_uid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 14, name: "old_pivot_refresh_uid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 15, name: "new_pivot_refresh_timestamp", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 16, name: "old_pivot_refresh_timestamp", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 17, name: "new_options_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 18, name: "old_options_map", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 19, name: "new_view_row_order", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 20, name: "old_view_row_order", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 21, name: "new_view_column_order", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 22, name: "old_view_column_order", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 23, name: "new_collapsed_row_groups", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 24, name: "old_collapsed_row_groups", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 25, name: "new_collapsed_column_groups", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 26, name: "old_collapsed_column_groups", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 27, name: "new_hierarchical_cell_diff_map", kind: "message", T: () => TSTArchives_1.HierarchicalCellDiffMapArchive },
            { no: 28, name: "old_hierarchical_cell_diff_map", kind: "message", T: () => TSTArchives_1.HierarchicalCellDiffMapArchive },
            { no: 29, name: "formula_rewrite_command_for_undo", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 30, name: "new_body_uid_tract", kind: "message", T: () => TSPMessages_3.UUIDRectArchive },
            { no: 31, name: "old_body_uid_tract", kind: "message", T: () => TSPMessages_3.UUIDRectArchive },
            { no: 32, name: "old_target_pivot_refresh_uid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 33, name: "new_target_pivot_row_column_rule_change_uid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 34, name: "old_target_pivot_row_column_rule_change_uid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 35, name: "new_target_pivot_aggregate_rule_change_uid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 36, name: "old_target_pivot_aggregate_rule_change_uid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 37, name: "is_order_finalized", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 39, name: "new_filter_set", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 40, name: "old_filter_set", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 41, name: "use_small_table_limits", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 42, name: "setting_filters_enabled", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 43, name: "undo_setting_filters_enabled", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = { newViewRowOrder: [], oldViewRowOrder: [], newViewColumnOrder: [], oldViewColumnOrder: [], newCollapsedRowGroups: [], oldCollapsedRowGroups: [], newCollapsedColumnGroups: [], oldCollapsedColumnGroups: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.UUID new_target_pivot_refresh_uid */ 2:
                    message.newTargetPivotRefreshUid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.newTargetPivotRefreshUid);
                    break;
                case /* optional TST.GroupColumnListArchive new_row_groupings */ 3:
                    message.newRowGroupings = TSTArchives_11.GroupColumnListArchive.internalBinaryRead(reader, reader.uint32(), options, message.newRowGroupings);
                    break;
                case /* optional TST.GroupColumnListArchive old_row_groupings */ 4:
                    message.oldRowGroupings = TSTArchives_11.GroupColumnListArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldRowGroupings);
                    break;
                case /* optional TST.GroupColumnListArchive new_column_groupings */ 5:
                    message.newColumnGroupings = TSTArchives_11.GroupColumnListArchive.internalBinaryRead(reader, reader.uint32(), options, message.newColumnGroupings);
                    break;
                case /* optional TST.GroupColumnListArchive old_column_groupings */ 6:
                    message.oldColumnGroupings = TSTArchives_11.GroupColumnListArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldColumnGroupings);
                    break;
                case /* optional TST.ColumnAggregateListArchive new_aggregates */ 7:
                    message.newAggregates = TSTArchives_9.ColumnAggregateListArchive.internalBinaryRead(reader, reader.uint32(), options, message.newAggregates);
                    break;
                case /* optional TST.ColumnAggregateListArchive old_aggregates */ 8:
                    message.oldAggregates = TSTArchives_9.ColumnAggregateListArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldAggregates);
                    break;
                case /* optional TST.TableDimensionArchive new_flattening_dimension */ 9:
                    message.newFlatteningDimension = reader.int32();
                    break;
                case /* optional TST.TableDimensionArchive old_flattening_dimension */ 10:
                    message.oldFlatteningDimension = reader.int32();
                    break;
                case /* optional TSP.Reference new_pivot_data_model */ 11:
                    message.newPivotDataModel = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.newPivotDataModel);
                    break;
                case /* optional TSP.Reference old_pivot_data_model */ 12:
                    message.oldPivotDataModel = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.oldPivotDataModel);
                    break;
                case /* optional TSP.UUID new_pivot_refresh_uid */ 13:
                    message.newPivotRefreshUid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.newPivotRefreshUid);
                    break;
                case /* optional TSP.UUID old_pivot_refresh_uid */ 14:
                    message.oldPivotRefreshUid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.oldPivotRefreshUid);
                    break;
                case /* optional double new_pivot_refresh_timestamp */ 15:
                    message.newPivotRefreshTimestamp = reader.double();
                    break;
                case /* optional double old_pivot_refresh_timestamp */ 16:
                    message.oldPivotRefreshTimestamp = reader.double();
                    break;
                case /* optional TSP.Reference new_options_map */ 17:
                    message.newOptionsMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.newOptionsMap);
                    break;
                case /* optional TSP.Reference old_options_map */ 18:
                    message.oldOptionsMap = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.oldOptionsMap);
                    break;
                case /* repeated TSP.UUID new_view_row_order */ 19:
                    message.newViewRowOrder.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID old_view_row_order */ 20:
                    message.oldViewRowOrder.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID new_view_column_order */ 21:
                    message.newViewColumnOrder.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID old_view_column_order */ 22:
                    message.oldViewColumnOrder.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID new_collapsed_row_groups */ 23:
                    message.newCollapsedRowGroups.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID old_collapsed_row_groups */ 24:
                    message.oldCollapsedRowGroups.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID new_collapsed_column_groups */ 25:
                    message.newCollapsedColumnGroups.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID old_collapsed_column_groups */ 26:
                    message.oldCollapsedColumnGroups.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TST.HierarchicalCellDiffMapArchive new_hierarchical_cell_diff_map */ 27:
                    message.newHierarchicalCellDiffMap = TSTArchives_1.HierarchicalCellDiffMapArchive.internalBinaryRead(reader, reader.uint32(), options, message.newHierarchicalCellDiffMap);
                    break;
                case /* optional TST.HierarchicalCellDiffMapArchive old_hierarchical_cell_diff_map */ 28:
                    message.oldHierarchicalCellDiffMap = TSTArchives_1.HierarchicalCellDiffMapArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldHierarchicalCellDiffMap);
                    break;
                case /* optional TSP.Reference formula_rewrite_command_for_undo */ 29:
                    message.formulaRewriteCommandForUndo = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.formulaRewriteCommandForUndo);
                    break;
                case /* optional TSP.UUIDRectArchive new_body_uid_tract */ 30:
                    message.newBodyUidTract = TSPMessages_3.UUIDRectArchive.internalBinaryRead(reader, reader.uint32(), options, message.newBodyUidTract);
                    break;
                case /* optional TSP.UUIDRectArchive old_body_uid_tract */ 31:
                    message.oldBodyUidTract = TSPMessages_3.UUIDRectArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldBodyUidTract);
                    break;
                case /* optional TSP.UUID old_target_pivot_refresh_uid */ 32:
                    message.oldTargetPivotRefreshUid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.oldTargetPivotRefreshUid);
                    break;
                case /* optional TSP.UUID new_target_pivot_row_column_rule_change_uid */ 33:
                    message.newTargetPivotRowColumnRuleChangeUid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.newTargetPivotRowColumnRuleChangeUid);
                    break;
                case /* optional TSP.UUID old_target_pivot_row_column_rule_change_uid */ 34:
                    message.oldTargetPivotRowColumnRuleChangeUid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.oldTargetPivotRowColumnRuleChangeUid);
                    break;
                case /* optional TSP.UUID new_target_pivot_aggregate_rule_change_uid */ 35:
                    message.newTargetPivotAggregateRuleChangeUid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.newTargetPivotAggregateRuleChangeUid);
                    break;
                case /* optional TSP.UUID old_target_pivot_aggregate_rule_change_uid */ 36:
                    message.oldTargetPivotAggregateRuleChangeUid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.oldTargetPivotAggregateRuleChangeUid);
                    break;
                case /* optional bool is_order_finalized */ 37:
                    message.isOrderFinalized = reader.bool();
                    break;
                case /* optional TSP.Reference new_filter_set */ 39:
                    message.newFilterSet = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.newFilterSet);
                    break;
                case /* optional TSP.Reference old_filter_set */ 40:
                    message.oldFilterSet = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.oldFilterSet);
                    break;
                case /* optional bool use_small_table_limits */ 41:
                    message.useSmallTableLimits = reader.bool();
                    break;
                case /* optional int32 setting_filters_enabled */ 42:
                    message.settingFiltersEnabled = reader.int32();
                    break;
                case /* optional int32 undo_setting_filters_enabled */ 43:
                    message.undoSettingFiltersEnabled = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID new_target_pivot_refresh_uid = 2; */
        if (message.newTargetPivotRefreshUid)
            TSPMessages_4.UUID.internalBinaryWrite(message.newTargetPivotRefreshUid, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.GroupColumnListArchive new_row_groupings = 3; */
        if (message.newRowGroupings)
            TSTArchives_11.GroupColumnListArchive.internalBinaryWrite(message.newRowGroupings, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.GroupColumnListArchive old_row_groupings = 4; */
        if (message.oldRowGroupings)
            TSTArchives_11.GroupColumnListArchive.internalBinaryWrite(message.oldRowGroupings, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.GroupColumnListArchive new_column_groupings = 5; */
        if (message.newColumnGroupings)
            TSTArchives_11.GroupColumnListArchive.internalBinaryWrite(message.newColumnGroupings, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.GroupColumnListArchive old_column_groupings = 6; */
        if (message.oldColumnGroupings)
            TSTArchives_11.GroupColumnListArchive.internalBinaryWrite(message.oldColumnGroupings, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.ColumnAggregateListArchive new_aggregates = 7; */
        if (message.newAggregates)
            TSTArchives_9.ColumnAggregateListArchive.internalBinaryWrite(message.newAggregates, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.ColumnAggregateListArchive old_aggregates = 8; */
        if (message.oldAggregates)
            TSTArchives_9.ColumnAggregateListArchive.internalBinaryWrite(message.oldAggregates, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.TableDimensionArchive new_flattening_dimension = 9; */
        if (message.newFlatteningDimension !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).int32(message.newFlatteningDimension);
        /* optional TST.TableDimensionArchive old_flattening_dimension = 10; */
        if (message.oldFlatteningDimension !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).int32(message.oldFlatteningDimension);
        /* optional TSP.Reference new_pivot_data_model = 11; */
        if (message.newPivotDataModel)
            TSPMessages_5.Reference.internalBinaryWrite(message.newPivotDataModel, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference old_pivot_data_model = 12; */
        if (message.oldPivotDataModel)
            TSPMessages_5.Reference.internalBinaryWrite(message.oldPivotDataModel, writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID new_pivot_refresh_uid = 13; */
        if (message.newPivotRefreshUid)
            TSPMessages_4.UUID.internalBinaryWrite(message.newPivotRefreshUid, writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID old_pivot_refresh_uid = 14; */
        if (message.oldPivotRefreshUid)
            TSPMessages_4.UUID.internalBinaryWrite(message.oldPivotRefreshUid, writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional double new_pivot_refresh_timestamp = 15; */
        if (message.newPivotRefreshTimestamp !== undefined)
            writer.tag(15, runtime_1.WireType.Bit64).double(message.newPivotRefreshTimestamp);
        /* optional double old_pivot_refresh_timestamp = 16; */
        if (message.oldPivotRefreshTimestamp !== undefined)
            writer.tag(16, runtime_1.WireType.Bit64).double(message.oldPivotRefreshTimestamp);
        /* optional TSP.Reference new_options_map = 17; */
        if (message.newOptionsMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.newOptionsMap, writer.tag(17, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference old_options_map = 18; */
        if (message.oldOptionsMap)
            TSPMessages_5.Reference.internalBinaryWrite(message.oldOptionsMap, writer.tag(18, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID new_view_row_order = 19; */
        for (let i = 0; i < message.newViewRowOrder.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.newViewRowOrder[i], writer.tag(19, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID old_view_row_order = 20; */
        for (let i = 0; i < message.oldViewRowOrder.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.oldViewRowOrder[i], writer.tag(20, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID new_view_column_order = 21; */
        for (let i = 0; i < message.newViewColumnOrder.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.newViewColumnOrder[i], writer.tag(21, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID old_view_column_order = 22; */
        for (let i = 0; i < message.oldViewColumnOrder.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.oldViewColumnOrder[i], writer.tag(22, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID new_collapsed_row_groups = 23; */
        for (let i = 0; i < message.newCollapsedRowGroups.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.newCollapsedRowGroups[i], writer.tag(23, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID old_collapsed_row_groups = 24; */
        for (let i = 0; i < message.oldCollapsedRowGroups.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.oldCollapsedRowGroups[i], writer.tag(24, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID new_collapsed_column_groups = 25; */
        for (let i = 0; i < message.newCollapsedColumnGroups.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.newCollapsedColumnGroups[i], writer.tag(25, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID old_collapsed_column_groups = 26; */
        for (let i = 0; i < message.oldCollapsedColumnGroups.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.oldCollapsedColumnGroups[i], writer.tag(26, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.HierarchicalCellDiffMapArchive new_hierarchical_cell_diff_map = 27; */
        if (message.newHierarchicalCellDiffMap)
            TSTArchives_1.HierarchicalCellDiffMapArchive.internalBinaryWrite(message.newHierarchicalCellDiffMap, writer.tag(27, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.HierarchicalCellDiffMapArchive old_hierarchical_cell_diff_map = 28; */
        if (message.oldHierarchicalCellDiffMap)
            TSTArchives_1.HierarchicalCellDiffMapArchive.internalBinaryWrite(message.oldHierarchicalCellDiffMap, writer.tag(28, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference formula_rewrite_command_for_undo = 29; */
        if (message.formulaRewriteCommandForUndo)
            TSPMessages_5.Reference.internalBinaryWrite(message.formulaRewriteCommandForUndo, writer.tag(29, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDRectArchive new_body_uid_tract = 30; */
        if (message.newBodyUidTract)
            TSPMessages_3.UUIDRectArchive.internalBinaryWrite(message.newBodyUidTract, writer.tag(30, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDRectArchive old_body_uid_tract = 31; */
        if (message.oldBodyUidTract)
            TSPMessages_3.UUIDRectArchive.internalBinaryWrite(message.oldBodyUidTract, writer.tag(31, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID old_target_pivot_refresh_uid = 32; */
        if (message.oldTargetPivotRefreshUid)
            TSPMessages_4.UUID.internalBinaryWrite(message.oldTargetPivotRefreshUid, writer.tag(32, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID new_target_pivot_row_column_rule_change_uid = 33; */
        if (message.newTargetPivotRowColumnRuleChangeUid)
            TSPMessages_4.UUID.internalBinaryWrite(message.newTargetPivotRowColumnRuleChangeUid, writer.tag(33, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID old_target_pivot_row_column_rule_change_uid = 34; */
        if (message.oldTargetPivotRowColumnRuleChangeUid)
            TSPMessages_4.UUID.internalBinaryWrite(message.oldTargetPivotRowColumnRuleChangeUid, writer.tag(34, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID new_target_pivot_aggregate_rule_change_uid = 35; */
        if (message.newTargetPivotAggregateRuleChangeUid)
            TSPMessages_4.UUID.internalBinaryWrite(message.newTargetPivotAggregateRuleChangeUid, writer.tag(35, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID old_target_pivot_aggregate_rule_change_uid = 36; */
        if (message.oldTargetPivotAggregateRuleChangeUid)
            TSPMessages_4.UUID.internalBinaryWrite(message.oldTargetPivotAggregateRuleChangeUid, writer.tag(36, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_order_finalized = 37; */
        if (message.isOrderFinalized !== undefined)
            writer.tag(37, runtime_1.WireType.Varint).bool(message.isOrderFinalized);
        /* optional TSP.Reference new_filter_set = 39; */
        if (message.newFilterSet)
            TSPMessages_5.Reference.internalBinaryWrite(message.newFilterSet, writer.tag(39, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference old_filter_set = 40; */
        if (message.oldFilterSet)
            TSPMessages_5.Reference.internalBinaryWrite(message.oldFilterSet, writer.tag(40, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool use_small_table_limits = 41; */
        if (message.useSmallTableLimits !== undefined)
            writer.tag(41, runtime_1.WireType.Varint).bool(message.useSmallTableLimits);
        /* optional int32 setting_filters_enabled = 42; */
        if (message.settingFiltersEnabled !== undefined)
            writer.tag(42, runtime_1.WireType.Varint).int32(message.settingFiltersEnabled);
        /* optional int32 undo_setting_filters_enabled = 43; */
        if (message.undoSettingFiltersEnabled !== undefined)
            writer.tag(43, runtime_1.WireType.Varint).int32(message.undoSettingFiltersEnabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandPivotSetPivotRulesArchive
 */
exports.CommandPivotSetPivotRulesArchive = new CommandPivotSetPivotRulesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandPivotSetGroupingColumnOptionsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandPivotSetGroupingColumnOptionsArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "grouping_column_uid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 3, name: "non_sorting_flag", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "bool_value", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "undo_bool_value", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.UUID grouping_column_uid */ 2:
                    message.groupingColumnUid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.groupingColumnUid);
                    break;
                case /* optional uint32 non_sorting_flag */ 3:
                    message.nonSortingFlag = reader.uint32();
                    break;
                case /* optional bool bool_value */ 4:
                    message.boolValue = reader.bool();
                    break;
                case /* optional bool undo_bool_value */ 5:
                    message.undoBoolValue = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID grouping_column_uid = 2; */
        if (message.groupingColumnUid)
            TSPMessages_4.UUID.internalBinaryWrite(message.groupingColumnUid, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 non_sorting_flag = 3; */
        if (message.nonSortingFlag !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.nonSortingFlag);
        /* optional bool bool_value = 4; */
        if (message.boolValue !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.boolValue);
        /* optional bool undo_bool_value = 5; */
        if (message.undoBoolValue !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.undoBoolValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandPivotSetGroupingColumnOptionsArchive
 */
exports.CommandPivotSetGroupingColumnOptionsArchive = new CommandPivotSetGroupingColumnOptionsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandPivotHideShowGrandTotalsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandPivotHideShowGrandTotalsArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "dimension", kind: "enum", opt: true, T: () => ["TST.TableDimensionArchive", TSTArchives_22.TableDimensionArchive] },
            { no: 3, name: "is_hiding", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "undo_is_hiding", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TST.TableDimensionArchive dimension */ 2:
                    message.dimension = reader.int32();
                    break;
                case /* optional bool is_hiding */ 3:
                    message.isHiding = reader.bool();
                    break;
                case /* optional bool undo_is_hiding */ 4:
                    message.undoIsHiding = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.TableDimensionArchive dimension = 2; */
        if (message.dimension !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.dimension);
        /* optional bool is_hiding = 3; */
        if (message.isHiding !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.isHiding);
        /* optional bool undo_is_hiding = 4; */
        if (message.undoIsHiding !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.undoIsHiding);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandPivotHideShowGrandTotalsArchive
 */
exports.CommandPivotHideShowGrandTotalsArchive = new CommandPivotHideShowGrandTotalsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandPivotSortArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandPivotSortArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TableCommandArchive },
            { no: 2, name: "dimension", kind: "enum", opt: true, T: () => ["TST.TableDimensionArchive", TSTArchives_22.TableDimensionArchive] },
            { no: 3, name: "column_order", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 4, name: "undo_column_order", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 5, name: "row_order", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 6, name: "undo_row_order", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 7, name: "target_pivot_row_column_rule_change_uid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 8, name: "target_pivot_aggregate_rule_change_uid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 9, name: "target_pivot_data_refresh_uid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 10, name: "grouping_column_uid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 11, name: "sorting_flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "undo_sorting_flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "sorting_aggregate_rule_uid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 14, name: "undo_sorting_aggregate_rule_uid", kind: "message", T: () => TSPMessages_4.UUID },
            { no: 15, name: "is_order_finalized", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { columnOrder: [], undoColumnOrder: [], rowOrder: [], undoRowOrder: [], isOrderFinalized: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TST.TableCommandArchive super */ 1:
                    message.super = exports.TableCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TST.TableDimensionArchive dimension */ 2:
                    message.dimension = reader.int32();
                    break;
                case /* repeated TSP.UUID column_order */ 3:
                    message.columnOrder.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID undo_column_order */ 4:
                    message.undoColumnOrder.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID row_order */ 5:
                    message.rowOrder.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUID undo_row_order */ 6:
                    message.undoRowOrder.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* TSP.UUID target_pivot_row_column_rule_change_uid */ 7:
                    message.targetPivotRowColumnRuleChangeUid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.targetPivotRowColumnRuleChangeUid);
                    break;
                case /* TSP.UUID target_pivot_aggregate_rule_change_uid */ 8:
                    message.targetPivotAggregateRuleChangeUid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.targetPivotAggregateRuleChangeUid);
                    break;
                case /* TSP.UUID target_pivot_data_refresh_uid */ 9:
                    message.targetPivotDataRefreshUid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.targetPivotDataRefreshUid);
                    break;
                case /* optional TSP.UUID grouping_column_uid */ 10:
                    message.groupingColumnUid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.groupingColumnUid);
                    break;
                case /* optional uint32 sorting_flags */ 11:
                    message.sortingFlags = reader.uint32();
                    break;
                case /* optional uint32 undo_sorting_flags */ 12:
                    message.undoSortingFlags = reader.uint32();
                    break;
                case /* optional TSP.UUID sorting_aggregate_rule_uid */ 13:
                    message.sortingAggregateRuleUid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.sortingAggregateRuleUid);
                    break;
                case /* optional TSP.UUID undo_sorting_aggregate_rule_uid */ 14:
                    message.undoSortingAggregateRuleUid = TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options, message.undoSortingAggregateRuleUid);
                    break;
                case /* bool is_order_finalized */ 15:
                    message.isOrderFinalized = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TST.TableCommandArchive super = 1; */
        if (message.super)
            exports.TableCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.TableDimensionArchive dimension = 2; */
        if (message.dimension !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.dimension);
        /* repeated TSP.UUID column_order = 3; */
        for (let i = 0; i < message.columnOrder.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.columnOrder[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID undo_column_order = 4; */
        for (let i = 0; i < message.undoColumnOrder.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.undoColumnOrder[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID row_order = 5; */
        for (let i = 0; i < message.rowOrder.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.rowOrder[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUID undo_row_order = 6; */
        for (let i = 0; i < message.undoRowOrder.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.undoRowOrder[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID target_pivot_row_column_rule_change_uid = 7; */
        if (message.targetPivotRowColumnRuleChangeUid)
            TSPMessages_4.UUID.internalBinaryWrite(message.targetPivotRowColumnRuleChangeUid, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID target_pivot_aggregate_rule_change_uid = 8; */
        if (message.targetPivotAggregateRuleChangeUid)
            TSPMessages_4.UUID.internalBinaryWrite(message.targetPivotAggregateRuleChangeUid, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUID target_pivot_data_refresh_uid = 9; */
        if (message.targetPivotDataRefreshUid)
            TSPMessages_4.UUID.internalBinaryWrite(message.targetPivotDataRefreshUid, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID grouping_column_uid = 10; */
        if (message.groupingColumnUid)
            TSPMessages_4.UUID.internalBinaryWrite(message.groupingColumnUid, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 sorting_flags = 11; */
        if (message.sortingFlags !== undefined)
            writer.tag(11, runtime_1.WireType.Varint).uint32(message.sortingFlags);
        /* optional uint32 undo_sorting_flags = 12; */
        if (message.undoSortingFlags !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).uint32(message.undoSortingFlags);
        /* optional TSP.UUID sorting_aggregate_rule_uid = 13; */
        if (message.sortingAggregateRuleUid)
            TSPMessages_4.UUID.internalBinaryWrite(message.sortingAggregateRuleUid, writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUID undo_sorting_aggregate_rule_uid = 14; */
        if (message.undoSortingAggregateRuleUid)
            TSPMessages_4.UUID.internalBinaryWrite(message.undoSortingAggregateRuleUid, writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool is_order_finalized = 15; */
        if (message.isOrderFinalized !== false)
            writer.tag(15, runtime_1.WireType.Varint).bool(message.isOrderFinalized);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandPivotSortArchive
 */
exports.CommandPivotSortArchive = new CommandPivotSortArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandRewriteTrackedReferencesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandRewriteTrackedReferencesArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_4.CommandArchive },
            { no: 2, name: "rewrite_spec", kind: "message", T: () => exports.FormulaRewriteSpecArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_4.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TST.FormulaRewriteSpecArchive rewrite_spec */ 2:
                    message.rewriteSpec = exports.FormulaRewriteSpecArchive.internalBinaryRead(reader, reader.uint32(), options, message.rewriteSpec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_4.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TST.FormulaRewriteSpecArchive rewrite_spec = 2; */
        if (message.rewriteSpec)
            exports.FormulaRewriteSpecArchive.internalBinaryWrite(message.rewriteSpec, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandRewriteTrackedReferencesArchive
 */
exports.CommandRewriteTrackedReferencesArchive = new CommandRewriteTrackedReferencesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandExtendTableIDHistoryArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TST.CommandExtendTableIDHistoryArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_4.CommandArchive },
            { no: 2, name: "rewrite_spec", kind: "message", T: () => exports.FormulaRewriteSpecArchive },
            { no: 3, name: "table_uid_history_rollback", kind: "message", T: () => TSCEArchives_10.RewriteTableUIDInfoArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_4.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TST.FormulaRewriteSpecArchive rewrite_spec */ 2:
                    message.rewriteSpec = exports.FormulaRewriteSpecArchive.internalBinaryRead(reader, reader.uint32(), options, message.rewriteSpec);
                    break;
                case /* optional TSCE.RewriteTableUIDInfoArchive table_uid_history_rollback */ 3:
                    message.tableUidHistoryRollback = TSCEArchives_10.RewriteTableUIDInfoArchive.internalBinaryRead(reader, reader.uint32(), options, message.tableUidHistoryRollback);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_4.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TST.FormulaRewriteSpecArchive rewrite_spec = 2; */
        if (message.rewriteSpec)
            exports.FormulaRewriteSpecArchive.internalBinaryWrite(message.rewriteSpec, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSCE.RewriteTableUIDInfoArchive table_uid_history_rollback = 3; */
        if (message.tableUidHistoryRollback)
            TSCEArchives_10.RewriteTableUIDInfoArchive.internalBinaryWrite(message.tableUidHistoryRollback, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TST.CommandExtendTableIDHistoryArchive
 */
exports.CommandExtendTableIDHistoryArchive = new CommandExtendTableIDHistoryArchive$Type();
//# sourceMappingURL=TSTCommandArchives.js.map