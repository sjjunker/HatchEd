"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListStyleArchive = exports.ParagraphStyleArchive = exports.ParagraphStylePropertiesArchive = exports.LineSpacingArchive = exports.TabsArchive = exports.TabArchive = exports.CharacterStyleArchive = exports.CharacterStylePropertiesArchive = exports.FontFeatureArchive = exports.PencilAnnotationArchive = exports.HighlightArchive = exports.StorageArchive = exports.OverlappingFieldAttributeTable_OverlappingFieldAttribute = exports.OverlappingFieldAttributeTable = exports.ParaDataAttributeTable_ParaDataAttribute = exports.ParaDataAttributeTable = exports.StringAttributeTable_StringAttribute = exports.StringAttributeTable = exports.ObjectAttributeTable_ObjectAttribute = exports.ObjectAttributeTable = exports.SelectionArchive = exports.WritingDirectionType = exports.CaretAffinity = exports.StyleInsertionBehavior = exports.SelectionType = exports.DropCapArchive_DropCapWrapType = exports.DropCapArchive_DropCapType = exports.ChangeArchive_ChangeKind = exports.MergeSmartFieldArchive_MergeCategory = exports.DateTimeSmartFieldArchive_DateTimeFormatterStyle = exports.DateTimeSmartFieldArchive_DateTimeUpdatePlan = exports.TextualAttachmentArchive_Kind = exports.UndoTransaction_ActionGroupKind = exports.UndoTransaction_ActionKind = exports.UndoTransaction_UndoKind = exports.ShapeStylePropertiesArchive_VerticalAlignmentType = exports.ColumnStylePropertiesArchive_VerticalAlignmentType = exports.ListStyleArchive_NumberType = exports.ListStyleArchive_LabelType = exports.ParagraphStylePropertiesArchive_OutlineStyleType = exports.ParagraphStylePropertiesArchive_ParagraphBorderType = exports.ParagraphStylePropertiesArchive_TextAlignmentType = exports.LineSpacingArchive_LineSpacingModeType = exports.TabArchive_TabAlignmentType = exports.CharacterStylePropertiesArchive_SuperscriptType = exports.CharacterStylePropertiesArchive_StrikethruType = exports.CharacterStylePropertiesArchive_LigaturesType = exports.CharacterStylePropertiesArchive_UnderlineType = exports.CharacterStylePropertiesArchive_CapitalizationType = exports.StorageArchive_KindType = void 0;
exports.PlaceholderSmartFieldArchive = exports.HyperlinkFieldArchive = exports.SmartFieldArchive = exports.NumberAttachmentArchive = exports.FootnoteReferenceAttachmentArchive = exports.TOCAttachmentArchive = exports.DrawableAttachmentArchive = exports.UIGraphicalAttachment = exports.TSWPTOCPageNumberAttachmentArchive = exports.TextualAttachmentArchive = exports.EquationInfoArchive = exports.TOCLayoutHintArchive = exports.TOCInfoArchive = exports.CommentInfoArchive = exports.ShapeInfoArchive = exports.UndoTransactionWrapperArchive = exports.UndoTransaction_StorageActionGroup = exports.UndoTransaction_StorageAction = exports.UndoTransaction_UnionTransaction = exports.UndoTransaction_CTDateTransaction = exports.UndoTransaction_ObjectDOLCTransaction = exports.UndoTransaction_ParagraphDataTransaction = exports.UndoTransaction_CharDeltaTransaction = exports.UndoTransaction_InsertNilTransaction = exports.UndoTransaction_InsertAttributeTransaction = exports.UndoTransaction_AttributeIndexTransaction = exports.UndoTransaction_ReplaceCharIndexTransaction = exports.UndoTransaction_CharIndexTransaction = exports.UndoTransaction_TextTransaction = exports.UndoTransaction_GenericTransaction = exports.UndoTransaction = exports.TOCEntryInstanceArchive = exports.TOCSettingsArchive_TOCEntryData = exports.TOCSettingsArchive = exports.TOCEntryStyleArchive = exports.TOCEntryStylePropertiesArchive = exports.TextPresetDisplayItemArchive = exports.ThemePresetsArchive = exports.ShapeStyleArchive = exports.ShapeStylePropertiesArchive = exports.ColumnStyleArchive = exports.ColumnStylePropertiesArchive = exports.PaddingArchive = exports.ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive = exports.ColumnsArchive_NonEqualColumnsArchive = exports.ColumnsArchive_EqualColumnsArchive = exports.ColumnsArchive = exports.TextStylePresetArchive = exports.ListStyleArchive_LabelImage = exports.ListStyleArchive_LabelGeometry = void 0;
exports.CollaboratorTextCursorSubselectionArchive = exports.DropCapStyleArchive = exports.DropCapStylePropertiesArchive = exports.DropCapArchive = exports.FlowInfoContainerArchive = exports.FlowInfoArchive = exports.HyperlinkSelectionArchive = exports.SectionPlaceholderArchive = exports.ChangeSessionArchive = exports.ChangeArchive = exports.TateChuYokoFieldArchive = exports.RubyFieldArchive = exports.TOCSmartFieldArchive_TOCEntry = exports.TOCSmartFieldArchive = exports.MergeSmartFieldArchive = exports.MergeFieldTypeArchive = exports.FilenameSmartFieldArchive = exports.BookmarkFieldArchive = exports.DateTimeSmartFieldArchive = exports.CitationSmartFieldArchive = exports.CitationRecordArchive = exports.BibliographySmartFieldArchive = exports.UnsupportedHyperlinkFieldArchive = void 0;
const runtime_1 = require("@protobuf-ts/runtime");
const runtime_2 = require("@protobuf-ts/runtime");
const runtime_3 = require("@protobuf-ts/runtime");
const runtime_4 = require("@protobuf-ts/runtime");
const runtime_5 = require("@protobuf-ts/runtime");
const TSDArchives_1 = require("./TSDArchives");
const TSPMessages_1 = require("./TSPMessages");
const TSDArchives_2 = require("./TSDArchives");
const TSPMessages_2 = require("./TSPMessages");
const TSPMessages_3 = require("./TSPMessages");
const TSSArchives_1 = require("./TSSArchives");
const TSDArchives_3 = require("./TSDArchives");
const TSDArchives_4 = require("./TSDArchives");
const TSDArchives_5 = require("./TSDArchives");
const TSPMessages_4 = require("./TSPMessages");
const TSPMessages_5 = require("./TSPMessages");
const TSPMessages_6 = require("./TSPMessages");
/**
 * @generated from protobuf enum TSWP.StorageArchive.KindType
 */
var StorageArchive_KindType;
(function (StorageArchive_KindType) {
    /**
     * @generated from protobuf enum value: BODY = 0;
     */
    StorageArchive_KindType[StorageArchive_KindType["BODY"] = 0] = "BODY";
    /**
     * @generated from protobuf enum value: HEADER = 1;
     */
    StorageArchive_KindType[StorageArchive_KindType["HEADER"] = 1] = "HEADER";
    /**
     * @generated from protobuf enum value: FOOTNOTE = 2;
     */
    StorageArchive_KindType[StorageArchive_KindType["FOOTNOTE"] = 2] = "FOOTNOTE";
    /**
     * @generated from protobuf enum value: TEXTBOX = 3;
     */
    StorageArchive_KindType[StorageArchive_KindType["TEXTBOX"] = 3] = "TEXTBOX";
    /**
     * @generated from protobuf enum value: NOTE = 4;
     */
    StorageArchive_KindType[StorageArchive_KindType["NOTE"] = 4] = "NOTE";
    /**
     * @generated from protobuf enum value: CELL = 5;
     */
    StorageArchive_KindType[StorageArchive_KindType["CELL"] = 5] = "CELL";
    /**
     * @generated from protobuf enum value: UNCLASSIFIED = 6;
     */
    StorageArchive_KindType[StorageArchive_KindType["UNCLASSIFIED"] = 6] = "UNCLASSIFIED";
    /**
     * @generated from protobuf enum value: TABLEOFCONTENTS = 7;
     */
    StorageArchive_KindType[StorageArchive_KindType["TABLEOFCONTENTS"] = 7] = "TABLEOFCONTENTS";
    /**
     * @generated from protobuf enum value: UNDEFINED = 8;
     */
    StorageArchive_KindType[StorageArchive_KindType["UNDEFINED"] = 8] = "UNDEFINED";
})(StorageArchive_KindType = exports.StorageArchive_KindType || (exports.StorageArchive_KindType = {}));
/**
 * @generated from protobuf enum TSWP.CharacterStylePropertiesArchive.CapitalizationType
 */
var CharacterStylePropertiesArchive_CapitalizationType;
(function (CharacterStylePropertiesArchive_CapitalizationType) {
    /**
     * @generated from protobuf enum value: kNoCaps = 0;
     */
    CharacterStylePropertiesArchive_CapitalizationType[CharacterStylePropertiesArchive_CapitalizationType["kNoCaps"] = 0] = "kNoCaps";
    /**
     * @generated from protobuf enum value: kAllCaps = 1;
     */
    CharacterStylePropertiesArchive_CapitalizationType[CharacterStylePropertiesArchive_CapitalizationType["kAllCaps"] = 1] = "kAllCaps";
    /**
     * @generated from protobuf enum value: kSmallCaps = 2;
     */
    CharacterStylePropertiesArchive_CapitalizationType[CharacterStylePropertiesArchive_CapitalizationType["kSmallCaps"] = 2] = "kSmallCaps";
    /**
     * @generated from protobuf enum value: kTitled = 3;
     */
    CharacterStylePropertiesArchive_CapitalizationType[CharacterStylePropertiesArchive_CapitalizationType["kTitled"] = 3] = "kTitled";
})(CharacterStylePropertiesArchive_CapitalizationType = exports.CharacterStylePropertiesArchive_CapitalizationType || (exports.CharacterStylePropertiesArchive_CapitalizationType = {}));
/**
 * @generated from protobuf enum TSWP.CharacterStylePropertiesArchive.UnderlineType
 */
var CharacterStylePropertiesArchive_UnderlineType;
(function (CharacterStylePropertiesArchive_UnderlineType) {
    /**
     * @generated from protobuf enum value: kNoUnderline = 0;
     */
    CharacterStylePropertiesArchive_UnderlineType[CharacterStylePropertiesArchive_UnderlineType["kNoUnderline"] = 0] = "kNoUnderline";
    /**
     * @generated from protobuf enum value: kSingleUnderline = 1;
     */
    CharacterStylePropertiesArchive_UnderlineType[CharacterStylePropertiesArchive_UnderlineType["kSingleUnderline"] = 1] = "kSingleUnderline";
    /**
     * @generated from protobuf enum value: kDoubleUnderline = 2;
     */
    CharacterStylePropertiesArchive_UnderlineType[CharacterStylePropertiesArchive_UnderlineType["kDoubleUnderline"] = 2] = "kDoubleUnderline";
    /**
     * @generated from protobuf enum value: kWavyUnderline = 3;
     */
    CharacterStylePropertiesArchive_UnderlineType[CharacterStylePropertiesArchive_UnderlineType["kWavyUnderline"] = 3] = "kWavyUnderline";
})(CharacterStylePropertiesArchive_UnderlineType = exports.CharacterStylePropertiesArchive_UnderlineType || (exports.CharacterStylePropertiesArchive_UnderlineType = {}));
/**
 * @generated from protobuf enum TSWP.CharacterStylePropertiesArchive.LigaturesType
 */
var CharacterStylePropertiesArchive_LigaturesType;
(function (CharacterStylePropertiesArchive_LigaturesType) {
    /**
     * @generated from protobuf enum value: kRequiredLigatures = 0;
     */
    CharacterStylePropertiesArchive_LigaturesType[CharacterStylePropertiesArchive_LigaturesType["kRequiredLigatures"] = 0] = "kRequiredLigatures";
    /**
     * @generated from protobuf enum value: kStandardLigatures = 1;
     */
    CharacterStylePropertiesArchive_LigaturesType[CharacterStylePropertiesArchive_LigaturesType["kStandardLigatures"] = 1] = "kStandardLigatures";
    /**
     * @generated from protobuf enum value: kAllLigatures = 2;
     */
    CharacterStylePropertiesArchive_LigaturesType[CharacterStylePropertiesArchive_LigaturesType["kAllLigatures"] = 2] = "kAllLigatures";
})(CharacterStylePropertiesArchive_LigaturesType = exports.CharacterStylePropertiesArchive_LigaturesType || (exports.CharacterStylePropertiesArchive_LigaturesType = {}));
/**
 * @generated from protobuf enum TSWP.CharacterStylePropertiesArchive.StrikethruType
 */
var CharacterStylePropertiesArchive_StrikethruType;
(function (CharacterStylePropertiesArchive_StrikethruType) {
    /**
     * @generated from protobuf enum value: kNoStrikethru = 0;
     */
    CharacterStylePropertiesArchive_StrikethruType[CharacterStylePropertiesArchive_StrikethruType["kNoStrikethru"] = 0] = "kNoStrikethru";
    /**
     * @generated from protobuf enum value: kSingleStrikethru = 1;
     */
    CharacterStylePropertiesArchive_StrikethruType[CharacterStylePropertiesArchive_StrikethruType["kSingleStrikethru"] = 1] = "kSingleStrikethru";
    /**
     * @generated from protobuf enum value: kDoubleStrikethru = 2;
     */
    CharacterStylePropertiesArchive_StrikethruType[CharacterStylePropertiesArchive_StrikethruType["kDoubleStrikethru"] = 2] = "kDoubleStrikethru";
    /**
     * @generated from protobuf enum value: kTripleStrikethru = 3;
     */
    CharacterStylePropertiesArchive_StrikethruType[CharacterStylePropertiesArchive_StrikethruType["kTripleStrikethru"] = 3] = "kTripleStrikethru";
})(CharacterStylePropertiesArchive_StrikethruType = exports.CharacterStylePropertiesArchive_StrikethruType || (exports.CharacterStylePropertiesArchive_StrikethruType = {}));
/**
 * @generated from protobuf enum TSWP.CharacterStylePropertiesArchive.SuperscriptType
 */
var CharacterStylePropertiesArchive_SuperscriptType;
(function (CharacterStylePropertiesArchive_SuperscriptType) {
    /**
     * @generated from protobuf enum value: kNoScript = 0;
     */
    CharacterStylePropertiesArchive_SuperscriptType[CharacterStylePropertiesArchive_SuperscriptType["kNoScript"] = 0] = "kNoScript";
    /**
     * @generated from protobuf enum value: kSuperscript = 1;
     */
    CharacterStylePropertiesArchive_SuperscriptType[CharacterStylePropertiesArchive_SuperscriptType["kSuperscript"] = 1] = "kSuperscript";
    /**
     * @generated from protobuf enum value: kSubscript = 2;
     */
    CharacterStylePropertiesArchive_SuperscriptType[CharacterStylePropertiesArchive_SuperscriptType["kSubscript"] = 2] = "kSubscript";
})(CharacterStylePropertiesArchive_SuperscriptType = exports.CharacterStylePropertiesArchive_SuperscriptType || (exports.CharacterStylePropertiesArchive_SuperscriptType = {}));
/**
 * @generated from protobuf enum TSWP.TabArchive.TabAlignmentType
 */
var TabArchive_TabAlignmentType;
(function (TabArchive_TabAlignmentType) {
    /**
     * @generated from protobuf enum value: kTabAlignmentLeft = 0;
     */
    TabArchive_TabAlignmentType[TabArchive_TabAlignmentType["kTabAlignmentLeft"] = 0] = "kTabAlignmentLeft";
    /**
     * @generated from protobuf enum value: kTabAlignmentCenter = 1;
     */
    TabArchive_TabAlignmentType[TabArchive_TabAlignmentType["kTabAlignmentCenter"] = 1] = "kTabAlignmentCenter";
    /**
     * @generated from protobuf enum value: kTabAlignmentRight = 2;
     */
    TabArchive_TabAlignmentType[TabArchive_TabAlignmentType["kTabAlignmentRight"] = 2] = "kTabAlignmentRight";
    /**
     * @generated from protobuf enum value: kTabAlignmentDecimal = 3;
     */
    TabArchive_TabAlignmentType[TabArchive_TabAlignmentType["kTabAlignmentDecimal"] = 3] = "kTabAlignmentDecimal";
})(TabArchive_TabAlignmentType = exports.TabArchive_TabAlignmentType || (exports.TabArchive_TabAlignmentType = {}));
/**
 * @generated from protobuf enum TSWP.LineSpacingArchive.LineSpacingModeType
 */
var LineSpacingArchive_LineSpacingModeType;
(function (LineSpacingArchive_LineSpacingModeType) {
    /**
     * @generated from protobuf enum value: kRelativeLineSpacing = 0;
     */
    LineSpacingArchive_LineSpacingModeType[LineSpacingArchive_LineSpacingModeType["kRelativeLineSpacing"] = 0] = "kRelativeLineSpacing";
    /**
     * @generated from protobuf enum value: kMinimumLineSpacing = 1;
     */
    LineSpacingArchive_LineSpacingModeType[LineSpacingArchive_LineSpacingModeType["kMinimumLineSpacing"] = 1] = "kMinimumLineSpacing";
    /**
     * @generated from protobuf enum value: kExactLineSpacing = 2;
     */
    LineSpacingArchive_LineSpacingModeType[LineSpacingArchive_LineSpacingModeType["kExactLineSpacing"] = 2] = "kExactLineSpacing";
    /**
     * @generated from protobuf enum value: kMaximumLineSpacing = 3;
     */
    LineSpacingArchive_LineSpacingModeType[LineSpacingArchive_LineSpacingModeType["kMaximumLineSpacing"] = 3] = "kMaximumLineSpacing";
    /**
     * @generated from protobuf enum value: kSpaceBetweenLineSpacing = 4;
     */
    LineSpacingArchive_LineSpacingModeType[LineSpacingArchive_LineSpacingModeType["kSpaceBetweenLineSpacing"] = 4] = "kSpaceBetweenLineSpacing";
})(LineSpacingArchive_LineSpacingModeType = exports.LineSpacingArchive_LineSpacingModeType || (exports.LineSpacingArchive_LineSpacingModeType = {}));
/**
 * @generated from protobuf enum TSWP.ParagraphStylePropertiesArchive.TextAlignmentType
 */
var ParagraphStylePropertiesArchive_TextAlignmentType;
(function (ParagraphStylePropertiesArchive_TextAlignmentType) {
    /**
     * @generated from protobuf enum value: TATvalue0 = 0;
     */
    ParagraphStylePropertiesArchive_TextAlignmentType[ParagraphStylePropertiesArchive_TextAlignmentType["TATvalue0"] = 0] = "TATvalue0";
    /**
     * @generated from protobuf enum value: TATvalue1 = 1;
     */
    ParagraphStylePropertiesArchive_TextAlignmentType[ParagraphStylePropertiesArchive_TextAlignmentType["TATvalue1"] = 1] = "TATvalue1";
    /**
     * @generated from protobuf enum value: TATvalue2 = 2;
     */
    ParagraphStylePropertiesArchive_TextAlignmentType[ParagraphStylePropertiesArchive_TextAlignmentType["TATvalue2"] = 2] = "TATvalue2";
    /**
     * @generated from protobuf enum value: TATvalue3 = 3;
     */
    ParagraphStylePropertiesArchive_TextAlignmentType[ParagraphStylePropertiesArchive_TextAlignmentType["TATvalue3"] = 3] = "TATvalue3";
    /**
     * @generated from protobuf enum value: TATvalue4 = 4;
     */
    ParagraphStylePropertiesArchive_TextAlignmentType[ParagraphStylePropertiesArchive_TextAlignmentType["TATvalue4"] = 4] = "TATvalue4";
})(ParagraphStylePropertiesArchive_TextAlignmentType = exports.ParagraphStylePropertiesArchive_TextAlignmentType || (exports.ParagraphStylePropertiesArchive_TextAlignmentType = {}));
/**
 * @generated from protobuf enum TSWP.ParagraphStylePropertiesArchive.ParagraphBorderType
 */
var ParagraphStylePropertiesArchive_ParagraphBorderType;
(function (ParagraphStylePropertiesArchive_ParagraphBorderType) {
    /**
     * @generated from protobuf enum value: PBTvalue0 = 0;
     */
    ParagraphStylePropertiesArchive_ParagraphBorderType[ParagraphStylePropertiesArchive_ParagraphBorderType["PBTvalue0"] = 0] = "PBTvalue0";
    /**
     * @generated from protobuf enum value: PBTvalue1 = 1;
     */
    ParagraphStylePropertiesArchive_ParagraphBorderType[ParagraphStylePropertiesArchive_ParagraphBorderType["PBTvalue1"] = 1] = "PBTvalue1";
    /**
     * @generated from protobuf enum value: PBTvalue2 = 2;
     */
    ParagraphStylePropertiesArchive_ParagraphBorderType[ParagraphStylePropertiesArchive_ParagraphBorderType["PBTvalue2"] = 2] = "PBTvalue2";
    /**
     * @generated from protobuf enum value: PBTvalue3 = 3;
     */
    ParagraphStylePropertiesArchive_ParagraphBorderType[ParagraphStylePropertiesArchive_ParagraphBorderType["PBTvalue3"] = 3] = "PBTvalue3";
    /**
     * @generated from protobuf enum value: PBTvalue4 = 4;
     */
    ParagraphStylePropertiesArchive_ParagraphBorderType[ParagraphStylePropertiesArchive_ParagraphBorderType["PBTvalue4"] = 4] = "PBTvalue4";
})(ParagraphStylePropertiesArchive_ParagraphBorderType = exports.ParagraphStylePropertiesArchive_ParagraphBorderType || (exports.ParagraphStylePropertiesArchive_ParagraphBorderType = {}));
/**
 * @generated from protobuf enum TSWP.ParagraphStylePropertiesArchive.OutlineStyleType
 */
var ParagraphStylePropertiesArchive_OutlineStyleType;
(function (ParagraphStylePropertiesArchive_OutlineStyleType) {
    /**
     * @generated from protobuf enum value: OSTvalue0 = 0;
     */
    ParagraphStylePropertiesArchive_OutlineStyleType[ParagraphStylePropertiesArchive_OutlineStyleType["OSTvalue0"] = 0] = "OSTvalue0";
    /**
     * @generated from protobuf enum value: OSTvalue1 = 1;
     */
    ParagraphStylePropertiesArchive_OutlineStyleType[ParagraphStylePropertiesArchive_OutlineStyleType["OSTvalue1"] = 1] = "OSTvalue1";
    /**
     * @generated from protobuf enum value: OSTvalue2 = 2;
     */
    ParagraphStylePropertiesArchive_OutlineStyleType[ParagraphStylePropertiesArchive_OutlineStyleType["OSTvalue2"] = 2] = "OSTvalue2";
})(ParagraphStylePropertiesArchive_OutlineStyleType = exports.ParagraphStylePropertiesArchive_OutlineStyleType || (exports.ParagraphStylePropertiesArchive_OutlineStyleType = {}));
/**
 * @generated from protobuf enum TSWP.ListStyleArchive.LabelType
 */
var ListStyleArchive_LabelType;
(function (ListStyleArchive_LabelType) {
    /**
     * @generated from protobuf enum value: kNone = 0;
     */
    ListStyleArchive_LabelType[ListStyleArchive_LabelType["kNone"] = 0] = "kNone";
    /**
     * @generated from protobuf enum value: kImage = 1;
     */
    ListStyleArchive_LabelType[ListStyleArchive_LabelType["kImage"] = 1] = "kImage";
    /**
     * @generated from protobuf enum value: kString = 2;
     */
    ListStyleArchive_LabelType[ListStyleArchive_LabelType["kString"] = 2] = "kString";
    /**
     * @generated from protobuf enum value: kNumber = 3;
     */
    ListStyleArchive_LabelType[ListStyleArchive_LabelType["kNumber"] = 3] = "kNumber";
})(ListStyleArchive_LabelType = exports.ListStyleArchive_LabelType || (exports.ListStyleArchive_LabelType = {}));
/**
 * @generated from protobuf enum TSWP.ListStyleArchive.NumberType
 */
var ListStyleArchive_NumberType;
(function (ListStyleArchive_NumberType) {
    /**
     * @generated from protobuf enum value: kNumericDecimal = 0;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kNumericDecimal"] = 0] = "kNumericDecimal";
    /**
     * @generated from protobuf enum value: kNumericDoubleParen = 1;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kNumericDoubleParen"] = 1] = "kNumericDoubleParen";
    /**
     * @generated from protobuf enum value: kNumericRightParen = 2;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kNumericRightParen"] = 2] = "kNumericRightParen";
    /**
     * @generated from protobuf enum value: kRomanUpperDecimal = 3;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kRomanUpperDecimal"] = 3] = "kRomanUpperDecimal";
    /**
     * @generated from protobuf enum value: kRomanUpperDoubleParen = 4;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kRomanUpperDoubleParen"] = 4] = "kRomanUpperDoubleParen";
    /**
     * @generated from protobuf enum value: kRomanUpperRightParen = 5;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kRomanUpperRightParen"] = 5] = "kRomanUpperRightParen";
    /**
     * @generated from protobuf enum value: kRomanLowerDecimal = 6;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kRomanLowerDecimal"] = 6] = "kRomanLowerDecimal";
    /**
     * @generated from protobuf enum value: kRomanLowerDoubleParen = 7;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kRomanLowerDoubleParen"] = 7] = "kRomanLowerDoubleParen";
    /**
     * @generated from protobuf enum value: kRomanLowerRightParen = 8;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kRomanLowerRightParen"] = 8] = "kRomanLowerRightParen";
    /**
     * @generated from protobuf enum value: kAlphaUpperDecimal = 9;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kAlphaUpperDecimal"] = 9] = "kAlphaUpperDecimal";
    /**
     * @generated from protobuf enum value: kAlphaUpperDoubleParen = 10;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kAlphaUpperDoubleParen"] = 10] = "kAlphaUpperDoubleParen";
    /**
     * @generated from protobuf enum value: kAlphaUpperRightParen = 11;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kAlphaUpperRightParen"] = 11] = "kAlphaUpperRightParen";
    /**
     * @generated from protobuf enum value: kAlphaLowerDecimal = 12;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kAlphaLowerDecimal"] = 12] = "kAlphaLowerDecimal";
    /**
     * @generated from protobuf enum value: kAlphaLowerDoubleParen = 13;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kAlphaLowerDoubleParen"] = 13] = "kAlphaLowerDoubleParen";
    /**
     * @generated from protobuf enum value: kAlphaLowerRightParen = 14;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kAlphaLowerRightParen"] = 14] = "kAlphaLowerRightParen";
    /**
     * @generated from protobuf enum value: kIdeographicJapaneseDecimalKind = 15;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kIdeographicJapaneseDecimalKind"] = 15] = "kIdeographicJapaneseDecimalKind";
    /**
     * @generated from protobuf enum value: kIdeographicJapaneseDoubleParenKind = 16;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kIdeographicJapaneseDoubleParenKind"] = 16] = "kIdeographicJapaneseDoubleParenKind";
    /**
     * @generated from protobuf enum value: kIdeographicJapaneseRightParenKind = 17;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kIdeographicJapaneseRightParenKind"] = 17] = "kIdeographicJapaneseRightParenKind";
    /**
     * @generated from protobuf enum value: kHiraganaDecimalKind = 18;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kHiraganaDecimalKind"] = 18] = "kHiraganaDecimalKind";
    /**
     * @generated from protobuf enum value: kHiraganaDoubleParenKind = 19;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kHiraganaDoubleParenKind"] = 19] = "kHiraganaDoubleParenKind";
    /**
     * @generated from protobuf enum value: kHiraganaRightParenKind = 20;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kHiraganaRightParenKind"] = 20] = "kHiraganaRightParenKind";
    /**
     * @generated from protobuf enum value: kKatakanaDecimalKind = 21;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kKatakanaDecimalKind"] = 21] = "kKatakanaDecimalKind";
    /**
     * @generated from protobuf enum value: kKatakanaDoubleParenKind = 22;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kKatakanaDoubleParenKind"] = 22] = "kKatakanaDoubleParenKind";
    /**
     * @generated from protobuf enum value: kKatakanaRightParenKind = 23;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kKatakanaRightParenKind"] = 23] = "kKatakanaRightParenKind";
    /**
     * @generated from protobuf enum value: kHiraganaIrohaDecimalKind = 24;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kHiraganaIrohaDecimalKind"] = 24] = "kHiraganaIrohaDecimalKind";
    /**
     * @generated from protobuf enum value: kHiraganaIrohaDoubleParenKind = 25;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kHiraganaIrohaDoubleParenKind"] = 25] = "kHiraganaIrohaDoubleParenKind";
    /**
     * @generated from protobuf enum value: kHiraganaIrohaRightParenKind = 26;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kHiraganaIrohaRightParenKind"] = 26] = "kHiraganaIrohaRightParenKind";
    /**
     * @generated from protobuf enum value: kKatakanaIrohaDecimalKind = 27;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kKatakanaIrohaDecimalKind"] = 27] = "kKatakanaIrohaDecimalKind";
    /**
     * @generated from protobuf enum value: kKatakanaIrohaDoubleParenKind = 28;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kKatakanaIrohaDoubleParenKind"] = 28] = "kKatakanaIrohaDoubleParenKind";
    /**
     * @generated from protobuf enum value: kKatakanaIrohaRightParenKind = 29;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kKatakanaIrohaRightParenKind"] = 29] = "kKatakanaIrohaRightParenKind";
    /**
     * @generated from protobuf enum value: kIdeographicSimplifiedChineseDecimalKind = 30;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kIdeographicSimplifiedChineseDecimalKind"] = 30] = "kIdeographicSimplifiedChineseDecimalKind";
    /**
     * @generated from protobuf enum value: kIdeographicSimplifiedChineseDoubleParenKind = 31;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kIdeographicSimplifiedChineseDoubleParenKind"] = 31] = "kIdeographicSimplifiedChineseDoubleParenKind";
    /**
     * @generated from protobuf enum value: kIdeographicSimplifiedChineseRightParenKind = 32;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kIdeographicSimplifiedChineseRightParenKind"] = 32] = "kIdeographicSimplifiedChineseRightParenKind";
    /**
     * @generated from protobuf enum value: kIdeographicTraditionalChineseDecimalKind = 33;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kIdeographicTraditionalChineseDecimalKind"] = 33] = "kIdeographicTraditionalChineseDecimalKind";
    /**
     * @generated from protobuf enum value: kIdeographicTraditionalChineseDoubleParenKind = 34;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kIdeographicTraditionalChineseDoubleParenKind"] = 34] = "kIdeographicTraditionalChineseDoubleParenKind";
    /**
     * @generated from protobuf enum value: kIdeographicTraditionalChineseRightParenKind = 35;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kIdeographicTraditionalChineseRightParenKind"] = 35] = "kIdeographicTraditionalChineseRightParenKind";
    /**
     * @generated from protobuf enum value: kIdeographicFormalJapaneseDecimalKind = 36;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kIdeographicFormalJapaneseDecimalKind"] = 36] = "kIdeographicFormalJapaneseDecimalKind";
    /**
     * @generated from protobuf enum value: kIdeographicFormalJapaneseDoubleParenKind = 37;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kIdeographicFormalJapaneseDoubleParenKind"] = 37] = "kIdeographicFormalJapaneseDoubleParenKind";
    /**
     * @generated from protobuf enum value: kIdeographicFormalJapaneseRightParenKind = 38;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kIdeographicFormalJapaneseRightParenKind"] = 38] = "kIdeographicFormalJapaneseRightParenKind";
    /**
     * @generated from protobuf enum value: kIdeographicFormalSimplifiedChineseDecimalKind = 39;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kIdeographicFormalSimplifiedChineseDecimalKind"] = 39] = "kIdeographicFormalSimplifiedChineseDecimalKind";
    /**
     * @generated from protobuf enum value: kIdeographicFormalSimplifiedChineseDoubleParenKind = 40;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kIdeographicFormalSimplifiedChineseDoubleParenKind"] = 40] = "kIdeographicFormalSimplifiedChineseDoubleParenKind";
    /**
     * @generated from protobuf enum value: kIdeographicFormalSimplifiedChineseRightParenKind = 41;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kIdeographicFormalSimplifiedChineseRightParenKind"] = 41] = "kIdeographicFormalSimplifiedChineseRightParenKind";
    /**
     * @generated from protobuf enum value: kIdeographicFormalTraditionalChineseDecimalKind = 42;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kIdeographicFormalTraditionalChineseDecimalKind"] = 42] = "kIdeographicFormalTraditionalChineseDecimalKind";
    /**
     * @generated from protobuf enum value: kIdeographicFormalTraditionalChineseDoubleParenKind = 43;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kIdeographicFormalTraditionalChineseDoubleParenKind"] = 43] = "kIdeographicFormalTraditionalChineseDoubleParenKind";
    /**
     * @generated from protobuf enum value: kIdeographicFormalTraditionalChineseRightParenKind = 44;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kIdeographicFormalTraditionalChineseRightParenKind"] = 44] = "kIdeographicFormalTraditionalChineseRightParenKind";
    /**
     * @generated from protobuf enum value: kKoreanAlphabetDecimalKind = 45;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kKoreanAlphabetDecimalKind"] = 45] = "kKoreanAlphabetDecimalKind";
    /**
     * @generated from protobuf enum value: kKoreanAlphabetDoubleParenKind = 46;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kKoreanAlphabetDoubleParenKind"] = 46] = "kKoreanAlphabetDoubleParenKind";
    /**
     * @generated from protobuf enum value: kKoreanAlphabetRightParenKind = 47;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kKoreanAlphabetRightParenKind"] = 47] = "kKoreanAlphabetRightParenKind";
    /**
     * @generated from protobuf enum value: kCircledNumberKind = 48;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kCircledNumberKind"] = 48] = "kCircledNumberKind";
    /**
     * @generated from protobuf enum value: kArabianNumericDecimalKind = 49;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kArabianNumericDecimalKind"] = 49] = "kArabianNumericDecimalKind";
    /**
     * @generated from protobuf enum value: kArabianNumericDoubleParenKind = 50;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kArabianNumericDoubleParenKind"] = 50] = "kArabianNumericDoubleParenKind";
    /**
     * @generated from protobuf enum value: kArabianNumericRightParenKind = 51;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kArabianNumericRightParenKind"] = 51] = "kArabianNumericRightParenKind";
    /**
     * @generated from protobuf enum value: kArabianAlphaDecimalKind = 52;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kArabianAlphaDecimalKind"] = 52] = "kArabianAlphaDecimalKind";
    /**
     * @generated from protobuf enum value: kArabianAlphaDoubleParenKind = 53;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kArabianAlphaDoubleParenKind"] = 53] = "kArabianAlphaDoubleParenKind";
    /**
     * @generated from protobuf enum value: kArabianAlphaRightParenKind = 54;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kArabianAlphaRightParenKind"] = 54] = "kArabianAlphaRightParenKind";
    /**
     * @generated from protobuf enum value: kArabianAbjadDecimalKind = 55;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kArabianAbjadDecimalKind"] = 55] = "kArabianAbjadDecimalKind";
    /**
     * @generated from protobuf enum value: kArabianAbjadDoubleParenKind = 56;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kArabianAbjadDoubleParenKind"] = 56] = "kArabianAbjadDoubleParenKind";
    /**
     * @generated from protobuf enum value: kArabianAbjadRightParenKind = 57;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kArabianAbjadRightParenKind"] = 57] = "kArabianAbjadRightParenKind";
    /**
     * @generated from protobuf enum value: kHebrewAlphaDecimalKind = 58;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kHebrewAlphaDecimalKind"] = 58] = "kHebrewAlphaDecimalKind";
    /**
     * @generated from protobuf enum value: kHebrewAlphaDoubleParenKind = 59;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kHebrewAlphaDoubleParenKind"] = 59] = "kHebrewAlphaDoubleParenKind";
    /**
     * @generated from protobuf enum value: kHebrewAlphaRightParenKind = 60;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kHebrewAlphaRightParenKind"] = 60] = "kHebrewAlphaRightParenKind";
    /**
     * @generated from protobuf enum value: kHebrewBiblicalStandardKind = 61;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kHebrewBiblicalStandardKind"] = 61] = "kHebrewBiblicalStandardKind";
    /**
     * @generated from protobuf enum value: kHebrewBiblicalDecimalKind = 62;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kHebrewBiblicalDecimalKind"] = 62] = "kHebrewBiblicalDecimalKind";
    /**
     * @generated from protobuf enum value: kHebrewBiblicalDoubleParenKind = 63;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kHebrewBiblicalDoubleParenKind"] = 63] = "kHebrewBiblicalDoubleParenKind";
    /**
     * @generated from protobuf enum value: kHebrewBiblicalRightParenKind = 64;
     */
    ListStyleArchive_NumberType[ListStyleArchive_NumberType["kHebrewBiblicalRightParenKind"] = 64] = "kHebrewBiblicalRightParenKind";
})(ListStyleArchive_NumberType = exports.ListStyleArchive_NumberType || (exports.ListStyleArchive_NumberType = {}));
/**
 * @generated from protobuf enum TSWP.ColumnStylePropertiesArchive.VerticalAlignmentType
 */
var ColumnStylePropertiesArchive_VerticalAlignmentType;
(function (ColumnStylePropertiesArchive_VerticalAlignmentType) {
    /**
     * @generated from protobuf enum value: kFrameAlignTop = 0;
     */
    ColumnStylePropertiesArchive_VerticalAlignmentType[ColumnStylePropertiesArchive_VerticalAlignmentType["kFrameAlignTop"] = 0] = "kFrameAlignTop";
    /**
     * @generated from protobuf enum value: kFrameAlignMiddle = 1;
     */
    ColumnStylePropertiesArchive_VerticalAlignmentType[ColumnStylePropertiesArchive_VerticalAlignmentType["kFrameAlignMiddle"] = 1] = "kFrameAlignMiddle";
    /**
     * @generated from protobuf enum value: kFrameAlignBottom = 2;
     */
    ColumnStylePropertiesArchive_VerticalAlignmentType[ColumnStylePropertiesArchive_VerticalAlignmentType["kFrameAlignBottom"] = 2] = "kFrameAlignBottom";
    /**
     * @generated from protobuf enum value: kFrameAlignJustify = 3;
     */
    ColumnStylePropertiesArchive_VerticalAlignmentType[ColumnStylePropertiesArchive_VerticalAlignmentType["kFrameAlignJustify"] = 3] = "kFrameAlignJustify";
})(ColumnStylePropertiesArchive_VerticalAlignmentType = exports.ColumnStylePropertiesArchive_VerticalAlignmentType || (exports.ColumnStylePropertiesArchive_VerticalAlignmentType = {}));
/**
 * @generated from protobuf enum TSWP.ShapeStylePropertiesArchive.VerticalAlignmentType
 */
var ShapeStylePropertiesArchive_VerticalAlignmentType;
(function (ShapeStylePropertiesArchive_VerticalAlignmentType) {
    /**
     * @generated from protobuf enum value: kFrameAlignTop = 0;
     */
    ShapeStylePropertiesArchive_VerticalAlignmentType[ShapeStylePropertiesArchive_VerticalAlignmentType["kFrameAlignTop"] = 0] = "kFrameAlignTop";
    /**
     * @generated from protobuf enum value: kFrameAlignMiddle = 1;
     */
    ShapeStylePropertiesArchive_VerticalAlignmentType[ShapeStylePropertiesArchive_VerticalAlignmentType["kFrameAlignMiddle"] = 1] = "kFrameAlignMiddle";
    /**
     * @generated from protobuf enum value: kFrameAlignBottom = 2;
     */
    ShapeStylePropertiesArchive_VerticalAlignmentType[ShapeStylePropertiesArchive_VerticalAlignmentType["kFrameAlignBottom"] = 2] = "kFrameAlignBottom";
    /**
     * @generated from protobuf enum value: kFrameAlignJustify = 3;
     */
    ShapeStylePropertiesArchive_VerticalAlignmentType[ShapeStylePropertiesArchive_VerticalAlignmentType["kFrameAlignJustify"] = 3] = "kFrameAlignJustify";
})(ShapeStylePropertiesArchive_VerticalAlignmentType = exports.ShapeStylePropertiesArchive_VerticalAlignmentType || (exports.ShapeStylePropertiesArchive_VerticalAlignmentType = {}));
/**
 * @generated from protobuf enum TSWP.UndoTransaction.UndoKind
 */
var UndoTransaction_UndoKind;
(function (UndoTransaction_UndoKind) {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UndoTransaction_UndoKind[UndoTransaction_UndoKind["UNSPECIFIED$"] = 0] = "UNSPECIFIED$";
    /**
     * @generated from protobuf enum value: REPLACE_TEXT = 1;
     */
    UndoTransaction_UndoKind[UndoTransaction_UndoKind["REPLACE_TEXT"] = 1] = "REPLACE_TEXT";
    /**
     * @generated from protobuf enum value: INSERT_ATTRIBUTE = 2;
     */
    UndoTransaction_UndoKind[UndoTransaction_UndoKind["INSERT_ATTRIBUTE"] = 2] = "INSERT_ATTRIBUTE";
    /**
     * @generated from protobuf enum value: DELETE_ATTRIBUTE = 3;
     */
    UndoTransaction_UndoKind[UndoTransaction_UndoKind["DELETE_ATTRIBUTE"] = 3] = "DELETE_ATTRIBUTE";
    /**
     * @generated from protobuf enum value: ADJUST_CHAR_INDEXES = 4;
     */
    UndoTransaction_UndoKind[UndoTransaction_UndoKind["ADJUST_CHAR_INDEXES"] = 4] = "ADJUST_CHAR_INDEXES";
    /**
     * @generated from protobuf enum value: COMPR_ADJUST_CHAR_INDEXES = 5;
     */
    UndoTransaction_UndoKind[UndoTransaction_UndoKind["COMPR_ADJUST_CHAR_INDEXES"] = 5] = "COMPR_ADJUST_CHAR_INDEXES";
    /**
     * @generated from protobuf enum value: REPLACE_CHAR_INDEX = 6;
     */
    UndoTransaction_UndoKind[UndoTransaction_UndoKind["REPLACE_CHAR_INDEX"] = 6] = "REPLACE_CHAR_INDEX";
    /**
     * @generated from protobuf enum value: REPLACE_OBJECT = 7;
     */
    UndoTransaction_UndoKind[UndoTransaction_UndoKind["REPLACE_OBJECT"] = 7] = "REPLACE_OBJECT";
    /**
     * @generated from protobuf enum value: REPLACE_PARAGRAPH_DATA = 8;
     */
    UndoTransaction_UndoKind[UndoTransaction_UndoKind["REPLACE_PARAGRAPH_DATA"] = 8] = "REPLACE_PARAGRAPH_DATA";
    /**
     * @generated from protobuf enum value: OBJECT_DOLC = 9;
     */
    UndoTransaction_UndoKind[UndoTransaction_UndoKind["OBJECT_DOLC"] = 9] = "OBJECT_DOLC";
    /**
     * @generated from protobuf enum value: CT_DATE = 10;
     */
    UndoTransaction_UndoKind[UndoTransaction_UndoKind["CT_DATE"] = 10] = "CT_DATE";
})(UndoTransaction_UndoKind = exports.UndoTransaction_UndoKind || (exports.UndoTransaction_UndoKind = {}));
/**
 * @generated from protobuf enum TSWP.UndoTransaction.ActionKind
 */
var UndoTransaction_ActionKind;
(function (UndoTransaction_ActionKind) {
    /**
     * @generated from protobuf enum value: ACTION_UNDEFINED = 0;
     */
    UndoTransaction_ActionKind[UndoTransaction_ActionKind["ACTION_UNDEFINED"] = 0] = "ACTION_UNDEFINED";
    /**
     * @generated from protobuf enum value: ACTION_TEXT = 1;
     */
    UndoTransaction_ActionKind[UndoTransaction_ActionKind["ACTION_TEXT"] = 1] = "ACTION_TEXT";
    /**
     * @generated from protobuf enum value: ACTION_ATTRIBUTE = 2;
     */
    UndoTransaction_ActionKind[UndoTransaction_ActionKind["ACTION_ATTRIBUTE"] = 2] = "ACTION_ATTRIBUTE";
})(UndoTransaction_ActionKind = exports.UndoTransaction_ActionKind || (exports.UndoTransaction_ActionKind = {}));
/**
 * @generated from protobuf enum TSWP.UndoTransaction.ActionGroupKind
 */
var UndoTransaction_ActionGroupKind;
(function (UndoTransaction_ActionGroupKind) {
    /**
     * @generated from protobuf enum value: ACTION_GROUP_UNDEFINED = 0;
     */
    UndoTransaction_ActionGroupKind[UndoTransaction_ActionGroupKind["ACTION_GROUP_UNDEFINED"] = 0] = "ACTION_GROUP_UNDEFINED";
    /**
     * @generated from protobuf enum value: ACTION_GROUP_TEXT = 1;
     */
    UndoTransaction_ActionGroupKind[UndoTransaction_ActionGroupKind["ACTION_GROUP_TEXT"] = 1] = "ACTION_GROUP_TEXT";
    /**
     * @generated from protobuf enum value: ACTION_GROUP_ATTRIBUTE = 2;
     */
    UndoTransaction_ActionGroupKind[UndoTransaction_ActionGroupKind["ACTION_GROUP_ATTRIBUTE"] = 2] = "ACTION_GROUP_ATTRIBUTE";
})(UndoTransaction_ActionGroupKind = exports.UndoTransaction_ActionGroupKind || (exports.UndoTransaction_ActionGroupKind = {}));
/**
 * @generated from protobuf enum TSWP.TextualAttachmentArchive.Kind
 */
var TextualAttachmentArchive_Kind;
(function (TextualAttachmentArchive_Kind) {
    /**
     * @generated from protobuf enum value: kKindPageNumber = 0;
     */
    TextualAttachmentArchive_Kind[TextualAttachmentArchive_Kind["kKindPageNumber"] = 0] = "kKindPageNumber";
    /**
     * @generated from protobuf enum value: kKindPageCount = 1;
     */
    TextualAttachmentArchive_Kind[TextualAttachmentArchive_Kind["kKindPageCount"] = 1] = "kKindPageCount";
    /**
     * @generated from protobuf enum value: kKindFootnoteMark = 2;
     */
    TextualAttachmentArchive_Kind[TextualAttachmentArchive_Kind["kKindFootnoteMark"] = 2] = "kKindFootnoteMark";
})(TextualAttachmentArchive_Kind = exports.TextualAttachmentArchive_Kind || (exports.TextualAttachmentArchive_Kind = {}));
/**
 * @generated from protobuf enum TSWP.DateTimeSmartFieldArchive.DateTimeUpdatePlan
 */
var DateTimeSmartFieldArchive_DateTimeUpdatePlan;
(function (DateTimeSmartFieldArchive_DateTimeUpdatePlan) {
    /**
     * @generated from protobuf enum value: kDateTimeUpdatePlanNever = 0;
     */
    DateTimeSmartFieldArchive_DateTimeUpdatePlan[DateTimeSmartFieldArchive_DateTimeUpdatePlan["kDateTimeUpdatePlanNever"] = 0] = "kDateTimeUpdatePlanNever";
    /**
     * @generated from protobuf enum value: kDateTimeUpdatePlanAuto = 1;
     */
    DateTimeSmartFieldArchive_DateTimeUpdatePlan[DateTimeSmartFieldArchive_DateTimeUpdatePlan["kDateTimeUpdatePlanAuto"] = 1] = "kDateTimeUpdatePlanAuto";
    /**
     * @generated from protobuf enum value: kDateTimeUpdatePlanOnce = 2;
     */
    DateTimeSmartFieldArchive_DateTimeUpdatePlan[DateTimeSmartFieldArchive_DateTimeUpdatePlan["kDateTimeUpdatePlanOnce"] = 2] = "kDateTimeUpdatePlanOnce";
})(DateTimeSmartFieldArchive_DateTimeUpdatePlan = exports.DateTimeSmartFieldArchive_DateTimeUpdatePlan || (exports.DateTimeSmartFieldArchive_DateTimeUpdatePlan = {}));
/**
 * @generated from protobuf enum TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle
 */
var DateTimeSmartFieldArchive_DateTimeFormatterStyle;
(function (DateTimeSmartFieldArchive_DateTimeFormatterStyle) {
    /**
     * @generated from protobuf enum value: kDateTimeFormatterStyleNone = 0;
     */
    DateTimeSmartFieldArchive_DateTimeFormatterStyle[DateTimeSmartFieldArchive_DateTimeFormatterStyle["kDateTimeFormatterStyleNone"] = 0] = "kDateTimeFormatterStyleNone";
    /**
     * @generated from protobuf enum value: kDateTimeFormatterStyleShort = 1;
     */
    DateTimeSmartFieldArchive_DateTimeFormatterStyle[DateTimeSmartFieldArchive_DateTimeFormatterStyle["kDateTimeFormatterStyleShort"] = 1] = "kDateTimeFormatterStyleShort";
    /**
     * @generated from protobuf enum value: kDateTimeFormatterStyleMedium = 2;
     */
    DateTimeSmartFieldArchive_DateTimeFormatterStyle[DateTimeSmartFieldArchive_DateTimeFormatterStyle["kDateTimeFormatterStyleMedium"] = 2] = "kDateTimeFormatterStyleMedium";
    /**
     * @generated from protobuf enum value: kDateTimeFormatterStyleLong = 3;
     */
    DateTimeSmartFieldArchive_DateTimeFormatterStyle[DateTimeSmartFieldArchive_DateTimeFormatterStyle["kDateTimeFormatterStyleLong"] = 3] = "kDateTimeFormatterStyleLong";
    /**
     * @generated from protobuf enum value: kDateTimeFormatterStyleFull = 4;
     */
    DateTimeSmartFieldArchive_DateTimeFormatterStyle[DateTimeSmartFieldArchive_DateTimeFormatterStyle["kDateTimeFormatterStyleFull"] = 4] = "kDateTimeFormatterStyleFull";
})(DateTimeSmartFieldArchive_DateTimeFormatterStyle = exports.DateTimeSmartFieldArchive_DateTimeFormatterStyle || (exports.DateTimeSmartFieldArchive_DateTimeFormatterStyle = {}));
/**
 * @generated from protobuf enum TSWP.MergeSmartFieldArchive.MergeCategory
 */
var MergeSmartFieldArchive_MergeCategory;
(function (MergeSmartFieldArchive_MergeCategory) {
    /**
     * @generated from protobuf enum value: kMergeCategoryTo = 0;
     */
    MergeSmartFieldArchive_MergeCategory[MergeSmartFieldArchive_MergeCategory["kMergeCategoryTo"] = 0] = "kMergeCategoryTo";
    /**
     * @generated from protobuf enum value: kMergeCategoryFrom = 1;
     */
    MergeSmartFieldArchive_MergeCategory[MergeSmartFieldArchive_MergeCategory["kMergeCategoryFrom"] = 1] = "kMergeCategoryFrom";
})(MergeSmartFieldArchive_MergeCategory = exports.MergeSmartFieldArchive_MergeCategory || (exports.MergeSmartFieldArchive_MergeCategory = {}));
/**
 * @generated from protobuf enum TSWP.ChangeArchive.ChangeKind
 */
var ChangeArchive_ChangeKind;
(function (ChangeArchive_ChangeKind) {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    ChangeArchive_ChangeKind[ChangeArchive_ChangeKind["UNSPECIFIED$"] = 0] = "UNSPECIFIED$";
    /**
     * @generated from protobuf enum value: kChangeKindInsertion = 1;
     */
    ChangeArchive_ChangeKind[ChangeArchive_ChangeKind["kChangeKindInsertion"] = 1] = "kChangeKindInsertion";
    /**
     * @generated from protobuf enum value: kChangeKindDeletion = 2;
     */
    ChangeArchive_ChangeKind[ChangeArchive_ChangeKind["kChangeKindDeletion"] = 2] = "kChangeKindDeletion";
})(ChangeArchive_ChangeKind = exports.ChangeArchive_ChangeKind || (exports.ChangeArchive_ChangeKind = {}));
/**
 * @generated from protobuf enum TSWP.DropCapArchive.DropCapType
 */
var DropCapArchive_DropCapType;
(function (DropCapArchive_DropCapType) {
    /**
     * @generated from protobuf enum value: TSWPDropCapTypeText = 0;
     */
    DropCapArchive_DropCapType[DropCapArchive_DropCapType["TSWPDropCapTypeText"] = 0] = "TSWPDropCapTypeText";
    /**
     * @generated from protobuf enum value: TSWPDropCapTypeShape = 1;
     */
    DropCapArchive_DropCapType[DropCapArchive_DropCapType["TSWPDropCapTypeShape"] = 1] = "TSWPDropCapTypeShape";
    /**
     * @generated from protobuf enum value: TSWPDropCapTypeImage = 2;
     */
    DropCapArchive_DropCapType[DropCapArchive_DropCapType["TSWPDropCapTypeImage"] = 2] = "TSWPDropCapTypeImage";
})(DropCapArchive_DropCapType = exports.DropCapArchive_DropCapType || (exports.DropCapArchive_DropCapType = {}));
/**
 * @generated from protobuf enum TSWP.DropCapArchive.DropCapWrapType
 */
var DropCapArchive_DropCapWrapType;
(function (DropCapArchive_DropCapWrapType) {
    /**
     * @generated from protobuf enum value: TSWPDropCapWrapTypeRectangular = 0;
     */
    DropCapArchive_DropCapWrapType[DropCapArchive_DropCapWrapType["TSWPDropCapWrapTypeRectangular"] = 0] = "TSWPDropCapWrapTypeRectangular";
    /**
     * @generated from protobuf enum value: TSWPDropCapWrapTypeContour = 1;
     */
    DropCapArchive_DropCapWrapType[DropCapArchive_DropCapWrapType["TSWPDropCapWrapTypeContour"] = 1] = "TSWPDropCapWrapTypeContour";
    /**
     * @generated from protobuf enum value: TSWPDropCapWrapTypeNone = 2;
     */
    DropCapArchive_DropCapWrapType[DropCapArchive_DropCapWrapType["TSWPDropCapWrapTypeNone"] = 2] = "TSWPDropCapWrapTypeNone";
})(DropCapArchive_DropCapWrapType = exports.DropCapArchive_DropCapWrapType || (exports.DropCapArchive_DropCapWrapType = {}));
/**
 * @generated from protobuf enum TSWP.SelectionType
 */
var SelectionType;
(function (SelectionType) {
    /**
     * @generated from protobuf enum value: SelectionType_Normal = 0;
     */
    SelectionType[SelectionType["SelectionType_Normal"] = 0] = "SelectionType_Normal";
    /**
     * @generated from protobuf enum value: SelectionType_ListLabel = 1;
     */
    SelectionType[SelectionType["SelectionType_ListLabel"] = 1] = "SelectionType_ListLabel";
    /**
     * @generated from protobuf enum value: SelectionType_ListTopic = 2;
     */
    SelectionType[SelectionType["SelectionType_ListTopic"] = 2] = "SelectionType_ListTopic";
    /**
     * @generated from protobuf enum value: SelectionType_Replace = 3;
     */
    SelectionType[SelectionType["SelectionType_Replace"] = 3] = "SelectionType_Replace";
    /**
     * @generated from protobuf enum value: SelectionType_CopyPasteStyle = 4;
     */
    SelectionType[SelectionType["SelectionType_CopyPasteStyle"] = 4] = "SelectionType_CopyPasteStyle";
    /**
     * @generated from protobuf enum value: SelectionType_Replace2 = 5;
     */
    SelectionType[SelectionType["SelectionType_Replace2"] = 5] = "SelectionType_Replace2";
    /**
     * @generated from protobuf enum value: SelectionType_SmartField = 6;
     */
    SelectionType[SelectionType["SelectionType_SmartField"] = 6] = "SelectionType_SmartField";
    /**
     * @generated from protobuf enum value: SelectionType_Visual = 7;
     */
    SelectionType[SelectionType["SelectionType_Visual"] = 7] = "SelectionType_Visual";
    /**
     * @generated from protobuf enum value: SelectionType_Logical = 8;
     */
    SelectionType[SelectionType["SelectionType_Logical"] = 8] = "SelectionType_Logical";
})(SelectionType = exports.SelectionType || (exports.SelectionType = {}));
/**
 * @generated from protobuf enum TSWP.StyleInsertionBehavior
 */
var StyleInsertionBehavior;
(function (StyleInsertionBehavior) {
    /**
     * @generated from protobuf enum value: StyleInsertionBehavior_NoGrow = 0;
     */
    StyleInsertionBehavior[StyleInsertionBehavior["StyleInsertionBehavior_NoGrow"] = 0] = "StyleInsertionBehavior_NoGrow";
    /**
     * @generated from protobuf enum value: StyleInsertionBehavior_GrowLeft = 1;
     */
    StyleInsertionBehavior[StyleInsertionBehavior["StyleInsertionBehavior_GrowLeft"] = 1] = "StyleInsertionBehavior_GrowLeft";
    /**
     * @generated from protobuf enum value: StyleInsertionBehavior_GrowRight = 2;
     */
    StyleInsertionBehavior[StyleInsertionBehavior["StyleInsertionBehavior_GrowRight"] = 2] = "StyleInsertionBehavior_GrowRight";
})(StyleInsertionBehavior = exports.StyleInsertionBehavior || (exports.StyleInsertionBehavior = {}));
/**
 * @generated from protobuf enum TSWP.CaretAffinity
 */
var CaretAffinity;
(function (CaretAffinity) {
    /**
     * @generated from protobuf enum value: CaretAffinity_Start = 0;
     */
    CaretAffinity[CaretAffinity["CaretAffinity_Start"] = 0] = "CaretAffinity_Start";
    /**
     * @generated from protobuf enum value: CaretAffinity_End = 1;
     */
    CaretAffinity[CaretAffinity["CaretAffinity_End"] = 1] = "CaretAffinity_End";
})(CaretAffinity = exports.CaretAffinity || (exports.CaretAffinity = {}));
/**
 * @generated from protobuf enum TSWP.WritingDirectionType
 */
var WritingDirectionType;
(function (WritingDirectionType) {
    /**
     * @generated from protobuf enum value: kWritingDirectionNatural = -1;
     */
    WritingDirectionType[WritingDirectionType["kWritingDirectionNatural"] = -1] = "kWritingDirectionNatural";
    /**
     * @generated from protobuf enum value: kWritingDirectionLeftToRight = 0;
     */
    WritingDirectionType[WritingDirectionType["kWritingDirectionLeftToRight"] = 0] = "kWritingDirectionLeftToRight";
    /**
     * @generated from protobuf enum value: kWritingDirectionRightToLeft = 1;
     */
    WritingDirectionType[WritingDirectionType["kWritingDirectionRightToLeft"] = 1] = "kWritingDirectionRightToLeft";
})(WritingDirectionType = exports.WritingDirectionType || (exports.WritingDirectionType = {}));
// @generated message type with reflection information, may provide speed optimized methods
class SelectionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.SelectionArchive", [
            { no: 1, name: "deprecated_type", kind: "enum", T: () => ["TSWP.SelectionType", SelectionType] },
            { no: 2, name: "deprecated_range", kind: "message", T: () => TSPMessages_6.Range },
            { no: 3, name: "styleInsertionBehavior", kind: "enum", T: () => ["TSWP.StyleInsertionBehavior", StyleInsertionBehavior] },
            { no: 4, name: "caretAffinity", kind: "enum", T: () => ["TSWP.CaretAffinity", CaretAffinity] },
            { no: 5, name: "smart_field_range", kind: "message", T: () => TSPMessages_6.Range },
            { no: 6, name: "leading_edge", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "leading_char_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "type", kind: "enum", opt: true, T: () => ["TSWP.SelectionType", SelectionType] },
            { no: 9, name: "ranges", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_6.Range }
        ]);
    }
    create(value) {
        const message = { deprecatedType: 0, styleInsertionBehavior: 0, caretAffinity: 0, ranges: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSWP.SelectionType deprecated_type = 1 [deprecated = true];*/ 1:
                    message.deprecatedType = reader.int32();
                    break;
                case /* TSP.Range deprecated_range = 2 [deprecated = true];*/ 2:
                    message.deprecatedRange = TSPMessages_6.Range.internalBinaryRead(reader, reader.uint32(), options, message.deprecatedRange);
                    break;
                case /* TSWP.StyleInsertionBehavior styleInsertionBehavior */ 3:
                    message.styleInsertionBehavior = reader.int32();
                    break;
                case /* TSWP.CaretAffinity caretAffinity */ 4:
                    message.caretAffinity = reader.int32();
                    break;
                case /* TSP.Range smart_field_range */ 5:
                    message.smartFieldRange = TSPMessages_6.Range.internalBinaryRead(reader, reader.uint32(), options, message.smartFieldRange);
                    break;
                case /* optional bool leading_edge */ 6:
                    message.leadingEdge = reader.bool();
                    break;
                case /* optional uint32 leading_char_index */ 7:
                    message.leadingCharIndex = reader.uint32();
                    break;
                case /* optional TSWP.SelectionType type */ 8:
                    message.type = reader.int32();
                    break;
                case /* repeated TSP.Range ranges */ 9:
                    message.ranges.push(TSPMessages_6.Range.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSWP.SelectionType deprecated_type = 1 [deprecated = true]; */
        if (message.deprecatedType !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.deprecatedType);
        /* TSP.Range deprecated_range = 2 [deprecated = true]; */
        if (message.deprecatedRange)
            TSPMessages_6.Range.internalBinaryWrite(message.deprecatedRange, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSWP.StyleInsertionBehavior styleInsertionBehavior = 3; */
        if (message.styleInsertionBehavior !== 0)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.styleInsertionBehavior);
        /* TSWP.CaretAffinity caretAffinity = 4; */
        if (message.caretAffinity !== 0)
            writer.tag(4, runtime_1.WireType.Varint).int32(message.caretAffinity);
        /* TSP.Range smart_field_range = 5; */
        if (message.smartFieldRange)
            TSPMessages_6.Range.internalBinaryWrite(message.smartFieldRange, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool leading_edge = 6; */
        if (message.leadingEdge !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.leadingEdge);
        /* optional uint32 leading_char_index = 7; */
        if (message.leadingCharIndex !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).uint32(message.leadingCharIndex);
        /* optional TSWP.SelectionType type = 8; */
        if (message.type !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).int32(message.type);
        /* repeated TSP.Range ranges = 9; */
        for (let i = 0; i < message.ranges.length; i++)
            TSPMessages_6.Range.internalBinaryWrite(message.ranges[i], writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.SelectionArchive
 */
exports.SelectionArchive = new SelectionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ObjectAttributeTable$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ObjectAttributeTable", [
            { no: 1, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ObjectAttributeTable_ObjectAttribute }
        ]);
    }
    create(value) {
        const message = { entries: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSWP.ObjectAttributeTable.ObjectAttribute entries */ 1:
                    message.entries.push(exports.ObjectAttributeTable_ObjectAttribute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSWP.ObjectAttributeTable.ObjectAttribute entries = 1; */
        for (let i = 0; i < message.entries.length; i++)
            exports.ObjectAttributeTable_ObjectAttribute.internalBinaryWrite(message.entries[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ObjectAttributeTable
 */
exports.ObjectAttributeTable = new ObjectAttributeTable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ObjectAttributeTable_ObjectAttribute$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ObjectAttributeTable.ObjectAttribute", [
            { no: 1, name: "character_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "object", kind: "message", T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = { characterIndex: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 character_index */ 1:
                    message.characterIndex = reader.uint32();
                    break;
                case /* optional TSP.Reference object */ 2:
                    message.object = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.object);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 character_index = 1; */
        if (message.characterIndex !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.characterIndex);
        /* optional TSP.Reference object = 2; */
        if (message.object)
            TSPMessages_5.Reference.internalBinaryWrite(message.object, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ObjectAttributeTable.ObjectAttribute
 */
exports.ObjectAttributeTable_ObjectAttribute = new ObjectAttributeTable_ObjectAttribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StringAttributeTable$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.StringAttributeTable", [
            { no: 1, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.StringAttributeTable_StringAttribute }
        ]);
    }
    create(value) {
        const message = { entries: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSWP.StringAttributeTable.StringAttribute entries */ 1:
                    message.entries.push(exports.StringAttributeTable_StringAttribute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSWP.StringAttributeTable.StringAttribute entries = 1; */
        for (let i = 0; i < message.entries.length; i++)
            exports.StringAttributeTable_StringAttribute.internalBinaryWrite(message.entries[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.StringAttributeTable
 */
exports.StringAttributeTable = new StringAttributeTable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StringAttributeTable_StringAttribute$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.StringAttributeTable.StringAttribute", [
            { no: 1, name: "character_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "object", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { characterIndex: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 character_index */ 1:
                    message.characterIndex = reader.uint32();
                    break;
                case /* optional string object */ 2:
                    message.object = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 character_index = 1; */
        if (message.characterIndex !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.characterIndex);
        /* optional string object = 2; */
        if (message.object !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.object);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.StringAttributeTable.StringAttribute
 */
exports.StringAttributeTable_StringAttribute = new StringAttributeTable_StringAttribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ParaDataAttributeTable$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ParaDataAttributeTable", [
            { no: 1, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ParaDataAttributeTable_ParaDataAttribute }
        ]);
    }
    create(value) {
        const message = { entries: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSWP.ParaDataAttributeTable.ParaDataAttribute entries */ 1:
                    message.entries.push(exports.ParaDataAttributeTable_ParaDataAttribute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSWP.ParaDataAttributeTable.ParaDataAttribute entries = 1; */
        for (let i = 0; i < message.entries.length; i++)
            exports.ParaDataAttributeTable_ParaDataAttribute.internalBinaryWrite(message.entries[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ParaDataAttributeTable
 */
exports.ParaDataAttributeTable = new ParaDataAttributeTable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ParaDataAttributeTable_ParaDataAttribute$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ParaDataAttributeTable.ParaDataAttribute", [
            { no: 1, name: "character_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "first", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "second", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { characterIndex: 0, first: 0, second: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 character_index */ 1:
                    message.characterIndex = reader.uint32();
                    break;
                case /* uint32 first */ 2:
                    message.first = reader.uint32();
                    break;
                case /* uint32 second */ 3:
                    message.second = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 character_index = 1; */
        if (message.characterIndex !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.characterIndex);
        /* uint32 first = 2; */
        if (message.first !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.first);
        /* uint32 second = 3; */
        if (message.second !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.second);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ParaDataAttributeTable.ParaDataAttribute
 */
exports.ParaDataAttributeTable_ParaDataAttribute = new ParaDataAttributeTable_ParaDataAttribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OverlappingFieldAttributeTable$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.OverlappingFieldAttributeTable", [
            { no: 1, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.OverlappingFieldAttributeTable_OverlappingFieldAttribute }
        ]);
    }
    create(value) {
        const message = { entries: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSWP.OverlappingFieldAttributeTable.OverlappingFieldAttribute entries */ 1:
                    message.entries.push(exports.OverlappingFieldAttributeTable_OverlappingFieldAttribute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSWP.OverlappingFieldAttributeTable.OverlappingFieldAttribute entries = 1; */
        for (let i = 0; i < message.entries.length; i++)
            exports.OverlappingFieldAttributeTable_OverlappingFieldAttribute.internalBinaryWrite(message.entries[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.OverlappingFieldAttributeTable
 */
exports.OverlappingFieldAttributeTable = new OverlappingFieldAttributeTable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OverlappingFieldAttributeTable_OverlappingFieldAttribute$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.OverlappingFieldAttributeTable.OverlappingFieldAttribute", [
            { no: 1, name: "range", kind: "message", T: () => TSPMessages_6.Range },
            { no: 2, name: "field", kind: "message", T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.Range range */ 1:
                    message.range = TSPMessages_6.Range.internalBinaryRead(reader, reader.uint32(), options, message.range);
                    break;
                case /* TSP.Reference field */ 2:
                    message.field = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.field);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.Range range = 1; */
        if (message.range)
            TSPMessages_6.Range.internalBinaryWrite(message.range, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference field = 2; */
        if (message.field)
            TSPMessages_5.Reference.internalBinaryWrite(message.field, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.OverlappingFieldAttributeTable.OverlappingFieldAttribute
 */
exports.OverlappingFieldAttributeTable_OverlappingFieldAttribute = new OverlappingFieldAttributeTable_OverlappingFieldAttribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StorageArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.StorageArchive", [
            { no: 1, name: "kind", kind: "enum", opt: true, T: () => ["TSWP.StorageArchive.KindType", StorageArchive_KindType] },
            { no: 2, name: "style_sheet", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 3, name: "text", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "has_itext", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "in_document", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "table_para_style", kind: "message", T: () => exports.ObjectAttributeTable },
            { no: 6, name: "table_para_data", kind: "message", T: () => exports.ParaDataAttributeTable },
            { no: 7, name: "table_list_style", kind: "message", T: () => exports.ObjectAttributeTable },
            { no: 8, name: "table_char_style", kind: "message", T: () => exports.ObjectAttributeTable },
            { no: 9, name: "table_attachment", kind: "message", T: () => exports.ObjectAttributeTable },
            { no: 11, name: "table_smartfield", kind: "message", T: () => exports.ObjectAttributeTable },
            { no: 12, name: "table_layout_style", kind: "message", T: () => exports.ObjectAttributeTable },
            { no: 14, name: "table_para_starts", kind: "message", T: () => exports.ParaDataAttributeTable },
            { no: 15, name: "table_bookmark", kind: "message", T: () => exports.ObjectAttributeTable },
            { no: 16, name: "table_footnote", kind: "message", T: () => exports.ObjectAttributeTable },
            { no: 17, name: "table_section", kind: "message", T: () => exports.ObjectAttributeTable },
            { no: 18, name: "table_rubyfield", kind: "message", T: () => exports.ObjectAttributeTable },
            { no: 19, name: "table_language", kind: "message", T: () => exports.StringAttributeTable },
            { no: 20, name: "table_dictation", kind: "message", T: () => exports.StringAttributeTable },
            { no: 21, name: "table_insertion", kind: "message", T: () => exports.ObjectAttributeTable },
            { no: 22, name: "table_deletion", kind: "message", T: () => exports.ObjectAttributeTable },
            { no: 23, name: "table_highlight", kind: "message", T: () => exports.ObjectAttributeTable },
            { no: 24, name: "table_para_bidi", kind: "message", T: () => exports.ParaDataAttributeTable },
            { no: 25, name: "table_overlapping_highlight", kind: "message", T: () => exports.OverlappingFieldAttributeTable },
            { no: 26, name: "table_pencil_annotation", kind: "message", T: () => exports.OverlappingFieldAttributeTable },
            { no: 27, name: "table_tatechuyoko", kind: "message", T: () => exports.ObjectAttributeTable },
            { no: 28, name: "table_drop_cap_style", kind: "message", T: () => exports.ObjectAttributeTable }
        ]);
    }
    create(value) {
        const message = { text: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.StorageArchive.KindType kind */ 1:
                    message.kind = reader.int32();
                    break;
                case /* optional TSP.Reference style_sheet */ 2:
                    message.styleSheet = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.styleSheet);
                    break;
                case /* repeated string text */ 3:
                    message.text.push(reader.string());
                    break;
                case /* optional bool has_itext */ 4:
                    message.hasItext = reader.bool();
                    break;
                case /* optional bool in_document */ 10:
                    message.inDocument = reader.bool();
                    break;
                case /* optional TSWP.ObjectAttributeTable table_para_style */ 5:
                    message.tableParaStyle = exports.ObjectAttributeTable.internalBinaryRead(reader, reader.uint32(), options, message.tableParaStyle);
                    break;
                case /* optional TSWP.ParaDataAttributeTable table_para_data */ 6:
                    message.tableParaData = exports.ParaDataAttributeTable.internalBinaryRead(reader, reader.uint32(), options, message.tableParaData);
                    break;
                case /* optional TSWP.ObjectAttributeTable table_list_style */ 7:
                    message.tableListStyle = exports.ObjectAttributeTable.internalBinaryRead(reader, reader.uint32(), options, message.tableListStyle);
                    break;
                case /* optional TSWP.ObjectAttributeTable table_char_style */ 8:
                    message.tableCharStyle = exports.ObjectAttributeTable.internalBinaryRead(reader, reader.uint32(), options, message.tableCharStyle);
                    break;
                case /* optional TSWP.ObjectAttributeTable table_attachment */ 9:
                    message.tableAttachment = exports.ObjectAttributeTable.internalBinaryRead(reader, reader.uint32(), options, message.tableAttachment);
                    break;
                case /* optional TSWP.ObjectAttributeTable table_smartfield */ 11:
                    message.tableSmartfield = exports.ObjectAttributeTable.internalBinaryRead(reader, reader.uint32(), options, message.tableSmartfield);
                    break;
                case /* optional TSWP.ObjectAttributeTable table_layout_style */ 12:
                    message.tableLayoutStyle = exports.ObjectAttributeTable.internalBinaryRead(reader, reader.uint32(), options, message.tableLayoutStyle);
                    break;
                case /* optional TSWP.ParaDataAttributeTable table_para_starts */ 14:
                    message.tableParaStarts = exports.ParaDataAttributeTable.internalBinaryRead(reader, reader.uint32(), options, message.tableParaStarts);
                    break;
                case /* optional TSWP.ObjectAttributeTable table_bookmark */ 15:
                    message.tableBookmark = exports.ObjectAttributeTable.internalBinaryRead(reader, reader.uint32(), options, message.tableBookmark);
                    break;
                case /* optional TSWP.ObjectAttributeTable table_footnote */ 16:
                    message.tableFootnote = exports.ObjectAttributeTable.internalBinaryRead(reader, reader.uint32(), options, message.tableFootnote);
                    break;
                case /* optional TSWP.ObjectAttributeTable table_section */ 17:
                    message.tableSection = exports.ObjectAttributeTable.internalBinaryRead(reader, reader.uint32(), options, message.tableSection);
                    break;
                case /* optional TSWP.ObjectAttributeTable table_rubyfield */ 18:
                    message.tableRubyfield = exports.ObjectAttributeTable.internalBinaryRead(reader, reader.uint32(), options, message.tableRubyfield);
                    break;
                case /* optional TSWP.StringAttributeTable table_language */ 19:
                    message.tableLanguage = exports.StringAttributeTable.internalBinaryRead(reader, reader.uint32(), options, message.tableLanguage);
                    break;
                case /* optional TSWP.StringAttributeTable table_dictation */ 20:
                    message.tableDictation = exports.StringAttributeTable.internalBinaryRead(reader, reader.uint32(), options, message.tableDictation);
                    break;
                case /* optional TSWP.ObjectAttributeTable table_insertion */ 21:
                    message.tableInsertion = exports.ObjectAttributeTable.internalBinaryRead(reader, reader.uint32(), options, message.tableInsertion);
                    break;
                case /* optional TSWP.ObjectAttributeTable table_deletion */ 22:
                    message.tableDeletion = exports.ObjectAttributeTable.internalBinaryRead(reader, reader.uint32(), options, message.tableDeletion);
                    break;
                case /* optional TSWP.ObjectAttributeTable table_highlight */ 23:
                    message.tableHighlight = exports.ObjectAttributeTable.internalBinaryRead(reader, reader.uint32(), options, message.tableHighlight);
                    break;
                case /* optional TSWP.ParaDataAttributeTable table_para_bidi */ 24:
                    message.tableParaBidi = exports.ParaDataAttributeTable.internalBinaryRead(reader, reader.uint32(), options, message.tableParaBidi);
                    break;
                case /* optional TSWP.OverlappingFieldAttributeTable table_overlapping_highlight */ 25:
                    message.tableOverlappingHighlight = exports.OverlappingFieldAttributeTable.internalBinaryRead(reader, reader.uint32(), options, message.tableOverlappingHighlight);
                    break;
                case /* optional TSWP.OverlappingFieldAttributeTable table_pencil_annotation */ 26:
                    message.tablePencilAnnotation = exports.OverlappingFieldAttributeTable.internalBinaryRead(reader, reader.uint32(), options, message.tablePencilAnnotation);
                    break;
                case /* optional TSWP.ObjectAttributeTable table_tatechuyoko */ 27:
                    message.tableTatechuyoko = exports.ObjectAttributeTable.internalBinaryRead(reader, reader.uint32(), options, message.tableTatechuyoko);
                    break;
                case /* optional TSWP.ObjectAttributeTable table_drop_cap_style */ 28:
                    message.tableDropCapStyle = exports.ObjectAttributeTable.internalBinaryRead(reader, reader.uint32(), options, message.tableDropCapStyle);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.StorageArchive.KindType kind = 1; */
        if (message.kind !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.kind);
        /* optional TSP.Reference style_sheet = 2; */
        if (message.styleSheet)
            TSPMessages_5.Reference.internalBinaryWrite(message.styleSheet, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated string text = 3; */
        for (let i = 0; i < message.text.length; i++)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.text[i]);
        /* optional bool has_itext = 4; */
        if (message.hasItext !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.hasItext);
        /* optional bool in_document = 10; */
        if (message.inDocument !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).bool(message.inDocument);
        /* optional TSWP.ObjectAttributeTable table_para_style = 5; */
        if (message.tableParaStyle)
            exports.ObjectAttributeTable.internalBinaryWrite(message.tableParaStyle, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.ParaDataAttributeTable table_para_data = 6; */
        if (message.tableParaData)
            exports.ParaDataAttributeTable.internalBinaryWrite(message.tableParaData, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.ObjectAttributeTable table_list_style = 7; */
        if (message.tableListStyle)
            exports.ObjectAttributeTable.internalBinaryWrite(message.tableListStyle, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.ObjectAttributeTable table_char_style = 8; */
        if (message.tableCharStyle)
            exports.ObjectAttributeTable.internalBinaryWrite(message.tableCharStyle, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.ObjectAttributeTable table_attachment = 9; */
        if (message.tableAttachment)
            exports.ObjectAttributeTable.internalBinaryWrite(message.tableAttachment, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.ObjectAttributeTable table_smartfield = 11; */
        if (message.tableSmartfield)
            exports.ObjectAttributeTable.internalBinaryWrite(message.tableSmartfield, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.ObjectAttributeTable table_layout_style = 12; */
        if (message.tableLayoutStyle)
            exports.ObjectAttributeTable.internalBinaryWrite(message.tableLayoutStyle, writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.ParaDataAttributeTable table_para_starts = 14; */
        if (message.tableParaStarts)
            exports.ParaDataAttributeTable.internalBinaryWrite(message.tableParaStarts, writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.ObjectAttributeTable table_bookmark = 15; */
        if (message.tableBookmark)
            exports.ObjectAttributeTable.internalBinaryWrite(message.tableBookmark, writer.tag(15, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.ObjectAttributeTable table_footnote = 16; */
        if (message.tableFootnote)
            exports.ObjectAttributeTable.internalBinaryWrite(message.tableFootnote, writer.tag(16, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.ObjectAttributeTable table_section = 17; */
        if (message.tableSection)
            exports.ObjectAttributeTable.internalBinaryWrite(message.tableSection, writer.tag(17, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.ObjectAttributeTable table_rubyfield = 18; */
        if (message.tableRubyfield)
            exports.ObjectAttributeTable.internalBinaryWrite(message.tableRubyfield, writer.tag(18, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.StringAttributeTable table_language = 19; */
        if (message.tableLanguage)
            exports.StringAttributeTable.internalBinaryWrite(message.tableLanguage, writer.tag(19, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.StringAttributeTable table_dictation = 20; */
        if (message.tableDictation)
            exports.StringAttributeTable.internalBinaryWrite(message.tableDictation, writer.tag(20, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.ObjectAttributeTable table_insertion = 21; */
        if (message.tableInsertion)
            exports.ObjectAttributeTable.internalBinaryWrite(message.tableInsertion, writer.tag(21, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.ObjectAttributeTable table_deletion = 22; */
        if (message.tableDeletion)
            exports.ObjectAttributeTable.internalBinaryWrite(message.tableDeletion, writer.tag(22, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.ObjectAttributeTable table_highlight = 23; */
        if (message.tableHighlight)
            exports.ObjectAttributeTable.internalBinaryWrite(message.tableHighlight, writer.tag(23, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.ParaDataAttributeTable table_para_bidi = 24; */
        if (message.tableParaBidi)
            exports.ParaDataAttributeTable.internalBinaryWrite(message.tableParaBidi, writer.tag(24, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.OverlappingFieldAttributeTable table_overlapping_highlight = 25; */
        if (message.tableOverlappingHighlight)
            exports.OverlappingFieldAttributeTable.internalBinaryWrite(message.tableOverlappingHighlight, writer.tag(25, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.OverlappingFieldAttributeTable table_pencil_annotation = 26; */
        if (message.tablePencilAnnotation)
            exports.OverlappingFieldAttributeTable.internalBinaryWrite(message.tablePencilAnnotation, writer.tag(26, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.ObjectAttributeTable table_tatechuyoko = 27; */
        if (message.tableTatechuyoko)
            exports.ObjectAttributeTable.internalBinaryWrite(message.tableTatechuyoko, writer.tag(27, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.ObjectAttributeTable table_drop_cap_style = 28; */
        if (message.tableDropCapStyle)
            exports.ObjectAttributeTable.internalBinaryWrite(message.tableDropCapStyle, writer.tag(28, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.StorageArchive
 */
exports.StorageArchive = new StorageArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HighlightArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.HighlightArchive", [
            { no: 1, name: "commentStorage", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 2, name: "text_attribute_uuid_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference commentStorage */ 1:
                    message.commentStorage = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.commentStorage);
                    break;
                case /* optional string text_attribute_uuid_string */ 2:
                    message.textAttributeUuidString = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference commentStorage = 1; */
        if (message.commentStorage)
            TSPMessages_5.Reference.internalBinaryWrite(message.commentStorage, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string text_attribute_uuid_string = 2; */
        if (message.textAttributeUuidString !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.textAttributeUuidString);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.HighlightArchive
 */
exports.HighlightArchive = new HighlightArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PencilAnnotationArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.PencilAnnotationArchive", [
            { no: 1, name: "pencil_annotation_storage", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 2, name: "text_attribute_uuid_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference pencil_annotation_storage */ 1:
                    message.pencilAnnotationStorage = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.pencilAnnotationStorage);
                    break;
                case /* optional string text_attribute_uuid_string */ 2:
                    message.textAttributeUuidString = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference pencil_annotation_storage = 1; */
        if (message.pencilAnnotationStorage)
            TSPMessages_5.Reference.internalBinaryWrite(message.pencilAnnotationStorage, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string text_attribute_uuid_string = 2; */
        if (message.textAttributeUuidString !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.textAttributeUuidString);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.PencilAnnotationArchive
 */
exports.PencilAnnotationArchive = new PencilAnnotationArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FontFeatureArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.FontFeatureArchive", [
            { no: 1, name: "feature_type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "feature_selector", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { featureType: 0, featureSelector: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 feature_type */ 1:
                    message.featureType = reader.uint32();
                    break;
                case /* uint32 feature_selector */ 2:
                    message.featureSelector = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 feature_type = 1; */
        if (message.featureType !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.featureType);
        /* uint32 feature_selector = 2; */
        if (message.featureSelector !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.featureSelector);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.FontFeatureArchive
 */
exports.FontFeatureArchive = new FontFeatureArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CharacterStylePropertiesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.CharacterStylePropertiesArchive", [
            { no: 1, name: "bold", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "italic", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "font_size", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "font_name_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "font_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "font_color_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "font_color", kind: "message", T: () => TSPMessages_4.Color },
            { no: 8, name: "language_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "language", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "superscript", kind: "enum", opt: true, T: () => ["TSWP.CharacterStylePropertiesArchive.SuperscriptType", CharacterStylePropertiesArchive_SuperscriptType] },
            { no: 11, name: "underline", kind: "enum", opt: true, T: () => ["TSWP.CharacterStylePropertiesArchive.UnderlineType", CharacterStylePropertiesArchive_UnderlineType] },
            { no: 12, name: "strikethru", kind: "enum", opt: true, T: () => ["TSWP.CharacterStylePropertiesArchive.StrikethruType", CharacterStylePropertiesArchive_StrikethruType] },
            { no: 13, name: "capitalization", kind: "enum", opt: true, T: () => ["TSWP.CharacterStylePropertiesArchive.CapitalizationType", CharacterStylePropertiesArchive_CapitalizationType] },
            { no: 14, name: "baseline_shift", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 15, name: "kerning", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 16, name: "ligatures", kind: "enum", opt: true, T: () => ["TSWP.CharacterStylePropertiesArchive.LigaturesType", CharacterStylePropertiesArchive_LigaturesType] },
            { no: 17, name: "outline_color_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "outline_color", kind: "message", T: () => TSPMessages_4.Color },
            { no: 19, name: "outline", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 20, name: "shadow_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "shadow", kind: "message", T: () => TSDArchives_5.ShadowArchive },
            { no: 22, name: "strikethru_color_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 23, name: "strikethru_color", kind: "message", T: () => TSPMessages_4.Color },
            { no: 24, name: "strikethru_width", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 25, name: "background_color_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 26, name: "background_color", kind: "message", T: () => TSPMessages_4.Color },
            { no: 27, name: "tracking", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 28, name: "underline_color_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 29, name: "underline_color", kind: "message", T: () => TSPMessages_4.Color },
            { no: 30, name: "underline_width", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 31, name: "word_strikethru", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 32, name: "word_underline", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 33, name: "font_features_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 34, name: "font_features", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.FontFeatureArchive },
            { no: 35, name: "writing_direction", kind: "enum", opt: true, T: () => ["TSWP.WritingDirectionType", WritingDirectionType] },
            { no: 36, name: "emphasis_marks_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 37, name: "emphasis_marks", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 38, name: "compatibility_font_name_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 39, name: "compatibility_font_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 40, name: "is_named_point_size", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 41, name: "capitalization_uses_linguistics", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 42, name: "tate_chu_yoko", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 43, name: "tsd_stroke_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 44, name: "tsd_stroke", kind: "message", T: () => TSDArchives_4.StrokeArchive },
            { no: 45, name: "tsd_fill_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 46, name: "tsd_fill", kind: "message", T: () => TSDArchives_3.FillArchive },
            { no: 47, name: "tsd_fill_should_fill_text_container", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { fontFeatures: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool bold */ 1:
                    message.bold = reader.bool();
                    break;
                case /* optional bool italic */ 2:
                    message.italic = reader.bool();
                    break;
                case /* optional float font_size */ 3:
                    message.fontSize = reader.float();
                    break;
                case /* optional bool font_name_null */ 4:
                    message.fontNameNull = reader.bool();
                    break;
                case /* optional string font_name */ 5:
                    message.fontName = reader.string();
                    break;
                case /* optional bool font_color_null */ 6:
                    message.fontColorNull = reader.bool();
                    break;
                case /* optional TSP.Color font_color */ 7:
                    message.fontColor = TSPMessages_4.Color.internalBinaryRead(reader, reader.uint32(), options, message.fontColor);
                    break;
                case /* optional bool language_null */ 8:
                    message.languageNull = reader.bool();
                    break;
                case /* optional string language */ 9:
                    message.language = reader.string();
                    break;
                case /* optional TSWP.CharacterStylePropertiesArchive.SuperscriptType superscript */ 10:
                    message.superscript = reader.int32();
                    break;
                case /* optional TSWP.CharacterStylePropertiesArchive.UnderlineType underline */ 11:
                    message.underline = reader.int32();
                    break;
                case /* optional TSWP.CharacterStylePropertiesArchive.StrikethruType strikethru */ 12:
                    message.strikethru = reader.int32();
                    break;
                case /* optional TSWP.CharacterStylePropertiesArchive.CapitalizationType capitalization */ 13:
                    message.capitalization = reader.int32();
                    break;
                case /* optional float baseline_shift */ 14:
                    message.baselineShift = reader.float();
                    break;
                case /* optional float kerning */ 15:
                    message.kerning = reader.float();
                    break;
                case /* optional TSWP.CharacterStylePropertiesArchive.LigaturesType ligatures */ 16:
                    message.ligatures = reader.int32();
                    break;
                case /* optional bool outline_color_null */ 17:
                    message.outlineColorNull = reader.bool();
                    break;
                case /* optional TSP.Color outline_color */ 18:
                    message.outlineColor = TSPMessages_4.Color.internalBinaryRead(reader, reader.uint32(), options, message.outlineColor);
                    break;
                case /* optional float outline */ 19:
                    message.outline = reader.float();
                    break;
                case /* optional bool shadow_null */ 20:
                    message.shadowNull = reader.bool();
                    break;
                case /* optional TSD.ShadowArchive shadow */ 21:
                    message.shadow = TSDArchives_5.ShadowArchive.internalBinaryRead(reader, reader.uint32(), options, message.shadow);
                    break;
                case /* optional bool strikethru_color_null */ 22:
                    message.strikethruColorNull = reader.bool();
                    break;
                case /* optional TSP.Color strikethru_color */ 23:
                    message.strikethruColor = TSPMessages_4.Color.internalBinaryRead(reader, reader.uint32(), options, message.strikethruColor);
                    break;
                case /* optional float strikethru_width */ 24:
                    message.strikethruWidth = reader.float();
                    break;
                case /* optional bool background_color_null */ 25:
                    message.backgroundColorNull = reader.bool();
                    break;
                case /* optional TSP.Color background_color */ 26:
                    message.backgroundColor = TSPMessages_4.Color.internalBinaryRead(reader, reader.uint32(), options, message.backgroundColor);
                    break;
                case /* optional float tracking */ 27:
                    message.tracking = reader.float();
                    break;
                case /* optional bool underline_color_null */ 28:
                    message.underlineColorNull = reader.bool();
                    break;
                case /* optional TSP.Color underline_color */ 29:
                    message.underlineColor = TSPMessages_4.Color.internalBinaryRead(reader, reader.uint32(), options, message.underlineColor);
                    break;
                case /* optional float underline_width */ 30:
                    message.underlineWidth = reader.float();
                    break;
                case /* optional bool word_strikethru */ 31:
                    message.wordStrikethru = reader.bool();
                    break;
                case /* optional bool word_underline */ 32:
                    message.wordUnderline = reader.bool();
                    break;
                case /* optional bool font_features_null */ 33:
                    message.fontFeaturesNull = reader.bool();
                    break;
                case /* repeated TSWP.FontFeatureArchive font_features */ 34:
                    message.fontFeatures.push(exports.FontFeatureArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSWP.WritingDirectionType writing_direction */ 35:
                    message.writingDirection = reader.int32();
                    break;
                case /* optional bool emphasis_marks_null */ 36:
                    message.emphasisMarksNull = reader.bool();
                    break;
                case /* optional string emphasis_marks */ 37:
                    message.emphasisMarks = reader.string();
                    break;
                case /* optional bool compatibility_font_name_null */ 38:
                    message.compatibilityFontNameNull = reader.bool();
                    break;
                case /* optional string compatibility_font_name */ 39:
                    message.compatibilityFontName = reader.string();
                    break;
                case /* optional bool is_named_point_size */ 40:
                    message.isNamedPointSize = reader.bool();
                    break;
                case /* optional bool capitalization_uses_linguistics */ 41:
                    message.capitalizationUsesLinguistics = reader.bool();
                    break;
                case /* optional bool tate_chu_yoko */ 42:
                    message.tateChuYoko = reader.bool();
                    break;
                case /* optional bool tsd_stroke_null */ 43:
                    message.tsdStrokeNull = reader.bool();
                    break;
                case /* optional TSD.StrokeArchive tsd_stroke */ 44:
                    message.tsdStroke = TSDArchives_4.StrokeArchive.internalBinaryRead(reader, reader.uint32(), options, message.tsdStroke);
                    break;
                case /* optional bool tsd_fill_null */ 45:
                    message.tsdFillNull = reader.bool();
                    break;
                case /* optional TSD.FillArchive tsd_fill */ 46:
                    message.tsdFill = TSDArchives_3.FillArchive.internalBinaryRead(reader, reader.uint32(), options, message.tsdFill);
                    break;
                case /* optional bool tsd_fill_should_fill_text_container */ 47:
                    message.tsdFillShouldFillTextContainer = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional bool bold = 1; */
        if (message.bold !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.bold);
        /* optional bool italic = 2; */
        if (message.italic !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.italic);
        /* optional float font_size = 3; */
        if (message.fontSize !== undefined)
            writer.tag(3, runtime_1.WireType.Bit32).float(message.fontSize);
        /* optional bool font_name_null = 4; */
        if (message.fontNameNull !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.fontNameNull);
        /* optional string font_name = 5; */
        if (message.fontName !== undefined)
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.fontName);
        /* optional bool font_color_null = 6; */
        if (message.fontColorNull !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.fontColorNull);
        /* optional TSP.Color font_color = 7; */
        if (message.fontColor)
            TSPMessages_4.Color.internalBinaryWrite(message.fontColor, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool language_null = 8; */
        if (message.languageNull !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.languageNull);
        /* optional string language = 9; */
        if (message.language !== undefined)
            writer.tag(9, runtime_1.WireType.LengthDelimited).string(message.language);
        /* optional TSWP.CharacterStylePropertiesArchive.SuperscriptType superscript = 10; */
        if (message.superscript !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).int32(message.superscript);
        /* optional TSWP.CharacterStylePropertiesArchive.UnderlineType underline = 11; */
        if (message.underline !== undefined)
            writer.tag(11, runtime_1.WireType.Varint).int32(message.underline);
        /* optional TSWP.CharacterStylePropertiesArchive.StrikethruType strikethru = 12; */
        if (message.strikethru !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).int32(message.strikethru);
        /* optional TSWP.CharacterStylePropertiesArchive.CapitalizationType capitalization = 13; */
        if (message.capitalization !== undefined)
            writer.tag(13, runtime_1.WireType.Varint).int32(message.capitalization);
        /* optional float baseline_shift = 14; */
        if (message.baselineShift !== undefined)
            writer.tag(14, runtime_1.WireType.Bit32).float(message.baselineShift);
        /* optional float kerning = 15; */
        if (message.kerning !== undefined)
            writer.tag(15, runtime_1.WireType.Bit32).float(message.kerning);
        /* optional TSWP.CharacterStylePropertiesArchive.LigaturesType ligatures = 16; */
        if (message.ligatures !== undefined)
            writer.tag(16, runtime_1.WireType.Varint).int32(message.ligatures);
        /* optional bool outline_color_null = 17; */
        if (message.outlineColorNull !== undefined)
            writer.tag(17, runtime_1.WireType.Varint).bool(message.outlineColorNull);
        /* optional TSP.Color outline_color = 18; */
        if (message.outlineColor)
            TSPMessages_4.Color.internalBinaryWrite(message.outlineColor, writer.tag(18, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional float outline = 19; */
        if (message.outline !== undefined)
            writer.tag(19, runtime_1.WireType.Bit32).float(message.outline);
        /* optional bool shadow_null = 20; */
        if (message.shadowNull !== undefined)
            writer.tag(20, runtime_1.WireType.Varint).bool(message.shadowNull);
        /* optional TSD.ShadowArchive shadow = 21; */
        if (message.shadow)
            TSDArchives_5.ShadowArchive.internalBinaryWrite(message.shadow, writer.tag(21, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool strikethru_color_null = 22; */
        if (message.strikethruColorNull !== undefined)
            writer.tag(22, runtime_1.WireType.Varint).bool(message.strikethruColorNull);
        /* optional TSP.Color strikethru_color = 23; */
        if (message.strikethruColor)
            TSPMessages_4.Color.internalBinaryWrite(message.strikethruColor, writer.tag(23, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional float strikethru_width = 24; */
        if (message.strikethruWidth !== undefined)
            writer.tag(24, runtime_1.WireType.Bit32).float(message.strikethruWidth);
        /* optional bool background_color_null = 25; */
        if (message.backgroundColorNull !== undefined)
            writer.tag(25, runtime_1.WireType.Varint).bool(message.backgroundColorNull);
        /* optional TSP.Color background_color = 26; */
        if (message.backgroundColor)
            TSPMessages_4.Color.internalBinaryWrite(message.backgroundColor, writer.tag(26, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional float tracking = 27; */
        if (message.tracking !== undefined)
            writer.tag(27, runtime_1.WireType.Bit32).float(message.tracking);
        /* optional bool underline_color_null = 28; */
        if (message.underlineColorNull !== undefined)
            writer.tag(28, runtime_1.WireType.Varint).bool(message.underlineColorNull);
        /* optional TSP.Color underline_color = 29; */
        if (message.underlineColor)
            TSPMessages_4.Color.internalBinaryWrite(message.underlineColor, writer.tag(29, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional float underline_width = 30; */
        if (message.underlineWidth !== undefined)
            writer.tag(30, runtime_1.WireType.Bit32).float(message.underlineWidth);
        /* optional bool word_strikethru = 31; */
        if (message.wordStrikethru !== undefined)
            writer.tag(31, runtime_1.WireType.Varint).bool(message.wordStrikethru);
        /* optional bool word_underline = 32; */
        if (message.wordUnderline !== undefined)
            writer.tag(32, runtime_1.WireType.Varint).bool(message.wordUnderline);
        /* optional bool font_features_null = 33; */
        if (message.fontFeaturesNull !== undefined)
            writer.tag(33, runtime_1.WireType.Varint).bool(message.fontFeaturesNull);
        /* repeated TSWP.FontFeatureArchive font_features = 34; */
        for (let i = 0; i < message.fontFeatures.length; i++)
            exports.FontFeatureArchive.internalBinaryWrite(message.fontFeatures[i], writer.tag(34, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.WritingDirectionType writing_direction = 35; */
        if (message.writingDirection !== undefined)
            writer.tag(35, runtime_1.WireType.Varint).int32(message.writingDirection);
        /* optional bool emphasis_marks_null = 36; */
        if (message.emphasisMarksNull !== undefined)
            writer.tag(36, runtime_1.WireType.Varint).bool(message.emphasisMarksNull);
        /* optional string emphasis_marks = 37; */
        if (message.emphasisMarks !== undefined)
            writer.tag(37, runtime_1.WireType.LengthDelimited).string(message.emphasisMarks);
        /* optional bool compatibility_font_name_null = 38; */
        if (message.compatibilityFontNameNull !== undefined)
            writer.tag(38, runtime_1.WireType.Varint).bool(message.compatibilityFontNameNull);
        /* optional string compatibility_font_name = 39; */
        if (message.compatibilityFontName !== undefined)
            writer.tag(39, runtime_1.WireType.LengthDelimited).string(message.compatibilityFontName);
        /* optional bool is_named_point_size = 40; */
        if (message.isNamedPointSize !== undefined)
            writer.tag(40, runtime_1.WireType.Varint).bool(message.isNamedPointSize);
        /* optional bool capitalization_uses_linguistics = 41; */
        if (message.capitalizationUsesLinguistics !== undefined)
            writer.tag(41, runtime_1.WireType.Varint).bool(message.capitalizationUsesLinguistics);
        /* optional bool tate_chu_yoko = 42; */
        if (message.tateChuYoko !== undefined)
            writer.tag(42, runtime_1.WireType.Varint).bool(message.tateChuYoko);
        /* optional bool tsd_stroke_null = 43; */
        if (message.tsdStrokeNull !== undefined)
            writer.tag(43, runtime_1.WireType.Varint).bool(message.tsdStrokeNull);
        /* optional TSD.StrokeArchive tsd_stroke = 44; */
        if (message.tsdStroke)
            TSDArchives_4.StrokeArchive.internalBinaryWrite(message.tsdStroke, writer.tag(44, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool tsd_fill_null = 45; */
        if (message.tsdFillNull !== undefined)
            writer.tag(45, runtime_1.WireType.Varint).bool(message.tsdFillNull);
        /* optional TSD.FillArchive tsd_fill = 46; */
        if (message.tsdFill)
            TSDArchives_3.FillArchive.internalBinaryWrite(message.tsdFill, writer.tag(46, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool tsd_fill_should_fill_text_container = 47; */
        if (message.tsdFillShouldFillTextContainer !== undefined)
            writer.tag(47, runtime_1.WireType.Varint).bool(message.tsdFillShouldFillTextContainer);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.CharacterStylePropertiesArchive
 */
exports.CharacterStylePropertiesArchive = new CharacterStylePropertiesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CharacterStyleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.CharacterStyleArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSSArchives_1.StyleArchive },
            { no: 10, name: "override_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "char_properties", kind: "message", T: () => exports.CharacterStylePropertiesArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSS.StyleArchive super */ 1:
                    message.super = TSSArchives_1.StyleArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional uint32 override_count */ 10:
                    message.overrideCount = reader.uint32();
                    break;
                case /* optional TSWP.CharacterStylePropertiesArchive char_properties */ 11:
                    message.charProperties = exports.CharacterStylePropertiesArchive.internalBinaryRead(reader, reader.uint32(), options, message.charProperties);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSS.StyleArchive super = 1; */
        if (message.super)
            TSSArchives_1.StyleArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 override_count = 10; */
        if (message.overrideCount !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).uint32(message.overrideCount);
        /* optional TSWP.CharacterStylePropertiesArchive char_properties = 11; */
        if (message.charProperties)
            exports.CharacterStylePropertiesArchive.internalBinaryWrite(message.charProperties, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.CharacterStyleArchive
 */
exports.CharacterStyleArchive = new CharacterStyleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TabArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.TabArchive", [
            { no: 1, name: "position", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "alignment", kind: "enum", opt: true, T: () => ["TSWP.TabArchive.TabAlignmentType", TabArchive_TabAlignmentType] },
            { no: 3, name: "leader", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float position */ 1:
                    message.position = reader.float();
                    break;
                case /* optional TSWP.TabArchive.TabAlignmentType alignment */ 2:
                    message.alignment = reader.int32();
                    break;
                case /* optional string leader */ 3:
                    message.leader = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional float position = 1; */
        if (message.position !== undefined)
            writer.tag(1, runtime_1.WireType.Bit32).float(message.position);
        /* optional TSWP.TabArchive.TabAlignmentType alignment = 2; */
        if (message.alignment !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.alignment);
        /* optional string leader = 3; */
        if (message.leader !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.leader);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.TabArchive
 */
exports.TabArchive = new TabArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TabsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.TabsArchive", [
            { no: 1, name: "tabs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.TabArchive }
        ]);
    }
    create(value) {
        const message = { tabs: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSWP.TabArchive tabs */ 1:
                    message.tabs.push(exports.TabArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSWP.TabArchive tabs = 1; */
        for (let i = 0; i < message.tabs.length; i++)
            exports.TabArchive.internalBinaryWrite(message.tabs[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.TabsArchive
 */
exports.TabsArchive = new TabsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LineSpacingArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.LineSpacingArchive", [
            { no: 1, name: "mode", kind: "enum", opt: true, T: () => ["TSWP.LineSpacingArchive.LineSpacingModeType", LineSpacingArchive_LineSpacingModeType] },
            { no: 2, name: "amount", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "baselineRule", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.LineSpacingArchive.LineSpacingModeType mode */ 1:
                    message.mode = reader.int32();
                    break;
                case /* optional float amount */ 2:
                    message.amount = reader.float();
                    break;
                case /* optional float baselineRule */ 3:
                    message.baselineRule = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.LineSpacingArchive.LineSpacingModeType mode = 1; */
        if (message.mode !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.mode);
        /* optional float amount = 2; */
        if (message.amount !== undefined)
            writer.tag(2, runtime_1.WireType.Bit32).float(message.amount);
        /* optional float baselineRule = 3; */
        if (message.baselineRule !== undefined)
            writer.tag(3, runtime_1.WireType.Bit32).float(message.baselineRule);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.LineSpacingArchive
 */
exports.LineSpacingArchive = new LineSpacingArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ParagraphStylePropertiesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ParagraphStylePropertiesArchive", [
            { no: 1, name: "alignment", kind: "enum", opt: true, T: () => ["TSWP.ParagraphStylePropertiesArchive.TextAlignmentType", ParagraphStylePropertiesArchive_TextAlignmentType] },
            { no: 2, name: "decimal_tab_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "decimal_tab", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "default_tab_stops", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "fill_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "fill", kind: "message", T: () => TSPMessages_4.Color },
            { no: 7, name: "first_line_indent", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "hyphenate", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "keep_lines_together", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "keep_with_next", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "left_indent", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "line_spacing_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "line_spacing", kind: "message", T: () => exports.LineSpacingArchive },
            { no: 14, name: "page_break_before", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "borders", kind: "enum", opt: true, T: () => ["TSWP.ParagraphStylePropertiesArchive.ParagraphBorderType", ParagraphStylePropertiesArchive_ParagraphBorderType] },
            { no: 16, name: "rule_offset_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "rule_offset", kind: "message", T: () => TSPMessages_3.Point },
            { no: 18, name: "rule_width", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 19, name: "right_indent", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 20, name: "space_after", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 21, name: "space_before", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 24, name: "tabs_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 25, name: "tabs", kind: "message", T: () => exports.TabsArchive },
            { no: 26, name: "widow_control", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 27, name: "outline_level", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 28, name: "outline_style", kind: "enum", opt: true, T: () => ["TSWP.ParagraphStylePropertiesArchive.OutlineStyleType", ParagraphStylePropertiesArchive_OutlineStyleType] },
            { no: 29, name: "following_style_id_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 30, name: "following_style_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 31, name: "stroke_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 32, name: "stroke", kind: "message", T: () => TSDArchives_4.StrokeArchive },
            { no: 33, name: "show_in_toc", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 34, name: "toc_style_id_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 35, name: "toc_style_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 38, name: "writing_direction", kind: "enum", opt: true, T: () => ["TSWP.WritingDirectionType", WritingDirectionType] },
            { no: 39, name: "list_style_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 40, name: "list_style", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 41, name: "following_style_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 42, name: "following_style", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 43, name: "show_in_bookmarks_list", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 44, name: "show_in_toc_navigator", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.ParagraphStylePropertiesArchive.TextAlignmentType alignment */ 1:
                    message.alignment = reader.int32();
                    break;
                case /* optional bool decimal_tab_null */ 2:
                    message.decimalTabNull = reader.bool();
                    break;
                case /* optional string decimal_tab */ 3:
                    message.decimalTab = reader.string();
                    break;
                case /* optional float default_tab_stops */ 4:
                    message.defaultTabStops = reader.float();
                    break;
                case /* optional bool fill_null */ 5:
                    message.fillNull = reader.bool();
                    break;
                case /* optional TSP.Color fill */ 6:
                    message.fill = TSPMessages_4.Color.internalBinaryRead(reader, reader.uint32(), options, message.fill);
                    break;
                case /* optional float first_line_indent */ 7:
                    message.firstLineIndent = reader.float();
                    break;
                case /* optional bool hyphenate */ 8:
                    message.hyphenate = reader.bool();
                    break;
                case /* optional bool keep_lines_together */ 9:
                    message.keepLinesTogether = reader.bool();
                    break;
                case /* optional bool keep_with_next */ 10:
                    message.keepWithNext = reader.bool();
                    break;
                case /* optional float left_indent */ 11:
                    message.leftIndent = reader.float();
                    break;
                case /* optional bool line_spacing_null */ 12:
                    message.lineSpacingNull = reader.bool();
                    break;
                case /* optional TSWP.LineSpacingArchive line_spacing */ 13:
                    message.lineSpacing = exports.LineSpacingArchive.internalBinaryRead(reader, reader.uint32(), options, message.lineSpacing);
                    break;
                case /* optional bool page_break_before */ 14:
                    message.pageBreakBefore = reader.bool();
                    break;
                case /* optional TSWP.ParagraphStylePropertiesArchive.ParagraphBorderType borders */ 15:
                    message.borders = reader.int32();
                    break;
                case /* optional bool rule_offset_null */ 16:
                    message.ruleOffsetNull = reader.bool();
                    break;
                case /* optional TSP.Point rule_offset */ 17:
                    message.ruleOffset = TSPMessages_3.Point.internalBinaryRead(reader, reader.uint32(), options, message.ruleOffset);
                    break;
                case /* optional float rule_width */ 18:
                    message.ruleWidth = reader.float();
                    break;
                case /* optional float right_indent */ 19:
                    message.rightIndent = reader.float();
                    break;
                case /* optional float space_after */ 20:
                    message.spaceAfter = reader.float();
                    break;
                case /* optional float space_before */ 21:
                    message.spaceBefore = reader.float();
                    break;
                case /* optional bool tabs_null */ 24:
                    message.tabsNull = reader.bool();
                    break;
                case /* optional TSWP.TabsArchive tabs */ 25:
                    message.tabs = exports.TabsArchive.internalBinaryRead(reader, reader.uint32(), options, message.tabs);
                    break;
                case /* optional bool widow_control */ 26:
                    message.widowControl = reader.bool();
                    break;
                case /* optional uint32 outline_level */ 27:
                    message.outlineLevel = reader.uint32();
                    break;
                case /* optional TSWP.ParagraphStylePropertiesArchive.OutlineStyleType outline_style */ 28:
                    message.outlineStyle = reader.int32();
                    break;
                case /* optional bool following_style_id_null */ 29:
                    message.followingStyleIdNull = reader.bool();
                    break;
                case /* optional string following_style_id */ 30:
                    message.followingStyleId = reader.string();
                    break;
                case /* optional bool stroke_null */ 31:
                    message.strokeNull = reader.bool();
                    break;
                case /* optional TSD.StrokeArchive stroke */ 32:
                    message.stroke = TSDArchives_4.StrokeArchive.internalBinaryRead(reader, reader.uint32(), options, message.stroke);
                    break;
                case /* optional bool show_in_toc */ 33:
                    message.showInToc = reader.bool();
                    break;
                case /* optional bool toc_style_id_null */ 34:
                    message.tocStyleIdNull = reader.bool();
                    break;
                case /* optional string toc_style_id */ 35:
                    message.tocStyleId = reader.string();
                    break;
                case /* optional TSWP.WritingDirectionType writing_direction */ 38:
                    message.writingDirection = reader.int32();
                    break;
                case /* optional bool list_style_null */ 39:
                    message.listStyleNull = reader.bool();
                    break;
                case /* optional TSP.Reference list_style */ 40:
                    message.listStyle = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.listStyle);
                    break;
                case /* optional bool following_style_null */ 41:
                    message.followingStyleNull = reader.bool();
                    break;
                case /* optional TSP.Reference following_style */ 42:
                    message.followingStyle = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.followingStyle);
                    break;
                case /* optional bool show_in_bookmarks_list */ 43:
                    message.showInBookmarksList = reader.bool();
                    break;
                case /* optional bool show_in_toc_navigator */ 44:
                    message.showInTocNavigator = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.ParagraphStylePropertiesArchive.TextAlignmentType alignment = 1; */
        if (message.alignment !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.alignment);
        /* optional bool decimal_tab_null = 2; */
        if (message.decimalTabNull !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.decimalTabNull);
        /* optional string decimal_tab = 3; */
        if (message.decimalTab !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.decimalTab);
        /* optional float default_tab_stops = 4; */
        if (message.defaultTabStops !== undefined)
            writer.tag(4, runtime_1.WireType.Bit32).float(message.defaultTabStops);
        /* optional bool fill_null = 5; */
        if (message.fillNull !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.fillNull);
        /* optional TSP.Color fill = 6; */
        if (message.fill)
            TSPMessages_4.Color.internalBinaryWrite(message.fill, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional float first_line_indent = 7; */
        if (message.firstLineIndent !== undefined)
            writer.tag(7, runtime_1.WireType.Bit32).float(message.firstLineIndent);
        /* optional bool hyphenate = 8; */
        if (message.hyphenate !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.hyphenate);
        /* optional bool keep_lines_together = 9; */
        if (message.keepLinesTogether !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).bool(message.keepLinesTogether);
        /* optional bool keep_with_next = 10; */
        if (message.keepWithNext !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).bool(message.keepWithNext);
        /* optional float left_indent = 11; */
        if (message.leftIndent !== undefined)
            writer.tag(11, runtime_1.WireType.Bit32).float(message.leftIndent);
        /* optional bool line_spacing_null = 12; */
        if (message.lineSpacingNull !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).bool(message.lineSpacingNull);
        /* optional TSWP.LineSpacingArchive line_spacing = 13; */
        if (message.lineSpacing)
            exports.LineSpacingArchive.internalBinaryWrite(message.lineSpacing, writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool page_break_before = 14; */
        if (message.pageBreakBefore !== undefined)
            writer.tag(14, runtime_1.WireType.Varint).bool(message.pageBreakBefore);
        /* optional TSWP.ParagraphStylePropertiesArchive.ParagraphBorderType borders = 15; */
        if (message.borders !== undefined)
            writer.tag(15, runtime_1.WireType.Varint).int32(message.borders);
        /* optional bool rule_offset_null = 16; */
        if (message.ruleOffsetNull !== undefined)
            writer.tag(16, runtime_1.WireType.Varint).bool(message.ruleOffsetNull);
        /* optional TSP.Point rule_offset = 17; */
        if (message.ruleOffset)
            TSPMessages_3.Point.internalBinaryWrite(message.ruleOffset, writer.tag(17, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional float rule_width = 18; */
        if (message.ruleWidth !== undefined)
            writer.tag(18, runtime_1.WireType.Bit32).float(message.ruleWidth);
        /* optional float right_indent = 19; */
        if (message.rightIndent !== undefined)
            writer.tag(19, runtime_1.WireType.Bit32).float(message.rightIndent);
        /* optional float space_after = 20; */
        if (message.spaceAfter !== undefined)
            writer.tag(20, runtime_1.WireType.Bit32).float(message.spaceAfter);
        /* optional float space_before = 21; */
        if (message.spaceBefore !== undefined)
            writer.tag(21, runtime_1.WireType.Bit32).float(message.spaceBefore);
        /* optional bool tabs_null = 24; */
        if (message.tabsNull !== undefined)
            writer.tag(24, runtime_1.WireType.Varint).bool(message.tabsNull);
        /* optional TSWP.TabsArchive tabs = 25; */
        if (message.tabs)
            exports.TabsArchive.internalBinaryWrite(message.tabs, writer.tag(25, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool widow_control = 26; */
        if (message.widowControl !== undefined)
            writer.tag(26, runtime_1.WireType.Varint).bool(message.widowControl);
        /* optional uint32 outline_level = 27; */
        if (message.outlineLevel !== undefined)
            writer.tag(27, runtime_1.WireType.Varint).uint32(message.outlineLevel);
        /* optional TSWP.ParagraphStylePropertiesArchive.OutlineStyleType outline_style = 28; */
        if (message.outlineStyle !== undefined)
            writer.tag(28, runtime_1.WireType.Varint).int32(message.outlineStyle);
        /* optional bool following_style_id_null = 29; */
        if (message.followingStyleIdNull !== undefined)
            writer.tag(29, runtime_1.WireType.Varint).bool(message.followingStyleIdNull);
        /* optional string following_style_id = 30; */
        if (message.followingStyleId !== undefined)
            writer.tag(30, runtime_1.WireType.LengthDelimited).string(message.followingStyleId);
        /* optional bool stroke_null = 31; */
        if (message.strokeNull !== undefined)
            writer.tag(31, runtime_1.WireType.Varint).bool(message.strokeNull);
        /* optional TSD.StrokeArchive stroke = 32; */
        if (message.stroke)
            TSDArchives_4.StrokeArchive.internalBinaryWrite(message.stroke, writer.tag(32, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool show_in_toc = 33; */
        if (message.showInToc !== undefined)
            writer.tag(33, runtime_1.WireType.Varint).bool(message.showInToc);
        /* optional bool toc_style_id_null = 34; */
        if (message.tocStyleIdNull !== undefined)
            writer.tag(34, runtime_1.WireType.Varint).bool(message.tocStyleIdNull);
        /* optional string toc_style_id = 35; */
        if (message.tocStyleId !== undefined)
            writer.tag(35, runtime_1.WireType.LengthDelimited).string(message.tocStyleId);
        /* optional TSWP.WritingDirectionType writing_direction = 38; */
        if (message.writingDirection !== undefined)
            writer.tag(38, runtime_1.WireType.Varint).int32(message.writingDirection);
        /* optional bool list_style_null = 39; */
        if (message.listStyleNull !== undefined)
            writer.tag(39, runtime_1.WireType.Varint).bool(message.listStyleNull);
        /* optional TSP.Reference list_style = 40; */
        if (message.listStyle)
            TSPMessages_5.Reference.internalBinaryWrite(message.listStyle, writer.tag(40, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool following_style_null = 41; */
        if (message.followingStyleNull !== undefined)
            writer.tag(41, runtime_1.WireType.Varint).bool(message.followingStyleNull);
        /* optional TSP.Reference following_style = 42; */
        if (message.followingStyle)
            TSPMessages_5.Reference.internalBinaryWrite(message.followingStyle, writer.tag(42, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool show_in_bookmarks_list = 43; */
        if (message.showInBookmarksList !== undefined)
            writer.tag(43, runtime_1.WireType.Varint).bool(message.showInBookmarksList);
        /* optional bool show_in_toc_navigator = 44; */
        if (message.showInTocNavigator !== undefined)
            writer.tag(44, runtime_1.WireType.Varint).bool(message.showInTocNavigator);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ParagraphStylePropertiesArchive
 */
exports.ParagraphStylePropertiesArchive = new ParagraphStylePropertiesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ParagraphStyleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ParagraphStyleArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSSArchives_1.StyleArchive },
            { no: 10, name: "override_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "char_properties", kind: "message", T: () => exports.CharacterStylePropertiesArchive },
            { no: 12, name: "para_properties", kind: "message", T: () => exports.ParagraphStylePropertiesArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSS.StyleArchive super */ 1:
                    message.super = TSSArchives_1.StyleArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional uint32 override_count */ 10:
                    message.overrideCount = reader.uint32();
                    break;
                case /* optional TSWP.CharacterStylePropertiesArchive char_properties */ 11:
                    message.charProperties = exports.CharacterStylePropertiesArchive.internalBinaryRead(reader, reader.uint32(), options, message.charProperties);
                    break;
                case /* optional TSWP.ParagraphStylePropertiesArchive para_properties */ 12:
                    message.paraProperties = exports.ParagraphStylePropertiesArchive.internalBinaryRead(reader, reader.uint32(), options, message.paraProperties);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSS.StyleArchive super = 1; */
        if (message.super)
            TSSArchives_1.StyleArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 override_count = 10; */
        if (message.overrideCount !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).uint32(message.overrideCount);
        /* optional TSWP.CharacterStylePropertiesArchive char_properties = 11; */
        if (message.charProperties)
            exports.CharacterStylePropertiesArchive.internalBinaryWrite(message.charProperties, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.ParagraphStylePropertiesArchive para_properties = 12; */
        if (message.paraProperties)
            exports.ParagraphStylePropertiesArchive.internalBinaryWrite(message.paraProperties, writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ParagraphStyleArchive
 */
exports.ParagraphStyleArchive = new ParagraphStyleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListStyleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ListStyleArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSSArchives_1.StyleArchive },
            { no: 10, name: "override_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "label_types", kind: "enum", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ["TSWP.ListStyleArchive.LabelType", ListStyleArchive_LabelType] },
            { no: 12, name: "text_indents", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 13, name: "indents", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 14, name: "geometries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ListStyleArchive_LabelGeometry },
            { no: 15, name: "number_types", kind: "enum", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ["TSWP.ListStyleArchive.NumberType", ListStyleArchive_NumberType] },
            { no: 16, name: "strings", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "images", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ListStyleArchive_LabelImage },
            { no: 18, name: "shadow_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "shadow", kind: "message", T: () => TSDArchives_5.ShadowArchive },
            { no: 20, name: "font_color_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "font_color", kind: "message", T: () => TSPMessages_4.Color },
            { no: 22, name: "font_name_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 23, name: "font_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 24, name: "writing_direction", kind: "enum", opt: true, T: () => ["TSWP.WritingDirectionType", WritingDirectionType] },
            { no: 25, name: "tiered_numbers", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { labelTypes: [], textIndents: [], indents: [], geometries: [], numberTypes: [], strings: [], images: [], tieredNumbers: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSS.StyleArchive super */ 1:
                    message.super = TSSArchives_1.StyleArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional uint32 override_count */ 10:
                    message.overrideCount = reader.uint32();
                    break;
                case /* repeated TSWP.ListStyleArchive.LabelType label_types */ 11:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.labelTypes.push(reader.int32());
                    else
                        message.labelTypes.push(reader.int32());
                    break;
                case /* repeated float text_indents */ 12:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.textIndents.push(reader.float());
                    else
                        message.textIndents.push(reader.float());
                    break;
                case /* repeated float indents */ 13:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.indents.push(reader.float());
                    else
                        message.indents.push(reader.float());
                    break;
                case /* repeated TSWP.ListStyleArchive.LabelGeometry geometries */ 14:
                    message.geometries.push(exports.ListStyleArchive_LabelGeometry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSWP.ListStyleArchive.NumberType number_types */ 15:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.numberTypes.push(reader.int32());
                    else
                        message.numberTypes.push(reader.int32());
                    break;
                case /* repeated string strings */ 16:
                    message.strings.push(reader.string());
                    break;
                case /* repeated TSWP.ListStyleArchive.LabelImage images */ 17:
                    message.images.push(exports.ListStyleArchive_LabelImage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool shadow_null */ 18:
                    message.shadowNull = reader.bool();
                    break;
                case /* optional TSD.ShadowArchive shadow */ 19:
                    message.shadow = TSDArchives_5.ShadowArchive.internalBinaryRead(reader, reader.uint32(), options, message.shadow);
                    break;
                case /* optional bool font_color_null */ 20:
                    message.fontColorNull = reader.bool();
                    break;
                case /* optional TSP.Color font_color */ 21:
                    message.fontColor = TSPMessages_4.Color.internalBinaryRead(reader, reader.uint32(), options, message.fontColor);
                    break;
                case /* optional bool font_name_null */ 22:
                    message.fontNameNull = reader.bool();
                    break;
                case /* optional string font_name */ 23:
                    message.fontName = reader.string();
                    break;
                case /* optional TSWP.WritingDirectionType writing_direction */ 24:
                    message.writingDirection = reader.int32();
                    break;
                case /* repeated bool tiered_numbers */ 25:
                    if (wireType === runtime_1.WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.tieredNumbers.push(reader.bool());
                    else
                        message.tieredNumbers.push(reader.bool());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSS.StyleArchive super = 1; */
        if (message.super)
            TSSArchives_1.StyleArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 override_count = 10; */
        if (message.overrideCount !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).uint32(message.overrideCount);
        /* repeated TSWP.ListStyleArchive.LabelType label_types = 11; */
        for (let i = 0; i < message.labelTypes.length; i++)
            writer.tag(11, runtime_1.WireType.Varint).int32(message.labelTypes[i]);
        /* repeated float text_indents = 12; */
        for (let i = 0; i < message.textIndents.length; i++)
            writer.tag(12, runtime_1.WireType.Bit32).float(message.textIndents[i]);
        /* repeated float indents = 13; */
        for (let i = 0; i < message.indents.length; i++)
            writer.tag(13, runtime_1.WireType.Bit32).float(message.indents[i]);
        /* repeated TSWP.ListStyleArchive.LabelGeometry geometries = 14; */
        for (let i = 0; i < message.geometries.length; i++)
            exports.ListStyleArchive_LabelGeometry.internalBinaryWrite(message.geometries[i], writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSWP.ListStyleArchive.NumberType number_types = 15; */
        for (let i = 0; i < message.numberTypes.length; i++)
            writer.tag(15, runtime_1.WireType.Varint).int32(message.numberTypes[i]);
        /* repeated string strings = 16; */
        for (let i = 0; i < message.strings.length; i++)
            writer.tag(16, runtime_1.WireType.LengthDelimited).string(message.strings[i]);
        /* repeated TSWP.ListStyleArchive.LabelImage images = 17; */
        for (let i = 0; i < message.images.length; i++)
            exports.ListStyleArchive_LabelImage.internalBinaryWrite(message.images[i], writer.tag(17, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool shadow_null = 18; */
        if (message.shadowNull !== undefined)
            writer.tag(18, runtime_1.WireType.Varint).bool(message.shadowNull);
        /* optional TSD.ShadowArchive shadow = 19; */
        if (message.shadow)
            TSDArchives_5.ShadowArchive.internalBinaryWrite(message.shadow, writer.tag(19, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool font_color_null = 20; */
        if (message.fontColorNull !== undefined)
            writer.tag(20, runtime_1.WireType.Varint).bool(message.fontColorNull);
        /* optional TSP.Color font_color = 21; */
        if (message.fontColor)
            TSPMessages_4.Color.internalBinaryWrite(message.fontColor, writer.tag(21, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool font_name_null = 22; */
        if (message.fontNameNull !== undefined)
            writer.tag(22, runtime_1.WireType.Varint).bool(message.fontNameNull);
        /* optional string font_name = 23; */
        if (message.fontName !== undefined)
            writer.tag(23, runtime_1.WireType.LengthDelimited).string(message.fontName);
        /* optional TSWP.WritingDirectionType writing_direction = 24; */
        if (message.writingDirection !== undefined)
            writer.tag(24, runtime_1.WireType.Varint).int32(message.writingDirection);
        /* repeated bool tiered_numbers = 25; */
        for (let i = 0; i < message.tieredNumbers.length; i++)
            writer.tag(25, runtime_1.WireType.Varint).bool(message.tieredNumbers[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ListStyleArchive
 */
exports.ListStyleArchive = new ListStyleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListStyleArchive_LabelGeometry$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ListStyleArchive.LabelGeometry", [
            { no: 1, name: "scale", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "baseline_offset", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "scale_with_text", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float scale */ 1:
                    message.scale = reader.float();
                    break;
                case /* optional float baseline_offset */ 2:
                    message.baselineOffset = reader.float();
                    break;
                case /* optional bool scale_with_text */ 3:
                    message.scaleWithText = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional float scale = 1; */
        if (message.scale !== undefined)
            writer.tag(1, runtime_1.WireType.Bit32).float(message.scale);
        /* optional float baseline_offset = 2; */
        if (message.baselineOffset !== undefined)
            writer.tag(2, runtime_1.WireType.Bit32).float(message.baselineOffset);
        /* optional bool scale_with_text = 3; */
        if (message.scaleWithText !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.scaleWithText);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ListStyleArchive.LabelGeometry
 */
exports.ListStyleArchive_LabelGeometry = new ListStyleArchive_LabelGeometry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListStyleArchive_LabelImage$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ListStyleArchive.LabelImage", [
            { no: 3, name: "image", kind: "message", T: () => TSPMessages_2.DataReference },
            { no: 2, name: "image_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 1, name: "database_image", kind: "message", T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.DataReference image */ 3:
                    message.image = TSPMessages_2.DataReference.internalBinaryRead(reader, reader.uint32(), options, message.image);
                    break;
                case /* optional bool image_null */ 2:
                    message.imageNull = reader.bool();
                    break;
                case /* optional TSP.Reference database_image */ 1:
                    message.databaseImage = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.databaseImage);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.DataReference image = 3; */
        if (message.image)
            TSPMessages_2.DataReference.internalBinaryWrite(message.image, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool image_null = 2; */
        if (message.imageNull !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.imageNull);
        /* optional TSP.Reference database_image = 1; */
        if (message.databaseImage)
            TSPMessages_5.Reference.internalBinaryWrite(message.databaseImage, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ListStyleArchive.LabelImage
 */
exports.ListStyleArchive_LabelImage = new ListStyleArchive_LabelImage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TextStylePresetArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.TextStylePresetArchive", [
            { no: 1, name: "preset_identifier", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "paragraph_style", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 3, name: "list_style", kind: "message", T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string preset_identifier */ 1:
                    message.presetIdentifier = reader.string();
                    break;
                case /* optional TSP.Reference paragraph_style */ 2:
                    message.paragraphStyle = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.paragraphStyle);
                    break;
                case /* optional TSP.Reference list_style */ 3:
                    message.listStyle = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.listStyle);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string preset_identifier = 1; */
        if (message.presetIdentifier !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.presetIdentifier);
        /* optional TSP.Reference paragraph_style = 2; */
        if (message.paragraphStyle)
            TSPMessages_5.Reference.internalBinaryWrite(message.paragraphStyle, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference list_style = 3; */
        if (message.listStyle)
            TSPMessages_5.Reference.internalBinaryWrite(message.listStyle, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.TextStylePresetArchive
 */
exports.TextStylePresetArchive = new TextStylePresetArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ColumnsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ColumnsArchive", [
            { no: 1, name: "equal_columns", kind: "message", T: () => exports.ColumnsArchive_EqualColumnsArchive },
            { no: 2, name: "non_equal_columns", kind: "message", T: () => exports.ColumnsArchive_NonEqualColumnsArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.ColumnsArchive.EqualColumnsArchive equal_columns */ 1:
                    message.equalColumns = exports.ColumnsArchive_EqualColumnsArchive.internalBinaryRead(reader, reader.uint32(), options, message.equalColumns);
                    break;
                case /* optional TSWP.ColumnsArchive.NonEqualColumnsArchive non_equal_columns */ 2:
                    message.nonEqualColumns = exports.ColumnsArchive_NonEqualColumnsArchive.internalBinaryRead(reader, reader.uint32(), options, message.nonEqualColumns);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.ColumnsArchive.EqualColumnsArchive equal_columns = 1; */
        if (message.equalColumns)
            exports.ColumnsArchive_EqualColumnsArchive.internalBinaryWrite(message.equalColumns, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.ColumnsArchive.NonEqualColumnsArchive non_equal_columns = 2; */
        if (message.nonEqualColumns)
            exports.ColumnsArchive_NonEqualColumnsArchive.internalBinaryWrite(message.nonEqualColumns, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ColumnsArchive
 */
exports.ColumnsArchive = new ColumnsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ColumnsArchive_EqualColumnsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ColumnsArchive.EqualColumnsArchive", [
            { no: 1, name: "count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "gap", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 count */ 1:
                    message.count = reader.uint32();
                    break;
                case /* optional float gap */ 2:
                    message.gap = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional uint32 count = 1; */
        if (message.count !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.count);
        /* optional float gap = 2; */
        if (message.gap !== undefined)
            writer.tag(2, runtime_1.WireType.Bit32).float(message.gap);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ColumnsArchive.EqualColumnsArchive
 */
exports.ColumnsArchive_EqualColumnsArchive = new ColumnsArchive_EqualColumnsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ColumnsArchive_NonEqualColumnsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ColumnsArchive.NonEqualColumnsArchive", [
            { no: 1, name: "first", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "following", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive }
        ]);
    }
    create(value) {
        const message = { first: 0, following: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float first */ 1:
                    message.first = reader.float();
                    break;
                case /* repeated TSWP.ColumnsArchive.NonEqualColumnsArchive.GapWidthArchive following */ 2:
                    message.following.push(exports.ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* float first = 1; */
        if (message.first !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).float(message.first);
        /* repeated TSWP.ColumnsArchive.NonEqualColumnsArchive.GapWidthArchive following = 2; */
        for (let i = 0; i < message.following.length; i++)
            exports.ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive.internalBinaryWrite(message.following[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ColumnsArchive.NonEqualColumnsArchive
 */
exports.ColumnsArchive_NonEqualColumnsArchive = new ColumnsArchive_NonEqualColumnsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ColumnsArchive.NonEqualColumnsArchive.GapWidthArchive", [
            { no: 1, name: "gap", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "width", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value) {
        const message = { gap: 0, width: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float gap */ 1:
                    message.gap = reader.float();
                    break;
                case /* float width */ 2:
                    message.width = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* float gap = 1; */
        if (message.gap !== 0)
            writer.tag(1, runtime_1.WireType.Bit32).float(message.gap);
        /* float width = 2; */
        if (message.width !== 0)
            writer.tag(2, runtime_1.WireType.Bit32).float(message.width);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ColumnsArchive.NonEqualColumnsArchive.GapWidthArchive
 */
exports.ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive = new ColumnsArchive_NonEqualColumnsArchive_GapWidthArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PaddingArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.PaddingArchive", [
            { no: 1, name: "left", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "top", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "right", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "bottom", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional float left */ 1:
                    message.left = reader.float();
                    break;
                case /* optional float top */ 2:
                    message.top = reader.float();
                    break;
                case /* optional float right */ 3:
                    message.right = reader.float();
                    break;
                case /* optional float bottom */ 4:
                    message.bottom = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional float left = 1; */
        if (message.left !== undefined)
            writer.tag(1, runtime_1.WireType.Bit32).float(message.left);
        /* optional float top = 2; */
        if (message.top !== undefined)
            writer.tag(2, runtime_1.WireType.Bit32).float(message.top);
        /* optional float right = 3; */
        if (message.right !== undefined)
            writer.tag(3, runtime_1.WireType.Bit32).float(message.right);
        /* optional float bottom = 4; */
        if (message.bottom !== undefined)
            writer.tag(4, runtime_1.WireType.Bit32).float(message.bottom);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.PaddingArchive
 */
exports.PaddingArchive = new PaddingArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ColumnStylePropertiesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ColumnStylePropertiesArchive", [
            { no: 1, name: "continuous", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "shrink_to_fit", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "vertical_text", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "min_horizontal_inset", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "vertical_alignment", kind: "enum", opt: true, T: () => ["TSWP.ColumnStylePropertiesArchive.VerticalAlignmentType", ColumnStylePropertiesArchive_VerticalAlignmentType] },
            { no: 6, name: "columns_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "columns", kind: "message", T: () => exports.ColumnsArchive },
            { no: 8, name: "margins_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "margins", kind: "message", T: () => exports.PaddingArchive },
            { no: 10, name: "padding_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "padding", kind: "message", T: () => exports.PaddingArchive },
            { no: 12, name: "writing_direction", kind: "enum", opt: true, T: () => ["TSWP.WritingDirectionType", WritingDirectionType] }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool continuous */ 1:
                    message.continuous = reader.bool();
                    break;
                case /* optional bool shrink_to_fit */ 2:
                    message.shrinkToFit = reader.bool();
                    break;
                case /* optional bool vertical_text */ 3:
                    message.verticalText = reader.bool();
                    break;
                case /* optional float min_horizontal_inset */ 4:
                    message.minHorizontalInset = reader.float();
                    break;
                case /* optional TSWP.ColumnStylePropertiesArchive.VerticalAlignmentType vertical_alignment */ 5:
                    message.verticalAlignment = reader.int32();
                    break;
                case /* optional bool columns_null */ 6:
                    message.columnsNull = reader.bool();
                    break;
                case /* optional TSWP.ColumnsArchive columns */ 7:
                    message.columns = exports.ColumnsArchive.internalBinaryRead(reader, reader.uint32(), options, message.columns);
                    break;
                case /* optional bool margins_null */ 8:
                    message.marginsNull = reader.bool();
                    break;
                case /* optional TSWP.PaddingArchive margins */ 9:
                    message.margins = exports.PaddingArchive.internalBinaryRead(reader, reader.uint32(), options, message.margins);
                    break;
                case /* optional bool padding_null */ 10:
                    message.paddingNull = reader.bool();
                    break;
                case /* optional TSWP.PaddingArchive padding */ 11:
                    message.padding = exports.PaddingArchive.internalBinaryRead(reader, reader.uint32(), options, message.padding);
                    break;
                case /* optional TSWP.WritingDirectionType writing_direction */ 12:
                    message.writingDirection = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional bool continuous = 1; */
        if (message.continuous !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.continuous);
        /* optional bool shrink_to_fit = 2; */
        if (message.shrinkToFit !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.shrinkToFit);
        /* optional bool vertical_text = 3; */
        if (message.verticalText !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.verticalText);
        /* optional float min_horizontal_inset = 4; */
        if (message.minHorizontalInset !== undefined)
            writer.tag(4, runtime_1.WireType.Bit32).float(message.minHorizontalInset);
        /* optional TSWP.ColumnStylePropertiesArchive.VerticalAlignmentType vertical_alignment = 5; */
        if (message.verticalAlignment !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).int32(message.verticalAlignment);
        /* optional bool columns_null = 6; */
        if (message.columnsNull !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.columnsNull);
        /* optional TSWP.ColumnsArchive columns = 7; */
        if (message.columns)
            exports.ColumnsArchive.internalBinaryWrite(message.columns, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool margins_null = 8; */
        if (message.marginsNull !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.marginsNull);
        /* optional TSWP.PaddingArchive margins = 9; */
        if (message.margins)
            exports.PaddingArchive.internalBinaryWrite(message.margins, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool padding_null = 10; */
        if (message.paddingNull !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).bool(message.paddingNull);
        /* optional TSWP.PaddingArchive padding = 11; */
        if (message.padding)
            exports.PaddingArchive.internalBinaryWrite(message.padding, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.WritingDirectionType writing_direction = 12; */
        if (message.writingDirection !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).int32(message.writingDirection);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ColumnStylePropertiesArchive
 */
exports.ColumnStylePropertiesArchive = new ColumnStylePropertiesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ColumnStyleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ColumnStyleArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSSArchives_1.StyleArchive },
            { no: 10, name: "override_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "column_properties", kind: "message", T: () => exports.ColumnStylePropertiesArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSS.StyleArchive super */ 1:
                    message.super = TSSArchives_1.StyleArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional uint32 override_count */ 10:
                    message.overrideCount = reader.uint32();
                    break;
                case /* optional TSWP.ColumnStylePropertiesArchive column_properties */ 11:
                    message.columnProperties = exports.ColumnStylePropertiesArchive.internalBinaryRead(reader, reader.uint32(), options, message.columnProperties);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSS.StyleArchive super = 1; */
        if (message.super)
            TSSArchives_1.StyleArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 override_count = 10; */
        if (message.overrideCount !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).uint32(message.overrideCount);
        /* optional TSWP.ColumnStylePropertiesArchive column_properties = 11; */
        if (message.columnProperties)
            exports.ColumnStylePropertiesArchive.internalBinaryWrite(message.columnProperties, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ColumnStyleArchive
 */
exports.ColumnStyleArchive = new ColumnStyleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShapeStylePropertiesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ShapeStylePropertiesArchive", [
            { no: 1, name: "shrink_to_fit", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "vertical_alignment", kind: "enum", opt: true, T: () => ["TSWP.ShapeStylePropertiesArchive.VerticalAlignmentType", ShapeStylePropertiesArchive_VerticalAlignmentType] },
            { no: 3, name: "columns_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "columns", kind: "message", T: () => exports.ColumnsArchive },
            { no: 5, name: "padding_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "padding", kind: "message", T: () => exports.PaddingArchive },
            { no: 7, name: "default_text_preset_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "vertical_text", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "paragraph_style_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "paragraph_style", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 11, name: "vertical_text_40", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool shrink_to_fit */ 1:
                    message.shrinkToFit = reader.bool();
                    break;
                case /* optional TSWP.ShapeStylePropertiesArchive.VerticalAlignmentType vertical_alignment */ 2:
                    message.verticalAlignment = reader.int32();
                    break;
                case /* optional bool columns_null */ 3:
                    message.columnsNull = reader.bool();
                    break;
                case /* optional TSWP.ColumnsArchive columns */ 4:
                    message.columns = exports.ColumnsArchive.internalBinaryRead(reader, reader.uint32(), options, message.columns);
                    break;
                case /* optional bool padding_null */ 5:
                    message.paddingNull = reader.bool();
                    break;
                case /* optional TSWP.PaddingArchive padding */ 6:
                    message.padding = exports.PaddingArchive.internalBinaryRead(reader, reader.uint32(), options, message.padding);
                    break;
                case /* optional uint32 default_text_preset_index */ 7:
                    message.defaultTextPresetIndex = reader.uint32();
                    break;
                case /* optional bool vertical_text */ 8:
                    message.verticalText = reader.bool();
                    break;
                case /* optional bool paragraph_style_null */ 9:
                    message.paragraphStyleNull = reader.bool();
                    break;
                case /* optional TSP.Reference paragraph_style */ 10:
                    message.paragraphStyle = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.paragraphStyle);
                    break;
                case /* optional bool vertical_text_40 */ 11:
                    message.verticalText40 = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional bool shrink_to_fit = 1; */
        if (message.shrinkToFit !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.shrinkToFit);
        /* optional TSWP.ShapeStylePropertiesArchive.VerticalAlignmentType vertical_alignment = 2; */
        if (message.verticalAlignment !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.verticalAlignment);
        /* optional bool columns_null = 3; */
        if (message.columnsNull !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.columnsNull);
        /* optional TSWP.ColumnsArchive columns = 4; */
        if (message.columns)
            exports.ColumnsArchive.internalBinaryWrite(message.columns, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool padding_null = 5; */
        if (message.paddingNull !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.paddingNull);
        /* optional TSWP.PaddingArchive padding = 6; */
        if (message.padding)
            exports.PaddingArchive.internalBinaryWrite(message.padding, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 default_text_preset_index = 7; */
        if (message.defaultTextPresetIndex !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).uint32(message.defaultTextPresetIndex);
        /* optional bool vertical_text = 8; */
        if (message.verticalText !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.verticalText);
        /* optional bool paragraph_style_null = 9; */
        if (message.paragraphStyleNull !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).bool(message.paragraphStyleNull);
        /* optional TSP.Reference paragraph_style = 10; */
        if (message.paragraphStyle)
            TSPMessages_5.Reference.internalBinaryWrite(message.paragraphStyle, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool vertical_text_40 = 11; */
        if (message.verticalText40 !== undefined)
            writer.tag(11, runtime_1.WireType.Varint).bool(message.verticalText40);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ShapeStylePropertiesArchive
 */
exports.ShapeStylePropertiesArchive = new ShapeStylePropertiesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShapeStyleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ShapeStyleArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSDArchives_2.ShapeStyleArchive },
            { no: 10, name: "override_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "shape_properties", kind: "message", T: () => exports.ShapeStylePropertiesArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.ShapeStyleArchive super */ 1:
                    message.super = TSDArchives_2.ShapeStyleArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional uint32 override_count */ 10:
                    message.overrideCount = reader.uint32();
                    break;
                case /* optional TSWP.ShapeStylePropertiesArchive shape_properties */ 11:
                    message.shapeProperties = exports.ShapeStylePropertiesArchive.internalBinaryRead(reader, reader.uint32(), options, message.shapeProperties);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.ShapeStyleArchive super = 1; */
        if (message.super)
            TSDArchives_2.ShapeStyleArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 override_count = 10; */
        if (message.overrideCount !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).uint32(message.overrideCount);
        /* optional TSWP.ShapeStylePropertiesArchive shape_properties = 11; */
        if (message.shapeProperties)
            exports.ShapeStylePropertiesArchive.internalBinaryWrite(message.shapeProperties, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ShapeStyleArchive
 */
exports.ShapeStyleArchive = new ShapeStyleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ThemePresetsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ThemePresetsArchive", [
            { no: 1, name: "list_style_presets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.Reference },
            { no: 2, name: "text_style_presets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.Reference },
            { no: 3, name: "imported_text_style_presets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.Reference },
            { no: 4, name: "toc_entry_style_presets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.Reference },
            { no: 5, name: "toc_settings_presets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.Reference },
            { no: 6, name: "character_style_presets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.Reference },
            { no: 7, name: "paragraph_style_presets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.Reference },
            { no: 8, name: "dropcap_style_presets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = { listStylePresets: [], textStylePresets: [], importedTextStylePresets: [], tocEntryStylePresets: [], tocSettingsPresets: [], characterStylePresets: [], paragraphStylePresets: [], dropcapStylePresets: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.Reference list_style_presets */ 1:
                    message.listStylePresets.push(TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference text_style_presets */ 2:
                    message.textStylePresets.push(TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference imported_text_style_presets */ 3:
                    message.importedTextStylePresets.push(TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference toc_entry_style_presets */ 4:
                    message.tocEntryStylePresets.push(TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference toc_settings_presets */ 5:
                    message.tocSettingsPresets.push(TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference character_style_presets */ 6:
                    message.characterStylePresets.push(TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference paragraph_style_presets */ 7:
                    message.paragraphStylePresets.push(TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference dropcap_style_presets */ 8:
                    message.dropcapStylePresets.push(TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.Reference list_style_presets = 1; */
        for (let i = 0; i < message.listStylePresets.length; i++)
            TSPMessages_5.Reference.internalBinaryWrite(message.listStylePresets[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference text_style_presets = 2; */
        for (let i = 0; i < message.textStylePresets.length; i++)
            TSPMessages_5.Reference.internalBinaryWrite(message.textStylePresets[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference imported_text_style_presets = 3; */
        for (let i = 0; i < message.importedTextStylePresets.length; i++)
            TSPMessages_5.Reference.internalBinaryWrite(message.importedTextStylePresets[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference toc_entry_style_presets = 4; */
        for (let i = 0; i < message.tocEntryStylePresets.length; i++)
            TSPMessages_5.Reference.internalBinaryWrite(message.tocEntryStylePresets[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference toc_settings_presets = 5; */
        for (let i = 0; i < message.tocSettingsPresets.length; i++)
            TSPMessages_5.Reference.internalBinaryWrite(message.tocSettingsPresets[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference character_style_presets = 6; */
        for (let i = 0; i < message.characterStylePresets.length; i++)
            TSPMessages_5.Reference.internalBinaryWrite(message.characterStylePresets[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference paragraph_style_presets = 7; */
        for (let i = 0; i < message.paragraphStylePresets.length; i++)
            TSPMessages_5.Reference.internalBinaryWrite(message.paragraphStylePresets[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference dropcap_style_presets = 8; */
        for (let i = 0; i < message.dropcapStylePresets.length; i++)
            TSPMessages_5.Reference.internalBinaryWrite(message.dropcapStylePresets[i], writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ThemePresetsArchive
 */
exports.ThemePresetsArchive = new ThemePresetsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TextPresetDisplayItemArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.TextPresetDisplayItemArchive", [
            { no: 1, name: "preset", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 2, name: "display_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { displayName: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.Reference preset */ 1:
                    message.preset = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.preset);
                    break;
                case /* string display_name */ 2:
                    message.displayName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.Reference preset = 1; */
        if (message.preset)
            TSPMessages_5.Reference.internalBinaryWrite(message.preset, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string display_name = 2; */
        if (message.displayName !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.displayName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.TextPresetDisplayItemArchive
 */
exports.TextPresetDisplayItemArchive = new TextPresetDisplayItemArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TOCEntryStylePropertiesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.TOCEntryStylePropertiesArchive", [
            { no: 1, name: "page_number_style_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "page_number_style", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 3, name: "show_page_number", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool page_number_style_null */ 1:
                    message.pageNumberStyleNull = reader.bool();
                    break;
                case /* optional TSP.Reference page_number_style */ 2:
                    message.pageNumberStyle = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.pageNumberStyle);
                    break;
                case /* optional bool show_page_number */ 3:
                    message.showPageNumber = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional bool page_number_style_null = 1; */
        if (message.pageNumberStyleNull !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.pageNumberStyleNull);
        /* optional TSP.Reference page_number_style = 2; */
        if (message.pageNumberStyle)
            TSPMessages_5.Reference.internalBinaryWrite(message.pageNumberStyle, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool show_page_number = 3; */
        if (message.showPageNumber !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.showPageNumber);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.TOCEntryStylePropertiesArchive
 */
exports.TOCEntryStylePropertiesArchive = new TOCEntryStylePropertiesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TOCEntryStyleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.TOCEntryStyleArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.ParagraphStyleArchive },
            { no: 2, name: "toc_properties", kind: "message", T: () => exports.TOCEntryStylePropertiesArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSWP.ParagraphStyleArchive super */ 1:
                    message.super = exports.ParagraphStyleArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSWP.TOCEntryStylePropertiesArchive toc_properties */ 2:
                    message.tocProperties = exports.TOCEntryStylePropertiesArchive.internalBinaryRead(reader, reader.uint32(), options, message.tocProperties);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSWP.ParagraphStyleArchive super = 1; */
        if (message.super)
            exports.ParagraphStyleArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.TOCEntryStylePropertiesArchive toc_properties = 2; */
        if (message.tocProperties)
            exports.TOCEntryStylePropertiesArchive.internalBinaryWrite(message.tocProperties, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.TOCEntryStyleArchive
 */
exports.TOCEntryStyleArchive = new TOCEntryStyleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TOCSettingsArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.TOCSettingsArchive", [
            { no: 1, name: "toc_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "toc_scope", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.TOCSettingsArchive_TOCEntryData }
        ]);
    }
    create(value) {
        const message = { entries: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string toc_name */ 1:
                    message.tocName = reader.string();
                    break;
                case /* optional uint32 toc_scope */ 2:
                    message.tocScope = reader.uint32();
                    break;
                case /* repeated TSWP.TOCSettingsArchive.TOCEntryData entries */ 3:
                    message.entries.push(exports.TOCSettingsArchive_TOCEntryData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string toc_name = 1; */
        if (message.tocName !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.tocName);
        /* optional uint32 toc_scope = 2; */
        if (message.tocScope !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.tocScope);
        /* repeated TSWP.TOCSettingsArchive.TOCEntryData entries = 3; */
        for (let i = 0; i < message.entries.length; i++)
            exports.TOCSettingsArchive_TOCEntryData.internalBinaryWrite(message.entries[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.TOCSettingsArchive
 */
exports.TOCSettingsArchive = new TOCSettingsArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TOCSettingsArchive_TOCEntryData$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.TOCSettingsArchive.TOCEntryData", [
            { no: 1, name: "paragraph_style", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 2, name: "toc_entry_style", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 3, name: "show_in_toc", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference paragraph_style */ 1:
                    message.paragraphStyle = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.paragraphStyle);
                    break;
                case /* optional TSP.Reference toc_entry_style */ 2:
                    message.tocEntryStyle = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.tocEntryStyle);
                    break;
                case /* optional bool show_in_toc */ 3:
                    message.showInToc = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference paragraph_style = 1; */
        if (message.paragraphStyle)
            TSPMessages_5.Reference.internalBinaryWrite(message.paragraphStyle, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference toc_entry_style = 2; */
        if (message.tocEntryStyle)
            TSPMessages_5.Reference.internalBinaryWrite(message.tocEntryStyle, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool show_in_toc = 3; */
        if (message.showInToc !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.showInToc);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.TOCSettingsArchive.TOCEntryData
 */
exports.TOCSettingsArchive_TOCEntryData = new TOCSettingsArchive_TOCEntryData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TOCEntryInstanceArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.TOCEntryInstanceArchive", [
            { no: 1, name: "paragraph_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "page_number", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "number_format", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "heading", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "indexed_style", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 6, name: "indexed_list_style", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 7, name: "indexed_list_start", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "indexed_paragraph_level", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "number_format_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { paragraphIndex: 0, pageNumber: 0, numberFormat: 0, heading: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 paragraph_index */ 1:
                    message.paragraphIndex = reader.uint32();
                    break;
                case /* uint32 page_number */ 2:
                    message.pageNumber = reader.uint32();
                    break;
                case /* uint32 number_format */ 3:
                    message.numberFormat = reader.uint32();
                    break;
                case /* string heading */ 4:
                    message.heading = reader.string();
                    break;
                case /* TSP.Reference indexed_style */ 5:
                    message.indexedStyle = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.indexedStyle);
                    break;
                case /* optional TSP.Reference indexed_list_style */ 6:
                    message.indexedListStyle = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.indexedListStyle);
                    break;
                case /* optional uint32 indexed_list_start */ 7:
                    message.indexedListStart = reader.uint32();
                    break;
                case /* optional uint32 indexed_paragraph_level */ 8:
                    message.indexedParagraphLevel = reader.uint32();
                    break;
                case /* optional string number_format_name */ 9:
                    message.numberFormatName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 paragraph_index = 1; */
        if (message.paragraphIndex !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.paragraphIndex);
        /* uint32 page_number = 2; */
        if (message.pageNumber !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.pageNumber);
        /* uint32 number_format = 3; */
        if (message.numberFormat !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.numberFormat);
        /* string heading = 4; */
        if (message.heading !== "")
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.heading);
        /* TSP.Reference indexed_style = 5; */
        if (message.indexedStyle)
            TSPMessages_5.Reference.internalBinaryWrite(message.indexedStyle, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference indexed_list_style = 6; */
        if (message.indexedListStyle)
            TSPMessages_5.Reference.internalBinaryWrite(message.indexedListStyle, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 indexed_list_start = 7; */
        if (message.indexedListStart !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).uint32(message.indexedListStart);
        /* optional uint32 indexed_paragraph_level = 8; */
        if (message.indexedParagraphLevel !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).uint32(message.indexedParagraphLevel);
        /* optional string number_format_name = 9; */
        if (message.numberFormatName !== undefined)
            writer.tag(9, runtime_1.WireType.LengthDelimited).string(message.numberFormatName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.TOCEntryInstanceArchive
 */
exports.TOCEntryInstanceArchive = new TOCEntryInstanceArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UndoTransaction$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.UndoTransaction", [
            { no: 1, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.UndoTransaction_UnionTransaction },
            { no: 2, name: "group_entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.UndoTransaction_StorageActionGroup },
            { no: 3, name: "flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "version", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { entries: [], groupEntries: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSWP.UndoTransaction.UnionTransaction entries */ 1:
                    message.entries.push(exports.UndoTransaction_UnionTransaction.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSWP.UndoTransaction.StorageActionGroup group_entries */ 2:
                    message.groupEntries.push(exports.UndoTransaction_StorageActionGroup.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 flags */ 3:
                    message.flags = reader.uint32();
                    break;
                case /* optional uint32 version */ 4:
                    message.version = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSWP.UndoTransaction.UnionTransaction entries = 1; */
        for (let i = 0; i < message.entries.length; i++)
            exports.UndoTransaction_UnionTransaction.internalBinaryWrite(message.entries[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSWP.UndoTransaction.StorageActionGroup group_entries = 2; */
        for (let i = 0; i < message.groupEntries.length; i++)
            exports.UndoTransaction_StorageActionGroup.internalBinaryWrite(message.groupEntries[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 flags = 3; */
        if (message.flags !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.flags);
        /* optional uint32 version = 4; */
        if (message.version !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.UndoTransaction
 */
exports.UndoTransaction = new UndoTransaction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UndoTransaction_GenericTransaction$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.UndoTransaction.GenericTransaction", [
            { no: 1, name: "value1", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "value2", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "value3", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { value1: 0, value2: 0, value3: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 value1 */ 1:
                    message.value1 = reader.uint32();
                    break;
                case /* uint32 value2 */ 2:
                    message.value2 = reader.uint32();
                    break;
                case /* uint32 value3 */ 3:
                    message.value3 = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 value1 = 1; */
        if (message.value1 !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.value1);
        /* uint32 value2 = 2; */
        if (message.value2 !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.value2);
        /* uint32 value3 = 3; */
        if (message.value3 !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.value3);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.UndoTransaction.GenericTransaction
 */
exports.UndoTransaction_GenericTransaction = new UndoTransaction_GenericTransaction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UndoTransaction_TextTransaction$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.UndoTransaction.TextTransaction", [
            { no: 1, name: "insert_location", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "insert_length", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "string_to_delete", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { insertLocation: 0, insertLength: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 insert_location */ 1:
                    message.insertLocation = reader.uint32();
                    break;
                case /* uint32 insert_length */ 2:
                    message.insertLength = reader.uint32();
                    break;
                case /* optional string string_to_delete */ 3:
                    message.stringToDelete = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 insert_location = 1; */
        if (message.insertLocation !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.insertLocation);
        /* uint32 insert_length = 2; */
        if (message.insertLength !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.insertLength);
        /* optional string string_to_delete = 3; */
        if (message.stringToDelete !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.stringToDelete);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.UndoTransaction.TextTransaction
 */
exports.UndoTransaction_TextTransaction = new UndoTransaction_TextTransaction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UndoTransaction_CharIndexTransaction$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.UndoTransaction.CharIndexTransaction", [
            { no: 1, name: "char_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "object", kind: "message", T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = { charIndex: 0, count: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 char_index */ 1:
                    message.charIndex = reader.uint32();
                    break;
                case /* uint32 count */ 2:
                    message.count = reader.uint32();
                    break;
                case /* optional TSP.Reference object */ 3:
                    message.object = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.object);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 char_index = 1; */
        if (message.charIndex !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.charIndex);
        /* uint32 count = 2; */
        if (message.count !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.count);
        /* optional TSP.Reference object = 3; */
        if (message.object)
            TSPMessages_5.Reference.internalBinaryWrite(message.object, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.UndoTransaction.CharIndexTransaction
 */
exports.UndoTransaction_CharIndexTransaction = new UndoTransaction_CharIndexTransaction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UndoTransaction_ReplaceCharIndexTransaction$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.UndoTransaction.ReplaceCharIndexTransaction", [
            { no: 1, name: "attribute_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "char_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { attributeIndex: 0, charIndex: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 attribute_index */ 1:
                    message.attributeIndex = reader.uint32();
                    break;
                case /* uint32 char_index */ 2:
                    message.charIndex = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 attribute_index = 1; */
        if (message.attributeIndex !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.attributeIndex);
        /* uint32 char_index = 2; */
        if (message.charIndex !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.charIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.UndoTransaction.ReplaceCharIndexTransaction
 */
exports.UndoTransaction_ReplaceCharIndexTransaction = new UndoTransaction_ReplaceCharIndexTransaction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UndoTransaction_AttributeIndexTransaction$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.UndoTransaction.AttributeIndexTransaction", [
            { no: 1, name: "attribute_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "char_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "object", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 4, name: "string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { attributeIndex: 0, charIndex: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 attribute_index */ 1:
                    message.attributeIndex = reader.uint32();
                    break;
                case /* uint32 char_index */ 2:
                    message.charIndex = reader.uint32();
                    break;
                case /* optional TSP.Reference object */ 3:
                    message.object = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.object);
                    break;
                case /* optional string string */ 4:
                    message.string = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 attribute_index = 1; */
        if (message.attributeIndex !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.attributeIndex);
        /* uint32 char_index = 2; */
        if (message.charIndex !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.charIndex);
        /* optional TSP.Reference object = 3; */
        if (message.object)
            TSPMessages_5.Reference.internalBinaryWrite(message.object, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string string = 4; */
        if (message.string !== undefined)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.string);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.UndoTransaction.AttributeIndexTransaction
 */
exports.UndoTransaction_AttributeIndexTransaction = new UndoTransaction_AttributeIndexTransaction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UndoTransaction_InsertAttributeTransaction$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.UndoTransaction.InsertAttributeTransaction", [
            { no: 1, name: "attribute_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "attribute_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "object", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 4, name: "string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { attributeIndex: 0, attributeCount: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 attribute_index */ 1:
                    message.attributeIndex = reader.uint32();
                    break;
                case /* uint32 attribute_count */ 2:
                    message.attributeCount = reader.uint32();
                    break;
                case /* optional TSP.Reference object */ 3:
                    message.object = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.object);
                    break;
                case /* optional string string */ 4:
                    message.string = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 attribute_index = 1; */
        if (message.attributeIndex !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.attributeIndex);
        /* uint32 attribute_count = 2; */
        if (message.attributeCount !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.attributeCount);
        /* optional TSP.Reference object = 3; */
        if (message.object)
            TSPMessages_5.Reference.internalBinaryWrite(message.object, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string string = 4; */
        if (message.string !== undefined)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.string);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.UndoTransaction.InsertAttributeTransaction
 */
exports.UndoTransaction_InsertAttributeTransaction = new UndoTransaction_InsertAttributeTransaction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UndoTransaction_InsertNilTransaction$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.UndoTransaction.InsertNilTransaction", [
            { no: 1, name: "attribute_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "attribute_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { attributeIndex: 0, attributeCount: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 attribute_index */ 1:
                    message.attributeIndex = reader.uint32();
                    break;
                case /* uint32 attribute_count */ 2:
                    message.attributeCount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 attribute_index = 1; */
        if (message.attributeIndex !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.attributeIndex);
        /* uint32 attribute_count = 2; */
        if (message.attributeCount !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.attributeCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.UndoTransaction.InsertNilTransaction
 */
exports.UndoTransaction_InsertNilTransaction = new UndoTransaction_InsertNilTransaction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UndoTransaction_CharDeltaTransaction$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.UndoTransaction.CharDeltaTransaction", [
            { no: 1, name: "char_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "attribute_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "char_delta", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value) {
        const message = { charIndex: 0, attributeIndex: 0, charDelta: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 char_index */ 1:
                    message.charIndex = reader.uint32();
                    break;
                case /* uint32 attribute_index */ 2:
                    message.attributeIndex = reader.uint32();
                    break;
                case /* sint32 char_delta */ 3:
                    message.charDelta = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 char_index = 1; */
        if (message.charIndex !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.charIndex);
        /* uint32 attribute_index = 2; */
        if (message.attributeIndex !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.attributeIndex);
        /* sint32 char_delta = 3; */
        if (message.charDelta !== 0)
            writer.tag(3, runtime_1.WireType.Varint).sint32(message.charDelta);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.UndoTransaction.CharDeltaTransaction
 */
exports.UndoTransaction_CharDeltaTransaction = new UndoTransaction_CharDeltaTransaction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UndoTransaction_ParagraphDataTransaction$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.UndoTransaction.ParagraphDataTransaction", [
            { no: 1, name: "attribute_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "first", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "second", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "char_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { attributeIndex: 0, first: 0, second: 0, charIndex: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 attribute_index */ 1:
                    message.attributeIndex = reader.uint32();
                    break;
                case /* uint32 first */ 2:
                    message.first = reader.uint32();
                    break;
                case /* uint32 second */ 3:
                    message.second = reader.uint32();
                    break;
                case /* uint32 char_index */ 4:
                    message.charIndex = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 attribute_index = 1; */
        if (message.attributeIndex !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.attributeIndex);
        /* uint32 first = 2; */
        if (message.first !== 0)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.first);
        /* uint32 second = 3; */
        if (message.second !== 0)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.second);
        /* uint32 char_index = 4; */
        if (message.charIndex !== 0)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.charIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.UndoTransaction.ParagraphDataTransaction
 */
exports.UndoTransaction_ParagraphDataTransaction = new UndoTransaction_ParagraphDataTransaction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UndoTransaction_ObjectDOLCTransaction$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.UndoTransaction.ObjectDOLCTransaction", [
            { no: 1, name: "flags", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "object", kind: "message", T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = { flags: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 flags */ 1:
                    message.flags = reader.uint32();
                    break;
                case /* optional TSP.Reference object */ 2:
                    message.object = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.object);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 flags = 1; */
        if (message.flags !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.flags);
        /* optional TSP.Reference object = 2; */
        if (message.object)
            TSPMessages_5.Reference.internalBinaryWrite(message.object, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.UndoTransaction.ObjectDOLCTransaction
 */
exports.UndoTransaction_ObjectDOLCTransaction = new UndoTransaction_ObjectDOLCTransaction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UndoTransaction_CTDateTransaction$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.UndoTransaction.CTDateTransaction", [
            { no: 1, name: "attribute_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "date", kind: "message", T: () => TSPMessages_1.Date }
        ]);
    }
    create(value) {
        const message = { attributeIndex: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 attribute_index */ 1:
                    message.attributeIndex = reader.uint32();
                    break;
                case /* optional TSP.Date date */ 2:
                    message.date = TSPMessages_1.Date.internalBinaryRead(reader, reader.uint32(), options, message.date);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 attribute_index = 1; */
        if (message.attributeIndex !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.attributeIndex);
        /* optional TSP.Date date = 2; */
        if (message.date)
            TSPMessages_1.Date.internalBinaryWrite(message.date, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.UndoTransaction.CTDateTransaction
 */
exports.UndoTransaction_CTDateTransaction = new UndoTransaction_CTDateTransaction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UndoTransaction_UnionTransaction$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.UndoTransaction.UnionTransaction", [
            { no: 1, name: "kind", kind: "enum", T: () => ["TSWP.UndoTransaction.UndoKind", UndoTransaction_UndoKind] },
            { no: 2, name: "table", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "generic", kind: "message", T: () => exports.UndoTransaction_GenericTransaction },
            { no: 6, name: "text", kind: "message", T: () => exports.UndoTransaction_TextTransaction },
            { no: 7, name: "char_index", kind: "message", T: () => exports.UndoTransaction_CharIndexTransaction },
            { no: 8, name: "replace_char_index", kind: "message", T: () => exports.UndoTransaction_ReplaceCharIndexTransaction },
            { no: 9, name: "attribute_index", kind: "message", T: () => exports.UndoTransaction_AttributeIndexTransaction },
            { no: 10, name: "insert_nil", kind: "message", T: () => exports.UndoTransaction_InsertNilTransaction },
            { no: 11, name: "insert_attribute", kind: "message", T: () => exports.UndoTransaction_InsertAttributeTransaction },
            { no: 12, name: "char_delta", kind: "message", T: () => exports.UndoTransaction_CharDeltaTransaction },
            { no: 13, name: "paragraph_data", kind: "message", T: () => exports.UndoTransaction_ParagraphDataTransaction },
            { no: 14, name: "object_dolc", kind: "message", T: () => exports.UndoTransaction_ObjectDOLCTransaction },
            { no: 15, name: "ct_date", kind: "message", T: () => exports.UndoTransaction_CTDateTransaction }
        ]);
    }
    create(value) {
        const message = { kind: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSWP.UndoTransaction.UndoKind kind */ 1:
                    message.kind = reader.int32();
                    break;
                case /* optional uint32 table */ 2:
                    message.table = reader.uint32();
                    break;
                case /* optional TSWP.UndoTransaction.GenericTransaction generic */ 5:
                    message.generic = exports.UndoTransaction_GenericTransaction.internalBinaryRead(reader, reader.uint32(), options, message.generic);
                    break;
                case /* optional TSWP.UndoTransaction.TextTransaction text */ 6:
                    message.text = exports.UndoTransaction_TextTransaction.internalBinaryRead(reader, reader.uint32(), options, message.text);
                    break;
                case /* optional TSWP.UndoTransaction.CharIndexTransaction char_index */ 7:
                    message.charIndex = exports.UndoTransaction_CharIndexTransaction.internalBinaryRead(reader, reader.uint32(), options, message.charIndex);
                    break;
                case /* optional TSWP.UndoTransaction.ReplaceCharIndexTransaction replace_char_index */ 8:
                    message.replaceCharIndex = exports.UndoTransaction_ReplaceCharIndexTransaction.internalBinaryRead(reader, reader.uint32(), options, message.replaceCharIndex);
                    break;
                case /* optional TSWP.UndoTransaction.AttributeIndexTransaction attribute_index */ 9:
                    message.attributeIndex = exports.UndoTransaction_AttributeIndexTransaction.internalBinaryRead(reader, reader.uint32(), options, message.attributeIndex);
                    break;
                case /* optional TSWP.UndoTransaction.InsertNilTransaction insert_nil */ 10:
                    message.insertNil = exports.UndoTransaction_InsertNilTransaction.internalBinaryRead(reader, reader.uint32(), options, message.insertNil);
                    break;
                case /* optional TSWP.UndoTransaction.InsertAttributeTransaction insert_attribute */ 11:
                    message.insertAttribute = exports.UndoTransaction_InsertAttributeTransaction.internalBinaryRead(reader, reader.uint32(), options, message.insertAttribute);
                    break;
                case /* optional TSWP.UndoTransaction.CharDeltaTransaction char_delta */ 12:
                    message.charDelta = exports.UndoTransaction_CharDeltaTransaction.internalBinaryRead(reader, reader.uint32(), options, message.charDelta);
                    break;
                case /* optional TSWP.UndoTransaction.ParagraphDataTransaction paragraph_data */ 13:
                    message.paragraphData = exports.UndoTransaction_ParagraphDataTransaction.internalBinaryRead(reader, reader.uint32(), options, message.paragraphData);
                    break;
                case /* optional TSWP.UndoTransaction.ObjectDOLCTransaction object_dolc */ 14:
                    message.objectDolc = exports.UndoTransaction_ObjectDOLCTransaction.internalBinaryRead(reader, reader.uint32(), options, message.objectDolc);
                    break;
                case /* optional TSWP.UndoTransaction.CTDateTransaction ct_date */ 15:
                    message.ctDate = exports.UndoTransaction_CTDateTransaction.internalBinaryRead(reader, reader.uint32(), options, message.ctDate);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSWP.UndoTransaction.UndoKind kind = 1; */
        if (message.kind !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.kind);
        /* optional uint32 table = 2; */
        if (message.table !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.table);
        /* optional TSWP.UndoTransaction.GenericTransaction generic = 5; */
        if (message.generic)
            exports.UndoTransaction_GenericTransaction.internalBinaryWrite(message.generic, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.UndoTransaction.TextTransaction text = 6; */
        if (message.text)
            exports.UndoTransaction_TextTransaction.internalBinaryWrite(message.text, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.UndoTransaction.CharIndexTransaction char_index = 7; */
        if (message.charIndex)
            exports.UndoTransaction_CharIndexTransaction.internalBinaryWrite(message.charIndex, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.UndoTransaction.ReplaceCharIndexTransaction replace_char_index = 8; */
        if (message.replaceCharIndex)
            exports.UndoTransaction_ReplaceCharIndexTransaction.internalBinaryWrite(message.replaceCharIndex, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.UndoTransaction.AttributeIndexTransaction attribute_index = 9; */
        if (message.attributeIndex)
            exports.UndoTransaction_AttributeIndexTransaction.internalBinaryWrite(message.attributeIndex, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.UndoTransaction.InsertNilTransaction insert_nil = 10; */
        if (message.insertNil)
            exports.UndoTransaction_InsertNilTransaction.internalBinaryWrite(message.insertNil, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.UndoTransaction.InsertAttributeTransaction insert_attribute = 11; */
        if (message.insertAttribute)
            exports.UndoTransaction_InsertAttributeTransaction.internalBinaryWrite(message.insertAttribute, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.UndoTransaction.CharDeltaTransaction char_delta = 12; */
        if (message.charDelta)
            exports.UndoTransaction_CharDeltaTransaction.internalBinaryWrite(message.charDelta, writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.UndoTransaction.ParagraphDataTransaction paragraph_data = 13; */
        if (message.paragraphData)
            exports.UndoTransaction_ParagraphDataTransaction.internalBinaryWrite(message.paragraphData, writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.UndoTransaction.ObjectDOLCTransaction object_dolc = 14; */
        if (message.objectDolc)
            exports.UndoTransaction_ObjectDOLCTransaction.internalBinaryWrite(message.objectDolc, writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.UndoTransaction.CTDateTransaction ct_date = 15; */
        if (message.ctDate)
            exports.UndoTransaction_CTDateTransaction.internalBinaryWrite(message.ctDate, writer.tag(15, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.UndoTransaction.UnionTransaction
 */
exports.UndoTransaction_UnionTransaction = new UndoTransaction_UnionTransaction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UndoTransaction_StorageAction$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.UndoTransaction.StorageAction", [
            { no: 1, name: "kind", kind: "enum", T: () => ["TSWP.UndoTransaction.ActionKind", UndoTransaction_ActionKind] },
            { no: 2, name: "flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "table", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "range", kind: "message", T: () => TSPMessages_6.Range },
            { no: 5, name: "string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "object", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 7, name: "date", kind: "message", T: () => TSPMessages_1.Date },
            { no: 8, name: "paragraph_level", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "paragraph_flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "paragraph_value", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "placement_index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "placement_uuid_path", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "undo_object", kind: "message", T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = { kind: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSWP.UndoTransaction.ActionKind kind */ 1:
                    message.kind = reader.int32();
                    break;
                case /* optional uint32 flags */ 2:
                    message.flags = reader.uint32();
                    break;
                case /* optional uint32 table */ 3:
                    message.table = reader.uint32();
                    break;
                case /* optional TSP.Range range */ 4:
                    message.range = TSPMessages_6.Range.internalBinaryRead(reader, reader.uint32(), options, message.range);
                    break;
                case /* optional string string */ 5:
                    message.string = reader.string();
                    break;
                case /* optional TSP.Reference object */ 6:
                    message.object = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.object);
                    break;
                case /* optional TSP.Date date */ 7:
                    message.date = TSPMessages_1.Date.internalBinaryRead(reader, reader.uint32(), options, message.date);
                    break;
                case /* optional uint32 paragraph_level */ 8:
                    message.paragraphLevel = reader.uint32();
                    break;
                case /* optional uint32 paragraph_flags */ 9:
                    message.paragraphFlags = reader.uint32();
                    break;
                case /* optional uint32 paragraph_value */ 10:
                    message.paragraphValue = reader.uint32();
                    break;
                case /* optional int32 placement_index */ 11:
                    message.placementIndex = reader.int32();
                    break;
                case /* optional string placement_uuid_path */ 12:
                    message.placementUuidPath = reader.string();
                    break;
                case /* optional TSP.Reference undo_object */ 13:
                    message.undoObject = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoObject);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSWP.UndoTransaction.ActionKind kind = 1; */
        if (message.kind !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.kind);
        /* optional uint32 flags = 2; */
        if (message.flags !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.flags);
        /* optional uint32 table = 3; */
        if (message.table !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.table);
        /* optional TSP.Range range = 4; */
        if (message.range)
            TSPMessages_6.Range.internalBinaryWrite(message.range, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string string = 5; */
        if (message.string !== undefined)
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.string);
        /* optional TSP.Reference object = 6; */
        if (message.object)
            TSPMessages_5.Reference.internalBinaryWrite(message.object, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Date date = 7; */
        if (message.date)
            TSPMessages_1.Date.internalBinaryWrite(message.date, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 paragraph_level = 8; */
        if (message.paragraphLevel !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).uint32(message.paragraphLevel);
        /* optional uint32 paragraph_flags = 9; */
        if (message.paragraphFlags !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).uint32(message.paragraphFlags);
        /* optional uint32 paragraph_value = 10; */
        if (message.paragraphValue !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).uint32(message.paragraphValue);
        /* optional int32 placement_index = 11; */
        if (message.placementIndex !== undefined)
            writer.tag(11, runtime_1.WireType.Varint).int32(message.placementIndex);
        /* optional string placement_uuid_path = 12; */
        if (message.placementUuidPath !== undefined)
            writer.tag(12, runtime_1.WireType.LengthDelimited).string(message.placementUuidPath);
        /* optional TSP.Reference undo_object = 13; */
        if (message.undoObject)
            TSPMessages_5.Reference.internalBinaryWrite(message.undoObject, writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.UndoTransaction.StorageAction
 */
exports.UndoTransaction_StorageAction = new UndoTransaction_StorageAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UndoTransaction_StorageActionGroup$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.UndoTransaction.StorageActionGroup", [
            { no: 1, name: "kind", kind: "enum", T: () => ["TSWP.UndoTransaction.ActionGroupKind", UndoTransaction_ActionGroupKind] },
            { no: 3, name: "forward_actions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.UndoTransaction_StorageAction },
            { no: 4, name: "inverse_forward_actions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.UndoTransaction_StorageAction },
            { no: 6, name: "inverse_detail_actions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.UndoTransaction_StorageAction }
        ]);
    }
    create(value) {
        const message = { kind: 0, forwardActions: [], inverseForwardActions: [], inverseDetailActions: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSWP.UndoTransaction.ActionGroupKind kind */ 1:
                    message.kind = reader.int32();
                    break;
                case /* repeated TSWP.UndoTransaction.StorageAction forward_actions */ 3:
                    message.forwardActions.push(exports.UndoTransaction_StorageAction.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSWP.UndoTransaction.StorageAction inverse_forward_actions */ 4:
                    message.inverseForwardActions.push(exports.UndoTransaction_StorageAction.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSWP.UndoTransaction.StorageAction inverse_detail_actions */ 6:
                    message.inverseDetailActions.push(exports.UndoTransaction_StorageAction.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSWP.UndoTransaction.ActionGroupKind kind = 1; */
        if (message.kind !== 0)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.kind);
        /* repeated TSWP.UndoTransaction.StorageAction forward_actions = 3; */
        for (let i = 0; i < message.forwardActions.length; i++)
            exports.UndoTransaction_StorageAction.internalBinaryWrite(message.forwardActions[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSWP.UndoTransaction.StorageAction inverse_forward_actions = 4; */
        for (let i = 0; i < message.inverseForwardActions.length; i++)
            exports.UndoTransaction_StorageAction.internalBinaryWrite(message.inverseForwardActions[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSWP.UndoTransaction.StorageAction inverse_detail_actions = 6; */
        for (let i = 0; i < message.inverseDetailActions.length; i++)
            exports.UndoTransaction_StorageAction.internalBinaryWrite(message.inverseDetailActions[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.UndoTransaction.StorageActionGroup
 */
exports.UndoTransaction_StorageActionGroup = new UndoTransaction_StorageActionGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UndoTransactionWrapperArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.UndoTransactionWrapperArchive", [
            { no: 1, name: "undo_transaction", kind: "message", T: () => exports.UndoTransaction }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSWP.UndoTransaction undo_transaction */ 1:
                    message.undoTransaction = exports.UndoTransaction.internalBinaryRead(reader, reader.uint32(), options, message.undoTransaction);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSWP.UndoTransaction undo_transaction = 1; */
        if (message.undoTransaction)
            exports.UndoTransaction.internalBinaryWrite(message.undoTransaction, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.UndoTransactionWrapperArchive
 */
exports.UndoTransactionWrapperArchive = new UndoTransactionWrapperArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShapeInfoArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ShapeInfoArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSDArchives_1.ShapeArchive },
            { no: 2, name: "deprecated_storage", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 3, name: "text_flow", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 4, name: "owned_storage", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 6, name: "is_text_box", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.ShapeArchive super */ 1:
                    message.super = TSDArchives_1.ShapeArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference deprecated_storage = 2 [deprecated = true];*/ 2:
                    message.deprecatedStorage = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.deprecatedStorage);
                    break;
                case /* optional TSP.Reference text_flow */ 3:
                    message.textFlow = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.textFlow);
                    break;
                case /* optional TSP.Reference owned_storage */ 4:
                    message.ownedStorage = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.ownedStorage);
                    break;
                case /* optional bool is_text_box */ 6:
                    message.isTextBox = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.ShapeArchive super = 1; */
        if (message.super)
            TSDArchives_1.ShapeArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference deprecated_storage = 2 [deprecated = true]; */
        if (message.deprecatedStorage)
            TSPMessages_5.Reference.internalBinaryWrite(message.deprecatedStorage, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference text_flow = 3; */
        if (message.textFlow)
            TSPMessages_5.Reference.internalBinaryWrite(message.textFlow, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference owned_storage = 4; */
        if (message.ownedStorage)
            TSPMessages_5.Reference.internalBinaryWrite(message.ownedStorage, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_text_box = 6; */
        if (message.isTextBox !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.isTextBox);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ShapeInfoArchive
 */
exports.ShapeInfoArchive = new ShapeInfoArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommentInfoArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.CommentInfoArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.ShapeInfoArchive },
            { no: 2, name: "comment_storage", kind: "message", T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSWP.ShapeInfoArchive super */ 1:
                    message.super = exports.ShapeInfoArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference comment_storage */ 2:
                    message.commentStorage = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.commentStorage);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSWP.ShapeInfoArchive super = 1; */
        if (message.super)
            exports.ShapeInfoArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference comment_storage = 2; */
        if (message.commentStorage)
            TSPMessages_5.Reference.internalBinaryWrite(message.commentStorage, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.CommentInfoArchive
 */
exports.CommentInfoArchive = new CommentInfoArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TOCInfoArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.TOCInfoArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.ShapeInfoArchive },
            { no: 2, name: "toc_settings", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 3, name: "toc_entry_data", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.Reference },
            { no: 4, name: "page_number_ranges", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_6.Range },
            { no: 5, name: "sync_toc_settings_with_toc_navigator", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { tocEntryData: [], pageNumberRanges: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSWP.ShapeInfoArchive super */ 1:
                    message.super = exports.ShapeInfoArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference toc_settings */ 2:
                    message.tocSettings = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.tocSettings);
                    break;
                case /* repeated TSP.Reference toc_entry_data */ 3:
                    message.tocEntryData.push(TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Range page_number_ranges */ 4:
                    message.pageNumberRanges.push(TSPMessages_6.Range.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool sync_toc_settings_with_toc_navigator */ 5:
                    message.syncTocSettingsWithTocNavigator = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSWP.ShapeInfoArchive super = 1; */
        if (message.super)
            exports.ShapeInfoArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference toc_settings = 2; */
        if (message.tocSettings)
            TSPMessages_5.Reference.internalBinaryWrite(message.tocSettings, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference toc_entry_data = 3; */
        for (let i = 0; i < message.tocEntryData.length; i++)
            TSPMessages_5.Reference.internalBinaryWrite(message.tocEntryData[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Range page_number_ranges = 4; */
        for (let i = 0; i < message.pageNumberRanges.length; i++)
            TSPMessages_6.Range.internalBinaryWrite(message.pageNumberRanges[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool sync_toc_settings_with_toc_navigator = 5; */
        if (message.syncTocSettingsWithTocNavigator !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.syncTocSettingsWithTocNavigator);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.TOCInfoArchive
 */
exports.TOCInfoArchive = new TOCInfoArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TOCLayoutHintArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.TOCLayoutHintArchive", [
            { no: 1, name: "charRange", kind: "message", T: () => TSPMessages_6.Range }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.Range charRange */ 1:
                    message.charRange = TSPMessages_6.Range.internalBinaryRead(reader, reader.uint32(), options, message.charRange);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.Range charRange = 1; */
        if (message.charRange)
            TSPMessages_6.Range.internalBinaryWrite(message.charRange, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.TOCLayoutHintArchive
 */
exports.TOCLayoutHintArchive = new TOCLayoutHintArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EquationInfoArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.EquationInfoArchive", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.EquationInfoArchive
 */
exports.EquationInfoArchive = new EquationInfoArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TextualAttachmentArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.TextualAttachmentArchive", [
            { no: 1, name: "string_equivalent", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "kind", kind: "enum", opt: true, T: () => ["TSWP.TextualAttachmentArchive.Kind", TextualAttachmentArchive_Kind] }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string string_equivalent */ 1:
                    message.stringEquivalent = reader.string();
                    break;
                case /* optional TSWP.TextualAttachmentArchive.Kind kind */ 2:
                    message.kind = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string string_equivalent = 1; */
        if (message.stringEquivalent !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.stringEquivalent);
        /* optional TSWP.TextualAttachmentArchive.Kind kind = 2; */
        if (message.kind !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.kind);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.TextualAttachmentArchive
 */
exports.TextualAttachmentArchive = new TextualAttachmentArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TSWPTOCPageNumberAttachmentArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.TSWPTOCPageNumberAttachmentArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TextualAttachmentArchive },
            { no: 2, name: "page_number", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "bookmark_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.TextualAttachmentArchive super */ 1:
                    message.super = exports.TextualAttachmentArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional string page_number */ 2:
                    message.pageNumber = reader.string();
                    break;
                case /* optional string bookmark_name */ 3:
                    message.bookmarkName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.TextualAttachmentArchive super = 1; */
        if (message.super)
            exports.TextualAttachmentArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string page_number = 2; */
        if (message.pageNumber !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.pageNumber);
        /* optional string bookmark_name = 3; */
        if (message.bookmarkName !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.bookmarkName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.TSWPTOCPageNumberAttachmentArchive
 */
exports.TSWPTOCPageNumberAttachmentArchive = new TSWPTOCPageNumberAttachmentArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UIGraphicalAttachment$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.UIGraphicalAttachment", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.UIGraphicalAttachment
 */
exports.UIGraphicalAttachment = new UIGraphicalAttachment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DrawableAttachmentArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.DrawableAttachmentArchive", [
            { no: 1, name: "drawable", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 2, name: "h_offset_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "h_offset", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "v_offset_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "v_offset", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference drawable */ 1:
                    message.drawable = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.drawable);
                    break;
                case /* optional uint32 h_offset_type */ 2:
                    message.hOffsetType = reader.uint32();
                    break;
                case /* optional float h_offset */ 3:
                    message.hOffset = reader.float();
                    break;
                case /* optional uint32 v_offset_type */ 4:
                    message.vOffsetType = reader.uint32();
                    break;
                case /* optional float v_offset */ 5:
                    message.vOffset = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference drawable = 1; */
        if (message.drawable)
            TSPMessages_5.Reference.internalBinaryWrite(message.drawable, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 h_offset_type = 2; */
        if (message.hOffsetType !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.hOffsetType);
        /* optional float h_offset = 3; */
        if (message.hOffset !== undefined)
            writer.tag(3, runtime_1.WireType.Bit32).float(message.hOffset);
        /* optional uint32 v_offset_type = 4; */
        if (message.vOffsetType !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.vOffsetType);
        /* optional float v_offset = 5; */
        if (message.vOffset !== undefined)
            writer.tag(5, runtime_1.WireType.Bit32).float(message.vOffset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.DrawableAttachmentArchive
 */
exports.DrawableAttachmentArchive = new DrawableAttachmentArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TOCAttachmentArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.TOCAttachmentArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.DrawableAttachmentArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSWP.DrawableAttachmentArchive super */ 1:
                    message.super = exports.DrawableAttachmentArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSWP.DrawableAttachmentArchive super = 1; */
        if (message.super)
            exports.DrawableAttachmentArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.TOCAttachmentArchive
 */
exports.TOCAttachmentArchive = new TOCAttachmentArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FootnoteReferenceAttachmentArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.FootnoteReferenceAttachmentArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TextualAttachmentArchive },
            { no: 2, name: "contained_storage", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 3, name: "custom_mark_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.TextualAttachmentArchive super */ 1:
                    message.super = exports.TextualAttachmentArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference contained_storage */ 2:
                    message.containedStorage = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.containedStorage);
                    break;
                case /* optional string custom_mark_string */ 3:
                    message.customMarkString = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.TextualAttachmentArchive super = 1; */
        if (message.super)
            exports.TextualAttachmentArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference contained_storage = 2; */
        if (message.containedStorage)
            TSPMessages_5.Reference.internalBinaryWrite(message.containedStorage, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string custom_mark_string = 3; */
        if (message.customMarkString !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.customMarkString);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.FootnoteReferenceAttachmentArchive
 */
exports.FootnoteReferenceAttachmentArchive = new FootnoteReferenceAttachmentArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NumberAttachmentArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.NumberAttachmentArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TextualAttachmentArchive },
            { no: 2, name: "number_format", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "string_value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "number_format_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.TextualAttachmentArchive super */ 1:
                    message.super = exports.TextualAttachmentArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional uint32 number_format */ 2:
                    message.numberFormat = reader.uint32();
                    break;
                case /* optional string string_value */ 3:
                    message.stringValue = reader.string();
                    break;
                case /* optional string number_format_name */ 4:
                    message.numberFormatName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.TextualAttachmentArchive super = 1; */
        if (message.super)
            exports.TextualAttachmentArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 number_format = 2; */
        if (message.numberFormat !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.numberFormat);
        /* optional string string_value = 3; */
        if (message.stringValue !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.stringValue);
        /* optional string number_format_name = 4; */
        if (message.numberFormatName !== undefined)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.numberFormatName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.NumberAttachmentArchive
 */
exports.NumberAttachmentArchive = new NumberAttachmentArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SmartFieldArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.SmartFieldArchive", [
            { no: 1, name: "text_attribute_uuid_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string text_attribute_uuid_string */ 1:
                    message.textAttributeUuidString = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string text_attribute_uuid_string = 1; */
        if (message.textAttributeUuidString !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.textAttributeUuidString);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.SmartFieldArchive
 */
exports.SmartFieldArchive = new SmartFieldArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HyperlinkFieldArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.HyperlinkFieldArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.SmartFieldArchive },
            { no: 2, name: "url_ref", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.SmartFieldArchive super */ 1:
                    message.super = exports.SmartFieldArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional string url_ref */ 2:
                    message.urlRef = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.SmartFieldArchive super = 1; */
        if (message.super)
            exports.SmartFieldArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string url_ref = 2; */
        if (message.urlRef !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.urlRef);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.HyperlinkFieldArchive
 */
exports.HyperlinkFieldArchive = new HyperlinkFieldArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlaceholderSmartFieldArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.PlaceholderSmartFieldArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.SmartFieldArchive },
            { no: 2, name: "localizable", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "script_tag", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.SmartFieldArchive super */ 1:
                    message.super = exports.SmartFieldArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional bool localizable */ 2:
                    message.localizable = reader.bool();
                    break;
                case /* optional string script_tag */ 3:
                    message.scriptTag = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.SmartFieldArchive super = 1; */
        if (message.super)
            exports.SmartFieldArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool localizable = 2; */
        if (message.localizable !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.localizable);
        /* optional string script_tag = 3; */
        if (message.scriptTag !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.scriptTag);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.PlaceholderSmartFieldArchive
 */
exports.PlaceholderSmartFieldArchive = new PlaceholderSmartFieldArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnsupportedHyperlinkFieldArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.UnsupportedHyperlinkFieldArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.PlaceholderSmartFieldArchive },
            { no: 2, name: "url_ref", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "url_original_ref", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.PlaceholderSmartFieldArchive super */ 1:
                    message.super = exports.PlaceholderSmartFieldArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional string url_ref */ 2:
                    message.urlRef = reader.string();
                    break;
                case /* optional string url_original_ref */ 3:
                    message.urlOriginalRef = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.PlaceholderSmartFieldArchive super = 1; */
        if (message.super)
            exports.PlaceholderSmartFieldArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string url_ref = 2; */
        if (message.urlRef !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.urlRef);
        /* optional string url_original_ref = 3; */
        if (message.urlOriginalRef !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.urlOriginalRef);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.UnsupportedHyperlinkFieldArchive
 */
exports.UnsupportedHyperlinkFieldArchive = new UnsupportedHyperlinkFieldArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BibliographySmartFieldArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.BibliographySmartFieldArchive", [
            { no: 3, name: "super", kind: "message", T: () => exports.SmartFieldArchive },
            { no: 2, name: "citation_records", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.Reference },
            { no: 4, name: "localizable", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 1, name: "old_super", kind: "message", T: () => exports.PlaceholderSmartFieldArchive }
        ]);
    }
    create(value) {
        const message = { citationRecords: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.SmartFieldArchive super */ 3:
                    message.super = exports.SmartFieldArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSP.Reference citation_records */ 2:
                    message.citationRecords.push(TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool localizable */ 4:
                    message.localizable = reader.bool();
                    break;
                case /* optional TSWP.PlaceholderSmartFieldArchive old_super */ 1:
                    message.oldSuper = exports.PlaceholderSmartFieldArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldSuper);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.SmartFieldArchive super = 3; */
        if (message.super)
            exports.SmartFieldArchive.internalBinaryWrite(message.super, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference citation_records = 2; */
        for (let i = 0; i < message.citationRecords.length; i++)
            TSPMessages_5.Reference.internalBinaryWrite(message.citationRecords[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool localizable = 4; */
        if (message.localizable !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.localizable);
        /* optional TSWP.PlaceholderSmartFieldArchive old_super = 1; */
        if (message.oldSuper)
            exports.PlaceholderSmartFieldArchive.internalBinaryWrite(message.oldSuper, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.BibliographySmartFieldArchive
 */
exports.BibliographySmartFieldArchive = new BibliographySmartFieldArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CitationRecordArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.CitationRecordArchive", [
            { no: 1, name: "endnote_xml", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "hide_author_names", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "hide_year", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "page_range", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "prefix", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "suffix", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "authors_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "title", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "year", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string endnote_xml */ 1:
                    message.endnoteXml = reader.string();
                    break;
                case /* optional bool hide_author_names */ 2:
                    message.hideAuthorNames = reader.bool();
                    break;
                case /* optional bool hide_year */ 3:
                    message.hideYear = reader.bool();
                    break;
                case /* optional string page_range */ 4:
                    message.pageRange = reader.string();
                    break;
                case /* optional string prefix */ 5:
                    message.prefix = reader.string();
                    break;
                case /* optional string suffix */ 6:
                    message.suffix = reader.string();
                    break;
                case /* optional string authors_string */ 7:
                    message.authorsString = reader.string();
                    break;
                case /* optional string title */ 8:
                    message.title = reader.string();
                    break;
                case /* optional string year */ 9:
                    message.year = reader.string();
                    break;
                case /* optional string type */ 10:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string endnote_xml = 1; */
        if (message.endnoteXml !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.endnoteXml);
        /* optional bool hide_author_names = 2; */
        if (message.hideAuthorNames !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).bool(message.hideAuthorNames);
        /* optional bool hide_year = 3; */
        if (message.hideYear !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.hideYear);
        /* optional string page_range = 4; */
        if (message.pageRange !== undefined)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.pageRange);
        /* optional string prefix = 5; */
        if (message.prefix !== undefined)
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.prefix);
        /* optional string suffix = 6; */
        if (message.suffix !== undefined)
            writer.tag(6, runtime_1.WireType.LengthDelimited).string(message.suffix);
        /* optional string authors_string = 7; */
        if (message.authorsString !== undefined)
            writer.tag(7, runtime_1.WireType.LengthDelimited).string(message.authorsString);
        /* optional string title = 8; */
        if (message.title !== undefined)
            writer.tag(8, runtime_1.WireType.LengthDelimited).string(message.title);
        /* optional string year = 9; */
        if (message.year !== undefined)
            writer.tag(9, runtime_1.WireType.LengthDelimited).string(message.year);
        /* optional string type = 10; */
        if (message.type !== undefined)
            writer.tag(10, runtime_1.WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.CitationRecordArchive
 */
exports.CitationRecordArchive = new CitationRecordArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CitationSmartFieldArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.CitationSmartFieldArchive", [
            { no: 3, name: "super", kind: "message", T: () => exports.SmartFieldArchive },
            { no: 2, name: "citation_records", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.Reference },
            { no: 4, name: "localizable", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 1, name: "old_super", kind: "message", T: () => exports.PlaceholderSmartFieldArchive }
        ]);
    }
    create(value) {
        const message = { citationRecords: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.SmartFieldArchive super */ 3:
                    message.super = exports.SmartFieldArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSP.Reference citation_records */ 2:
                    message.citationRecords.push(TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool localizable */ 4:
                    message.localizable = reader.bool();
                    break;
                case /* optional TSWP.PlaceholderSmartFieldArchive old_super */ 1:
                    message.oldSuper = exports.PlaceholderSmartFieldArchive.internalBinaryRead(reader, reader.uint32(), options, message.oldSuper);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.SmartFieldArchive super = 3; */
        if (message.super)
            exports.SmartFieldArchive.internalBinaryWrite(message.super, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference citation_records = 2; */
        for (let i = 0; i < message.citationRecords.length; i++)
            TSPMessages_5.Reference.internalBinaryWrite(message.citationRecords[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool localizable = 4; */
        if (message.localizable !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.localizable);
        /* optional TSWP.PlaceholderSmartFieldArchive old_super = 1; */
        if (message.oldSuper)
            exports.PlaceholderSmartFieldArchive.internalBinaryWrite(message.oldSuper, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.CitationSmartFieldArchive
 */
exports.CitationSmartFieldArchive = new CitationSmartFieldArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DateTimeSmartFieldArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.DateTimeSmartFieldArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.SmartFieldArchive },
            { no: 2, name: "format", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "locale_identifier", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "date_style", kind: "enum", opt: true, T: () => ["TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle", DateTimeSmartFieldArchive_DateTimeFormatterStyle] },
            { no: 5, name: "time_style", kind: "enum", opt: true, T: () => ["TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle", DateTimeSmartFieldArchive_DateTimeFormatterStyle] },
            { no: 6, name: "update_plan", kind: "enum", opt: true, T: () => ["TSWP.DateTimeSmartFieldArchive.DateTimeUpdatePlan", DateTimeSmartFieldArchive_DateTimeUpdatePlan] },
            { no: 7, name: "needs_update", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "date", kind: "message", T: () => TSPMessages_1.Date }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.SmartFieldArchive super */ 1:
                    message.super = exports.SmartFieldArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional string format */ 2:
                    message.format = reader.string();
                    break;
                case /* optional string locale_identifier */ 3:
                    message.localeIdentifier = reader.string();
                    break;
                case /* optional TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle date_style */ 4:
                    message.dateStyle = reader.int32();
                    break;
                case /* optional TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle time_style */ 5:
                    message.timeStyle = reader.int32();
                    break;
                case /* optional TSWP.DateTimeSmartFieldArchive.DateTimeUpdatePlan update_plan */ 6:
                    message.updatePlan = reader.int32();
                    break;
                case /* optional bool needs_update */ 7:
                    message.needsUpdate = reader.bool();
                    break;
                case /* optional TSP.Date date */ 8:
                    message.date = TSPMessages_1.Date.internalBinaryRead(reader, reader.uint32(), options, message.date);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.SmartFieldArchive super = 1; */
        if (message.super)
            exports.SmartFieldArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string format = 2; */
        if (message.format !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.format);
        /* optional string locale_identifier = 3; */
        if (message.localeIdentifier !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.localeIdentifier);
        /* optional TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle date_style = 4; */
        if (message.dateStyle !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).int32(message.dateStyle);
        /* optional TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle time_style = 5; */
        if (message.timeStyle !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).int32(message.timeStyle);
        /* optional TSWP.DateTimeSmartFieldArchive.DateTimeUpdatePlan update_plan = 6; */
        if (message.updatePlan !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).int32(message.updatePlan);
        /* optional bool needs_update = 7; */
        if (message.needsUpdate !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.needsUpdate);
        /* optional TSP.Date date = 8; */
        if (message.date)
            TSPMessages_1.Date.internalBinaryWrite(message.date, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.DateTimeSmartFieldArchive
 */
exports.DateTimeSmartFieldArchive = new DateTimeSmartFieldArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BookmarkFieldArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.BookmarkFieldArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.SmartFieldArchive },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ranged", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "hidden", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.SmartFieldArchive super */ 1:
                    message.super = exports.SmartFieldArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional uint32 ranged */ 3:
                    message.ranged = reader.uint32();
                    break;
                case /* optional uint32 hidden */ 4:
                    message.hidden = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.SmartFieldArchive super = 1; */
        if (message.super)
            exports.SmartFieldArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.name);
        /* optional uint32 ranged = 3; */
        if (message.ranged !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.ranged);
        /* optional uint32 hidden = 4; */
        if (message.hidden !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.hidden);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.BookmarkFieldArchive
 */
exports.BookmarkFieldArchive = new BookmarkFieldArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FilenameSmartFieldArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.FilenameSmartFieldArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.PlaceholderSmartFieldArchive },
            { no: 2, name: "display_flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.PlaceholderSmartFieldArchive super */ 1:
                    message.super = exports.PlaceholderSmartFieldArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional uint32 display_flags */ 2:
                    message.displayFlags = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.PlaceholderSmartFieldArchive super = 1; */
        if (message.super)
            exports.PlaceholderSmartFieldArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 display_flags = 2; */
        if (message.displayFlags !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.displayFlags);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.FilenameSmartFieldArchive
 */
exports.FilenameSmartFieldArchive = new FilenameSmartFieldArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MergeFieldTypeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.MergeFieldTypeArchive", [
            { no: 2, name: "contacts_property", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "contacts_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "contacts_label", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "table_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string contacts_property */ 2:
                    message.contactsProperty = reader.string();
                    break;
                case /* optional string contacts_key */ 3:
                    message.contactsKey = reader.string();
                    break;
                case /* optional string contacts_label */ 4:
                    message.contactsLabel = reader.string();
                    break;
                case /* optional string table_key */ 5:
                    message.tableKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string contacts_property = 2; */
        if (message.contactsProperty !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.contactsProperty);
        /* optional string contacts_key = 3; */
        if (message.contactsKey !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.contactsKey);
        /* optional string contacts_label = 4; */
        if (message.contactsLabel !== undefined)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.contactsLabel);
        /* optional string table_key = 5; */
        if (message.tableKey !== undefined)
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.tableKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.MergeFieldTypeArchive
 */
exports.MergeFieldTypeArchive = new MergeFieldTypeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MergeSmartFieldArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.MergeSmartFieldArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.PlaceholderSmartFieldArchive },
            { no: 2, name: "contacts_property", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "contacts_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "contacts_label", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "category", kind: "enum", opt: true, T: () => ["TSWP.MergeSmartFieldArchive.MergeCategory", MergeSmartFieldArchive_MergeCategory] },
            { no: 6, name: "requires_following_whitespace", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "whitespace", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "guid", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "table_key", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "field_type", kind: "message", T: () => exports.MergeFieldTypeArchive },
            { no: 11, name: "has_custom_text", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.PlaceholderSmartFieldArchive super */ 1:
                    message.super = exports.PlaceholderSmartFieldArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional string contacts_property */ 2:
                    message.contactsProperty = reader.string();
                    break;
                case /* optional string contacts_key */ 3:
                    message.contactsKey = reader.string();
                    break;
                case /* optional string contacts_label */ 4:
                    message.contactsLabel = reader.string();
                    break;
                case /* optional TSWP.MergeSmartFieldArchive.MergeCategory category */ 5:
                    message.category = reader.int32();
                    break;
                case /* optional bool requires_following_whitespace */ 6:
                    message.requiresFollowingWhitespace = reader.bool();
                    break;
                case /* optional string whitespace */ 7:
                    message.whitespace = reader.string();
                    break;
                case /* optional string guid */ 8:
                    message.guid = reader.string();
                    break;
                case /* optional string table_key */ 9:
                    message.tableKey = reader.string();
                    break;
                case /* optional TSWP.MergeFieldTypeArchive field_type */ 10:
                    message.fieldType = exports.MergeFieldTypeArchive.internalBinaryRead(reader, reader.uint32(), options, message.fieldType);
                    break;
                case /* optional bool has_custom_text */ 11:
                    message.hasCustomText = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.PlaceholderSmartFieldArchive super = 1; */
        if (message.super)
            exports.PlaceholderSmartFieldArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string contacts_property = 2; */
        if (message.contactsProperty !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.contactsProperty);
        /* optional string contacts_key = 3; */
        if (message.contactsKey !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.contactsKey);
        /* optional string contacts_label = 4; */
        if (message.contactsLabel !== undefined)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.contactsLabel);
        /* optional TSWP.MergeSmartFieldArchive.MergeCategory category = 5; */
        if (message.category !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).int32(message.category);
        /* optional bool requires_following_whitespace = 6; */
        if (message.requiresFollowingWhitespace !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.requiresFollowingWhitespace);
        /* optional string whitespace = 7; */
        if (message.whitespace !== undefined)
            writer.tag(7, runtime_1.WireType.LengthDelimited).string(message.whitespace);
        /* optional string guid = 8; */
        if (message.guid !== undefined)
            writer.tag(8, runtime_1.WireType.LengthDelimited).string(message.guid);
        /* optional string table_key = 9; */
        if (message.tableKey !== undefined)
            writer.tag(9, runtime_1.WireType.LengthDelimited).string(message.tableKey);
        /* optional TSWP.MergeFieldTypeArchive field_type = 10; */
        if (message.fieldType)
            exports.MergeFieldTypeArchive.internalBinaryWrite(message.fieldType, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool has_custom_text = 11; */
        if (message.hasCustomText !== undefined)
            writer.tag(11, runtime_1.WireType.Varint).bool(message.hasCustomText);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.MergeSmartFieldArchive
 */
exports.MergeSmartFieldArchive = new MergeSmartFieldArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TOCSmartFieldArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.TOCSmartFieldArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.PlaceholderSmartFieldArchive },
            { no: 2, name: "toc_entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.TOCSmartFieldArchive_TOCEntry }
        ]);
    }
    create(value) {
        const message = { tocEntries: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.PlaceholderSmartFieldArchive super */ 1:
                    message.super = exports.PlaceholderSmartFieldArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSWP.TOCSmartFieldArchive.TOCEntry toc_entries */ 2:
                    message.tocEntries.push(exports.TOCSmartFieldArchive_TOCEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.PlaceholderSmartFieldArchive super = 1; */
        if (message.super)
            exports.PlaceholderSmartFieldArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSWP.TOCSmartFieldArchive.TOCEntry toc_entries = 2; */
        for (let i = 0; i < message.tocEntries.length; i++)
            exports.TOCSmartFieldArchive_TOCEntry.internalBinaryWrite(message.tocEntries[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.TOCSmartFieldArchive
 */
exports.TOCSmartFieldArchive = new TOCSmartFieldArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TOCSmartFieldArchive_TOCEntry$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.TOCSmartFieldArchive.TOCEntry", [
            { no: 1, name: "bookmark_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "target_style", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 3, name: "range", kind: "message", T: () => TSPMessages_6.Range }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string bookmark_name */ 1:
                    message.bookmarkName = reader.string();
                    break;
                case /* optional TSP.Reference target_style */ 2:
                    message.targetStyle = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.targetStyle);
                    break;
                case /* optional TSP.Range range */ 3:
                    message.range = TSPMessages_6.Range.internalBinaryRead(reader, reader.uint32(), options, message.range);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional string bookmark_name = 1; */
        if (message.bookmarkName !== undefined)
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.bookmarkName);
        /* optional TSP.Reference target_style = 2; */
        if (message.targetStyle)
            TSPMessages_5.Reference.internalBinaryWrite(message.targetStyle, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Range range = 3; */
        if (message.range)
            TSPMessages_6.Range.internalBinaryWrite(message.range, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.TOCSmartFieldArchive.TOCEntry
 */
exports.TOCSmartFieldArchive_TOCEntry = new TOCSmartFieldArchive_TOCEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RubyFieldArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.RubyFieldArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.SmartFieldArchive },
            { no: 2, name: "ruby_text", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.SmartFieldArchive super */ 1:
                    message.super = exports.SmartFieldArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional string ruby_text */ 2:
                    message.rubyText = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.SmartFieldArchive super = 1; */
        if (message.super)
            exports.SmartFieldArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string ruby_text = 2; */
        if (message.rubyText !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.rubyText);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.RubyFieldArchive
 */
exports.RubyFieldArchive = new RubyFieldArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TateChuYokoFieldArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.TateChuYokoFieldArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.SmartFieldArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.SmartFieldArchive super */ 1:
                    message.super = exports.SmartFieldArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.SmartFieldArchive super = 1; */
        if (message.super)
            exports.SmartFieldArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.TateChuYokoFieldArchive
 */
exports.TateChuYokoFieldArchive = new TateChuYokoFieldArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ChangeArchive", [
            { no: 1, name: "kind", kind: "enum", opt: true, T: () => ["TSWP.ChangeArchive.ChangeKind", ChangeArchive_ChangeKind] },
            { no: 2, name: "session", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 3, name: "date", kind: "message", T: () => TSPMessages_1.Date },
            { no: 4, name: "text_attribute_uuid_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.ChangeArchive.ChangeKind kind */ 1:
                    message.kind = reader.int32();
                    break;
                case /* optional TSP.Reference session */ 2:
                    message.session = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.session);
                    break;
                case /* optional TSP.Date date */ 3:
                    message.date = TSPMessages_1.Date.internalBinaryRead(reader, reader.uint32(), options, message.date);
                    break;
                case /* optional string text_attribute_uuid_string */ 4:
                    message.textAttributeUuidString = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.ChangeArchive.ChangeKind kind = 1; */
        if (message.kind !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.kind);
        /* optional TSP.Reference session = 2; */
        if (message.session)
            TSPMessages_5.Reference.internalBinaryWrite(message.session, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Date date = 3; */
        if (message.date)
            TSPMessages_1.Date.internalBinaryWrite(message.date, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string text_attribute_uuid_string = 4; */
        if (message.textAttributeUuidString !== undefined)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.textAttributeUuidString);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ChangeArchive
 */
exports.ChangeArchive = new ChangeArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeSessionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ChangeSessionArchive", [
            { no: 1, name: "session_uid", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "author", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 3, name: "date", kind: "message", T: () => TSPMessages_1.Date }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 session_uid */ 1:
                    message.sessionUid = reader.uint32();
                    break;
                case /* optional TSP.Reference author */ 2:
                    message.author = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.author);
                    break;
                case /* optional TSP.Date date */ 3:
                    message.date = TSPMessages_1.Date.internalBinaryRead(reader, reader.uint32(), options, message.date);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional uint32 session_uid = 1; */
        if (message.sessionUid !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.sessionUid);
        /* optional TSP.Reference author = 2; */
        if (message.author)
            TSPMessages_5.Reference.internalBinaryWrite(message.author, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Date date = 3; */
        if (message.date)
            TSPMessages_1.Date.internalBinaryWrite(message.date, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ChangeSessionArchive
 */
exports.ChangeSessionArchive = new ChangeSessionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SectionPlaceholderArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.SectionPlaceholderArchive", [
            { no: 1, name: "parent_storage", kind: "message", T: () => TSPMessages_5.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference parent_storage */ 1:
                    message.parentStorage = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.parentStorage);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference parent_storage = 1; */
        if (message.parentStorage)
            TSPMessages_5.Reference.internalBinaryWrite(message.parentStorage, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.SectionPlaceholderArchive
 */
exports.SectionPlaceholderArchive = new SectionPlaceholderArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HyperlinkSelectionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.HyperlinkSelectionArchive", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.HyperlinkSelectionArchive
 */
exports.HyperlinkSelectionArchive = new HyperlinkSelectionArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FlowInfoArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.FlowInfoArchive", [
            { no: 1, name: "text_storage", kind: "message", T: () => TSPMessages_5.Reference },
            { no: 2, name: "textboxes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.Reference },
            { no: 3, name: "user_interface_identifier", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { textboxes: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSP.Reference text_storage */ 1:
                    message.textStorage = TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options, message.textStorage);
                    break;
                case /* repeated TSP.Reference textboxes */ 2:
                    message.textboxes.push(TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 user_interface_identifier */ 3:
                    message.userInterfaceIdentifier = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSP.Reference text_storage = 1; */
        if (message.textStorage)
            TSPMessages_5.Reference.internalBinaryWrite(message.textStorage, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference textboxes = 2; */
        for (let i = 0; i < message.textboxes.length; i++)
            TSPMessages_5.Reference.internalBinaryWrite(message.textboxes[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 user_interface_identifier = 3; */
        if (message.userInterfaceIdentifier !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.userInterfaceIdentifier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.FlowInfoArchive
 */
exports.FlowInfoArchive = new FlowInfoArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FlowInfoContainerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.FlowInfoContainerArchive", [
            { no: 1, name: "flow_infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.Reference },
            { no: 2, name: "next_user_interface_identifier", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { flowInfos: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSP.Reference flow_infos */ 1:
                    message.flowInfos.push(TSPMessages_5.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 next_user_interface_identifier */ 2:
                    message.nextUserInterfaceIdentifier = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSP.Reference flow_infos = 1; */
        for (let i = 0; i < message.flowInfos.length; i++)
            TSPMessages_5.Reference.internalBinaryWrite(message.flowInfos[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 next_user_interface_identifier = 2; */
        if (message.nextUserInterfaceIdentifier !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.nextUserInterfaceIdentifier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.FlowInfoContainerArchive
 */
exports.FlowInfoContainerArchive = new FlowInfoContainerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DropCapArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.DropCapArchive", [
            { no: 1, name: "type", kind: "enum", opt: true, T: () => ["TSWP.DropCapArchive.DropCapType", DropCapArchive_DropCapType] },
            { no: 2, name: "number_of_lines", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "number_of_raised_lines", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "deprecated_outdent", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "outdent", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "deprecated_padding", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "padding", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "wrap_type", kind: "enum", opt: true, T: () => ["TSWP.DropCapArchive.DropCapWrapType", DropCapArchive_DropCapWrapType] },
            { no: 7, name: "shape_enabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "deprecated_corner_radius", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 13, name: "corner_radius", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 9, name: "deprecated_character_scale", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 14, name: "character_scale", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 10, name: "number_of_characters", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.DropCapArchive.DropCapType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional uint32 number_of_lines */ 2:
                    message.numberOfLines = reader.uint32();
                    break;
                case /* optional uint32 number_of_raised_lines */ 3:
                    message.numberOfRaisedLines = reader.uint32();
                    break;
                case /* optional float deprecated_outdent */ 4:
                    message.deprecatedOutdent = reader.float();
                    break;
                case /* optional double outdent */ 11:
                    message.outdent = reader.double();
                    break;
                case /* optional float deprecated_padding */ 5:
                    message.deprecatedPadding = reader.float();
                    break;
                case /* optional double padding */ 12:
                    message.padding = reader.double();
                    break;
                case /* optional TSWP.DropCapArchive.DropCapWrapType wrap_type */ 6:
                    message.wrapType = reader.int32();
                    break;
                case /* optional bool shape_enabled */ 7:
                    message.shapeEnabled = reader.bool();
                    break;
                case /* optional float deprecated_corner_radius */ 8:
                    message.deprecatedCornerRadius = reader.float();
                    break;
                case /* optional double corner_radius */ 13:
                    message.cornerRadius = reader.double();
                    break;
                case /* optional float deprecated_character_scale */ 9:
                    message.deprecatedCharacterScale = reader.float();
                    break;
                case /* optional double character_scale */ 14:
                    message.characterScale = reader.double();
                    break;
                case /* optional uint32 number_of_characters */ 10:
                    message.numberOfCharacters = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.DropCapArchive.DropCapType type = 1; */
        if (message.type !== undefined)
            writer.tag(1, runtime_1.WireType.Varint).int32(message.type);
        /* optional uint32 number_of_lines = 2; */
        if (message.numberOfLines !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.numberOfLines);
        /* optional uint32 number_of_raised_lines = 3; */
        if (message.numberOfRaisedLines !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.numberOfRaisedLines);
        /* optional float deprecated_outdent = 4; */
        if (message.deprecatedOutdent !== undefined)
            writer.tag(4, runtime_1.WireType.Bit32).float(message.deprecatedOutdent);
        /* optional double outdent = 11; */
        if (message.outdent !== undefined)
            writer.tag(11, runtime_1.WireType.Bit64).double(message.outdent);
        /* optional float deprecated_padding = 5; */
        if (message.deprecatedPadding !== undefined)
            writer.tag(5, runtime_1.WireType.Bit32).float(message.deprecatedPadding);
        /* optional double padding = 12; */
        if (message.padding !== undefined)
            writer.tag(12, runtime_1.WireType.Bit64).double(message.padding);
        /* optional TSWP.DropCapArchive.DropCapWrapType wrap_type = 6; */
        if (message.wrapType !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).int32(message.wrapType);
        /* optional bool shape_enabled = 7; */
        if (message.shapeEnabled !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.shapeEnabled);
        /* optional float deprecated_corner_radius = 8; */
        if (message.deprecatedCornerRadius !== undefined)
            writer.tag(8, runtime_1.WireType.Bit32).float(message.deprecatedCornerRadius);
        /* optional double corner_radius = 13; */
        if (message.cornerRadius !== undefined)
            writer.tag(13, runtime_1.WireType.Bit64).double(message.cornerRadius);
        /* optional float deprecated_character_scale = 9; */
        if (message.deprecatedCharacterScale !== undefined)
            writer.tag(9, runtime_1.WireType.Bit32).float(message.deprecatedCharacterScale);
        /* optional double character_scale = 14; */
        if (message.characterScale !== undefined)
            writer.tag(14, runtime_1.WireType.Bit64).double(message.characterScale);
        /* optional uint32 number_of_characters = 10; */
        if (message.numberOfCharacters !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).uint32(message.numberOfCharacters);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.DropCapArchive
 */
exports.DropCapArchive = new DropCapArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DropCapStylePropertiesArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.DropCapStylePropertiesArchive", [
            { no: 1, name: "drop_cap", kind: "message", T: () => exports.DropCapArchive },
            { no: 3, name: "drop_cap_shape_stroke", kind: "message", T: () => TSDArchives_4.StrokeArchive },
            { no: 4, name: "drop_cap_shape_fill_null", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "drop_cap_shape_fill", kind: "message", T: () => TSDArchives_3.FillArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.DropCapArchive drop_cap */ 1:
                    message.dropCap = exports.DropCapArchive.internalBinaryRead(reader, reader.uint32(), options, message.dropCap);
                    break;
                case /* optional TSD.StrokeArchive drop_cap_shape_stroke */ 3:
                    message.dropCapShapeStroke = TSDArchives_4.StrokeArchive.internalBinaryRead(reader, reader.uint32(), options, message.dropCapShapeStroke);
                    break;
                case /* optional bool drop_cap_shape_fill_null */ 4:
                    message.dropCapShapeFillNull = reader.bool();
                    break;
                case /* optional TSD.FillArchive drop_cap_shape_fill */ 5:
                    message.dropCapShapeFill = TSDArchives_3.FillArchive.internalBinaryRead(reader, reader.uint32(), options, message.dropCapShapeFill);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.DropCapArchive drop_cap = 1; */
        if (message.dropCap)
            exports.DropCapArchive.internalBinaryWrite(message.dropCap, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.StrokeArchive drop_cap_shape_stroke = 3; */
        if (message.dropCapShapeStroke)
            TSDArchives_4.StrokeArchive.internalBinaryWrite(message.dropCapShapeStroke, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool drop_cap_shape_fill_null = 4; */
        if (message.dropCapShapeFillNull !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.dropCapShapeFillNull);
        /* optional TSD.FillArchive drop_cap_shape_fill = 5; */
        if (message.dropCapShapeFill)
            TSDArchives_3.FillArchive.internalBinaryWrite(message.dropCapShapeFill, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.DropCapStylePropertiesArchive
 */
exports.DropCapStylePropertiesArchive = new DropCapStylePropertiesArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DropCapStyleArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.DropCapStyleArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSSArchives_1.StyleArchive },
            { no: 10, name: "override_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "char_properties", kind: "message", T: () => exports.CharacterStylePropertiesArchive },
            { no: 12, name: "drop_cap_properties", kind: "message", T: () => exports.DropCapStylePropertiesArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSS.StyleArchive super */ 1:
                    message.super = TSSArchives_1.StyleArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional uint32 override_count */ 10:
                    message.overrideCount = reader.uint32();
                    break;
                case /* optional TSWP.CharacterStylePropertiesArchive char_properties */ 11:
                    message.charProperties = exports.CharacterStylePropertiesArchive.internalBinaryRead(reader, reader.uint32(), options, message.charProperties);
                    break;
                case /* optional TSWP.DropCapStylePropertiesArchive drop_cap_properties */ 12:
                    message.dropCapProperties = exports.DropCapStylePropertiesArchive.internalBinaryRead(reader, reader.uint32(), options, message.dropCapProperties);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSS.StyleArchive super = 1; */
        if (message.super)
            TSSArchives_1.StyleArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 override_count = 10; */
        if (message.overrideCount !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).uint32(message.overrideCount);
        /* optional TSWP.CharacterStylePropertiesArchive char_properties = 11; */
        if (message.charProperties)
            exports.CharacterStylePropertiesArchive.internalBinaryWrite(message.charProperties, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.DropCapStylePropertiesArchive drop_cap_properties = 12; */
        if (message.dropCapProperties)
            exports.DropCapStylePropertiesArchive.internalBinaryWrite(message.dropCapProperties, writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.DropCapStyleArchive
 */
exports.DropCapStyleArchive = new DropCapStyleArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CollaboratorTextCursorSubselectionArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.CollaboratorTextCursorSubselectionArchive", [
            { no: 1, name: "text_selection", kind: "message", T: () => exports.SelectionArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.SelectionArchive text_selection */ 1:
                    message.textSelection = exports.SelectionArchive.internalBinaryRead(reader, reader.uint32(), options, message.textSelection);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.SelectionArchive text_selection = 1; */
        if (message.textSelection)
            exports.SelectionArchive.internalBinaryWrite(message.textSelection, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.CollaboratorTextCursorSubselectionArchive
 */
exports.CollaboratorTextCursorSubselectionArchive = new CollaboratorTextCursorSubselectionArchive$Type();
//# sourceMappingURL=TSWPArchives.js.map