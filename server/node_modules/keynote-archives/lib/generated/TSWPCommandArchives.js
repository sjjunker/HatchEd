"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CharacterStyleChangePropertyCommand_GArchive = exports.EquationInfoGeometryCommandArchive = exports.ContainedObjectsCommandArchive_RearrangeBehaviorArgs = exports.ContainedObjectsCommandArchive_RemoveBehaviorArgs = exports.ContainedObjectsCommandArchive_AddBehaviorArgs = exports.ContainedObjectsCommandArchive = exports.TextCommentReplyCommandArchive = exports.RemoveFlowInfoCommandArchive = exports.AddFlowInfoCommandArchive = exports.UpdateFlowInfoCommandArchive = exports.SetObjectPropertiesCommandArchive = exports.ObjectPropertyArchive = exports.ShapeContentDescription = exports.ShapeSelectionTransformerArchive = exports.PencilAnnotationSelectionTransformerArchive = exports.SelectionTransformerArchive = exports.ShapeStyleSetValueCommandArchive = exports.StyleUpdatePropertyMapCommandArchive = exports.StyleReorderCommandArchive = exports.StyleDeleteCommandArchive = exports.StyleUpdateCommandArchive = exports.StyleRenameCommandArchive = exports.StyleCreateCommandArchive = exports.StyleBaseCommandArchive = exports.ShapeApplyPresetCommandArchive = exports.MoveRowsCommandArchive = exports.MoveColumnsCommandArchive = exports.TextApplyThemeCommandArchive = exports.AnchorAttachmentCommandArchive = exports.ModifyTOCSettingsPresetForThemeCommandArchive = exports.ModifyTOCSettingsForTOCInfoCommandArchive = exports.ModifyTOCSettingsBaseCommandArchive = exports.ModifyRubyTextCommandArchive = exports.ApplyRubyTextCommandArchive = exports.UpdateDateTimeFieldCommandArchive = exports.ApplyPlaceholderTextCommandArchive = exports.MergeCellsCommandArchive = exports.RemoveRowsCommandArchive = exports.RemoveColumnsCommandArchive = exports.InsertRowsCommandArchive = exports.InsertColumnsCommandArchive = exports.ReplaceAllUsesOfStyleCommandArchive = exports.SetColumnStyleCommandArchive = exports.StorageActionCommandArchive = exports.TextCommandArchive = exports.DummyCommandArchive = exports.ObjectPropertyType = exports.UpdateFlowInfoCommandArchive_Mode = exports.StorageActionCommandArchive_Kind = exports.TextCommandArchive_Kind = void 0;
exports.ParagraphStyleChangePropertyCommand_GArchive = void 0;
const runtime_1 = require("@protobuf-ts/runtime");
const runtime_2 = require("@protobuf-ts/runtime");
const runtime_3 = require("@protobuf-ts/runtime");
const runtime_4 = require("@protobuf-ts/runtime");
const runtime_5 = require("@protobuf-ts/runtime");
const TSWPArchives_sos_1 = require("./TSWPArchives_sos");
const TSWPArchives_sos_2 = require("./TSWPArchives_sos");
const TSPMessages_1 = require("./TSPMessages");
const TSDCommandArchives_1 = require("./TSDCommandArchives");
const TSKArchives_1 = require("./TSKArchives");
const TSKArchives_2 = require("./TSKArchives");
const TSKArchives_3 = require("./TSKArchives");
const TSDCommandArchives_2 = require("./TSDCommandArchives");
const TSDArchives_1 = require("./TSDArchives");
const TSPMessages_2 = require("./TSPMessages");
const TSDArchives_2 = require("./TSDArchives");
const TSDArchives_3 = require("./TSDArchives");
const TSDCommandArchives_3 = require("./TSDCommandArchives");
const TSWPArchives_sos_3 = require("./TSWPArchives_sos");
const TSDCommandArchives_4 = require("./TSDCommandArchives");
const TSSArchives_1 = require("./TSSArchives");
const TSDCommandArchives_5 = require("./TSDCommandArchives");
const TSSArchives_2 = require("./TSSArchives");
const TSWPArchives_1 = require("./TSWPArchives");
const TSPMessages_3 = require("./TSPMessages");
const TSWPArchives_2 = require("./TSWPArchives");
const TSKArchives_4 = require("./TSKArchives");
const TSPMessages_4 = require("./TSPMessages");
const TSPMessages_5 = require("./TSPMessages");
const TSWPArchives_3 = require("./TSWPArchives");
const TSPMessages_6 = require("./TSPMessages");
const TSKArchives_5 = require("./TSKArchives");
/**
 * @generated from protobuf enum TSWP.TextCommandArchive.Kind
 */
var TextCommandArchive_Kind;
(function (TextCommandArchive_Kind) {
    /**
     * @generated from protobuf enum value: kKindContained = 0;
     */
    TextCommandArchive_Kind[TextCommandArchive_Kind["kKindContained"] = 0] = "kKindContained";
    /**
     * @generated from protobuf enum value: kKindReplaceText = 1;
     */
    TextCommandArchive_Kind[TextCommandArchive_Kind["kKindReplaceText"] = 1] = "kKindReplaceText";
    /**
     * @generated from protobuf enum value: kKindPaste = 2;
     */
    TextCommandArchive_Kind[TextCommandArchive_Kind["kKindPaste"] = 2] = "kKindPaste";
    /**
     * @generated from protobuf enum value: kKindParagraphStyle = 3;
     */
    TextCommandArchive_Kind[TextCommandArchive_Kind["kKindParagraphStyle"] = 3] = "kKindParagraphStyle";
    /**
     * @generated from protobuf enum value: kKindListStyle = 4;
     */
    TextCommandArchive_Kind[TextCommandArchive_Kind["kKindListStyle"] = 4] = "kKindListStyle";
    /**
     * @generated from protobuf enum value: kKindIndentParagraphLevel = 5;
     */
    TextCommandArchive_Kind[TextCommandArchive_Kind["kKindIndentParagraphLevel"] = 5] = "kKindIndentParagraphLevel";
    /**
     * @generated from protobuf enum value: kKindDragText = 6;
     */
    TextCommandArchive_Kind[TextCommandArchive_Kind["kKindDragText"] = 6] = "kKindDragText";
    /**
     * @generated from protobuf enum value: kKindPasteStyle = 7;
     */
    TextCommandArchive_Kind[TextCommandArchive_Kind["kKindPasteStyle"] = 7] = "kKindPasteStyle";
    /**
     * @generated from protobuf enum value: kKindApplyChangesInRange = 8;
     */
    TextCommandArchive_Kind[TextCommandArchive_Kind["kKindApplyChangesInRange"] = 8] = "kKindApplyChangesInRange";
    /**
     * @generated from protobuf enum value: kKindInsertCitationField = 10;
     */
    TextCommandArchive_Kind[TextCommandArchive_Kind["kKindInsertCitationField"] = 10] = "kKindInsertCitationField";
    /**
     * @generated from protobuf enum value: kKindInsertBibliographyEntry = 11;
     */
    TextCommandArchive_Kind[TextCommandArchive_Kind["kKindInsertBibliographyEntry"] = 11] = "kKindInsertBibliographyEntry";
    /**
     * @generated from protobuf enum value: kKindFormatCitationFields = 12;
     */
    TextCommandArchive_Kind[TextCommandArchive_Kind["kKindFormatCitationFields"] = 12] = "kKindFormatCitationFields";
    /**
     * @generated from protobuf enum value: kKindInsertTOCSmartField = 13;
     */
    TextCommandArchive_Kind[TextCommandArchive_Kind["kKindInsertTOCSmartField"] = 13] = "kKindInsertTOCSmartField";
    /**
     * @generated from protobuf enum value: kKindInsertDateTimeField = 14;
     */
    TextCommandArchive_Kind[TextCommandArchive_Kind["kKindInsertDateTimeField"] = 14] = "kKindInsertDateTimeField";
    /**
     * @generated from protobuf enum value: kKindUpdateDateTimeField = 15;
     */
    TextCommandArchive_Kind[TextCommandArchive_Kind["kKindUpdateDateTimeField"] = 15] = "kKindUpdateDateTimeField";
    /**
     * @generated from protobuf enum value: kKindSetParagraphFirstTopicNumber = 16;
     */
    TextCommandArchive_Kind[TextCommandArchive_Kind["kKindSetParagraphFirstTopicNumber"] = 16] = "kKindSetParagraphFirstTopicNumber";
    /**
     * @generated from protobuf enum value: kKindCharacterStyle = 17;
     */
    TextCommandArchive_Kind[TextCommandArchive_Kind["kKindCharacterStyle"] = 17] = "kKindCharacterStyle";
    /**
     * @generated from protobuf enum value: kKindRevertStyles = 18;
     */
    TextCommandArchive_Kind[TextCommandArchive_Kind["kKindRevertStyles"] = 18] = "kKindRevertStyles";
    /**
     * @generated from protobuf enum value: kKindSetParagraphBidi = 19;
     */
    TextCommandArchive_Kind[TextCommandArchive_Kind["kKindSetParagraphBidi"] = 19] = "kKindSetParagraphBidi";
})(TextCommandArchive_Kind = exports.TextCommandArchive_Kind || (exports.TextCommandArchive_Kind = {}));
/**
 * @generated from protobuf enum TSWP.StorageActionCommandArchive.Kind
 */
var StorageActionCommandArchive_Kind;
(function (StorageActionCommandArchive_Kind) {
    /**
     * @generated from protobuf enum value: kKindContained = 0;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindContained"] = 0] = "kKindContained";
    /**
     * @generated from protobuf enum value: kKindReplaceText = 1;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindReplaceText"] = 1] = "kKindReplaceText";
    /**
     * @generated from protobuf enum value: kKindPaste = 2;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindPaste"] = 2] = "kKindPaste";
    /**
     * @generated from protobuf enum value: kKindParagraphStyle = 3;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindParagraphStyle"] = 3] = "kKindParagraphStyle";
    /**
     * @generated from protobuf enum value: kKindListStyle = 4;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindListStyle"] = 4] = "kKindListStyle";
    /**
     * @generated from protobuf enum value: kKindIndentParagraphLevel = 5;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindIndentParagraphLevel"] = 5] = "kKindIndentParagraphLevel";
    /**
     * @generated from protobuf enum value: kKindDragText = 6;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindDragText"] = 6] = "kKindDragText";
    /**
     * @generated from protobuf enum value: kKindPasteStyle = 7;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindPasteStyle"] = 7] = "kKindPasteStyle";
    /**
     * @generated from protobuf enum value: kKindApplyChangesInRange = 8;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindApplyChangesInRange"] = 8] = "kKindApplyChangesInRange";
    /**
     * @generated from protobuf enum value: kKindInsertCitationField = 10;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindInsertCitationField"] = 10] = "kKindInsertCitationField";
    /**
     * @generated from protobuf enum value: kKindInsertBibliographyEntry = 11;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindInsertBibliographyEntry"] = 11] = "kKindInsertBibliographyEntry";
    /**
     * @generated from protobuf enum value: kKindFormatCitationFields = 12;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindFormatCitationFields"] = 12] = "kKindFormatCitationFields";
    /**
     * @generated from protobuf enum value: kKindInsertTOCSmartField = 13;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindInsertTOCSmartField"] = 13] = "kKindInsertTOCSmartField";
    /**
     * @generated from protobuf enum value: kKindInsertDateTimeField = 14;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindInsertDateTimeField"] = 14] = "kKindInsertDateTimeField";
    /**
     * @generated from protobuf enum value: kKindUpdateDateTimeField = 15;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindUpdateDateTimeField"] = 15] = "kKindUpdateDateTimeField";
    /**
     * @generated from protobuf enum value: kKindSetParagraphFirstTopicNumber = 16;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindSetParagraphFirstTopicNumber"] = 16] = "kKindSetParagraphFirstTopicNumber";
    /**
     * @generated from protobuf enum value: kKindCharacterStyle = 17;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindCharacterStyle"] = 17] = "kKindCharacterStyle";
    /**
     * @generated from protobuf enum value: kKindRevertStyles = 18;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindRevertStyles"] = 18] = "kKindRevertStyles";
    /**
     * @generated from protobuf enum value: kKindSetParagraphBidi = 19;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindSetParagraphBidi"] = 19] = "kKindSetParagraphBidi";
    /**
     * @generated from protobuf enum value: kKindFormatText = 20;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindFormatText"] = 20] = "kKindFormatText";
    /**
     * @generated from protobuf enum value: kKindInsertAttachment = 21;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindInsertAttachment"] = 21] = "kKindInsertAttachment";
    /**
     * @generated from protobuf enum value: kKindCreateHyperlink = 22;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindCreateHyperlink"] = 22] = "kKindCreateHyperlink";
    /**
     * @generated from protobuf enum value: kKindModifyHyperlink = 23;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindModifyHyperlink"] = 23] = "kKindModifyHyperlink";
    /**
     * @generated from protobuf enum value: kKindRemoveHyperlink = 24;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindRemoveHyperlink"] = 24] = "kKindRemoveHyperlink";
    /**
     * @generated from protobuf enum value: kKindApplyHighlightText = 25;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindApplyHighlightText"] = 25] = "kKindApplyHighlightText";
    /**
     * @generated from protobuf enum value: kKindPropagateStyleChanges = 26;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindPropagateStyleChanges"] = 26] = "kKindPropagateStyleChanges";
    /**
     * @generated from protobuf enum value: kKindMovedAnchoredDrawableInline = 27;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindMovedAnchoredDrawableInline"] = 27] = "kKindMovedAnchoredDrawableInline";
    /**
     * @generated from protobuf enum value: kKindMoveDrawablesAttached = 28;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindMoveDrawablesAttached"] = 28] = "kKindMoveDrawablesAttached";
    /**
     * @generated from protobuf enum value: kKindMoveMoveDrawablesFloating = 29;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindMoveMoveDrawablesFloating"] = 29] = "kKindMoveMoveDrawablesFloating";
    /**
     * @generated from protobuf enum value: kKindMoveInlineDrawableAnchored = 30;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindMoveInlineDrawableAnchored"] = 30] = "kKindMoveInlineDrawableAnchored";
    /**
     * @generated from protobuf enum value: kKindAnchorAttachment = 31;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindAnchorAttachment"] = 31] = "kKindAnchorAttachment";
    /**
     * @generated from protobuf enum value: kKindBookmark = 32;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindBookmark"] = 32] = "kKindBookmark";
    /**
     * @generated from protobuf enum value: kKindReplaceSection = 33;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindReplaceSection"] = 33] = "kKindReplaceSection";
    /**
     * @generated from protobuf enum value: kKindApplyPencilAnnotation = 34;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindApplyPencilAnnotation"] = 34] = "kKindApplyPencilAnnotation";
    /**
     * @generated from protobuf enum value: kKindCreateRuby = 35;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindCreateRuby"] = 35] = "kKindCreateRuby";
    /**
     * @generated from protobuf enum value: kKindModifyRuby = 36;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindModifyRuby"] = 36] = "kKindModifyRuby";
    /**
     * @generated from protobuf enum value: kKindRemoveRuby = 37;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindRemoveRuby"] = 37] = "kKindRemoveRuby";
    /**
     * @generated from protobuf enum value: kKindTateChuYoko = 38;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindTateChuYoko"] = 38] = "kKindTateChuYoko";
    /**
     * @generated from protobuf enum value: kKindDropCapStyle = 39;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindDropCapStyle"] = 39] = "kKindDropCapStyle";
    /**
     * @generated from protobuf enum value: kKindMergeField = 40;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindMergeField"] = 40] = "kKindMergeField";
    /**
     * @generated from protobuf enum value: kKindModifyMergeField = 41;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindModifyMergeField"] = 41] = "kKindModifyMergeField";
    /**
     * @generated from protobuf enum value: kKindMergeFieldTypeReplace = 42;
     */
    StorageActionCommandArchive_Kind[StorageActionCommandArchive_Kind["kKindMergeFieldTypeReplace"] = 42] = "kKindMergeFieldTypeReplace";
})(StorageActionCommandArchive_Kind = exports.StorageActionCommandArchive_Kind || (exports.StorageActionCommandArchive_Kind = {}));
/**
 * @generated from protobuf enum TSWP.UpdateFlowInfoCommandArchive.Mode
 */
var UpdateFlowInfoCommandArchive_Mode;
(function (UpdateFlowInfoCommandArchive_Mode) {
    /**
     * @generated from protobuf enum value: kModeRearrange = 0;
     */
    UpdateFlowInfoCommandArchive_Mode[UpdateFlowInfoCommandArchive_Mode["kModeRearrange"] = 0] = "kModeRearrange";
    /**
     * @generated from protobuf enum value: kModeAdd = 1;
     */
    UpdateFlowInfoCommandArchive_Mode[UpdateFlowInfoCommandArchive_Mode["kModeAdd"] = 1] = "kModeAdd";
    /**
     * @generated from protobuf enum value: kModeRemove = 2;
     */
    UpdateFlowInfoCommandArchive_Mode[UpdateFlowInfoCommandArchive_Mode["kModeRemove"] = 2] = "kModeRemove";
    /**
     * @generated from protobuf enum value: kModeCompensate = 3;
     */
    UpdateFlowInfoCommandArchive_Mode[UpdateFlowInfoCommandArchive_Mode["kModeCompensate"] = 3] = "kModeCompensate";
})(UpdateFlowInfoCommandArchive_Mode = exports.UpdateFlowInfoCommandArchive_Mode || (exports.UpdateFlowInfoCommandArchive_Mode = {}));
/**
 * @generated from protobuf enum TSWP.ObjectPropertyType
 */
var ObjectPropertyType;
(function (ObjectPropertyType) {
    /**
     * @generated from protobuf enum value: kObjectPropertyTypeBool = 0;
     */
    ObjectPropertyType[ObjectPropertyType["kObjectPropertyTypeBool"] = 0] = "kObjectPropertyTypeBool";
    /**
     * @generated from protobuf enum value: kObjectPropertyTypeFloat = 1;
     */
    ObjectPropertyType[ObjectPropertyType["kObjectPropertyTypeFloat"] = 1] = "kObjectPropertyTypeFloat";
    /**
     * @generated from protobuf enum value: kObjectPropertyTypeInteger = 2;
     */
    ObjectPropertyType[ObjectPropertyType["kObjectPropertyTypeInteger"] = 2] = "kObjectPropertyTypeInteger";
    /**
     * @generated from protobuf enum value: kObjectPropertyTypeString = 3;
     */
    ObjectPropertyType[ObjectPropertyType["kObjectPropertyTypeString"] = 3] = "kObjectPropertyTypeString";
    /**
     * @generated from protobuf enum value: kObjectPropertyTypeIdPath = 4;
     */
    ObjectPropertyType[ObjectPropertyType["kObjectPropertyTypeIdPath"] = 4] = "kObjectPropertyTypeIdPath";
    /**
     * @generated from protobuf enum value: kObjectPropertyTypeFill = 5;
     */
    ObjectPropertyType[ObjectPropertyType["kObjectPropertyTypeFill"] = 5] = "kObjectPropertyTypeFill";
    /**
     * @generated from protobuf enum value: kObjectPropertyTypeColor = 6;
     */
    ObjectPropertyType[ObjectPropertyType["kObjectPropertyTypeColor"] = 6] = "kObjectPropertyTypeColor";
    /**
     * @generated from protobuf enum value: kObjectPropertyTypeShadow = 7;
     */
    ObjectPropertyType[ObjectPropertyType["kObjectPropertyTypeShadow"] = 7] = "kObjectPropertyTypeShadow";
})(ObjectPropertyType = exports.ObjectPropertyType || (exports.ObjectPropertyType = {}));
// @generated message type with reflection information, may provide speed optimized methods
class DummyCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.DummyCommandArchive", [
            { no: 1, name: "foo", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = { foo: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 foo */ 1:
                    message.foo = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 foo = 1; */
        if (message.foo !== 0)
            writer.tag(1, runtime_1.WireType.Varint).uint32(message.foo);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.DummyCommandArchive
 */
exports.DummyCommandArchive = new DummyCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TextCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.TextCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_5.CommandArchive },
            { no: 2, name: "storage", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 3, name: "undo_transaction", kind: "message", T: () => TSWPArchives_3.UndoTransaction },
            { no: 4, name: "restore_range_location", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "restore_range_length", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "redo_restore_range_location", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "redo_restore_range_length", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "text_command_flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "kind", kind: "enum", opt: true, T: () => ["TSWP.TextCommandArchive.Kind", TextCommandArchive_Kind] }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_5.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference storage */ 2:
                    message.storage = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.storage);
                    break;
                case /* optional TSWP.UndoTransaction undo_transaction */ 3:
                    message.undoTransaction = TSWPArchives_3.UndoTransaction.internalBinaryRead(reader, reader.uint32(), options, message.undoTransaction);
                    break;
                case /* optional uint32 restore_range_location */ 4:
                    message.restoreRangeLocation = reader.uint32();
                    break;
                case /* optional uint32 restore_range_length */ 5:
                    message.restoreRangeLength = reader.uint32();
                    break;
                case /* optional uint32 redo_restore_range_location */ 6:
                    message.redoRestoreRangeLocation = reader.uint32();
                    break;
                case /* optional uint32 redo_restore_range_length */ 7:
                    message.redoRestoreRangeLength = reader.uint32();
                    break;
                case /* optional uint32 text_command_flags */ 9:
                    message.textCommandFlags = reader.uint32();
                    break;
                case /* optional TSWP.TextCommandArchive.Kind kind */ 10:
                    message.kind = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_5.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference storage = 2; */
        if (message.storage)
            TSPMessages_6.Reference.internalBinaryWrite(message.storage, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.UndoTransaction undo_transaction = 3; */
        if (message.undoTransaction)
            TSWPArchives_3.UndoTransaction.internalBinaryWrite(message.undoTransaction, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 restore_range_location = 4; */
        if (message.restoreRangeLocation !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.restoreRangeLocation);
        /* optional uint32 restore_range_length = 5; */
        if (message.restoreRangeLength !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.restoreRangeLength);
        /* optional uint32 redo_restore_range_location = 6; */
        if (message.redoRestoreRangeLocation !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).uint32(message.redoRestoreRangeLocation);
        /* optional uint32 redo_restore_range_length = 7; */
        if (message.redoRestoreRangeLength !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).uint32(message.redoRestoreRangeLength);
        /* optional uint32 text_command_flags = 9; */
        if (message.textCommandFlags !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).uint32(message.textCommandFlags);
        /* optional TSWP.TextCommandArchive.Kind kind = 10; */
        if (message.kind !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).int32(message.kind);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.TextCommandArchive
 */
exports.TextCommandArchive = new TextCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StorageActionCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.StorageActionCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_5.CommandArchive },
            { no: 2, name: "storage", kind: "message", T: () => TSPMessages_5.UUIDPath },
            { no: 3, name: "undo_transaction", kind: "message", T: () => TSWPArchives_3.UndoTransaction },
            { no: 4, name: "text_command_flags", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "kind", kind: "enum", opt: true, T: () => ["TSWP.StorageActionCommandArchive.Kind", StorageActionCommandArchive_Kind] },
            { no: 6, name: "custom_format_keys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_4.UUID },
            { no: 7, name: "is_forward_inverse_command", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "coalesceable", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "coalescing_text", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "should_migrate_styles", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "changed_data_reference_record", kind: "message", T: () => TSKArchives_4.DataReferenceRecord },
            { no: 12, name: "coalescing_property", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "wp_kind", kind: "enum", opt: true, T: () => ["TSWP.StorageArchive.KindType", TSWPArchives_2.StorageArchive_KindType] }
        ]);
    }
    create(value) {
        const message = { customFormatKeys: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_5.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.UUIDPath storage */ 2:
                    message.storage = TSPMessages_5.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.storage);
                    break;
                case /* optional TSWP.UndoTransaction undo_transaction */ 3:
                    message.undoTransaction = TSWPArchives_3.UndoTransaction.internalBinaryRead(reader, reader.uint32(), options, message.undoTransaction);
                    break;
                case /* optional uint32 text_command_flags */ 4:
                    message.textCommandFlags = reader.uint32();
                    break;
                case /* optional TSWP.StorageActionCommandArchive.Kind kind */ 5:
                    message.kind = reader.int32();
                    break;
                case /* repeated TSP.UUID custom_format_keys */ 6:
                    message.customFormatKeys.push(TSPMessages_4.UUID.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool is_forward_inverse_command */ 7:
                    message.isForwardInverseCommand = reader.bool();
                    break;
                case /* optional bool coalesceable */ 8:
                    message.coalesceable = reader.bool();
                    break;
                case /* optional bool coalescing_text */ 9:
                    message.coalescingText = reader.bool();
                    break;
                case /* optional bool should_migrate_styles */ 10:
                    message.shouldMigrateStyles = reader.bool();
                    break;
                case /* optional TSK.DataReferenceRecord changed_data_reference_record */ 11:
                    message.changedDataReferenceRecord = TSKArchives_4.DataReferenceRecord.internalBinaryRead(reader, reader.uint32(), options, message.changedDataReferenceRecord);
                    break;
                case /* optional string coalescing_property */ 12:
                    message.coalescingProperty = reader.string();
                    break;
                case /* optional TSWP.StorageArchive.KindType wp_kind */ 13:
                    message.wpKind = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_5.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDPath storage = 2; */
        if (message.storage)
            TSPMessages_5.UUIDPath.internalBinaryWrite(message.storage, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.UndoTransaction undo_transaction = 3; */
        if (message.undoTransaction)
            TSWPArchives_3.UndoTransaction.internalBinaryWrite(message.undoTransaction, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 text_command_flags = 4; */
        if (message.textCommandFlags !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.textCommandFlags);
        /* optional TSWP.StorageActionCommandArchive.Kind kind = 5; */
        if (message.kind !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).int32(message.kind);
        /* repeated TSP.UUID custom_format_keys = 6; */
        for (let i = 0; i < message.customFormatKeys.length; i++)
            TSPMessages_4.UUID.internalBinaryWrite(message.customFormatKeys[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool is_forward_inverse_command = 7; */
        if (message.isForwardInverseCommand !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.isForwardInverseCommand);
        /* optional bool coalesceable = 8; */
        if (message.coalesceable !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).bool(message.coalesceable);
        /* optional bool coalescing_text = 9; */
        if (message.coalescingText !== undefined)
            writer.tag(9, runtime_1.WireType.Varint).bool(message.coalescingText);
        /* optional bool should_migrate_styles = 10; */
        if (message.shouldMigrateStyles !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).bool(message.shouldMigrateStyles);
        /* optional TSK.DataReferenceRecord changed_data_reference_record = 11; */
        if (message.changedDataReferenceRecord)
            TSKArchives_4.DataReferenceRecord.internalBinaryWrite(message.changedDataReferenceRecord, writer.tag(11, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string coalescing_property = 12; */
        if (message.coalescingProperty !== undefined)
            writer.tag(12, runtime_1.WireType.LengthDelimited).string(message.coalescingProperty);
        /* optional TSWP.StorageArchive.KindType wp_kind = 13; */
        if (message.wpKind !== undefined)
            writer.tag(13, runtime_1.WireType.Varint).int32(message.wpKind);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.StorageActionCommandArchive
 */
exports.StorageActionCommandArchive = new StorageActionCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetColumnStyleCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.SetColumnStyleCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_5.CommandArchive },
            { no: 2, name: "storage", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 3, name: "undo_transaction", kind: "message", T: () => TSWPArchives_3.UndoTransaction }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_5.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference storage */ 2:
                    message.storage = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.storage);
                    break;
                case /* optional TSWP.UndoTransaction undo_transaction */ 3:
                    message.undoTransaction = TSWPArchives_3.UndoTransaction.internalBinaryRead(reader, reader.uint32(), options, message.undoTransaction);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_5.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference storage = 2; */
        if (message.storage)
            TSPMessages_6.Reference.internalBinaryWrite(message.storage, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.UndoTransaction undo_transaction = 3; */
        if (message.undoTransaction)
            TSWPArchives_3.UndoTransaction.internalBinaryWrite(message.undoTransaction, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.SetColumnStyleCommandArchive
 */
exports.SetColumnStyleCommandArchive = new SetColumnStyleCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReplaceAllUsesOfStyleCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ReplaceAllUsesOfStyleCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_5.CommandArchive },
            { no: 2, name: "storage", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 3, name: "undo_transaction", kind: "message", T: () => TSWPArchives_3.UndoTransaction }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_5.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference storage */ 2:
                    message.storage = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.storage);
                    break;
                case /* optional TSWP.UndoTransaction undo_transaction */ 3:
                    message.undoTransaction = TSWPArchives_3.UndoTransaction.internalBinaryRead(reader, reader.uint32(), options, message.undoTransaction);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_5.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference storage = 2; */
        if (message.storage)
            TSPMessages_6.Reference.internalBinaryWrite(message.storage, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.UndoTransaction undo_transaction = 3; */
        if (message.undoTransaction)
            TSWPArchives_3.UndoTransaction.internalBinaryWrite(message.undoTransaction, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ReplaceAllUsesOfStyleCommandArchive
 */
exports.ReplaceAllUsesOfStyleCommandArchive = new ReplaceAllUsesOfStyleCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InsertColumnsCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.InsertColumnsCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_5.CommandArchive },
            { no: 2, name: "storage", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 3, name: "column_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "column_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "undo_transaction", kind: "message", T: () => TSWPArchives_3.UndoTransaction }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_5.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference storage */ 2:
                    message.storage = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.storage);
                    break;
                case /* optional uint32 column_index */ 3:
                    message.columnIndex = reader.uint32();
                    break;
                case /* optional uint32 column_count */ 4:
                    message.columnCount = reader.uint32();
                    break;
                case /* optional TSWP.UndoTransaction undo_transaction */ 5:
                    message.undoTransaction = TSWPArchives_3.UndoTransaction.internalBinaryRead(reader, reader.uint32(), options, message.undoTransaction);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_5.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference storage = 2; */
        if (message.storage)
            TSPMessages_6.Reference.internalBinaryWrite(message.storage, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 column_index = 3; */
        if (message.columnIndex !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.columnIndex);
        /* optional uint32 column_count = 4; */
        if (message.columnCount !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.columnCount);
        /* optional TSWP.UndoTransaction undo_transaction = 5; */
        if (message.undoTransaction)
            TSWPArchives_3.UndoTransaction.internalBinaryWrite(message.undoTransaction, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.InsertColumnsCommandArchive
 */
exports.InsertColumnsCommandArchive = new InsertColumnsCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InsertRowsCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.InsertRowsCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_5.CommandArchive },
            { no: 2, name: "storage", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 3, name: "row_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "row_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "undo_transaction", kind: "message", T: () => TSWPArchives_3.UndoTransaction }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_5.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference storage */ 2:
                    message.storage = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.storage);
                    break;
                case /* optional uint32 row_index */ 3:
                    message.rowIndex = reader.uint32();
                    break;
                case /* optional uint32 row_count */ 4:
                    message.rowCount = reader.uint32();
                    break;
                case /* optional TSWP.UndoTransaction undo_transaction */ 5:
                    message.undoTransaction = TSWPArchives_3.UndoTransaction.internalBinaryRead(reader, reader.uint32(), options, message.undoTransaction);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_5.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference storage = 2; */
        if (message.storage)
            TSPMessages_6.Reference.internalBinaryWrite(message.storage, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 row_index = 3; */
        if (message.rowIndex !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.rowIndex);
        /* optional uint32 row_count = 4; */
        if (message.rowCount !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.rowCount);
        /* optional TSWP.UndoTransaction undo_transaction = 5; */
        if (message.undoTransaction)
            TSWPArchives_3.UndoTransaction.internalBinaryWrite(message.undoTransaction, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.InsertRowsCommandArchive
 */
exports.InsertRowsCommandArchive = new InsertRowsCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveColumnsCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.RemoveColumnsCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_5.CommandArchive },
            { no: 2, name: "storage", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 3, name: "column_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "column_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "undo_transaction", kind: "message", T: () => TSWPArchives_3.UndoTransaction }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_5.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference storage */ 2:
                    message.storage = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.storage);
                    break;
                case /* optional uint32 column_index */ 3:
                    message.columnIndex = reader.uint32();
                    break;
                case /* optional uint32 column_count */ 4:
                    message.columnCount = reader.uint32();
                    break;
                case /* optional TSWP.UndoTransaction undo_transaction */ 5:
                    message.undoTransaction = TSWPArchives_3.UndoTransaction.internalBinaryRead(reader, reader.uint32(), options, message.undoTransaction);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_5.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference storage = 2; */
        if (message.storage)
            TSPMessages_6.Reference.internalBinaryWrite(message.storage, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 column_index = 3; */
        if (message.columnIndex !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.columnIndex);
        /* optional uint32 column_count = 4; */
        if (message.columnCount !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.columnCount);
        /* optional TSWP.UndoTransaction undo_transaction = 5; */
        if (message.undoTransaction)
            TSWPArchives_3.UndoTransaction.internalBinaryWrite(message.undoTransaction, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.RemoveColumnsCommandArchive
 */
exports.RemoveColumnsCommandArchive = new RemoveColumnsCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveRowsCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.RemoveRowsCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_5.CommandArchive },
            { no: 2, name: "storage", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 3, name: "row_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "row_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "undo_transaction", kind: "message", T: () => TSWPArchives_3.UndoTransaction }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_5.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference storage */ 2:
                    message.storage = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.storage);
                    break;
                case /* optional uint32 row_index */ 3:
                    message.rowIndex = reader.uint32();
                    break;
                case /* optional uint32 row_count */ 4:
                    message.rowCount = reader.uint32();
                    break;
                case /* optional TSWP.UndoTransaction undo_transaction */ 5:
                    message.undoTransaction = TSWPArchives_3.UndoTransaction.internalBinaryRead(reader, reader.uint32(), options, message.undoTransaction);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_5.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference storage = 2; */
        if (message.storage)
            TSPMessages_6.Reference.internalBinaryWrite(message.storage, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 row_index = 3; */
        if (message.rowIndex !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.rowIndex);
        /* optional uint32 row_count = 4; */
        if (message.rowCount !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.rowCount);
        /* optional TSWP.UndoTransaction undo_transaction = 5; */
        if (message.undoTransaction)
            TSWPArchives_3.UndoTransaction.internalBinaryWrite(message.undoTransaction, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.RemoveRowsCommandArchive
 */
exports.RemoveRowsCommandArchive = new RemoveRowsCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MergeCellsCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.MergeCellsCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_5.CommandArchive },
            { no: 2, name: "storage", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 3, name: "row", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "column", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "row_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "column_count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "undo_transaction", kind: "message", T: () => TSWPArchives_3.UndoTransaction }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_5.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference storage */ 2:
                    message.storage = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.storage);
                    break;
                case /* optional uint32 row */ 3:
                    message.row = reader.uint32();
                    break;
                case /* optional uint32 column */ 4:
                    message.column = reader.uint32();
                    break;
                case /* optional uint32 row_count */ 5:
                    message.rowCount = reader.uint32();
                    break;
                case /* optional uint32 column_count */ 6:
                    message.columnCount = reader.uint32();
                    break;
                case /* optional TSWP.UndoTransaction undo_transaction */ 7:
                    message.undoTransaction = TSWPArchives_3.UndoTransaction.internalBinaryRead(reader, reader.uint32(), options, message.undoTransaction);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_5.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference storage = 2; */
        if (message.storage)
            TSPMessages_6.Reference.internalBinaryWrite(message.storage, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 row = 3; */
        if (message.row !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.row);
        /* optional uint32 column = 4; */
        if (message.column !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.column);
        /* optional uint32 row_count = 5; */
        if (message.rowCount !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.rowCount);
        /* optional uint32 column_count = 6; */
        if (message.columnCount !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).uint32(message.columnCount);
        /* optional TSWP.UndoTransaction undo_transaction = 7; */
        if (message.undoTransaction)
            TSWPArchives_3.UndoTransaction.internalBinaryWrite(message.undoTransaction, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.MergeCellsCommandArchive
 */
exports.MergeCellsCommandArchive = new MergeCellsCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApplyPlaceholderTextCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ApplyPlaceholderTextCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_5.CommandArchive },
            { no: 2, name: "storage", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 3, name: "selection_range_location", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "selection_range_length", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "undo_transaction", kind: "message", T: () => TSWPArchives_3.UndoTransaction },
            { no: 6, name: "script_tag", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_5.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference storage */ 2:
                    message.storage = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.storage);
                    break;
                case /* optional uint32 selection_range_location */ 3:
                    message.selectionRangeLocation = reader.uint32();
                    break;
                case /* optional uint32 selection_range_length */ 4:
                    message.selectionRangeLength = reader.uint32();
                    break;
                case /* optional TSWP.UndoTransaction undo_transaction */ 5:
                    message.undoTransaction = TSWPArchives_3.UndoTransaction.internalBinaryRead(reader, reader.uint32(), options, message.undoTransaction);
                    break;
                case /* optional string script_tag */ 6:
                    message.scriptTag = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_5.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference storage = 2; */
        if (message.storage)
            TSPMessages_6.Reference.internalBinaryWrite(message.storage, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 selection_range_location = 3; */
        if (message.selectionRangeLocation !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.selectionRangeLocation);
        /* optional uint32 selection_range_length = 4; */
        if (message.selectionRangeLength !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.selectionRangeLength);
        /* optional TSWP.UndoTransaction undo_transaction = 5; */
        if (message.undoTransaction)
            TSWPArchives_3.UndoTransaction.internalBinaryWrite(message.undoTransaction, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string script_tag = 6; */
        if (message.scriptTag !== undefined)
            writer.tag(6, runtime_1.WireType.LengthDelimited).string(message.scriptTag);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ApplyPlaceholderTextCommandArchive
 */
exports.ApplyPlaceholderTextCommandArchive = new ApplyPlaceholderTextCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateDateTimeFieldCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.UpdateDateTimeFieldCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.TextCommandArchive },
            { no: 2, name: "date_time_field", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 3, name: "date", kind: "message", T: () => TSPMessages_3.Date },
            { no: 4, name: "date_style", kind: "enum", opt: true, T: () => ["TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle", TSWPArchives_1.DateTimeSmartFieldArchive_DateTimeFormatterStyle] },
            { no: 5, name: "time_style", kind: "enum", opt: true, T: () => ["TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle", TSWPArchives_1.DateTimeSmartFieldArchive_DateTimeFormatterStyle] }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.TextCommandArchive super */ 1:
                    message.super = exports.TextCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference date_time_field */ 2:
                    message.dateTimeField = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.dateTimeField);
                    break;
                case /* optional TSP.Date date */ 3:
                    message.date = TSPMessages_3.Date.internalBinaryRead(reader, reader.uint32(), options, message.date);
                    break;
                case /* optional TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle date_style */ 4:
                    message.dateStyle = reader.int32();
                    break;
                case /* optional TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle time_style */ 5:
                    message.timeStyle = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.TextCommandArchive super = 1; */
        if (message.super)
            exports.TextCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference date_time_field = 2; */
        if (message.dateTimeField)
            TSPMessages_6.Reference.internalBinaryWrite(message.dateTimeField, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Date date = 3; */
        if (message.date)
            TSPMessages_3.Date.internalBinaryWrite(message.date, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle date_style = 4; */
        if (message.dateStyle !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).int32(message.dateStyle);
        /* optional TSWP.DateTimeSmartFieldArchive.DateTimeFormatterStyle time_style = 5; */
        if (message.timeStyle !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).int32(message.timeStyle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.UpdateDateTimeFieldCommandArchive
 */
exports.UpdateDateTimeFieldCommandArchive = new UpdateDateTimeFieldCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApplyRubyTextCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ApplyRubyTextCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_5.CommandArchive },
            { no: 2, name: "storage", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 3, name: "selection_range_location", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "selection_range_length", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "ruby_text", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "undo_transaction", kind: "message", T: () => TSWPArchives_3.UndoTransaction }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_5.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference storage */ 2:
                    message.storage = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.storage);
                    break;
                case /* optional uint32 selection_range_location */ 3:
                    message.selectionRangeLocation = reader.uint32();
                    break;
                case /* optional uint32 selection_range_length */ 4:
                    message.selectionRangeLength = reader.uint32();
                    break;
                case /* optional string ruby_text */ 5:
                    message.rubyText = reader.string();
                    break;
                case /* optional TSWP.UndoTransaction undo_transaction */ 6:
                    message.undoTransaction = TSWPArchives_3.UndoTransaction.internalBinaryRead(reader, reader.uint32(), options, message.undoTransaction);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_5.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference storage = 2; */
        if (message.storage)
            TSPMessages_6.Reference.internalBinaryWrite(message.storage, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 selection_range_location = 3; */
        if (message.selectionRangeLocation !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.selectionRangeLocation);
        /* optional uint32 selection_range_length = 4; */
        if (message.selectionRangeLength !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.selectionRangeLength);
        /* optional string ruby_text = 5; */
        if (message.rubyText !== undefined)
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.rubyText);
        /* optional TSWP.UndoTransaction undo_transaction = 6; */
        if (message.undoTransaction)
            TSWPArchives_3.UndoTransaction.internalBinaryWrite(message.undoTransaction, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ApplyRubyTextCommandArchive
 */
exports.ApplyRubyTextCommandArchive = new ApplyRubyTextCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModifyRubyTextCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ModifyRubyTextCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_5.CommandArchive },
            { no: 2, name: "ruby_field", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 3, name: "ruby_text", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "base_text", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "undo_transaction", kind: "message", T: () => TSWPArchives_3.UndoTransaction }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_5.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference ruby_field */ 2:
                    message.rubyField = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.rubyField);
                    break;
                case /* optional string ruby_text */ 3:
                    message.rubyText = reader.string();
                    break;
                case /* optional string base_text */ 4:
                    message.baseText = reader.string();
                    break;
                case /* optional TSWP.UndoTransaction undo_transaction */ 5:
                    message.undoTransaction = TSWPArchives_3.UndoTransaction.internalBinaryRead(reader, reader.uint32(), options, message.undoTransaction);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_5.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference ruby_field = 2; */
        if (message.rubyField)
            TSPMessages_6.Reference.internalBinaryWrite(message.rubyField, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string ruby_text = 3; */
        if (message.rubyText !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.rubyText);
        /* optional string base_text = 4; */
        if (message.baseText !== undefined)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.baseText);
        /* optional TSWP.UndoTransaction undo_transaction = 5; */
        if (message.undoTransaction)
            TSWPArchives_3.UndoTransaction.internalBinaryWrite(message.undoTransaction, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ModifyRubyTextCommandArchive
 */
exports.ModifyRubyTextCommandArchive = new ModifyRubyTextCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModifyTOCSettingsBaseCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ModifyTOCSettingsBaseCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_5.CommandArchive },
            { no: 2, name: "old_toc_settings", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 3, name: "new_toc_settings", kind: "message", T: () => TSPMessages_6.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_5.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference old_toc_settings */ 2:
                    message.oldTocSettings = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.oldTocSettings);
                    break;
                case /* optional TSP.Reference new_toc_settings */ 3:
                    message.newTocSettings = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.newTocSettings);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_5.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference old_toc_settings = 2; */
        if (message.oldTocSettings)
            TSPMessages_6.Reference.internalBinaryWrite(message.oldTocSettings, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference new_toc_settings = 3; */
        if (message.newTocSettings)
            TSPMessages_6.Reference.internalBinaryWrite(message.newTocSettings, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ModifyTOCSettingsBaseCommandArchive
 */
exports.ModifyTOCSettingsBaseCommandArchive = new ModifyTOCSettingsBaseCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModifyTOCSettingsForTOCInfoCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ModifyTOCSettingsForTOCInfoCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.ModifyTOCSettingsBaseCommandArchive },
            { no: 2, name: "toc_info_uuid_path", kind: "message", T: () => TSPMessages_5.UUIDPath }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.ModifyTOCSettingsBaseCommandArchive super */ 1:
                    message.super = exports.ModifyTOCSettingsBaseCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.UUIDPath toc_info_uuid_path */ 2:
                    message.tocInfoUuidPath = TSPMessages_5.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.tocInfoUuidPath);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.ModifyTOCSettingsBaseCommandArchive super = 1; */
        if (message.super)
            exports.ModifyTOCSettingsBaseCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDPath toc_info_uuid_path = 2; */
        if (message.tocInfoUuidPath)
            TSPMessages_5.UUIDPath.internalBinaryWrite(message.tocInfoUuidPath, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ModifyTOCSettingsForTOCInfoCommandArchive
 */
exports.ModifyTOCSettingsForTOCInfoCommandArchive = new ModifyTOCSettingsForTOCInfoCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModifyTOCSettingsPresetForThemeCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ModifyTOCSettingsPresetForThemeCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.ModifyTOCSettingsBaseCommandArchive },
            { no: 2, name: "theme", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 3, name: "preset_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.ModifyTOCSettingsBaseCommandArchive super */ 1:
                    message.super = exports.ModifyTOCSettingsBaseCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference theme */ 2:
                    message.theme = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.theme);
                    break;
                case /* optional uint32 preset_index */ 3:
                    message.presetIndex = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.ModifyTOCSettingsBaseCommandArchive super = 1; */
        if (message.super)
            exports.ModifyTOCSettingsBaseCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference theme = 2; */
        if (message.theme)
            TSPMessages_6.Reference.internalBinaryWrite(message.theme, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 preset_index = 3; */
        if (message.presetIndex !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.presetIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ModifyTOCSettingsPresetForThemeCommandArchive
 */
exports.ModifyTOCSettingsPresetForThemeCommandArchive = new ModifyTOCSettingsPresetForThemeCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AnchorAttachmentCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.AnchorAttachmentCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.StorageActionCommandArchive },
            { no: 2, name: "attachment", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 3, name: "h_offset_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "h_offset", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "v_offset_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "v_offset", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "is_html_wrap", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "undo_h_offset_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "undo_h_offset", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "undo_v_offset_type", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "undo_v_offset", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "undo_is_html_wrap", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.StorageActionCommandArchive super */ 1:
                    message.super = exports.StorageActionCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference attachment */ 2:
                    message.attachment = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.attachment);
                    break;
                case /* optional uint32 h_offset_type */ 3:
                    message.hOffsetType = reader.uint32();
                    break;
                case /* optional float h_offset */ 4:
                    message.hOffset = reader.float();
                    break;
                case /* optional uint32 v_offset_type */ 5:
                    message.vOffsetType = reader.uint32();
                    break;
                case /* optional float v_offset */ 6:
                    message.vOffset = reader.float();
                    break;
                case /* optional bool is_html_wrap */ 7:
                    message.isHtmlWrap = reader.bool();
                    break;
                case /* optional uint32 undo_h_offset_type */ 8:
                    message.undoHOffsetType = reader.uint32();
                    break;
                case /* optional float undo_h_offset */ 9:
                    message.undoHOffset = reader.float();
                    break;
                case /* optional uint32 undo_v_offset_type */ 10:
                    message.undoVOffsetType = reader.uint32();
                    break;
                case /* optional float undo_v_offset */ 11:
                    message.undoVOffset = reader.float();
                    break;
                case /* optional bool undo_is_html_wrap */ 12:
                    message.undoIsHtmlWrap = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.StorageActionCommandArchive super = 1; */
        if (message.super)
            exports.StorageActionCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference attachment = 2; */
        if (message.attachment)
            TSPMessages_6.Reference.internalBinaryWrite(message.attachment, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 h_offset_type = 3; */
        if (message.hOffsetType !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.hOffsetType);
        /* optional float h_offset = 4; */
        if (message.hOffset !== undefined)
            writer.tag(4, runtime_1.WireType.Bit32).float(message.hOffset);
        /* optional uint32 v_offset_type = 5; */
        if (message.vOffsetType !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.vOffsetType);
        /* optional float v_offset = 6; */
        if (message.vOffset !== undefined)
            writer.tag(6, runtime_1.WireType.Bit32).float(message.vOffset);
        /* optional bool is_html_wrap = 7; */
        if (message.isHtmlWrap !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).bool(message.isHtmlWrap);
        /* optional uint32 undo_h_offset_type = 8; */
        if (message.undoHOffsetType !== undefined)
            writer.tag(8, runtime_1.WireType.Varint).uint32(message.undoHOffsetType);
        /* optional float undo_h_offset = 9; */
        if (message.undoHOffset !== undefined)
            writer.tag(9, runtime_1.WireType.Bit32).float(message.undoHOffset);
        /* optional uint32 undo_v_offset_type = 10; */
        if (message.undoVOffsetType !== undefined)
            writer.tag(10, runtime_1.WireType.Varint).uint32(message.undoVOffsetType);
        /* optional float undo_v_offset = 11; */
        if (message.undoVOffset !== undefined)
            writer.tag(11, runtime_1.WireType.Bit32).float(message.undoVOffset);
        /* optional bool undo_is_html_wrap = 12; */
        if (message.undoIsHtmlWrap !== undefined)
            writer.tag(12, runtime_1.WireType.Varint).bool(message.undoIsHtmlWrap);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.AnchorAttachmentCommandArchive
 */
exports.AnchorAttachmentCommandArchive = new AnchorAttachmentCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TextApplyThemeCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.TextApplyThemeCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSSArchives_2.ApplyThemeChildCommandArchive },
            { no: 2, name: "storage", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 6, name: "undo_transaction", kind: "message", T: () => TSWPArchives_3.UndoTransaction }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSS.ApplyThemeChildCommandArchive super */ 1:
                    message.super = TSSArchives_2.ApplyThemeChildCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference storage */ 2:
                    message.storage = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.storage);
                    break;
                case /* optional TSWP.UndoTransaction undo_transaction */ 6:
                    message.undoTransaction = TSWPArchives_3.UndoTransaction.internalBinaryRead(reader, reader.uint32(), options, message.undoTransaction);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSS.ApplyThemeChildCommandArchive super = 1; */
        if (message.super)
            TSSArchives_2.ApplyThemeChildCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference storage = 2; */
        if (message.storage)
            TSPMessages_6.Reference.internalBinaryWrite(message.storage, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.UndoTransaction undo_transaction = 6; */
        if (message.undoTransaction)
            TSWPArchives_3.UndoTransaction.internalBinaryWrite(message.undoTransaction, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.TextApplyThemeCommandArchive
 */
exports.TextApplyThemeCommandArchive = new TextApplyThemeCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MoveColumnsCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.MoveColumnsCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_5.CommandArchive },
            { no: 2, name: "storage", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 3, name: "src_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "dst_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "undo_transaction", kind: "message", T: () => TSWPArchives_3.UndoTransaction }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_5.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference storage */ 2:
                    message.storage = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.storage);
                    break;
                case /* optional uint32 src_index */ 3:
                    message.srcIndex = reader.uint32();
                    break;
                case /* optional uint32 dst_index */ 4:
                    message.dstIndex = reader.uint32();
                    break;
                case /* optional uint32 count */ 5:
                    message.count = reader.uint32();
                    break;
                case /* optional TSWP.UndoTransaction undo_transaction */ 6:
                    message.undoTransaction = TSWPArchives_3.UndoTransaction.internalBinaryRead(reader, reader.uint32(), options, message.undoTransaction);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_5.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference storage = 2; */
        if (message.storage)
            TSPMessages_6.Reference.internalBinaryWrite(message.storage, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 src_index = 3; */
        if (message.srcIndex !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.srcIndex);
        /* optional uint32 dst_index = 4; */
        if (message.dstIndex !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.dstIndex);
        /* optional uint32 count = 5; */
        if (message.count !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.count);
        /* optional TSWP.UndoTransaction undo_transaction = 6; */
        if (message.undoTransaction)
            TSWPArchives_3.UndoTransaction.internalBinaryWrite(message.undoTransaction, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.MoveColumnsCommandArchive
 */
exports.MoveColumnsCommandArchive = new MoveColumnsCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MoveRowsCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.MoveRowsCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_5.CommandArchive },
            { no: 2, name: "storage", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 3, name: "src_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "dst_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "count", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "undo_transaction", kind: "message", T: () => TSWPArchives_3.UndoTransaction }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_5.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference storage */ 2:
                    message.storage = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.storage);
                    break;
                case /* optional uint32 src_index */ 3:
                    message.srcIndex = reader.uint32();
                    break;
                case /* optional uint32 dst_index */ 4:
                    message.dstIndex = reader.uint32();
                    break;
                case /* optional uint32 count */ 5:
                    message.count = reader.uint32();
                    break;
                case /* optional TSWP.UndoTransaction undo_transaction */ 6:
                    message.undoTransaction = TSWPArchives_3.UndoTransaction.internalBinaryRead(reader, reader.uint32(), options, message.undoTransaction);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_5.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference storage = 2; */
        if (message.storage)
            TSPMessages_6.Reference.internalBinaryWrite(message.storage, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 src_index = 3; */
        if (message.srcIndex !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.srcIndex);
        /* optional uint32 dst_index = 4; */
        if (message.dstIndex !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.dstIndex);
        /* optional uint32 count = 5; */
        if (message.count !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.count);
        /* optional TSWP.UndoTransaction undo_transaction = 6; */
        if (message.undoTransaction)
            TSWPArchives_3.UndoTransaction.internalBinaryWrite(message.undoTransaction, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.MoveRowsCommandArchive
 */
exports.MoveRowsCommandArchive = new MoveRowsCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShapeApplyPresetCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ShapeApplyPresetCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSDCommandArchives_5.BaseApplyPresetCommandArchive },
            { no: 2, name: "undo_style", kind: "message", T: () => TSPMessages_6.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.BaseApplyPresetCommandArchive super */ 1:
                    message.super = TSDCommandArchives_5.BaseApplyPresetCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference undo_style */ 2:
                    message.undoStyle = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoStyle);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.BaseApplyPresetCommandArchive super = 1; */
        if (message.super)
            TSDCommandArchives_5.BaseApplyPresetCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_style = 2; */
        if (message.undoStyle)
            TSPMessages_6.Reference.internalBinaryWrite(message.undoStyle, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ShapeApplyPresetCommandArchive
 */
exports.ShapeApplyPresetCommandArchive = new ShapeApplyPresetCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StyleBaseCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.StyleBaseCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_5.CommandArchive },
            { no: 2, name: "theme", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 3, name: "style", kind: "message", T: () => TSPMessages_6.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_5.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference theme */ 2:
                    message.theme = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.theme);
                    break;
                case /* optional TSP.Reference style */ 3:
                    message.style = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.style);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_5.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference theme = 2; */
        if (message.theme)
            TSPMessages_6.Reference.internalBinaryWrite(message.theme, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference style = 3; */
        if (message.style)
            TSPMessages_6.Reference.internalBinaryWrite(message.style, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.StyleBaseCommandArchive
 */
exports.StyleBaseCommandArchive = new StyleBaseCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StyleCreateCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.StyleCreateCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.StyleBaseCommandArchive },
            { no: 2, name: "preset_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.StyleBaseCommandArchive super */ 1:
                    message.super = exports.StyleBaseCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional uint32 preset_index */ 2:
                    message.presetIndex = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.StyleBaseCommandArchive super = 1; */
        if (message.super)
            exports.StyleBaseCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 preset_index = 2; */
        if (message.presetIndex !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.presetIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.StyleCreateCommandArchive
 */
exports.StyleCreateCommandArchive = new StyleCreateCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StyleRenameCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.StyleRenameCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.StyleBaseCommandArchive },
            { no: 2, name: "updated_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "old_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.StyleBaseCommandArchive super */ 1:
                    message.super = exports.StyleBaseCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional string updated_name */ 2:
                    message.updatedName = reader.string();
                    break;
                case /* optional string old_name */ 3:
                    message.oldName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.StyleBaseCommandArchive super = 1; */
        if (message.super)
            exports.StyleBaseCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string updated_name = 2; */
        if (message.updatedName !== undefined)
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.updatedName);
        /* optional string old_name = 3; */
        if (message.oldName !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.oldName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.StyleRenameCommandArchive
 */
exports.StyleRenameCommandArchive = new StyleRenameCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StyleUpdateCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.StyleUpdateCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.StyleBaseCommandArchive },
            { no: 2, name: "original_style", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 3, name: "updated_style", kind: "message", T: () => TSPMessages_6.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.StyleBaseCommandArchive super */ 1:
                    message.super = exports.StyleBaseCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference original_style */ 2:
                    message.originalStyle = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.originalStyle);
                    break;
                case /* optional TSP.Reference updated_style */ 3:
                    message.updatedStyle = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.updatedStyle);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.StyleBaseCommandArchive super = 1; */
        if (message.super)
            exports.StyleBaseCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference original_style = 2; */
        if (message.originalStyle)
            TSPMessages_6.Reference.internalBinaryWrite(message.originalStyle, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference updated_style = 3; */
        if (message.updatedStyle)
            TSPMessages_6.Reference.internalBinaryWrite(message.updatedStyle, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.StyleUpdateCommandArchive
 */
exports.StyleUpdateCommandArchive = new StyleUpdateCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StyleDeleteCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.StyleDeleteCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.StyleBaseCommandArchive },
            { no: 2, name: "old_preset_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.StyleBaseCommandArchive super */ 1:
                    message.super = exports.StyleBaseCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional uint32 old_preset_index */ 2:
                    message.oldPresetIndex = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.StyleBaseCommandArchive super = 1; */
        if (message.super)
            exports.StyleBaseCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 old_preset_index = 2; */
        if (message.oldPresetIndex !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.oldPresetIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.StyleDeleteCommandArchive
 */
exports.StyleDeleteCommandArchive = new StyleDeleteCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StyleReorderCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.StyleReorderCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.StyleBaseCommandArchive },
            { no: 2, name: "old_preset_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "new_preset_index", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSWP.StyleBaseCommandArchive super */ 1:
                    message.super = exports.StyleBaseCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional uint32 old_preset_index */ 2:
                    message.oldPresetIndex = reader.uint32();
                    break;
                case /* optional uint32 new_preset_index */ 3:
                    message.newPresetIndex = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSWP.StyleBaseCommandArchive super = 1; */
        if (message.super)
            exports.StyleBaseCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 old_preset_index = 2; */
        if (message.oldPresetIndex !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.oldPresetIndex);
        /* optional uint32 new_preset_index = 3; */
        if (message.newPresetIndex !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.newPresetIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.StyleReorderCommandArchive
 */
exports.StyleReorderCommandArchive = new StyleReorderCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StyleUpdatePropertyMapCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.StyleUpdatePropertyMapCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSSArchives_1.StyleUpdatePropertyMapCommandArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSS.StyleUpdatePropertyMapCommandArchive super */ 1:
                    message.super = TSSArchives_1.StyleUpdatePropertyMapCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSS.StyleUpdatePropertyMapCommandArchive super = 1; */
        if (message.super)
            TSSArchives_1.StyleUpdatePropertyMapCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.StyleUpdatePropertyMapCommandArchive
 */
exports.StyleUpdatePropertyMapCommandArchive = new StyleUpdatePropertyMapCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShapeStyleSetValueCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ShapeStyleSetValueCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSDCommandArchives_4.BaseStyleSetValueCommandArchive },
            { no: 4, name: "change", kind: "message", T: () => TSWPArchives_sos_3.ShapeStylePropertyChangeSetArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.BaseStyleSetValueCommandArchive super */ 1:
                    message.super = TSDCommandArchives_4.BaseStyleSetValueCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSWPSOS.ShapeStylePropertyChangeSetArchive change */ 4:
                    message.change = TSWPArchives_sos_3.ShapeStylePropertyChangeSetArchive.internalBinaryRead(reader, reader.uint32(), options, message.change);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.BaseStyleSetValueCommandArchive super = 1; */
        if (message.super)
            TSDCommandArchives_4.BaseStyleSetValueCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWPSOS.ShapeStylePropertyChangeSetArchive change = 4; */
        if (message.change)
            TSWPArchives_sos_3.ShapeStylePropertyChangeSetArchive.internalBinaryWrite(message.change, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ShapeStyleSetValueCommandArchive
 */
exports.ShapeStyleSetValueCommandArchive = new ShapeStyleSetValueCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelectionTransformerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.SelectionTransformerArchive", [
            { no: 1, name: "storage_uuid_path", kind: "message", T: () => TSPMessages_5.UUIDPath },
            { no: 2, name: "selection", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 3, name: "transformed_to_noop", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUIDPath storage_uuid_path */ 1:
                    message.storageUuidPath = TSPMessages_5.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.storageUuidPath);
                    break;
                case /* TSP.Reference selection */ 2:
                    message.selection = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.selection);
                    break;
                case /* optional bool transformed_to_noop */ 3:
                    message.transformedToNoop = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUIDPath storage_uuid_path = 1; */
        if (message.storageUuidPath)
            TSPMessages_5.UUIDPath.internalBinaryWrite(message.storageUuidPath, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference selection = 2; */
        if (message.selection)
            TSPMessages_6.Reference.internalBinaryWrite(message.selection, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool transformed_to_noop = 3; */
        if (message.transformedToNoop !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.transformedToNoop);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.SelectionTransformerArchive
 */
exports.SelectionTransformerArchive = new SelectionTransformerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PencilAnnotationSelectionTransformerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.PencilAnnotationSelectionTransformerArchive", [
            { no: 1, name: "storage_uuid_path", kind: "message", T: () => TSPMessages_5.UUIDPath },
            { no: 2, name: "text_pencil_annotation_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { textPencilAnnotationUuid: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSP.UUIDPath storage_uuid_path */ 1:
                    message.storageUuidPath = TSPMessages_5.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.storageUuidPath);
                    break;
                case /* string text_pencil_annotation_uuid */ 2:
                    message.textPencilAnnotationUuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSP.UUIDPath storage_uuid_path = 1; */
        if (message.storageUuidPath)
            TSPMessages_5.UUIDPath.internalBinaryWrite(message.storageUuidPath, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string text_pencil_annotation_uuid = 2; */
        if (message.textPencilAnnotationUuid !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.textPencilAnnotationUuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.PencilAnnotationSelectionTransformerArchive
 */
exports.PencilAnnotationSelectionTransformerArchive = new PencilAnnotationSelectionTransformerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShapeSelectionTransformerArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ShapeSelectionTransformerArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSDCommandArchives_3.ShapeSelectionTransformerArchive },
            { no: 2, name: "storage_uuid_path", kind: "message", T: () => TSPMessages_5.UUIDPath }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.ShapeSelectionTransformerArchive super */ 1:
                    message.super = TSDCommandArchives_3.ShapeSelectionTransformerArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.UUIDPath storage_uuid_path */ 2:
                    message.storageUuidPath = TSPMessages_5.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.storageUuidPath);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.ShapeSelectionTransformerArchive super = 1; */
        if (message.super)
            TSDCommandArchives_3.ShapeSelectionTransformerArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDPath storage_uuid_path = 2; */
        if (message.storageUuidPath)
            TSPMessages_5.UUIDPath.internalBinaryWrite(message.storageUuidPath, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ShapeSelectionTransformerArchive
 */
exports.ShapeSelectionTransformerArchive = new ShapeSelectionTransformerArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShapeContentDescription$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ShapeContentDescription", [
            { no: 1, name: "super", kind: "message", T: () => TSDArchives_3.DrawableContentDescription },
            { no: 2, name: "text_range_location", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "text_range_length", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSD.DrawableContentDescription super */ 1:
                    message.super = TSDArchives_3.DrawableContentDescription.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional uint32 text_range_location */ 2:
                    message.textRangeLocation = reader.uint32();
                    break;
                case /* optional uint32 text_range_length */ 3:
                    message.textRangeLength = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSD.DrawableContentDescription super = 1; */
        if (message.super)
            TSDArchives_3.DrawableContentDescription.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 text_range_location = 2; */
        if (message.textRangeLocation !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).uint32(message.textRangeLocation);
        /* optional uint32 text_range_length = 3; */
        if (message.textRangeLength !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).uint32(message.textRangeLength);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ShapeContentDescription
 */
exports.ShapeContentDescription = new ShapeContentDescription$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ObjectPropertyArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ObjectPropertyArchive", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["TSWP.ObjectPropertyType", ObjectPropertyType] },
            { no: 3, name: "bool_value", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "float_value", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "integer_value", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "string_value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "id_path_value", kind: "message", T: () => TSPMessages_5.UUIDPath },
            { no: 8, name: "fill_value", kind: "message", T: () => TSDArchives_2.FillArchive },
            { no: 9, name: "color_value", kind: "message", T: () => TSPMessages_2.Color },
            { no: 10, name: "shadow_value", kind: "message", T: () => TSDArchives_1.ShadowArchive }
        ]);
    }
    create(value) {
        const message = { name: "", type: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* TSWP.ObjectPropertyType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* optional bool bool_value */ 3:
                    message.boolValue = reader.bool();
                    break;
                case /* optional float float_value */ 4:
                    message.floatValue = reader.float();
                    break;
                case /* optional int32 integer_value */ 5:
                    message.integerValue = reader.int32();
                    break;
                case /* optional string string_value */ 6:
                    message.stringValue = reader.string();
                    break;
                case /* optional TSP.UUIDPath id_path_value */ 7:
                    message.idPathValue = TSPMessages_5.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.idPathValue);
                    break;
                case /* optional TSD.FillArchive fill_value */ 8:
                    message.fillValue = TSDArchives_2.FillArchive.internalBinaryRead(reader, reader.uint32(), options, message.fillValue);
                    break;
                case /* optional TSP.Color color_value */ 9:
                    message.colorValue = TSPMessages_2.Color.internalBinaryRead(reader, reader.uint32(), options, message.colorValue);
                    break;
                case /* optional TSD.ShadowArchive shadow_value */ 10:
                    message.shadowValue = TSDArchives_1.ShadowArchive.internalBinaryRead(reader, reader.uint32(), options, message.shadowValue);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* TSWP.ObjectPropertyType type = 2; */
        if (message.type !== 0)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.type);
        /* optional bool bool_value = 3; */
        if (message.boolValue !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.boolValue);
        /* optional float float_value = 4; */
        if (message.floatValue !== undefined)
            writer.tag(4, runtime_1.WireType.Bit32).float(message.floatValue);
        /* optional int32 integer_value = 5; */
        if (message.integerValue !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).int32(message.integerValue);
        /* optional string string_value = 6; */
        if (message.stringValue !== undefined)
            writer.tag(6, runtime_1.WireType.LengthDelimited).string(message.stringValue);
        /* optional TSP.UUIDPath id_path_value = 7; */
        if (message.idPathValue)
            TSPMessages_5.UUIDPath.internalBinaryWrite(message.idPathValue, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.FillArchive fill_value = 8; */
        if (message.fillValue)
            TSDArchives_2.FillArchive.internalBinaryWrite(message.fillValue, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Color color_value = 9; */
        if (message.colorValue)
            TSPMessages_2.Color.internalBinaryWrite(message.colorValue, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.ShadowArchive shadow_value = 10; */
        if (message.shadowValue)
            TSDArchives_1.ShadowArchive.internalBinaryWrite(message.shadowValue, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ObjectPropertyArchive
 */
exports.ObjectPropertyArchive = new ObjectPropertyArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetObjectPropertiesCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.SetObjectPropertiesCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_5.CommandArchive },
            { no: 2, name: "object_uuid_path", kind: "message", T: () => TSPMessages_5.UUIDPath },
            { no: 3, name: "properties", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ObjectPropertyArchive },
            { no: 4, name: "action_string", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "old_properties", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => exports.ObjectPropertyArchive }
        ]);
    }
    create(value) {
        const message = { properties: [], oldProperties: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_5.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.UUIDPath object_uuid_path */ 2:
                    message.objectUuidPath = TSPMessages_5.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.objectUuidPath);
                    break;
                case /* repeated TSWP.ObjectPropertyArchive properties */ 3:
                    message.properties.push(exports.ObjectPropertyArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string action_string */ 4:
                    message.actionString = reader.string();
                    break;
                case /* repeated TSWP.ObjectPropertyArchive old_properties */ 5:
                    message.oldProperties.push(exports.ObjectPropertyArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_5.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.UUIDPath object_uuid_path = 2; */
        if (message.objectUuidPath)
            TSPMessages_5.UUIDPath.internalBinaryWrite(message.objectUuidPath, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSWP.ObjectPropertyArchive properties = 3; */
        for (let i = 0; i < message.properties.length; i++)
            exports.ObjectPropertyArchive.internalBinaryWrite(message.properties[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string action_string = 4; */
        if (message.actionString !== undefined)
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.actionString);
        /* repeated TSWP.ObjectPropertyArchive old_properties = 5; */
        for (let i = 0; i < message.oldProperties.length; i++)
            exports.ObjectPropertyArchive.internalBinaryWrite(message.oldProperties[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.SetObjectPropertiesCommandArchive
 */
exports.SetObjectPropertiesCommandArchive = new SetObjectPropertiesCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateFlowInfoCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.UpdateFlowInfoCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_5.CommandArchive },
            { no: 2, name: "command_mode", kind: "enum", opt: true, T: () => ["TSWP.UpdateFlowInfoCommandArchive.Mode", UpdateFlowInfoCommandArchive_Mode] },
            { no: 3, name: "flow_info_uuid_path", kind: "message", T: () => TSPMessages_5.UUIDPath },
            { no: 4, name: "text_box_id_path_to_add_or_remove", kind: "message", T: () => TSPMessages_5.UUIDPath },
            { no: 5, name: "text_box_id_paths_at_start", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.UUIDPath },
            { no: 6, name: "suggested_text_box_id_paths_at_end", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_5.UUIDPath },
            { no: 7, name: "undo_text_boxes_to_restore", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_6.Reference },
            { no: 8, name: "undo_added_shape_info", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 9, name: "undo_removed_shape_info", kind: "message", T: () => TSPMessages_6.Reference }
        ]);
    }
    create(value) {
        const message = { textBoxIdPathsAtStart: [], suggestedTextBoxIdPathsAtEnd: [], undoTextBoxesToRestore: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_5.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSWP.UpdateFlowInfoCommandArchive.Mode command_mode */ 2:
                    message.commandMode = reader.int32();
                    break;
                case /* optional TSP.UUIDPath flow_info_uuid_path */ 3:
                    message.flowInfoUuidPath = TSPMessages_5.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.flowInfoUuidPath);
                    break;
                case /* optional TSP.UUIDPath text_box_id_path_to_add_or_remove */ 4:
                    message.textBoxIdPathToAddOrRemove = TSPMessages_5.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.textBoxIdPathToAddOrRemove);
                    break;
                case /* repeated TSP.UUIDPath text_box_id_paths_at_start */ 5:
                    message.textBoxIdPathsAtStart.push(TSPMessages_5.UUIDPath.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.UUIDPath suggested_text_box_id_paths_at_end */ 6:
                    message.suggestedTextBoxIdPathsAtEnd.push(TSPMessages_5.UUIDPath.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TSP.Reference undo_text_boxes_to_restore */ 7:
                    message.undoTextBoxesToRestore.push(TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional TSP.Reference undo_added_shape_info */ 8:
                    message.undoAddedShapeInfo = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoAddedShapeInfo);
                    break;
                case /* optional TSP.Reference undo_removed_shape_info */ 9:
                    message.undoRemovedShapeInfo = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoRemovedShapeInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_5.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSWP.UpdateFlowInfoCommandArchive.Mode command_mode = 2; */
        if (message.commandMode !== undefined)
            writer.tag(2, runtime_1.WireType.Varint).int32(message.commandMode);
        /* optional TSP.UUIDPath flow_info_uuid_path = 3; */
        if (message.flowInfoUuidPath)
            TSPMessages_5.UUIDPath.internalBinaryWrite(message.flowInfoUuidPath, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDPath text_box_id_path_to_add_or_remove = 4; */
        if (message.textBoxIdPathToAddOrRemove)
            TSPMessages_5.UUIDPath.internalBinaryWrite(message.textBoxIdPathToAddOrRemove, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUIDPath text_box_id_paths_at_start = 5; */
        for (let i = 0; i < message.textBoxIdPathsAtStart.length; i++)
            TSPMessages_5.UUIDPath.internalBinaryWrite(message.textBoxIdPathsAtStart[i], writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.UUIDPath suggested_text_box_id_paths_at_end = 6; */
        for (let i = 0; i < message.suggestedTextBoxIdPathsAtEnd.length; i++)
            TSPMessages_5.UUIDPath.internalBinaryWrite(message.suggestedTextBoxIdPathsAtEnd[i], writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference undo_text_boxes_to_restore = 7; */
        for (let i = 0; i < message.undoTextBoxesToRestore.length; i++)
            TSPMessages_6.Reference.internalBinaryWrite(message.undoTextBoxesToRestore[i], writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_added_shape_info = 8; */
        if (message.undoAddedShapeInfo)
            TSPMessages_6.Reference.internalBinaryWrite(message.undoAddedShapeInfo, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_removed_shape_info = 9; */
        if (message.undoRemovedShapeInfo)
            TSPMessages_6.Reference.internalBinaryWrite(message.undoRemovedShapeInfo, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.UpdateFlowInfoCommandArchive
 */
exports.UpdateFlowInfoCommandArchive = new UpdateFlowInfoCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddFlowInfoCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.AddFlowInfoCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_5.CommandArchive },
            { no: 2, name: "flow_info_to_add", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 3, name: "flow_info_archive", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 4, name: "undo_user_interface_identifier_to_restore", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "undo_next_user_interface_identifier_to_restore", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "working_undo_object", kind: "message", T: () => TSPMessages_6.Reference }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_5.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.Reference flow_info_to_add */ 2:
                    message.flowInfoToAdd = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.flowInfoToAdd);
                    break;
                case /* optional TSP.Reference flow_info_archive */ 3:
                    message.flowInfoArchive = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.flowInfoArchive);
                    break;
                case /* optional uint32 undo_user_interface_identifier_to_restore */ 4:
                    message.undoUserInterfaceIdentifierToRestore = reader.uint32();
                    break;
                case /* optional uint32 undo_next_user_interface_identifier_to_restore */ 5:
                    message.undoNextUserInterfaceIdentifierToRestore = reader.uint32();
                    break;
                case /* optional TSP.Reference working_undo_object */ 6:
                    message.workingUndoObject = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.workingUndoObject);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_5.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference flow_info_to_add = 2; */
        if (message.flowInfoToAdd)
            TSPMessages_6.Reference.internalBinaryWrite(message.flowInfoToAdd, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference flow_info_archive = 3; */
        if (message.flowInfoArchive)
            TSPMessages_6.Reference.internalBinaryWrite(message.flowInfoArchive, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 undo_user_interface_identifier_to_restore = 4; */
        if (message.undoUserInterfaceIdentifierToRestore !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.undoUserInterfaceIdentifierToRestore);
        /* optional uint32 undo_next_user_interface_identifier_to_restore = 5; */
        if (message.undoNextUserInterfaceIdentifierToRestore !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.undoNextUserInterfaceIdentifierToRestore);
        /* optional TSP.Reference working_undo_object = 6; */
        if (message.workingUndoObject)
            TSPMessages_6.Reference.internalBinaryWrite(message.workingUndoObject, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.AddFlowInfoCommandArchive
 */
exports.AddFlowInfoCommandArchive = new AddFlowInfoCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveFlowInfoCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.RemoveFlowInfoCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_5.CommandArchive },
            { no: 2, name: "flow_info_uuid_path", kind: "message", T: () => TSPMessages_5.UUIDPath },
            { no: 3, name: "undo_object", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 4, name: "undo_user_interface_identifier_to_restore", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "undo_next_user_interface_identifier_to_restore", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_5.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.UUIDPath flow_info_uuid_path */ 2:
                    message.flowInfoUuidPath = TSPMessages_5.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.flowInfoUuidPath);
                    break;
                case /* optional TSP.Reference undo_object */ 3:
                    message.undoObject = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoObject);
                    break;
                case /* optional uint32 undo_user_interface_identifier_to_restore */ 4:
                    message.undoUserInterfaceIdentifierToRestore = reader.uint32();
                    break;
                case /* optional uint32 undo_next_user_interface_identifier_to_restore */ 5:
                    message.undoNextUserInterfaceIdentifierToRestore = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_5.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDPath flow_info_uuid_path = 2; */
        if (message.flowInfoUuidPath)
            TSPMessages_5.UUIDPath.internalBinaryWrite(message.flowInfoUuidPath, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference undo_object = 3; */
        if (message.undoObject)
            TSPMessages_6.Reference.internalBinaryWrite(message.undoObject, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 undo_user_interface_identifier_to_restore = 4; */
        if (message.undoUserInterfaceIdentifierToRestore !== undefined)
            writer.tag(4, runtime_1.WireType.Varint).uint32(message.undoUserInterfaceIdentifierToRestore);
        /* optional uint32 undo_next_user_interface_identifier_to_restore = 5; */
        if (message.undoNextUserInterfaceIdentifierToRestore !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).uint32(message.undoNextUserInterfaceIdentifierToRestore);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.RemoveFlowInfoCommandArchive
 */
exports.RemoveFlowInfoCommandArchive = new RemoveFlowInfoCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TextCommentReplyCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.TextCommentReplyCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_5.CommandArchive },
            { no: 2, name: "storage_uuid_path", kind: "message", T: () => TSPMessages_5.UUIDPath },
            { no: 3, name: "annotation_uuid", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "forward_comment", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 5, name: "inverse_comment", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 6, name: "forward_variant", kind: "enum", opt: true, T: () => ["TSD.CommentCommandVariant", TSDCommandArchives_2.CommentCommandVariant] },
            { no: 7, name: "inverse_variant", kind: "enum", opt: true, T: () => ["TSD.CommentCommandVariant", TSDCommandArchives_2.CommentCommandVariant] }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_5.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* optional TSP.UUIDPath storage_uuid_path */ 2:
                    message.storageUuidPath = TSPMessages_5.UUIDPath.internalBinaryRead(reader, reader.uint32(), options, message.storageUuidPath);
                    break;
                case /* optional string annotation_uuid */ 3:
                    message.annotationUuid = reader.string();
                    break;
                case /* optional TSP.Reference forward_comment */ 4:
                    message.forwardComment = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.forwardComment);
                    break;
                case /* optional TSP.Reference inverse_comment */ 5:
                    message.inverseComment = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.inverseComment);
                    break;
                case /* optional TSD.CommentCommandVariant forward_variant */ 6:
                    message.forwardVariant = reader.int32();
                    break;
                case /* optional TSD.CommentCommandVariant inverse_variant */ 7:
                    message.inverseVariant = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_5.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.UUIDPath storage_uuid_path = 2; */
        if (message.storageUuidPath)
            TSPMessages_5.UUIDPath.internalBinaryWrite(message.storageUuidPath, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string annotation_uuid = 3; */
        if (message.annotationUuid !== undefined)
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.annotationUuid);
        /* optional TSP.Reference forward_comment = 4; */
        if (message.forwardComment)
            TSPMessages_6.Reference.internalBinaryWrite(message.forwardComment, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSP.Reference inverse_comment = 5; */
        if (message.inverseComment)
            TSPMessages_6.Reference.internalBinaryWrite(message.inverseComment, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional TSD.CommentCommandVariant forward_variant = 6; */
        if (message.forwardVariant !== undefined)
            writer.tag(6, runtime_1.WireType.Varint).int32(message.forwardVariant);
        /* optional TSD.CommentCommandVariant inverse_variant = 7; */
        if (message.inverseVariant !== undefined)
            writer.tag(7, runtime_1.WireType.Varint).int32(message.inverseVariant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.TextCommentReplyCommandArchive
 */
exports.TextCommentReplyCommandArchive = new TextCommentReplyCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ContainedObjectsCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ContainedObjectsCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSKArchives_5.CommandArchive },
            { no: 2, name: "target", kind: "message", T: () => TSPMessages_6.Reference },
            { no: 3, name: "objects", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_6.Reference },
            { no: 4, name: "undo_object_for_commit", kind: "message", oneof: "undoObject", T: () => TSPMessages_6.Reference },
            { no: 5, name: "undo_object_for_make_inverse", kind: "message", oneof: "undoObject", T: () => TSPMessages_6.Reference },
            { no: 6, name: "add_behavior_args", kind: "message", oneof: "behavior", T: () => exports.ContainedObjectsCommandArchive_AddBehaviorArgs },
            { no: 7, name: "remove_behavior_args", kind: "message", oneof: "behavior", T: () => exports.ContainedObjectsCommandArchive_RemoveBehaviorArgs },
            { no: 8, name: "rearrange_behavior_args", kind: "message", oneof: "behavior", T: () => exports.ContainedObjectsCommandArchive_RearrangeBehaviorArgs },
            { no: 9, name: "container_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { objects: [], undoObject: { oneofKind: undefined }, behavior: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSK.CommandArchive super */ 1:
                    message.super = TSKArchives_5.CommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* TSP.Reference target */ 2:
                    message.target = TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* repeated TSP.Reference objects */ 3:
                    message.objects.push(TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* TSP.Reference undo_object_for_commit */ 4:
                    message.undoObject = {
                        oneofKind: "undoObjectForCommit",
                        undoObjectForCommit: TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoObject.undoObjectForCommit)
                    };
                    break;
                case /* TSP.Reference undo_object_for_make_inverse */ 5:
                    message.undoObject = {
                        oneofKind: "undoObjectForMakeInverse",
                        undoObjectForMakeInverse: TSPMessages_6.Reference.internalBinaryRead(reader, reader.uint32(), options, message.undoObject.undoObjectForMakeInverse)
                    };
                    break;
                case /* TSWP.ContainedObjectsCommandArchive.AddBehaviorArgs add_behavior_args */ 6:
                    message.behavior = {
                        oneofKind: "addBehaviorArgs",
                        addBehaviorArgs: exports.ContainedObjectsCommandArchive_AddBehaviorArgs.internalBinaryRead(reader, reader.uint32(), options, message.behavior.addBehaviorArgs)
                    };
                    break;
                case /* TSWP.ContainedObjectsCommandArchive.RemoveBehaviorArgs remove_behavior_args */ 7:
                    message.behavior = {
                        oneofKind: "removeBehaviorArgs",
                        removeBehaviorArgs: exports.ContainedObjectsCommandArchive_RemoveBehaviorArgs.internalBinaryRead(reader, reader.uint32(), options, message.behavior.removeBehaviorArgs)
                    };
                    break;
                case /* TSWP.ContainedObjectsCommandArchive.RearrangeBehaviorArgs rearrange_behavior_args */ 8:
                    message.behavior = {
                        oneofKind: "rearrangeBehaviorArgs",
                        rearrangeBehaviorArgs: exports.ContainedObjectsCommandArchive_RearrangeBehaviorArgs.internalBinaryRead(reader, reader.uint32(), options, message.behavior.rearrangeBehaviorArgs)
                    };
                    break;
                case /* optional string container_name */ 9:
                    message.containerName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSK.CommandArchive super = 1; */
        if (message.super)
            TSKArchives_5.CommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference target = 2; */
        if (message.target)
            TSPMessages_6.Reference.internalBinaryWrite(message.target, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Reference objects = 3; */
        for (let i = 0; i < message.objects.length; i++)
            TSPMessages_6.Reference.internalBinaryWrite(message.objects[i], writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference undo_object_for_commit = 4; */
        if (message.undoObject.oneofKind === "undoObjectForCommit")
            TSPMessages_6.Reference.internalBinaryWrite(message.undoObject.undoObjectForCommit, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSP.Reference undo_object_for_make_inverse = 5; */
        if (message.undoObject.oneofKind === "undoObjectForMakeInverse")
            TSPMessages_6.Reference.internalBinaryWrite(message.undoObject.undoObjectForMakeInverse, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSWP.ContainedObjectsCommandArchive.AddBehaviorArgs add_behavior_args = 6; */
        if (message.behavior.oneofKind === "addBehaviorArgs")
            exports.ContainedObjectsCommandArchive_AddBehaviorArgs.internalBinaryWrite(message.behavior.addBehaviorArgs, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSWP.ContainedObjectsCommandArchive.RemoveBehaviorArgs remove_behavior_args = 7; */
        if (message.behavior.oneofKind === "removeBehaviorArgs")
            exports.ContainedObjectsCommandArchive_RemoveBehaviorArgs.internalBinaryWrite(message.behavior.removeBehaviorArgs, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* TSWP.ContainedObjectsCommandArchive.RearrangeBehaviorArgs rearrange_behavior_args = 8; */
        if (message.behavior.oneofKind === "rearrangeBehaviorArgs")
            exports.ContainedObjectsCommandArchive_RearrangeBehaviorArgs.internalBinaryWrite(message.behavior.rearrangeBehaviorArgs, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional string container_name = 9; */
        if (message.containerName !== undefined)
            writer.tag(9, runtime_1.WireType.LengthDelimited).string(message.containerName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ContainedObjectsCommandArchive
 */
exports.ContainedObjectsCommandArchive = new ContainedObjectsCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ContainedObjectsCommandArchive_AddBehaviorArgs$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ContainedObjectsCommandArchive.AddBehaviorArgs", [
            { no: 1, name: "args_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSKArchives_3.AddIdOperationArgs }
        ]);
    }
    create(value) {
        const message = { argsList: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSK.AddIdOperationArgs args_list */ 1:
                    message.argsList.push(TSKArchives_3.AddIdOperationArgs.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSK.AddIdOperationArgs args_list = 1; */
        for (let i = 0; i < message.argsList.length; i++)
            TSKArchives_3.AddIdOperationArgs.internalBinaryWrite(message.argsList[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ContainedObjectsCommandArchive.AddBehaviorArgs
 */
exports.ContainedObjectsCommandArchive_AddBehaviorArgs = new ContainedObjectsCommandArchive_AddBehaviorArgs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ContainedObjectsCommandArchive_RemoveBehaviorArgs$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ContainedObjectsCommandArchive.RemoveBehaviorArgs", [
            { no: 1, name: "args_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSKArchives_2.RemoveIdOperationArgs }
        ]);
    }
    create(value) {
        const message = { argsList: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSK.RemoveIdOperationArgs args_list */ 1:
                    message.argsList.push(TSKArchives_2.RemoveIdOperationArgs.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSK.RemoveIdOperationArgs args_list = 1; */
        for (let i = 0; i < message.argsList.length; i++)
            TSKArchives_2.RemoveIdOperationArgs.internalBinaryWrite(message.argsList[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ContainedObjectsCommandArchive.RemoveBehaviorArgs
 */
exports.ContainedObjectsCommandArchive_RemoveBehaviorArgs = new ContainedObjectsCommandArchive_RemoveBehaviorArgs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ContainedObjectsCommandArchive_RearrangeBehaviorArgs$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ContainedObjectsCommandArchive.RearrangeBehaviorArgs", [
            { no: 1, name: "args_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSKArchives_1.RearrangeIdOperationArgs }
        ]);
    }
    create(value) {
        const message = { argsList: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated TSK.RearrangeIdOperationArgs args_list */ 1:
                    message.argsList.push(TSKArchives_1.RearrangeIdOperationArgs.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated TSK.RearrangeIdOperationArgs args_list = 1; */
        for (let i = 0; i < message.argsList.length; i++)
            TSKArchives_1.RearrangeIdOperationArgs.internalBinaryWrite(message.argsList[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ContainedObjectsCommandArchive.RearrangeBehaviorArgs
 */
exports.ContainedObjectsCommandArchive_RearrangeBehaviorArgs = new ContainedObjectsCommandArchive_RearrangeBehaviorArgs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EquationInfoGeometryCommandArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.EquationInfoGeometryCommandArchive", [
            { no: 1, name: "super", kind: "message", T: () => TSDCommandArchives_1.MediaInfoGeometryCommandArchive }
        ]);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional TSD.MediaInfoGeometryCommandArchive super */ 1:
                    message.super = TSDCommandArchives_1.MediaInfoGeometryCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* optional TSD.MediaInfoGeometryCommandArchive super = 1; */
        if (message.super)
            TSDCommandArchives_1.MediaInfoGeometryCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.EquationInfoGeometryCommandArchive
 */
exports.EquationInfoGeometryCommandArchive = new EquationInfoGeometryCommandArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CharacterStyleChangePropertyCommand_GArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.CharacterStyleChangePropertyCommand_GArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.StorageActionCommandArchive },
            { no: 2, name: "range_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_1.Range },
            { no: 3, name: "range_list_undefined", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "change_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSWPArchives_sos_2.CharacterStylePropertyChangeSetArchive },
            { no: 5, name: "change_list_undefined", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "disable_character_style_promotion", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { rangeList: [], changeList: [], disableCharacterStylePromotion: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSWP.StorageActionCommandArchive super */ 1:
                    message.super = exports.StorageActionCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSP.Range range_list */ 2:
                    message.rangeList.push(TSPMessages_1.Range.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool range_list_undefined */ 3:
                    message.rangeListUndefined = reader.bool();
                    break;
                case /* repeated TSWPSOS.CharacterStylePropertyChangeSetArchive change_list */ 4:
                    message.changeList.push(TSWPArchives_sos_2.CharacterStylePropertyChangeSetArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool change_list_undefined */ 5:
                    message.changeListUndefined = reader.bool();
                    break;
                case /* bool disable_character_style_promotion */ 6:
                    message.disableCharacterStylePromotion = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSWP.StorageActionCommandArchive super = 1; */
        if (message.super)
            exports.StorageActionCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Range range_list = 2; */
        for (let i = 0; i < message.rangeList.length; i++)
            TSPMessages_1.Range.internalBinaryWrite(message.rangeList[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool range_list_undefined = 3; */
        if (message.rangeListUndefined !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.rangeListUndefined);
        /* repeated TSWPSOS.CharacterStylePropertyChangeSetArchive change_list = 4; */
        for (let i = 0; i < message.changeList.length; i++)
            TSWPArchives_sos_2.CharacterStylePropertyChangeSetArchive.internalBinaryWrite(message.changeList[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool change_list_undefined = 5; */
        if (message.changeListUndefined !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.changeListUndefined);
        /* bool disable_character_style_promotion = 6; */
        if (message.disableCharacterStylePromotion !== false)
            writer.tag(6, runtime_1.WireType.Varint).bool(message.disableCharacterStylePromotion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.CharacterStyleChangePropertyCommand_GArchive
 */
exports.CharacterStyleChangePropertyCommand_GArchive = new CharacterStyleChangePropertyCommand_GArchive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ParagraphStyleChangePropertyCommand_GArchive$Type extends runtime_5.MessageType {
    constructor() {
        super("TSWP.ParagraphStyleChangePropertyCommand_GArchive", [
            { no: 1, name: "super", kind: "message", T: () => exports.StorageActionCommandArchive },
            { no: 2, name: "range_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSPMessages_1.Range },
            { no: 3, name: "range_list_undefined", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "change_list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TSWPArchives_sos_1.ParagraphStylePropertyChangeSetArchive },
            { no: 5, name: "change_list_undefined", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = { rangeList: [], changeList: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TSWP.StorageActionCommandArchive super */ 1:
                    message.super = exports.StorageActionCommandArchive.internalBinaryRead(reader, reader.uint32(), options, message.super);
                    break;
                case /* repeated TSP.Range range_list */ 2:
                    message.rangeList.push(TSPMessages_1.Range.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool range_list_undefined */ 3:
                    message.rangeListUndefined = reader.bool();
                    break;
                case /* repeated TSWPSOS.ParagraphStylePropertyChangeSetArchive change_list */ 4:
                    message.changeList.push(TSWPArchives_sos_1.ParagraphStylePropertyChangeSetArchive.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool change_list_undefined */ 5:
                    message.changeListUndefined = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* TSWP.StorageActionCommandArchive super = 1; */
        if (message.super)
            exports.StorageActionCommandArchive.internalBinaryWrite(message.super, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* repeated TSP.Range range_list = 2; */
        for (let i = 0; i < message.rangeList.length; i++)
            TSPMessages_1.Range.internalBinaryWrite(message.rangeList[i], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool range_list_undefined = 3; */
        if (message.rangeListUndefined !== undefined)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.rangeListUndefined);
        /* repeated TSWPSOS.ParagraphStylePropertyChangeSetArchive change_list = 4; */
        for (let i = 0; i < message.changeList.length; i++)
            TSWPArchives_sos_1.ParagraphStylePropertyChangeSetArchive.internalBinaryWrite(message.changeList[i], writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* optional bool change_list_undefined = 5; */
        if (message.changeListUndefined !== undefined)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.changeListUndefined);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TSWP.ParagraphStyleChangePropertyCommand_GArchive
 */
exports.ParagraphStyleChangePropertyCommand_GArchive = new ParagraphStyleChangePropertyCommand_GArchive$Type();
//# sourceMappingURL=TSWPCommandArchives.js.map