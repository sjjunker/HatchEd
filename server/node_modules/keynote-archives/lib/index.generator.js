"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateIndex = void 0;
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const langium_1 = require("langium");
const path_1 = require("path");
const readline_1 = require("readline");
async function readCodes() {
    const fileStream = (0, fs_1.createReadStream)((0, path_1.resolve)(__dirname, `./protocols/codes.csv`));
    const rl = (0, readline_1.createInterface)({
        input: fileStream,
        crlfDelay: Infinity
    });
    const prefixes = new Set();
    const result = new Map();
    for await (const line of rl) {
        const [code, prefix, datatype] = line.split(';');
        result.set(parseInt(code), { prefix, datatype });
        prefixes.add(prefix);
    }
    return [result, prefixes];
}
async function readTypes() {
    const files = await (0, promises_1.readdir)((0, path_1.resolve)(__dirname, './protocols'));
    const allTypes = new Map();
    for (const file of files) {
        const name = (0, path_1.basename)(file, '.proto');
        let prefix;
        if (name.startsWith('TSCHPreUFF')) {
            prefix = 'TSCHPreUFF';
        }
        else {
            const match = /^([A-Z]+)[A-Z][^A-Z]/.exec(name);
            if (!match) {
                continue;
            }
            prefix = match[1] + (name.endsWith('sos') ? 'SOS' : '');
        }
        const fileStream = (0, fs_1.createReadStream)((0, path_1.resolve)(__dirname, `./generated/${name}.ts`));
        const rl = (0, readline_1.createInterface)({
            input: fileStream,
            crlfDelay: Infinity
        });
        const types = new Set();
        for await (const line of rl) {
            const match = /^export const \w+ = new (\w+)\$Type\(\);$/.exec(line);
            if (match) {
                types.add(match[1]);
            }
        }
        if (!allTypes.has(prefix)) {
            allTypes.set(prefix, []);
        }
        allTypes.get(prefix)?.push({ name, types: [...types] });
    }
    return allTypes;
}
async function generateIndex() {
    const allTypes = await readTypes();
    const [codes] = await readCodes();
    const generatorNode = new langium_1.CompositeGeneratorNode();
    const imports = new Map();
    for (const [code, { prefix, datatype }] of codes) {
        if (prefix === 'package') {
            continue;
        }
        if (allTypes.has(prefix)) {
            const list = allTypes.get(prefix);
            let found = false;
            for (const { types, name } of list) {
                if (types.includes(datatype)) {
                    if (!imports.has(name)) {
                        imports.set(name, []);
                    }
                    imports.get(name).push([code, datatype]);
                    found = true;
                    break;
                }
            }
            if (!found) {
                throw new Error(`Unknown type ${datatype} for prefix ${prefix}`);
            }
        }
        else {
            throw new Error('Unknown prefix: ' + prefix);
        }
    }
    generatorNode.append(`export * from '../utils';`, langium_1.NL);
    for (const [_, list] of allTypes) {
        for (const { name } of list) {
            generatorNode.append(`export * as ${name} from './${name}';`, langium_1.NL);
        }
    }
    generatorNode.append(langium_1.NL);
    for (const [_, list] of allTypes) {
        for (const { name } of list) {
            generatorNode.append(`import * as ${name} from './${name}';`, langium_1.NL);
        }
    }
    generatorNode.append(`import { MessageType } from '@protobuf-ts/runtime';`, langium_1.NL, langium_1.NL);
    let lines = [];
    for (const [name, types] of imports) {
        for (const [code, datatype] of types) {
            lines.push([code, `  ${code}: ${name}.${datatype},`]);
        }
    }
    lines = lines.sort((a, b) => a[0] - b[0]);
    generatorNode.append(`export type KeynoteArchives = {`, langium_1.NL);
    for (const [_, line] of lines) {
        generatorNode.append(line, langium_1.NL);
    }
    generatorNode.append(`};`, langium_1.NL);
    generatorNode.append(langium_1.NL);
    generatorNode.append(`export type KeynoteArchivesMessageTypes = {`, langium_1.NL);
    generatorNode.append(`  [K in keyof KeynoteArchives]: MessageType<KeynoteArchives[K]>`, langium_1.NL);
    generatorNode.append(`}`, langium_1.NL, langium_1.NL);
    generatorNode.append(`export const KeynoteArchives: KeynoteArchivesMessageTypes = {`, langium_1.NL);
    for (const [_, line] of lines) {
        generatorNode.append(line, langium_1.NL);
    }
    generatorNode.append(`};`, langium_1.NL, langium_1.NL);
    for (const [_, list] of allTypes) {
        for (const { name, types } of list) {
            generatorNode.append(`export const ${name}$Archives: MessageType<object>[] = [`, langium_1.NL);
            for (const type of types) {
                generatorNode.append(`  ${name}.${type},`, langium_1.NL);
            }
            generatorNode.append(`];`, langium_1.NL);
        }
    }
    generatorNode.append(langium_1.NL, `export const AllArchives = [`, langium_1.NL);
    for (const [_, list] of allTypes) {
        for (const { name } of list) {
            generatorNode.append(`  ...${name}$Archives,`, langium_1.NL);
        }
    }
    generatorNode.append(`];`, langium_1.NL);
    await (0, promises_1.writeFile)((0, path_1.resolve)(__dirname, 'generated/index.ts'), (0, langium_1.toString)(generatorNode));
}
exports.generateIndex = generateIndex;
generateIndex();
//# sourceMappingURL=index.generator.js.map