"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.analyzeChunkFor = void 0;
const TSPArchiveMessages_1 = require("../generated/TSPArchiveMessages");
const _1 = require(".");
function analyzeChunkFor(chunk, registry) {
    const graph = {
        buffer: chunk,
        nodes: new Map(),
    };
    const reader = new _1.Uint8ArrayReader(chunk);
    scanForArchiveInfos(reader, registry, graph);
    return findPath(graph, chunk);
}
exports.analyzeChunkFor = analyzeChunkFor;
function findPath(graph, chunk) {
    let node = graph.nodes.get(0);
    const end = graph.nodes.get(chunk.length);
    const stack = [{
            node,
            outEdgeIndex: 0,
        }];
    do {
        const top = stack.length - 1;
        const frame = stack[top];
        if (frame.outEdgeIndex < frame.node.outedges.length) {
            const edge = frame.node.outedges[frame.outEdgeIndex];
            frame.outEdgeIndex++;
            node = graph.nodes.get(edge.endExcl);
            stack.push({
                node,
                outEdgeIndex: 0,
            });
        }
        else {
            stack.pop();
        }
    } while (node !== end);
    return stack.map((_, index) => {
        if (index === stack.length - 1) {
            return undefined;
        }
        const current = stack[index].node.outedges;
        const next = stack[index + 1].node.inedges;
        return current.find(edge => next.includes(edge));
    }).filter(p => p).map(p => p);
}
function scanForArchiveInfos(reader, registry, graph) {
    let gapStart = 0;
    let gapLength = 0;
    reader.pos = gapStart + gapLength;
    while (reader.pos < reader.buf.length) {
        let [success, metadata] = tryReadArchiveInfo(reader, registry);
        if (success) {
            if (gapLength > 0) {
                const edge = addGap(graph, gapStart, gapLength);
                gapStart = edge.endExcl;
                gapLength = 0;
            }
            addType(graph, metadata.offset, metadata.length, metadata.messageType);
        }
        else {
            gapLength++;
            reader.pos = gapStart + gapLength;
        }
    }
    if (gapLength > 0) {
        addGap(graph, gapStart, gapLength);
    }
}
function tryReadArchiveInfo(reader, registry) {
    const offset = reader.pos;
    try {
        const archiveInfoLength = reader.readVarint32();
        const archiveInfoBuffer = reader.readBytes(archiveInfoLength).slice();
        const archiveInfo = TSPArchiveMessages_1.ArchiveInfo.fromBinary(archiveInfoBuffer);
        for (const messageInfo of archiveInfo.messageInfos) {
            const messageBuffer = reader.readBytes(messageInfo.length).slice();
            registry[messageInfo.type].fromBinary(messageBuffer);
        }
        const length = reader.pos - offset;
        if (archiveInfo.messageInfos.length === 0) {
            throw new Error('No messages found');
        }
        return [true, {
                offset,
                length,
                messageType: 'ArchiveInfo'
            }];
    }
    catch {
        reader.pos = offset;
        return [false, undefined];
    }
}
function tryRead(reader, messageTypes) {
    const position = reader.pos;
    for (const messageType of messageTypes) {
        try {
            const offset = reader.pos;
            const messageLength = reader.readVarint32();
            const messageBuffer = reader.readBytes(messageLength).slice();
            messageType.fromBinary(messageBuffer);
            const length = reader.pos - offset;
            return [true, {
                    offset,
                    length,
                    messageType: messageType.typeName
                }];
        }
        catch {
            reader.pos = position;
            return [false, undefined];
        }
    }
    return [false, undefined];
}
function ensureNode(graph, offset) {
    if (!graph.nodes.has(offset)) {
        graph.nodes.set(offset, {
            offset,
            outedges: [],
            inedges: [],
        });
    }
    return graph.nodes.get(offset);
}
function addGap(graph, start, length) {
    const startNode = ensureNode(graph, start);
    const end = start + length;
    const endNode = ensureNode(graph, end);
    const edge = {
        type: 'gap',
        length,
        start,
        endExcl: end,
    };
    startNode.outedges.push(edge);
    endNode.inedges.push(edge);
    return edge;
}
function addType(graph, start, length, messageType) {
    const startNode = ensureNode(graph, start);
    const end = start + length;
    const endNode = ensureNode(graph, end);
    const edge = {
        type: 'type',
        length,
        start,
        endExcl: end,
        messageType,
    };
    startNode.outedges.push(edge);
    endNode.inedges.push(edge);
    return edge;
}
//# sourceMappingURL=analyze.js.map